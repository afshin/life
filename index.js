(()=>{var __webpack_modules__={"./node_modules/@lumino/algorithm/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayExt\": () => (/* binding */ ArrayExt),\n/* harmony export */   \"ArrayIterator\": () => (/* binding */ ArrayIterator),\n/* harmony export */   \"ChainIterator\": () => (/* binding */ ChainIterator),\n/* harmony export */   \"EmptyIterator\": () => (/* binding */ EmptyIterator),\n/* harmony export */   \"EnumerateIterator\": () => (/* binding */ EnumerateIterator),\n/* harmony export */   \"FilterIterator\": () => (/* binding */ FilterIterator),\n/* harmony export */   \"FnIterator\": () => (/* binding */ FnIterator),\n/* harmony export */   \"ItemIterator\": () => (/* binding */ ItemIterator),\n/* harmony export */   \"KeyIterator\": () => (/* binding */ KeyIterator),\n/* harmony export */   \"MapIterator\": () => (/* binding */ MapIterator),\n/* harmony export */   \"RangeIterator\": () => (/* binding */ RangeIterator),\n/* harmony export */   \"RepeatIterator\": () => (/* binding */ RepeatIterator),\n/* harmony export */   \"RetroArrayIterator\": () => (/* binding */ RetroArrayIterator),\n/* harmony export */   \"StrideIterator\": () => (/* binding */ StrideIterator),\n/* harmony export */   \"StringExt\": () => (/* binding */ StringExt),\n/* harmony export */   \"TakeIterator\": () => (/* binding */ TakeIterator),\n/* harmony export */   \"ValueIterator\": () => (/* binding */ ValueIterator),\n/* harmony export */   \"ZipIterator\": () => (/* binding */ ZipIterator),\n/* harmony export */   \"chain\": () => (/* binding */ chain),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"enumerate\": () => (/* binding */ enumerate),\n/* harmony export */   \"every\": () => (/* binding */ every),\n/* harmony export */   \"filter\": () => (/* binding */ filter),\n/* harmony export */   \"find\": () => (/* binding */ find),\n/* harmony export */   \"findIndex\": () => (/* binding */ findIndex),\n/* harmony export */   \"iter\": () => (/* binding */ iter),\n/* harmony export */   \"iterFn\": () => (/* binding */ iterFn),\n/* harmony export */   \"iterItems\": () => (/* binding */ iterItems),\n/* harmony export */   \"iterKeys\": () => (/* binding */ iterKeys),\n/* harmony export */   \"iterValues\": () => (/* binding */ iterValues),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"minmax\": () => (/* binding */ minmax),\n/* harmony export */   \"once\": () => (/* binding */ once),\n/* harmony export */   \"range\": () => (/* binding */ range),\n/* harmony export */   \"reduce\": () => (/* binding */ reduce),\n/* harmony export */   \"repeat\": () => (/* binding */ repeat),\n/* harmony export */   \"retro\": () => (/* binding */ retro),\n/* harmony export */   \"some\": () => (/* binding */ some),\n/* harmony export */   \"stride\": () => (/* binding */ stride),\n/* harmony export */   \"take\": () => (/* binding */ take),\n/* harmony export */   \"toArray\": () => (/* binding */ toArray),\n/* harmony export */   \"toObject\": () => (/* binding */ toObject),\n/* harmony export */   \"topologicSort\": () => (/* binding */ topologicSort),\n/* harmony export */   \"zip\": () => (/* binding */ zip)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for array-specific algorithms.\n */\nvar ArrayExt;\n(function (ArrayExt) {\n    /**\n     * Find the index of the first occurrence of a value in an array.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param value - The value to locate in the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first occurrence of the value, or `-1`\n     *   if the value is not found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four', 'one'];\n     * ArrayExt.firstIndexOf(data, 'red');        // -1\n     * ArrayExt.firstIndexOf(data, 'one');        // 0\n     * ArrayExt.firstIndexOf(data, 'one', 1);     // 4\n     * ArrayExt.firstIndexOf(data, 'two', 2);     // -1\n     * ArrayExt.firstIndexOf(data, 'two', 2, 1);  // 1\n     * ```\n     */\n    function firstIndexOf(array, value, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var span;\n        if (stop < start) {\n            span = (stop + 1) + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (var i = 0; i < span; ++i) {\n            var j = (start + i) % n;\n            if (array[j] === value) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.firstIndexOf = firstIndexOf;\n    /**\n     * Find the index of the last occurrence of a value in an array.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param value - The value to locate in the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the last occurrence of the value, or `-1`\n     *   if the value is not found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four', 'one'];\n     * ArrayExt.lastIndexOf(data, 'red');        // -1\n     * ArrayExt.lastIndexOf(data, 'one');        // 4\n     * ArrayExt.lastIndexOf(data, 'one', 1);     // 0\n     * ArrayExt.lastIndexOf(data, 'two', 0);     // -1\n     * ArrayExt.lastIndexOf(data, 'two', 0, 1);  // 1\n     * ```\n     */\n    function lastIndexOf(array, value, start, stop) {\n        if (start === void 0) { start = -1; }\n        if (stop === void 0) { stop = 0; }\n        var n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var span;\n        if (start < stop) {\n            span = (start + 1) + (n - stop);\n        }\n        else {\n            span = start - stop + 1;\n        }\n        for (var i = 0; i < span; ++i) {\n            var j = (start - i + n) % n;\n            if (array[j] === value) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.lastIndexOf = lastIndexOf;\n    /**\n     * Find the index of the first value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first matching value, or `-1` if no\n     *   matching value is found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findFirstIndex(data, isEven);       // 1\n     * ArrayExt.findFirstIndex(data, isEven, 4);    // 5\n     * ArrayExt.findFirstIndex(data, isEven, 6);    // -1\n     * ArrayExt.findFirstIndex(data, isEven, 6, 5); // 1\n     * ```\n     */\n    function findFirstIndex(array, fn, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var span;\n        if (stop < start) {\n            span = (stop + 1) + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (var i = 0; i < span; ++i) {\n            var j = (start + i) % n;\n            if (fn(array[j], j)) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.findFirstIndex = findFirstIndex;\n    /**\n     * Find the index of the last value which matches a predicate.\n     *\n     * @param object - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the last matching value, or `-1` if no\n     *   matching value is found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findLastIndex(data, isEven);        // 5\n     * ArrayExt.findLastIndex(data, isEven, 4);     // 3\n     * ArrayExt.findLastIndex(data, isEven, 0);     // -1\n     * ArrayExt.findLastIndex(data, isEven, 0, 1);  // 5\n     * ```\n     */\n    function findLastIndex(array, fn, start, stop) {\n        if (start === void 0) { start = -1; }\n        if (stop === void 0) { stop = 0; }\n        var n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var d;\n        if (start < stop) {\n            d = (start + 1) + (n - stop);\n        }\n        else {\n            d = start - stop + 1;\n        }\n        for (var i = 0; i < d; ++i) {\n            var j = (start - i + n) % n;\n            if (fn(array[j], j)) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.findLastIndex = findLastIndex;\n    /**\n     * Find the first value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The first matching value, or `undefined` if no matching\n     *   value is found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findFirstValue(data, isEven);       // 2\n     * ArrayExt.findFirstValue(data, isEven, 2);    // 4\n     * ArrayExt.findFirstValue(data, isEven, 6);    // undefined\n     * ArrayExt.findFirstValue(data, isEven, 6, 5); // 2\n     * ```\n     */\n    function findFirstValue(array, fn, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var index = findFirstIndex(array, fn, start, stop);\n        return index !== -1 ? array[index] : undefined;\n    }\n    ArrayExt.findFirstValue = findFirstValue;\n    /**\n     * Find the last value which matches a predicate.\n     *\n     * @param object - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The last matching value, or `undefined` if no matching\n     *   value is found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findLastValue(data, isEven);        // 2\n     * ArrayExt.findLastValue(data, isEven, 4);     // 4\n     * ArrayExt.findLastValue(data, isEven, 0);     // undefined\n     * ArrayExt.findLastValue(data, isEven, 0, 1);  // 2\n     * ```\n     */\n    function findLastValue(array, fn, start, stop) {\n        if (start === void 0) { start = -1; }\n        if (stop === void 0) { stop = 0; }\n        var index = findLastIndex(array, fn, start, stop);\n        return index !== -1 ? array[index] : undefined;\n    }\n    ArrayExt.findLastValue = findLastValue;\n    /**\n     * Find the index of the first element which compares `>=` to a value.\n     *\n     * @param array - The sorted array-like object to search.\n     *\n     * @param value - The value to locate in the array.\n     *\n     * @param fn - The 3-way comparison function to apply to the values.\n     *   It should return `< 0` if an element is less than a value, `0` if\n     *   an element is equal to a value, or `> 0` if an element is greater\n     *   than a value.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first element which compares `>=` to the\n     *   value, or `length` if there is no such element. If the computed\n     *   index for `stop` is less than `start`, then the computed index\n     *   for `start` is returned.\n     *\n     * #### Notes\n     * The array must already be sorted in ascending order according to\n     * the comparison function.\n     *\n     * #### Complexity\n     * Logarithmic.\n     *\n     * #### Undefined Behavior\n     * Searching a range which is not sorted in ascending order.\n     *\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function numberCmp(a: number, b: number): number {\n     *   return a - b;\n     * }\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.lowerBound(data, 0, numberCmp);   // 0\n     * ArrayExt.lowerBound(data, 6, numberCmp);   // 3\n     * ArrayExt.lowerBound(data, 7, numberCmp);   // 3\n     * ArrayExt.lowerBound(data, -1, numberCmp);  // 0\n     * ArrayExt.lowerBound(data, 10, numberCmp);  // 6\n     * ```\n     */\n    function lowerBound(array, value, fn, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var begin = start;\n        var span = stop - start + 1;\n        while (span > 0) {\n            var half = span >> 1;\n            var middle = begin + half;\n            if (fn(array[middle], value) < 0) {\n                begin = middle + 1;\n                span -= half + 1;\n            }\n            else {\n                span = half;\n            }\n        }\n        return begin;\n    }\n    ArrayExt.lowerBound = lowerBound;\n    /**\n     * Find the index of the first element which compares `>` than a value.\n     *\n     * @param array - The sorted array-like object to search.\n     *\n     * @param value - The value to locate in the array.\n     *\n     * @param fn - The 3-way comparison function to apply to the values.\n     *   It should return `< 0` if an element is less than a value, `0` if\n     *   an element is equal to a value, or `> 0` if an element is greater\n     *   than a value.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first element which compares `>` than the\n     *   value, or `length` if there is no such element. If the computed\n     *   index for `stop` is less than `start`, then the computed index\n     *   for `start` is returned.\n     *\n     * #### Notes\n     * The array must already be sorted in ascending order according to\n     * the comparison function.\n     *\n     * #### Complexity\n     * Logarithmic.\n     *\n     * #### Undefined Behavior\n     * Searching a range which is not sorted in ascending order.\n     *\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function numberCmp(a: number, b: number): number {\n     *   return a - b;\n     * }\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.upperBound(data, 0, numberCmp);   // 1\n     * ArrayExt.upperBound(data, 6, numberCmp);   // 3\n     * ArrayExt.upperBound(data, 7, numberCmp);   // 5\n     * ArrayExt.upperBound(data, -1, numberCmp);  // 0\n     * ArrayExt.upperBound(data, 10, numberCmp);  // 6\n     * ```\n     */\n    function upperBound(array, value, fn, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var begin = start;\n        var span = stop - start + 1;\n        while (span > 0) {\n            var half = span >> 1;\n            var middle = begin + half;\n            if (fn(array[middle], value) > 0) {\n                span = half;\n            }\n            else {\n                begin = middle + 1;\n                span -= half + 1;\n            }\n        }\n        return begin;\n    }\n    ArrayExt.upperBound = upperBound;\n    /**\n     * Test whether two arrays are shallowly equal.\n     *\n     * @param a - The first array-like object to compare.\n     *\n     * @param b - The second array-like object to compare.\n     *\n     * @param fn - The comparison function to apply to the elements. It\n     *   should return `true` if the elements are \"equal\". The default\n     *   compares elements using strict `===` equality.\n     *\n     * @returns Whether the two arrays are shallowly equal.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * Modifying the length of the arrays while comparing.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let d1 = [0, 3, 4, 7, 7, 9];\n     * let d2 = [0, 3, 4, 7, 7, 9];\n     * let d3 = [42];\n     * ArrayExt.shallowEqual(d1, d2);  // true\n     * ArrayExt.shallowEqual(d2, d3);  // false\n     * ```\n     */\n    function shallowEqual(a, b, fn) {\n        // Check for object identity first.\n        if (a === b) {\n            return true;\n        }\n        // Bail early if the lengths are different.\n        if (a.length !== b.length) {\n            return false;\n        }\n        // Compare each element for equality.\n        for (var i = 0, n = a.length; i < n; ++i) {\n            if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {\n                return false;\n            }\n        }\n        // The array are shallowly equal.\n        return true;\n    }\n    ArrayExt.shallowEqual = shallowEqual;\n    /**\n     * Create a slice of an array subject to an optional step.\n     *\n     * @param array - The array-like object of interest.\n     *\n     * @param options - The options for configuring the slice.\n     *\n     * @returns A new array with the specified values.\n     *\n     * @throws An exception if the slice `step` is `0`.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start`, `stop`, or `step` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.slice(data);                         // [0, 3, 4, 7, 7, 9]\n     * ArrayExt.slice(data, { start: 2 });           // [4, 7, 7, 9]\n     * ArrayExt.slice(data, { start: 0, stop: 4 });  // [0, 3, 4, 7]\n     * ArrayExt.slice(data, { step: 2 });            // [0, 4, 7]\n     * ArrayExt.slice(data, { step: -1 });           // [9, 7, 7, 4, 3, 0]\n     * ```\n     */\n    function slice(array, options) {\n        if (options === void 0) { options = {}; }\n        // Extract the options.\n        var start = options.start, stop = options.stop, step = options.step;\n        // Set up the `step` value.\n        if (step === undefined) {\n            step = 1;\n        }\n        // Validate the step size.\n        if (step === 0) {\n            throw new Error('Slice `step` cannot be zero.');\n        }\n        // Look up the length of the array.\n        var n = array.length;\n        // Set up the `start` value.\n        if (start === undefined) {\n            start = step < 0 ? n - 1 : 0;\n        }\n        else if (start < 0) {\n            start = Math.max(start + n, step < 0 ? -1 : 0);\n        }\n        else if (start >= n) {\n            start = step < 0 ? n - 1 : n;\n        }\n        // Set up the `stop` value.\n        if (stop === undefined) {\n            stop = step < 0 ? -1 : n;\n        }\n        else if (stop < 0) {\n            stop = Math.max(stop + n, step < 0 ? -1 : 0);\n        }\n        else if (stop >= n) {\n            stop = step < 0 ? n - 1 : n;\n        }\n        // Compute the slice length.\n        var length;\n        if ((step < 0 && stop >= start) || (step > 0 && start >= stop)) {\n            length = 0;\n        }\n        else if (step < 0) {\n            length = Math.floor((stop - start + 1) / step + 1);\n        }\n        else {\n            length = Math.floor((stop - start - 1) / step + 1);\n        }\n        // Compute the sliced result.\n        var result = [];\n        for (var i = 0; i < length; ++i) {\n            result[i] = array[start + i * step];\n        }\n        // Return the result.\n        return result;\n    }\n    ArrayExt.slice = slice;\n    /**\n     * Move an element in an array from one index to another.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param fromIndex - The index of the element to move. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * @param toIndex - The target index of the element. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or `toIndex` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.move(data, 1, 2);  // [0, 2, 1, 3, 4]\n     * ArrayExt.move(data, 4, 2);  // [0, 2, 4, 1, 3]\n     * ```\n     */\n    function move(array, fromIndex, toIndex) {\n        var n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (fromIndex < 0) {\n            fromIndex = Math.max(0, fromIndex + n);\n        }\n        else {\n            fromIndex = Math.min(fromIndex, n - 1);\n        }\n        if (toIndex < 0) {\n            toIndex = Math.max(0, toIndex + n);\n        }\n        else {\n            toIndex = Math.min(toIndex, n - 1);\n        }\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var value = array[fromIndex];\n        var d = fromIndex < toIndex ? 1 : -1;\n        for (var i = fromIndex; i !== toIndex; i += d) {\n            array[i] = array[i + d];\n        }\n        array[toIndex] = value;\n    }\n    ArrayExt.move = move;\n    /**\n     * Reverse an array in-place.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param start - The index of the first element in the range to be\n     *   reversed, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   reversed, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or  `stop` index which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.reverse(data, 1, 3);  // [0, 3, 2, 1, 4]\n     * ArrayExt.reverse(data, 3);     // [0, 3, 2, 4, 1]\n     * ArrayExt.reverse(data);        // [1, 4, 2, 3, 0]\n     * ```\n     */\n    function reverse(array, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        while (start < stop) {\n            var a = array[start];\n            var b = array[stop];\n            array[start++] = b;\n            array[stop--] = a;\n        }\n    }\n    ArrayExt.reverse = reverse;\n    /**\n     * Rotate the elements of an array in-place.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param delta - The amount of rotation to apply to the elements. A\n     *   positive value will rotate the elements to the left. A negative\n     *   value will rotate the elements to the right.\n     *\n     * @param start - The index of the first element in the range to be\n     *   rotated, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   rotated, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `delta`, `start`, or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.rotate(data, 2);        // [2, 3, 4, 0, 1]\n     * ArrayExt.rotate(data, -2);       // [0, 1, 2, 3, 4]\n     * ArrayExt.rotate(data, 10);       // [0, 1, 2, 3, 4]\n     * ArrayExt.rotate(data, 9);        // [4, 0, 1, 2, 3]\n     * ArrayExt.rotate(data, 2, 1, 3);  // [4, 2, 0, 1, 3]\n     * ```\n     */\n    function rotate(array, delta, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        if (start >= stop) {\n            return;\n        }\n        var length = stop - start + 1;\n        if (delta > 0) {\n            delta = delta % length;\n        }\n        else if (delta < 0) {\n            delta = ((delta % length) + length) % length;\n        }\n        if (delta === 0) {\n            return;\n        }\n        var pivot = start + delta;\n        reverse(array, start, pivot - 1);\n        reverse(array, pivot, stop);\n        reverse(array, start, stop);\n    }\n    ArrayExt.rotate = rotate;\n    /**\n     * Fill an array with a static value.\n     *\n     * @param array - The mutable array-like object to fill.\n     *\n     * @param value - The static value to use to fill the array.\n     *\n     * @param start - The index of the first element in the range to be\n     *   filled, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   filled, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Notes\n     * If `stop < start` the fill will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four'];\n     * ArrayExt.fill(data, 'r');        // ['r', 'r', 'r', 'r']\n     * ArrayExt.fill(data, 'g', 1);     // ['r', 'g', 'g', 'g']\n     * ArrayExt.fill(data, 'b', 2, 3);  // ['r', 'g', 'b', 'b']\n     * ArrayExt.fill(data, 'z', 3, 1);  // ['z', 'z', 'b', 'z']\n     * ```\n     */\n    function fill(array, value, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var span;\n        if (stop < start) {\n            span = (stop + 1) + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (var i = 0; i < span; ++i) {\n            array[(start + i) % n] = value;\n        }\n    }\n    ArrayExt.fill = fill;\n    /**\n     * Insert a value into an array at a specific index.\n     *\n     * @param array - The array of interest.\n     *\n     * @param index - The index at which to insert the value. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2];\n     * ArrayExt.insert(data, 0, -1);  // [-1, 0, 1, 2]\n     * ArrayExt.insert(data, 2, 12);  // [-1, 0, 12, 1, 2]\n     * ArrayExt.insert(data, -1, 7);  // [-1, 0, 12, 1, 7, 2]\n     * ArrayExt.insert(data, 6, 19);  // [-1, 0, 12, 1, 7, 2, 19]\n     * ```\n     */\n    function insert(array, index, value) {\n        var n = array.length;\n        if (index < 0) {\n            index = Math.max(0, index + n);\n        }\n        else {\n            index = Math.min(index, n);\n        }\n        for (var i = n; i > index; --i) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    ArrayExt.insert = insert;\n    /**\n     * Remove and return a value at a specific index in an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param index - The index of the value to remove. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The value at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeAt(data, 2);   // 23\n     * ArrayExt.removeAt(data, -2);  // 12\n     * ArrayExt.removeAt(data, 10);  // undefined;\n     * ```\n     */\n    function removeAt(array, index) {\n        var n = array.length;\n        if (index < 0) {\n            index += n;\n        }\n        if (index < 0 || index >= n) {\n            return undefined;\n        }\n        var value = array[index];\n        for (var i = index + 1; i < n; ++i) {\n            array[i - 1] = array[i];\n        }\n        array.length = n - 1;\n        return value;\n    }\n    ArrayExt.removeAt = removeAt;\n    /**\n     * Remove the first occurrence of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeFirstOf(data, 12);        // 1\n     * ArrayExt.removeFirstOf(data, 17);        // -1\n     * ArrayExt.removeFirstOf(data, 39, 3);     // -1\n     * ArrayExt.removeFirstOf(data, 39, 3, 2);  // 2\n     * ```\n     */\n    function removeFirstOf(array, value, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var index = firstIndexOf(array, value, start, stop);\n        if (index !== -1) {\n            removeAt(array, index);\n        }\n        return index;\n    }\n    ArrayExt.removeFirstOf = removeFirstOf;\n    /**\n     * Remove the last occurrence of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the array.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeLastOf(data, 12);        // 5\n     * ArrayExt.removeLastOf(data, 17);        // -1\n     * ArrayExt.removeLastOf(data, 39, 2);     // -1\n     * ArrayExt.removeLastOf(data, 39, 2, 3);  // 3\n     * ```\n     */\n    function removeLastOf(array, value, start, stop) {\n        if (start === void 0) { start = -1; }\n        if (stop === void 0) { stop = 0; }\n        var index = lastIndexOf(array, value, start, stop);\n        if (index !== -1) {\n            removeAt(array, index);\n        }\n        return index;\n    }\n    ArrayExt.removeLastOf = removeLastOf;\n    /**\n     * Remove all occurrences of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The number of elements removed from the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will conceptually wrap at the end of\n     * the array, however the array will be traversed front-to-back.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [14, 12, 23, 39, 14, 12, 19, 14];\n     * ArrayExt.removeAllOf(data, 12);        // 2\n     * ArrayExt.removeAllOf(data, 17);        // 0\n     * ArrayExt.removeAllOf(data, 14, 1, 4);  // 1\n     * ```\n     */\n    function removeAllOf(array, value, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var count = 0;\n        for (var i = 0; i < n; ++i) {\n            if (start <= stop && (i >= start && i <= stop) && array[i] === value) {\n                count++;\n            }\n            else if (stop < start && (i <= stop || i >= start) && array[i] === value) {\n                count++;\n            }\n            else if (count > 0) {\n                array[i - count] = array[i];\n            }\n        }\n        if (count > 0) {\n            array.length = n - count;\n        }\n        return count;\n    }\n    ArrayExt.removeAllOf = removeAllOf;\n    /**\n     * Remove the first occurrence of a value which matches a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The removed `{ index, value }`, which will be `-1` and\n     *   `undefined` if the value is not contained in the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeFirstWhere(data, isEven);     // { index: 0, value: 0 }\n     * ArrayExt.removeFirstWhere(data, isEven, 2);  // { index: 3, value: 14 }\n     * ArrayExt.removeFirstWhere(data, isEven, 4);  // { index: -1, value: undefined }\n     * ```\n     */\n    function removeFirstWhere(array, fn, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var value;\n        var index = findFirstIndex(array, fn, start, stop);\n        if (index !== -1) {\n            value = removeAt(array, index);\n        }\n        return { index: index, value: value };\n    }\n    ArrayExt.removeFirstWhere = removeFirstWhere;\n    /**\n     * Remove the last occurrence of a value which matches a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The removed `{ index, value }`, which will be `-1` and\n     *   `undefined` if the value is not contained in the array.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeLastWhere(data, isEven);        // { index: 5, value: 12 }\n     * ArrayExt.removeLastWhere(data, isEven, 2);     // { index: 1, value: 12 }\n     * ArrayExt.removeLastWhere(data, isEven, 2, 1);  // { index: -1, value: undefined }\n     * ```\n     */\n    function removeLastWhere(array, fn, start, stop) {\n        if (start === void 0) { start = -1; }\n        if (stop === void 0) { stop = 0; }\n        var value;\n        var index = findLastIndex(array, fn, start, stop);\n        if (index !== -1) {\n            value = removeAt(array, index);\n        }\n        return { index: index, value: value };\n    }\n    ArrayExt.removeLastWhere = removeLastWhere;\n    /**\n     * Remove all occurrences of values which match a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The number of elements removed from the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will conceptually wrap at the end of\n     * the array, however the array will be traversed front-to-back.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * function isNegative(value: number): boolean {\n     *   return value < 0;\n     * }\n     *\n     * let data = [0, 12, -13, -9, 23, 39, 14, -15, 12, 75];\n     * ArrayExt.removeAllWhere(data, isEven);            // 4\n     * ArrayExt.removeAllWhere(data, isNegative, 0, 3);  // 2\n     * ```\n     */\n    function removeAllWhere(array, fn, start, stop) {\n        if (start === void 0) { start = 0; }\n        if (stop === void 0) { stop = -1; }\n        var n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        var count = 0;\n        for (var i = 0; i < n; ++i) {\n            if (start <= stop && (i >= start && i <= stop) && fn(array[i], i)) {\n                count++;\n            }\n            else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {\n                count++;\n            }\n            else if (count > 0) {\n                array[i - count] = array[i];\n            }\n        }\n        if (count > 0) {\n            array.length = n - count;\n        }\n        return count;\n    }\n    ArrayExt.removeAllWhere = removeAllWhere;\n})(ArrayExt || (ArrayExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Create an iterator for an iterable object.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @returns A new iterator for the given object.\n *\n * #### Notes\n * This function allows iteration algorithms to operate on user-defined\n * iterable types and builtin array-like objects in a uniform fashion.\n */\nfunction iter(object) {\n    var it;\n    if (typeof object.iter === 'function') {\n        it = object.iter();\n    }\n    else {\n        it = new ArrayIterator(object);\n    }\n    return it;\n}\n/**\n * Create an iterator for the keys in an object.\n *\n * @param object - The object of interest.\n *\n * @returns A new iterator for the keys in the given object.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each, keys } from '@lumino/algorithm';\n *\n * let data = { one: 1, two: 2, three: 3 };\n *\n * each(keys(data), key => { console.log(key); }); // 'one', 'two', 'three'\n * ```\n */\nfunction iterKeys(object) {\n    return new KeyIterator(object);\n}\n/**\n * Create an iterator for the values in an object.\n *\n * @param object - The object of interest.\n *\n * @returns A new iterator for the values in the given object.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each, values } from '@lumino/algorithm';\n *\n * let data = { one: 1, two: 2, three: 3 };\n *\n * each(values(data), value => { console.log(value); }); // 1, 2, 3\n * ```\n */\nfunction iterValues(object) {\n    return new ValueIterator(object);\n}\n/**\n * Create an iterator for the items in an object.\n *\n * @param object - The object of interest.\n *\n * @returns A new iterator for the items in the given object.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each, items } from '@lumino/algorithm';\n *\n * let data = { one: 1, two: 2, three: 3 };\n *\n * each(items(data), value => { console.log(value); }); // ['one', 1], ['two', 2], ['three', 3]\n * ```\n */\nfunction iterItems(object) {\n    return new ItemIterator(object);\n}\n/**\n * Create an iterator for an iterator-like function.\n *\n * @param fn - A function which behaves like an iterator `next` method.\n *\n * @returns A new iterator for the given function.\n *\n * #### Notes\n * The returned iterator **cannot** be cloned.\n *\n * #### Example\n * ```typescript\n * import { each, iterFn } from '@lumino/algorithm';\n *\n * let it = iterFn((() => {\n *   let i = 0;\n *   return () => i > 3 ? undefined : i++;\n * })());\n *\n * each(it, v => { console.log(v); }); // 0, 1, 2, 3\n * ```\n */\nfunction iterFn(fn) {\n    return new FnIterator(fn);\n}\n/**\n * Invoke a function for each value in an iterable.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The callback function to invoke for each value.\n *\n * #### Notes\n * Iteration can be terminated early by returning `false` from the\n * callback function.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { each } from '@lumino/algorithm';\n *\n * let data = [5, 7, 0, -2, 9];\n *\n * each(data, value => { console.log(value); });\n * ```\n */\nfunction each(object, fn) {\n    var index = 0;\n    var it = iter(object);\n    var value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, index++) === false) {\n            return;\n        }\n    }\n}\n/**\n * Test whether all values in an iterable satisfy a predicate.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns `true` if all values pass the test, `false` otherwise.\n *\n * #### Notes\n * Iteration terminates on the first `false` predicate result.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { every } from '@lumino/algorithm';\n *\n * let data = [5, 7, 1];\n *\n * every(data, value => value % 2 === 0);  // false\n * every(data, value => value % 2 === 1);  // true\n * ```\n */\nfunction every(object, fn) {\n    var index = 0;\n    var it = iter(object);\n    var value;\n    while ((value = it.next()) !== undefined) {\n        if (!fn(value, index++)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Test whether any value in an iterable satisfies a predicate.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns `true` if any value passes the test, `false` otherwise.\n *\n * #### Notes\n * Iteration terminates on the first `true` predicate result.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { some } from '@lumino/algorithm';\n *\n * let data = [5, 7, 1];\n *\n * some(data, value => value === 7);  // true\n * some(data, value => value === 3);  // false\n * ```\n */\nfunction some(object, fn) {\n    var index = 0;\n    var it = iter(object);\n    var value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, index++)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Create an array from an iterable of values.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @returns A new array of values from the given object.\n *\n * #### Example\n * ```typescript\n * import { iter, toArray } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = iter(data);\n *\n * toArray(stream);  // [1, 2, 3, 4, 5, 6];\n * ```\n */\nfunction toArray(object) {\n    var index = 0;\n    var result = [];\n    var it = iter(object);\n    var value;\n    while ((value = it.next()) !== undefined) {\n        result[index++] = value;\n    }\n    return result;\n}\n/**\n * Create an object from an iterable of key/value pairs.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @returns A new object mapping keys to values.\n *\n * #### Example\n * ```typescript\n * import { toObject } from '@lumino/algorithm';\n *\n * let data = [['one', 1], ['two', 2], ['three', 3]];\n *\n * toObject(data);  // { one: 1, two: 2, three: 3 }\n * ```\n */\nfunction toObject(object) {\n    var it = iter(object);\n    var pair;\n    var result = {};\n    while ((pair = it.next()) !== undefined) {\n        result[pair[0]] = pair[1];\n    }\n    return result;\n}\n/**\n * An iterator for an array-like object.\n *\n * #### Notes\n * This iterator can be used for any builtin JS array-like object.\n */\nvar ArrayIterator = /** @class */ (function () {\n    /**\n     * Construct a new array iterator.\n     *\n     * @param source - The array-like object of interest.\n     */\n    function ArrayIterator(source) {\n        this._index = 0;\n        this._source = source;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    ArrayIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    ArrayIterator.prototype.clone = function () {\n        var result = new ArrayIterator(this._source);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    ArrayIterator.prototype.next = function () {\n        if (this._index >= this._source.length) {\n            return undefined;\n        }\n        return this._source[this._index++];\n    };\n    return ArrayIterator;\n}());\n/**\n * An iterator for the keys in an object.\n *\n * #### Notes\n * This iterator can be used for any JS object.\n */\nvar KeyIterator = /** @class */ (function () {\n    /**\n     * Construct a new key iterator.\n     *\n     * @param source - The object of interest.\n     *\n     * @param keys - The keys to iterate, if known.\n     */\n    function KeyIterator(source, keys) {\n        if (keys === void 0) { keys = Object.keys(source); }\n        this._index = 0;\n        this._source = source;\n        this._keys = keys;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    KeyIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    KeyIterator.prototype.clone = function () {\n        var result = new KeyIterator(this._source, this._keys);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    KeyIterator.prototype.next = function () {\n        if (this._index >= this._keys.length) {\n            return undefined;\n        }\n        var key = this._keys[this._index++];\n        if (key in this._source) {\n            return key;\n        }\n        return this.next();\n    };\n    return KeyIterator;\n}());\n/**\n * An iterator for the values in an object.\n *\n * #### Notes\n * This iterator can be used for any JS object.\n */\nvar ValueIterator = /** @class */ (function () {\n    /**\n     * Construct a new value iterator.\n     *\n     * @param source - The object of interest.\n     *\n     * @param keys - The keys to iterate, if known.\n     */\n    function ValueIterator(source, keys) {\n        if (keys === void 0) { keys = Object.keys(source); }\n        this._index = 0;\n        this._source = source;\n        this._keys = keys;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    ValueIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    ValueIterator.prototype.clone = function () {\n        var result = new ValueIterator(this._source, this._keys);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    ValueIterator.prototype.next = function () {\n        if (this._index >= this._keys.length) {\n            return undefined;\n        }\n        var key = this._keys[this._index++];\n        if (key in this._source) {\n            return this._source[key];\n        }\n        return this.next();\n    };\n    return ValueIterator;\n}());\n/**\n * An iterator for the items in an object.\n *\n * #### Notes\n * This iterator can be used for any JS object.\n */\nvar ItemIterator = /** @class */ (function () {\n    /**\n     * Construct a new item iterator.\n     *\n     * @param source - The object of interest.\n     *\n     * @param keys - The keys to iterate, if known.\n     */\n    function ItemIterator(source, keys) {\n        if (keys === void 0) { keys = Object.keys(source); }\n        this._index = 0;\n        this._source = source;\n        this._keys = keys;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    ItemIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    ItemIterator.prototype.clone = function () {\n        var result = new ItemIterator(this._source, this._keys);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    ItemIterator.prototype.next = function () {\n        if (this._index >= this._keys.length) {\n            return undefined;\n        }\n        var key = this._keys[this._index++];\n        if (key in this._source) {\n            return [key, this._source[key]];\n        }\n        return this.next();\n    };\n    return ItemIterator;\n}());\n/**\n * An iterator for an iterator-like function.\n */\nvar FnIterator = /** @class */ (function () {\n    /**\n     * Construct a new function iterator.\n     *\n     * @param fn - The iterator-like function of interest.\n     */\n    function FnIterator(fn) {\n        this._fn = fn;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    FnIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    FnIterator.prototype.clone = function () {\n        throw new Error('An `FnIterator` cannot be cloned.');\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    FnIterator.prototype.next = function () {\n        return this._fn.call(undefined);\n    };\n    return FnIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Chain together several iterables.\n *\n * @param objects - The iterable or array-like objects of interest.\n *\n * @returns An iterator which yields the values of the iterables\n *   in the order in which they are supplied.\n *\n * #### Example\n * ```typescript\n * import { chain, toArray } from '@lumino/algorithm';\n *\n * let data1 = [1, 2, 3];\n * let data2 = [4, 5, 6];\n *\n * let stream = chain(data1, data2);\n *\n * toArray(stream);  // [1, 2, 3, 4, 5, 6]\n * ```\n */\nfunction chain() {\n    var objects = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n    }\n    return new ChainIterator(iter(objects.map(iter)));\n}\n/**\n * An iterator which chains together several iterators.\n */\nvar ChainIterator = /** @class */ (function () {\n    /**\n     * Construct a new chain iterator.\n     *\n     * @param source - The iterator of iterators of interest.\n     */\n    function ChainIterator(source) {\n        this._cloned = false;\n        this._source = source;\n        this._active = undefined;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    ChainIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    ChainIterator.prototype.clone = function () {\n        var result = new ChainIterator(this._source.clone());\n        result._active = this._active && this._active.clone();\n        result._cloned = true;\n        this._cloned = true;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    ChainIterator.prototype.next = function () {\n        if (this._active === undefined) {\n            var active = this._source.next();\n            if (active === undefined) {\n                return undefined;\n            }\n            this._active = this._cloned ? active.clone() : active;\n        }\n        var value = this._active.next();\n        if (value !== undefined) {\n            return value;\n        }\n        this._active = undefined;\n        return this.next();\n    };\n    return ChainIterator;\n}());\n\n/**\n * Create an empty iterator.\n *\n * @returns A new iterator which yields nothing.\n *\n * #### Example\n * ```typescript\n * import { empty, toArray } from '@lumino/algorithm';\n *\n * let stream = empty<number>();\n *\n * toArray(stream);  // []\n * ```\n */\nfunction empty() {\n    return new EmptyIterator();\n}\n/**\n * An iterator which is always empty.\n */\nvar EmptyIterator = /** @class */ (function () {\n    /**\n     * Construct a new empty iterator.\n     */\n    function EmptyIterator() {\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    EmptyIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    EmptyIterator.prototype.clone = function () {\n        return new EmptyIterator();\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    EmptyIterator.prototype.next = function () {\n        return undefined;\n    };\n    return EmptyIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Enumerate an iterable object.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param start - The starting enum value. The default is `0`.\n *\n * @returns An iterator which yields the enumerated values.\n *\n * #### Example\n * ```typescript\n * import { enumerate, toArray } from '@lumino/algorithm';\n *\n * let data = ['foo', 'bar', 'baz'];\n *\n * let stream = enumerate(data, 1);\n *\n * toArray(stream);  // [[1, 'foo'], [2, 'bar'], [3, 'baz']]\n * ```\n */\nfunction enumerate(object, start) {\n    if (start === void 0) { start = 0; }\n    return new EnumerateIterator(iter(object), start);\n}\n/**\n * An iterator which enumerates the source values.\n */\nvar EnumerateIterator = /** @class */ (function () {\n    /**\n     * Construct a new enumerate iterator.\n     *\n     * @param source - The iterator of values of interest.\n     *\n     * @param start - The starting enum value.\n     */\n    function EnumerateIterator(source, start) {\n        this._source = source;\n        this._index = start;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    EnumerateIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    EnumerateIterator.prototype.clone = function () {\n        return new EnumerateIterator(this._source.clone(), this._index);\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    EnumerateIterator.prototype.next = function () {\n        var value = this._source.next();\n        if (value === undefined) {\n            return undefined;\n        }\n        return [this._index++, value];\n    };\n    return EnumerateIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Filter an iterable for values which pass a test.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The predicate function to invoke for each value.\n *\n * @returns An iterator which yields the values which pass the test.\n *\n * #### Example\n * ```typescript\n * import { filter, toArray } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = filter(data, value => value % 2 === 0);\n *\n * toArray(stream);  // [2, 4, 6]\n * ```\n */\nfunction filter(object, fn) {\n    return new FilterIterator(iter(object), fn);\n}\n/**\n * An iterator which yields values which pass a test.\n */\nvar FilterIterator = /** @class */ (function () {\n    /**\n     * Construct a new filter iterator.\n     *\n     * @param source - The iterator of values of interest.\n     *\n     * @param fn - The predicate function to invoke for each value.\n     */\n    function FilterIterator(source, fn) {\n        this._index = 0;\n        this._source = source;\n        this._fn = fn;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    FilterIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    FilterIterator.prototype.clone = function () {\n        var result = new FilterIterator(this._source.clone(), this._fn);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    FilterIterator.prototype.next = function () {\n        var fn = this._fn;\n        var it = this._source;\n        var value;\n        while ((value = it.next()) !== undefined) {\n            if (fn(value, this._index++)) {\n                return value;\n            }\n        }\n        return undefined;\n    };\n    return FilterIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Find the first value in an iterable which matches a predicate.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The predicate function to apply to the values.\n *\n * @returns The first matching value, or `undefined` if no matching\n *   value is found.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { find } from '@lumino/algorithm';\n *\n * interface IAnimal { species: string, name: string };\n *\n * function isCat(value: IAnimal): boolean {\n *   return value.species === 'cat';\n * }\n *\n * let data: IAnimal[] = [\n *   { species: 'dog', name: 'spot' },\n *   { species: 'cat', name: 'fluffy' },\n *   { species: 'alligator', name: 'pocho' }\n * ];\n *\n * find(data, isCat).name;  // 'fluffy'\n * ```\n */\nfunction find(object, fn) {\n    var index = 0;\n    var it = iter(object);\n    var value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, index++)) {\n            return value;\n        }\n    }\n    return undefined;\n}\n/**\n * Find the index of the first value which matches a predicate.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The predicate function to apply to the values.\n *\n * @returns The index of the first matching value, or `-1` if no\n *   matching value is found.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { findIndex } from '@lumino/algorithm';\n *\n * interface IAnimal { species: string, name: string };\n *\n * function isCat(value: IAnimal): boolean {\n *   return value.species === 'cat';\n * }\n *\n * let data: IAnimal[] = [\n *   { species: 'dog', name: 'spot' },\n *   { species: 'cat', name: 'fluffy' },\n *   { species: 'alligator', name: 'pocho' }\n * ];\n *\n * findIndex(data, isCat);  // 1\n * ```\n */\nfunction findIndex(object, fn) {\n    var index = 0;\n    var it = iter(object);\n    var value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, index++)) {\n            return index - 1;\n        }\n    }\n    return -1;\n}\n/**\n * Find the minimum value in an iterable.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns The minimum value in the iterable. If multiple values are\n *   equivalent to the minimum, the left-most value is returned. If\n *   the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { min } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * min([7, 4, 0, 3, 9, 4], numberCmp);  // 0\n * ```\n */\nfunction min(object, fn) {\n    var it = iter(object);\n    var value = it.next();\n    if (value === undefined) {\n        return undefined;\n    }\n    var result = value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, result) < 0) {\n            result = value;\n        }\n    }\n    return result;\n}\n/**\n * Find the maximum value in an iterable.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns The maximum value in the iterable. If multiple values are\n *   equivalent to the maximum, the left-most value is returned. If\n *   the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { max } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * max([7, 4, 0, 3, 9, 4], numberCmp);  // 9\n * ```\n */\nfunction max(object, fn) {\n    var it = iter(object);\n    var value = it.next();\n    if (value === undefined) {\n        return undefined;\n    }\n    var result = value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, result) > 0) {\n            result = value;\n        }\n    }\n    return result;\n}\n/**\n * Find the minimum and maximum values in an iterable.\n *\n * @param object - The iterable or array-like object to search.\n *\n * @param fn - The 3-way comparison function to apply to the values.\n *   It should return `< 0` if the first value is less than the second.\n *   `0` if the values are equivalent, or `> 0` if the first value is\n *   greater than the second.\n *\n * @returns A 2-tuple of the `[min, max]` values in the iterable. If\n *   multiple values are equivalent, the left-most values are returned.\n *   If the iterable is empty, this returns `undefined`.\n *\n * #### Complexity\n * Linear.\n *\n * #### Example\n * ```typescript\n * import { minmax } from '@lumino/algorithm';\n *\n * function numberCmp(a: number, b: number): number {\n *   return a - b;\n * }\n *\n * minmax([7, 4, 0, 3, 9, 4], numberCmp);  // [0, 9]\n * ```\n */\nfunction minmax(object, fn) {\n    var it = iter(object);\n    var value = it.next();\n    if (value === undefined) {\n        return undefined;\n    }\n    var vmin = value;\n    var vmax = value;\n    while ((value = it.next()) !== undefined) {\n        if (fn(value, vmin) < 0) {\n            vmin = value;\n        }\n        else if (fn(value, vmax) > 0) {\n            vmax = value;\n        }\n    }\n    return [vmin, vmax];\n}\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Transform the values of an iterable with a mapping function.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param fn - The mapping function to invoke for each value.\n *\n * @returns An iterator which yields the transformed values.\n *\n * #### Example\n * ```typescript\n * import { map, toArray } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3];\n *\n * let stream = map(data, value => value * 2);\n *\n * toArray(stream);  // [2, 4, 6]\n * ```\n */\nfunction map(object, fn) {\n    return new MapIterator(iter(object), fn);\n}\n/**\n * An iterator which transforms values using a mapping function.\n */\nvar MapIterator = /** @class */ (function () {\n    /**\n     * Construct a new map iterator.\n     *\n     * @param source - The iterator of values of interest.\n     *\n     * @param fn - The mapping function to invoke for each value.\n     */\n    function MapIterator(source, fn) {\n        this._index = 0;\n        this._source = source;\n        this._fn = fn;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    MapIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    MapIterator.prototype.clone = function () {\n        var result = new MapIterator(this._source.clone(), this._fn);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    MapIterator.prototype.next = function () {\n        var value = this._source.next();\n        if (value === undefined) {\n            return undefined;\n        }\n        return this._fn.call(undefined, value, this._index++);\n    };\n    return MapIterator;\n}());\n\n/**\n * Create an iterator of evenly spaced values.\n *\n * @param start - The starting value for the range, inclusive.\n *\n * @param stop - The stopping value for the range, exclusive.\n *\n * @param step - The distance between each value.\n *\n * @returns An iterator which produces evenly spaced values.\n *\n * #### Notes\n * In the single argument form of `range(stop)`, `start` defaults to\n * `0` and `step` defaults to `1`.\n *\n * In the two argument form of `range(start, stop)`, `step` defaults\n * to `1`.\n */\nfunction range(start, stop, step) {\n    if (stop === undefined) {\n        return new RangeIterator(0, start, 1);\n    }\n    if (step === undefined) {\n        return new RangeIterator(start, stop, 1);\n    }\n    return new RangeIterator(start, stop, step);\n}\n/**\n * An iterator which produces a range of evenly spaced values.\n */\nvar RangeIterator = /** @class */ (function () {\n    /**\n     * Construct a new range iterator.\n     *\n     * @param start - The starting value for the range, inclusive.\n     *\n     * @param stop - The stopping value for the range, exclusive.\n     *\n     * @param step - The distance between each value.\n     */\n    function RangeIterator(start, stop, step) {\n        this._index = 0;\n        this._start = start;\n        this._stop = stop;\n        this._step = step;\n        this._length = Private.rangeLength(start, stop, step);\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    RangeIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    RangeIterator.prototype.clone = function () {\n        var result = new RangeIterator(this._start, this._stop, this._step);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    RangeIterator.prototype.next = function () {\n        if (this._index >= this._length) {\n            return undefined;\n        }\n        return this._start + this._step * this._index++;\n    };\n    return RangeIterator;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Compute the effective length of a range.\n     *\n     * @param start - The starting value for the range, inclusive.\n     *\n     * @param stop - The stopping value for the range, exclusive.\n     *\n     * @param step - The distance between each value.\n     *\n     * @returns The number of steps need to traverse the range.\n     */\n    function rangeLength(start, stop, step) {\n        if (step === 0) {\n            return Infinity;\n        }\n        if (start > stop && step > 0) {\n            return 0;\n        }\n        if (start < stop && step < 0) {\n            return 0;\n        }\n        return Math.ceil((stop - start) / step);\n    }\n    Private.rangeLength = rangeLength;\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\nfunction reduce(object, fn, initial) {\n    // Setup the iterator and fetch the first value.\n    var index = 0;\n    var it = iter(object);\n    var first = it.next();\n    // An empty iterator and no initial value is an error.\n    if (first === undefined && initial === undefined) {\n        throw new TypeError('Reduce of empty iterable with no initial value.');\n    }\n    // If the iterator is empty, return the initial value.\n    if (first === undefined) {\n        return initial;\n    }\n    // If the iterator has a single item and no initial value, the\n    // reducer is not invoked and the first item is the return value.\n    var second = it.next();\n    if (second === undefined && initial === undefined) {\n        return first;\n    }\n    // If iterator has a single item and an initial value is provided,\n    // the reducer is invoked and that result is the return value.\n    if (second === undefined) {\n        return fn(initial, first, index++);\n    }\n    // Setup the initial accumlated value.\n    var accumulator;\n    if (initial === undefined) {\n        accumulator = fn(first, second, index++);\n    }\n    else {\n        accumulator = fn(fn(initial, first, index++), second, index++);\n    }\n    // Iterate the rest of the values, updating the accumulator.\n    var next;\n    while ((next = it.next()) !== undefined) {\n        accumulator = fn(accumulator, next, index++);\n    }\n    // Return the final accumulated value.\n    return accumulator;\n}\n\n/**\n * Create an iterator which repeats a value a number of times.\n *\n * @param value - The value to repeat.\n *\n * @param count - The number of times to repeat the value.\n *\n * @returns A new iterator which repeats the specified value.\n *\n * #### Example\n * ```typescript\n * import { repeat, toArray } from '@lumino/algorithm';\n *\n * let stream = repeat(7, 3);\n *\n * toArray(stream);  // [7, 7, 7]\n * ```\n */\nfunction repeat(value, count) {\n    return new RepeatIterator(value, count);\n}\n/**\n * Create an iterator which yields a value a single time.\n *\n * @param value - The value to wrap in an iterator.\n *\n * @returns A new iterator which yields the value a single time.\n *\n * #### Example\n * ```typescript\n * import { once, toArray } from '@lumino/algorithm';\n *\n * let stream = once(7);\n *\n * toArray(stream);  // [7]\n * ```\n */\nfunction once(value) {\n    return new RepeatIterator(value, 1);\n}\n/**\n * An iterator which repeats a value a specified number of times.\n */\nvar RepeatIterator = /** @class */ (function () {\n    /**\n     * Construct a new repeat iterator.\n     *\n     * @param value - The value to repeat.\n     *\n     * @param count - The number of times to repeat the value.\n     */\n    function RepeatIterator(value, count) {\n        this._value = value;\n        this._count = count;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    RepeatIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    RepeatIterator.prototype.clone = function () {\n        return new RepeatIterator(this._value, this._count);\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    RepeatIterator.prototype.next = function () {\n        if (this._count <= 0) {\n            return undefined;\n        }\n        this._count--;\n        return this._value;\n    };\n    return RepeatIterator;\n}());\n\n/**\n * Create an iterator for a retroable object.\n *\n * @param object - The retroable or array-like object of interest.\n *\n * @returns An iterator which traverses the object's values in reverse.\n *\n * #### Example\n * ```typescript\n * import { retro, toArray } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = retro(data);\n *\n * toArray(stream);  // [6, 5, 4, 3, 2, 1]\n * ```\n */\nfunction retro(object) {\n    var it;\n    if (typeof object.retro === 'function') {\n        it = object.retro();\n    }\n    else {\n        it = new RetroArrayIterator(object);\n    }\n    return it;\n}\n/**\n * An iterator which traverses an array-like object in reverse.\n *\n * #### Notes\n * This iterator can be used for any builtin JS array-like object.\n */\nvar RetroArrayIterator = /** @class */ (function () {\n    /**\n     * Construct a new retro iterator.\n     *\n     * @param source - The array-like object of interest.\n     */\n    function RetroArrayIterator(source) {\n        this._source = source;\n        this._index = source.length - 1;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    RetroArrayIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    RetroArrayIterator.prototype.clone = function () {\n        var result = new RetroArrayIterator(this._source);\n        result._index = this._index;\n        return result;\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    RetroArrayIterator.prototype.next = function () {\n        if (this._index < 0 || this._index >= this._source.length) {\n            return undefined;\n        }\n        return this._source[this._index--];\n    };\n    return RetroArrayIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Topologically sort an iterable of edges.\n *\n * @param edges - The iterable or array-like object of edges to sort.\n *   An edge is represented as a 2-tuple of `[fromNode, toNode]`.\n *\n * @returns The topologically sorted array of nodes.\n *\n * #### Notes\n * If a cycle is present in the graph, the cycle will be ignored and\n * the return value will be only approximately sorted.\n *\n * #### Example\n * ```typescript\n * import { topologicSort } from '@lumino/algorithm';\n *\n * let data = [\n *   ['d', 'e'],\n *   ['c', 'd'],\n *   ['a', 'b'],\n *   ['b', 'c']\n * ];\n *\n * topologicSort(data);  // ['a', 'b', 'c', 'd', 'e']\n * ```\n */\nfunction topologicSort(edges) {\n    // Setup the shared sorting state.\n    var sorted = [];\n    var visited = new Set();\n    var graph = new Map();\n    // Add the edges to the graph.\n    each(edges, addEdge);\n    // Visit each node in the graph.\n    graph.forEach(function (v, k) { visit(k); });\n    // Return the sorted results.\n    return sorted;\n    // Add an edge to the graph.\n    function addEdge(edge) {\n        var fromNode = edge[0], toNode = edge[1];\n        var children = graph.get(toNode);\n        if (children) {\n            children.push(fromNode);\n        }\n        else {\n            graph.set(toNode, [fromNode]);\n        }\n    }\n    // Recursively visit the node.\n    function visit(node) {\n        if (visited.has(node)) {\n            return;\n        }\n        visited.add(node);\n        var children = graph.get(node);\n        if (children) {\n            children.forEach(visit);\n        }\n        sorted.push(node);\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Iterate over an iterable using a stepped increment.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param step - The distance to step on each iteration. A value\n *   of less than `1` will behave the same as a value of `1`.\n *\n * @returns An iterator which traverses the iterable step-wise.\n *\n * #### Example\n * ```typescript\n * import { stride, toArray } from '@lumino/algorithm';\n *\n * let data = [1, 2, 3, 4, 5, 6];\n *\n * let stream = stride(data, 2);\n *\n * toArray(stream);  // [1, 3, 5];\n * ```\n */\nfunction stride(object, step) {\n    return new StrideIterator(iter(object), step);\n}\n/**\n * An iterator which traverses a source iterator step-wise.\n */\nvar StrideIterator = /** @class */ (function () {\n    /**\n     * Construct a new stride iterator.\n     *\n     * @param source - The iterator of values of interest.\n     *\n     * @param step - The distance to step on each iteration. A value\n     *   of less than `1` will behave the same as a value of `1`.\n     */\n    function StrideIterator(source, step) {\n        this._source = source;\n        this._step = step;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    StrideIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    StrideIterator.prototype.clone = function () {\n        return new StrideIterator(this._source.clone(), this._step);\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    StrideIterator.prototype.next = function () {\n        var value = this._source.next();\n        for (var n = this._step - 1; n > 0; --n) {\n            this._source.next();\n        }\n        return value;\n    };\n    return StrideIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for string-specific algorithms.\n */\nvar StringExt;\n(function (StringExt) {\n    /**\n     * Find the indices of characters in a source text.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The matched indices, or `null` if there is no match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * In order for there to be a match, all of the characters in `query`\n     * **must** appear in `source` in the order given by `query`.\n     *\n     * Characters are matched using strict `===` equality.\n     */\n    function findIndices(source, query, start) {\n        if (start === void 0) { start = 0; }\n        var indices = new Array(query.length);\n        for (var i = 0, j = start, n = query.length; i < n; ++i, ++j) {\n            j = source.indexOf(query[i], j);\n            if (j === -1) {\n                return null;\n            }\n            indices[i] = j;\n        }\n        return indices;\n    }\n    StringExt.findIndices = findIndices;\n    /**\n     * A string matcher which uses a sum-of-squares algorithm.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The match result, or `null` if there is no match.\n     *   A lower `score` represents a stronger match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * This scoring algorithm uses a sum-of-squares approach to determine\n     * the score. In order for there to be a match, all of the characters\n     * in `query` **must** appear in `source` in order. The index of each\n     * matching character is squared and added to the score. This means\n     * that early and consecutive character matches are preferred, while\n     * late matches are heavily penalized.\n     */\n    function matchSumOfSquares(source, query, start) {\n        if (start === void 0) { start = 0; }\n        var indices = findIndices(source, query, start);\n        if (!indices) {\n            return null;\n        }\n        var score = 0;\n        for (var i = 0, n = indices.length; i < n; ++i) {\n            var j = indices[i] - start;\n            score += j * j;\n        }\n        return { score: score, indices: indices };\n    }\n    StringExt.matchSumOfSquares = matchSumOfSquares;\n    /**\n     * A string matcher which uses a sum-of-deltas algorithm.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The match result, or `null` if there is no match.\n     *   A lower `score` represents a stronger match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * This scoring algorithm uses a sum-of-deltas approach to determine\n     * the score. In order for there to be a match, all of the characters\n     * in `query` **must** appear in `source` in order. The delta between\n     * the indices are summed to create the score. This means that groups\n     * of matched characters are preferred, while fragmented matches are\n     * penalized.\n     */\n    function matchSumOfDeltas(source, query, start) {\n        if (start === void 0) { start = 0; }\n        var indices = findIndices(source, query, start);\n        if (!indices) {\n            return null;\n        }\n        var score = 0;\n        var last = start - 1;\n        for (var i = 0, n = indices.length; i < n; ++i) {\n            var j = indices[i];\n            score += j - last - 1;\n            last = j;\n        }\n        return { score: score, indices: indices };\n    }\n    StringExt.matchSumOfDeltas = matchSumOfDeltas;\n    /**\n     * Highlight the matched characters of a source text.\n     *\n     * @param source - The text which should be highlighted.\n     *\n     * @param indices - The indices of the matched characters. They must\n     *   appear in increasing order and must be in bounds of the source.\n     *\n     * @param fn - The function to apply to the matched chunks.\n     *\n     * @returns An array of unmatched and highlighted chunks.\n     */\n    function highlight(source, indices, fn) {\n        // Set up the result array.\n        var result = [];\n        // Set up the counter variables.\n        var k = 0;\n        var last = 0;\n        var n = indices.length;\n        // Iterator over each index.\n        while (k < n) {\n            // Set up the chunk indices.\n            var i = indices[k];\n            var j = indices[k];\n            // Advance the right chunk index until it's non-contiguous.\n            while (++k < n && indices[k] === j + 1) {\n                j++;\n            }\n            // Extract the unmatched text.\n            if (last < i) {\n                result.push(source.slice(last, i));\n            }\n            // Extract and highlight the matched text.\n            if (i < j + 1) {\n                result.push(fn(source.slice(i, j + 1)));\n            }\n            // Update the last visited index.\n            last = j + 1;\n        }\n        // Extract any remaining unmatched text.\n        if (last < source.length) {\n            result.push(source.slice(last));\n        }\n        // Return the highlighted result.\n        return result;\n    }\n    StringExt.highlight = highlight;\n    /**\n     * A 3-way string comparison function.\n     *\n     * @param a - The first string of interest.\n     *\n     * @param b - The second string of interest.\n     *\n     * @returns `-1` if `a < b`, else `1` if `a > b`, else `0`.\n     */\n    function cmp(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n    StringExt.cmp = cmp;\n})(StringExt || (StringExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Take a fixed number of items from an iterable.\n *\n * @param object - The iterable or array-like object of interest.\n *\n * @param count - The number of items to take from the iterable.\n *\n * @returns An iterator which yields the specified number of items\n *   from the source iterable.\n *\n * #### Notes\n * The returned iterator will exhaust early if the source iterable\n * contains an insufficient number of items.\n */\nfunction take(object, count) {\n    return new TakeIterator(iter(object), count);\n}\n/**\n * An iterator which takes a fixed number of items from a source.\n */\nvar TakeIterator = /** @class */ (function () {\n    /**\n     * Construct a new take iterator.\n     *\n     * @param source - The iterator of interest.\n     *\n     * @param count - The number of items to take from the source.\n     */\n    function TakeIterator(source, count) {\n        this._source = source;\n        this._count = count;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    TakeIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    TakeIterator.prototype.clone = function () {\n        return new TakeIterator(this._source.clone(), this._count);\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    TakeIterator.prototype.next = function () {\n        if (this._count <= 0) {\n            return undefined;\n        }\n        var value = this._source.next();\n        if (value === undefined) {\n            return undefined;\n        }\n        this._count--;\n        return value;\n    };\n    return TakeIterator;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * Iterate several iterables in lockstep.\n *\n * @param objects - The iterable or array-like objects of interest.\n *\n * @returns An iterator which yields successive tuples of values where\n *   each value is taken in turn from the provided iterables. It will\n *   be as long as the shortest provided iterable.\n *\n * #### Example\n * ```typescript\n * import { zip, toArray } from '@lumino/algorithm';\n *\n * let data1 = [1, 2, 3];\n * let data2 = [4, 5, 6];\n *\n * let stream = zip(data1, data2);\n *\n * toArray(stream);  // [[1, 4], [2, 5], [3, 6]]\n * ```\n */\nfunction zip() {\n    var objects = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n    }\n    return new ZipIterator(objects.map(iter));\n}\n/**\n * An iterator which iterates several sources in lockstep.\n */\nvar ZipIterator = /** @class */ (function () {\n    /**\n     * Construct a new zip iterator.\n     *\n     * @param source - The iterators of interest.\n     */\n    function ZipIterator(source) {\n        this._source = source;\n    }\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    ZipIterator.prototype.iter = function () {\n        return this;\n    };\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    ZipIterator.prototype.clone = function () {\n        return new ZipIterator(this._source.map(function (it) { return it.clone(); }));\n    };\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    ZipIterator.prototype.next = function () {\n        var result = new Array(this._source.length);\n        for (var i = 0, n = this._source.length; i < n; ++i) {\n            var value = this._source[i].next();\n            if (value === undefined) {\n                return undefined;\n            }\n            result[i] = value;\n        }\n        return result;\n    };\n    return ZipIterator;\n}());\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9hbGdvcml0aG0vZGlzdC9pbmRleC5lczYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsOEJBQThCLFVBQVUsYUFBYTtBQUNyRCw4QkFBOEIsbUJBQW1CLElBQUk7QUFDckQsOEJBQThCLFNBQVMsY0FBYztBQUNyRCw4QkFBOEIsVUFBVSxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RCxvREFBb0QsS0FBSztBQUN6RCxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Qsc0RBQXNELEtBQUs7QUFDM0Qsc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLDZCQUE2QixtQkFBbUIsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUNBQWlDLHFCQUFxQixHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQ0FBZ0MscUJBQXFCLEdBQUc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixpQkFBaUIsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4QkFBOEI7QUFDckMsT0FBTyxnQ0FBZ0M7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4QkFBOEI7QUFDckMsT0FBTyxnQ0FBZ0M7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVtZjtBQUNwZiIsInNvdXJjZXMiOlsid2VicGFjazovL0BhZnNoaW4vbGlmZS8uL25vZGVfbW9kdWxlcy9AbHVtaW5vL2FsZ29yaXRobS9kaXN0L2luZGV4LmVzNi5qcz80NGUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIFBob3NwaG9ySlMgQ29udHJpYnV0b3JzXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgTElDRU5TRSwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciBhcnJheS1zcGVjaWZpYyBhbGdvcml0aG1zLlxuICovXG52YXIgQXJyYXlFeHQ7XG4oZnVuY3Rpb24gKEFycmF5RXh0KSB7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSB2YWx1ZSBpbiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheS1saWtlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbG9jYXRlIGluIHRoZSBhcnJheS4gVmFsdWVzIGFyZVxuICAgICAqICAgY29tcGFyZWQgdXNpbmcgc3RyaWN0IGA9PT1gIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDBgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgLTFgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgdmFsdWUsIG9yIGAtMWBcbiAgICAgKiAgIGlmIHRoZSB2YWx1ZSBpcyBub3QgZm91bmQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgYHN0b3AgPCBzdGFydGAgdGhlIHNlYXJjaCB3aWxsIHdyYXAgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIEEgYHN0YXJ0YCBvciBgc3RvcGAgd2hpY2ggaXMgbm9uLWludGVncmFsLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICAgICAqXG4gICAgICogbGV0IGRhdGEgPSBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdvbmUnXTtcbiAgICAgKiBBcnJheUV4dC5maXJzdEluZGV4T2YoZGF0YSwgJ3JlZCcpOyAgICAgICAgLy8gLTFcbiAgICAgKiBBcnJheUV4dC5maXJzdEluZGV4T2YoZGF0YSwgJ29uZScpOyAgICAgICAgLy8gMFxuICAgICAqIEFycmF5RXh0LmZpcnN0SW5kZXhPZihkYXRhLCAnb25lJywgMSk7ICAgICAvLyA0XG4gICAgICogQXJyYXlFeHQuZmlyc3RJbmRleE9mKGRhdGEsICd0d28nLCAyKTsgICAgIC8vIC0xXG4gICAgICogQXJyYXlFeHQuZmlyc3RJbmRleE9mKGRhdGEsICd0d28nLCAyLCAxKTsgIC8vIDFcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wIDwgMCkge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWF4KDAsIHN0b3AgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1pbihzdG9wLCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwYW47XG4gICAgICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIHNwYW4gPSAoc3RvcCArIDEpICsgKG4gLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGFuID0gc3RvcCAtIHN0YXJ0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSAoc3RhcnQgKyBpKSAlIG47XG4gICAgICAgICAgICBpZiAoYXJyYXlbal0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBBcnJheUV4dC5maXJzdEluZGV4T2YgPSBmaXJzdEluZGV4T2Y7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5LWxpa2Ugb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LiBWYWx1ZXMgYXJlXG4gICAgICogICBjb21wYXJlZCB1c2luZyBzdHJpY3QgYD09PWAgZXF1YWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgLTFgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgdGhlIHZhbHVlLCBvciBgLTFgXG4gICAgICogICBpZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIGBzdGFydCA8IHN0b3BgIHRoZSBzZWFyY2ggd2lsbCB3cmFwIGF0IHRoZSBmcm9udCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIEEgYHN0YXJ0YCBvciBgc3RvcGAgd2hpY2ggaXMgbm9uLWludGVncmFsLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICAgICAqXG4gICAgICogbGV0IGRhdGEgPSBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdvbmUnXTtcbiAgICAgKiBBcnJheUV4dC5sYXN0SW5kZXhPZihkYXRhLCAncmVkJyk7ICAgICAgICAvLyAtMVxuICAgICAqIEFycmF5RXh0Lmxhc3RJbmRleE9mKGRhdGEsICdvbmUnKTsgICAgICAgIC8vIDRcbiAgICAgKiBBcnJheUV4dC5sYXN0SW5kZXhPZihkYXRhLCAnb25lJywgMSk7ICAgICAvLyAwXG4gICAgICogQXJyYXlFeHQubGFzdEluZGV4T2YoZGF0YSwgJ3R3bycsIDApOyAgICAgLy8gLTFcbiAgICAgKiBBcnJheUV4dC5sYXN0SW5kZXhPZihkYXRhLCAndHdvJywgMCwgMSk7ICAvLyAxXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IC0xOyB9XG4gICAgICAgIGlmIChzdG9wID09PSB2b2lkIDApIHsgc3RvcCA9IDA7IH1cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wIDwgMCkge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWF4KDAsIHN0b3AgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1pbihzdG9wLCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwYW47XG4gICAgICAgIGlmIChzdGFydCA8IHN0b3ApIHtcbiAgICAgICAgICAgIHNwYW4gPSAoc3RhcnQgKyAxKSArIChuIC0gc3RvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGFuID0gc3RhcnQgLSBzdG9wICsgMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSAoc3RhcnQgLSBpICsgbikgJSBuO1xuICAgICAgICAgICAgaWYgKGFycmF5W2pdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgQXJyYXlFeHQubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggbWF0Y2hlcyBhIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheS1saWtlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaGluZyB2YWx1ZSwgb3IgYC0xYCBpZiBub1xuICAgICAqICAgbWF0Y2hpbmcgdmFsdWUgaXMgZm91bmQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgYHN0b3AgPCBzdGFydGAgdGhlIHNlYXJjaCB3aWxsIHdyYXAgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIEEgYHN0YXJ0YCBvciBgc3RvcGAgd2hpY2ggaXMgbm9uLWludGVncmFsLlxuICAgICAqXG4gICAgICogTW9kaWZ5aW5nIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHdoaWxlIHNlYXJjaGluZy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbih2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICogICByZXR1cm4gdmFsdWUgJSAyID09PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGxldCBkYXRhID0gWzEsIDIsIDMsIDQsIDMsIDIsIDFdO1xuICAgICAqIEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KGRhdGEsIGlzRXZlbik7ICAgICAgIC8vIDFcbiAgICAgKiBBcnJheUV4dC5maW5kRmlyc3RJbmRleChkYXRhLCBpc0V2ZW4sIDQpOyAgICAvLyA1XG4gICAgICogQXJyYXlFeHQuZmluZEZpcnN0SW5kZXgoZGF0YSwgaXNFdmVuLCA2KTsgICAgLy8gLTFcbiAgICAgKiBBcnJheUV4dC5maW5kRmlyc3RJbmRleChkYXRhLCBpc0V2ZW4sIDYsIDUpOyAvLyAxXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEZpcnN0SW5kZXgoYXJyYXksIGZuLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wIDwgMCkge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWF4KDAsIHN0b3AgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1pbihzdG9wLCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwYW47XG4gICAgICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIHNwYW4gPSAoc3RvcCArIDEpICsgKG4gLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGFuID0gc3RvcCAtIHN0YXJ0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSAoc3RhcnQgKyBpKSAlIG47XG4gICAgICAgICAgICBpZiAoZm4oYXJyYXlbal0sIGopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBBcnJheUV4dC5maW5kRmlyc3RJbmRleCA9IGZpbmRGaXJzdEluZGV4O1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHZhbHVlIHdoaWNoIG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gVGhlIGFycmF5LWxpa2Ugb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAwYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGxhc3QgbWF0Y2hpbmcgdmFsdWUsIG9yIGAtMWAgaWYgbm9cbiAgICAgKiAgIG1hdGNoaW5nIHZhbHVlIGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIGBzdGFydCA8IHN0b3BgIHRoZSBzZWFyY2ggd2lsbCB3cmFwIGF0IHRoZSBmcm9udCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIEEgYHN0YXJ0YCBvciBgc3RvcGAgd2hpY2ggaXMgbm9uLWludGVncmFsLlxuICAgICAqXG4gICAgICogTW9kaWZ5aW5nIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHdoaWxlIHNlYXJjaGluZy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbih2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICogICByZXR1cm4gdmFsdWUgJSAyID09PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGxldCBkYXRhID0gWzEsIDIsIDMsIDQsIDMsIDIsIDFdO1xuICAgICAqIEFycmF5RXh0LmZpbmRMYXN0SW5kZXgoZGF0YSwgaXNFdmVuKTsgICAgICAgIC8vIDVcbiAgICAgKiBBcnJheUV4dC5maW5kTGFzdEluZGV4KGRhdGEsIGlzRXZlbiwgNCk7ICAgICAvLyAzXG4gICAgICogQXJyYXlFeHQuZmluZExhc3RJbmRleChkYXRhLCBpc0V2ZW4sIDApOyAgICAgLy8gLTFcbiAgICAgKiBBcnJheUV4dC5maW5kTGFzdEluZGV4KGRhdGEsIGlzRXZlbiwgMCwgMSk7ICAvLyA1XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgZm4sIHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gLTE7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gMDsgfVxuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ICsgbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3AgPCAwKSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5tYXgoMCwgc3RvcCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWluKHN0b3AsIG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZDtcbiAgICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkge1xuICAgICAgICAgICAgZCA9IChzdGFydCArIDEpICsgKG4gLSBzdG9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBzdGFydCAtIHN0b3AgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaiA9IChzdGFydCAtIGkgKyBuKSAlIG47XG4gICAgICAgICAgICBpZiAoZm4oYXJyYXlbal0sIGopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBBcnJheUV4dC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5LWxpa2Ugb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAwYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcCAtIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYC0xYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nXG4gICAgICogICB2YWx1ZSBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiBgc3RvcCA8IHN0YXJ0YCB0aGUgc2VhcmNoIHdpbGwgd3JhcCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQSBgc3RhcnRgIG9yIGBzdG9wYCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiBNb2RpZnlpbmcgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgd2hpbGUgc2VhcmNoaW5nLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgKiAgIHJldHVybiB2YWx1ZSAlIDIgPT09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogbGV0IGRhdGEgPSBbMSwgMiwgMywgNCwgMywgMiwgMV07XG4gICAgICogQXJyYXlFeHQuZmluZEZpcnN0VmFsdWUoZGF0YSwgaXNFdmVuKTsgICAgICAgLy8gMlxuICAgICAqIEFycmF5RXh0LmZpbmRGaXJzdFZhbHVlKGRhdGEsIGlzRXZlbiwgMik7ICAgIC8vIDRcbiAgICAgKiBBcnJheUV4dC5maW5kRmlyc3RWYWx1ZShkYXRhLCBpc0V2ZW4sIDYpOyAgICAvLyB1bmRlZmluZWRcbiAgICAgKiBBcnJheUV4dC5maW5kRmlyc3RWYWx1ZShkYXRhLCBpc0V2ZW4sIDYsIDUpOyAvLyAyXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEZpcnN0VmFsdWUoYXJyYXksIGZuLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEZpcnN0SW5kZXgoYXJyYXksIGZuLCBzdGFydCwgc3RvcCk7XG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gLTEgPyBhcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEFycmF5RXh0LmZpbmRGaXJzdFZhbHVlID0gZmluZEZpcnN0VmFsdWU7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbGFzdCB2YWx1ZSB3aGljaCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iamVjdCAtIFRoZSBhcnJheS1saWtlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgLTFgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxhc3QgbWF0Y2hpbmcgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nXG4gICAgICogICB2YWx1ZSBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiBgc3RhcnQgPCBzdG9wYCB0aGUgc2VhcmNoIHdpbGwgd3JhcCBhdCB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyLlxuICAgICAqXG4gICAgICogIyMjIyBVbmRlZmluZWQgQmVoYXZpb3JcbiAgICAgKiBBIGBzdGFydGAgb3IgYHN0b3BgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqIE1vZGlmeWluZyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB3aGlsZSBzZWFyY2hpbmcuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4odmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAqICAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFsxLCAyLCAzLCA0LCAzLCAyLCAxXTtcbiAgICAgKiBBcnJheUV4dC5maW5kTGFzdFZhbHVlKGRhdGEsIGlzRXZlbik7ICAgICAgICAvLyAyXG4gICAgICogQXJyYXlFeHQuZmluZExhc3RWYWx1ZShkYXRhLCBpc0V2ZW4sIDQpOyAgICAgLy8gNFxuICAgICAqIEFycmF5RXh0LmZpbmRMYXN0VmFsdWUoZGF0YSwgaXNFdmVuLCAwKTsgICAgIC8vIHVuZGVmaW5lZFxuICAgICAqIEFycmF5RXh0LmZpbmRMYXN0VmFsdWUoZGF0YSwgaXNFdmVuLCAwLCAxKTsgIC8vIDJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdFZhbHVlKGFycmF5LCBmbiwgc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAtMTsgfVxuICAgICAgICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7IHN0b3AgPSAwOyB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRMYXN0SW5kZXgoYXJyYXksIGZuLCBzdGFydCwgc3RvcCk7XG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gLTEgPyBhcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEFycmF5RXh0LmZpbmRMYXN0VmFsdWUgPSBmaW5kTGFzdFZhbHVlO1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IHdoaWNoIGNvbXBhcmVzIGA+PWAgdG8gYSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBzb3J0ZWQgYXJyYXktbGlrZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgMy13YXkgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICAgICAqICAgSXQgc2hvdWxkIHJldHVybiBgPCAwYCBpZiBhbiBlbGVtZW50IGlzIGxlc3MgdGhhbiBhIHZhbHVlLCBgMGAgaWZcbiAgICAgKiAgIGFuIGVsZW1lbnQgaXMgZXF1YWwgdG8gYSB2YWx1ZSwgb3IgYD4gMGAgaWYgYW4gZWxlbWVudCBpcyBncmVhdGVyXG4gICAgICogICB0aGFuIGEgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IHdoaWNoIGNvbXBhcmVzIGA+PWAgdG8gdGhlXG4gICAgICogICB2YWx1ZSwgb3IgYGxlbmd0aGAgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50LiBJZiB0aGUgY29tcHV0ZWRcbiAgICAgKiAgIGluZGV4IGZvciBgc3RvcGAgaXMgbGVzcyB0aGFuIGBzdGFydGAsIHRoZW4gdGhlIGNvbXB1dGVkIGluZGV4XG4gICAgICogICBmb3IgYHN0YXJ0YCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgYXJyYXkgbXVzdCBhbHJlYWR5IGJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYWNjb3JkaW5nIHRvXG4gICAgICogdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMb2dhcml0aG1pYy5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogU2VhcmNoaW5nIGEgcmFuZ2Ugd2hpY2ggaXMgbm90IHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBBIGBzdGFydGAgb3IgYHN0b3BgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqIE1vZGlmeWluZyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB3aGlsZSBzZWFyY2hpbmcuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBudW1iZXJDbXAoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAqICAgcmV0dXJuIGEgLSBiO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGxldCBkYXRhID0gWzAsIDMsIDQsIDcsIDcsIDldO1xuICAgICAqIEFycmF5RXh0Lmxvd2VyQm91bmQoZGF0YSwgMCwgbnVtYmVyQ21wKTsgICAvLyAwXG4gICAgICogQXJyYXlFeHQubG93ZXJCb3VuZChkYXRhLCA2LCBudW1iZXJDbXApOyAgIC8vIDNcbiAgICAgKiBBcnJheUV4dC5sb3dlckJvdW5kKGRhdGEsIDcsIG51bWJlckNtcCk7ICAgLy8gM1xuICAgICAqIEFycmF5RXh0Lmxvd2VyQm91bmQoZGF0YSwgLTEsIG51bWJlckNtcCk7ICAvLyAwXG4gICAgICogQXJyYXlFeHQubG93ZXJCb3VuZChkYXRhLCAxMCwgbnVtYmVyQ21wKTsgIC8vIDZcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb3dlckJvdW5kKGFycmF5LCB2YWx1ZSwgZm4sIHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7IHN0b3AgPSAtMTsgfVxuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcCA8IDApIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1heCgwLCBzdG9wICsgbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5taW4oc3RvcCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbiA9IHN0YXJ0O1xuICAgICAgICB2YXIgc3BhbiA9IHN0b3AgLSBzdGFydCArIDE7XG4gICAgICAgIHdoaWxlIChzcGFuID4gMCkge1xuICAgICAgICAgICAgdmFyIGhhbGYgPSBzcGFuID4+IDE7XG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gYmVnaW4gKyBoYWxmO1xuICAgICAgICAgICAgaWYgKGZuKGFycmF5W21pZGRsZV0sIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IG1pZGRsZSArIDE7XG4gICAgICAgICAgICAgICAgc3BhbiAtPSBoYWxmICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYW4gPSBoYWxmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZWdpbjtcbiAgICB9XG4gICAgQXJyYXlFeHQubG93ZXJCb3VuZCA9IGxvd2VyQm91bmQ7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgd2hpY2ggY29tcGFyZXMgYD5gIHRoYW4gYSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBzb3J0ZWQgYXJyYXktbGlrZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgMy13YXkgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICAgICAqICAgSXQgc2hvdWxkIHJldHVybiBgPCAwYCBpZiBhbiBlbGVtZW50IGlzIGxlc3MgdGhhbiBhIHZhbHVlLCBgMGAgaWZcbiAgICAgKiAgIGFuIGVsZW1lbnQgaXMgZXF1YWwgdG8gYSB2YWx1ZSwgb3IgYD4gMGAgaWYgYW4gZWxlbWVudCBpcyBncmVhdGVyXG4gICAgICogICB0aGFuIGEgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IHdoaWNoIGNvbXBhcmVzIGA+YCB0aGFuIHRoZVxuICAgICAqICAgdmFsdWUsIG9yIGBsZW5ndGhgIGlmIHRoZXJlIGlzIG5vIHN1Y2ggZWxlbWVudC4gSWYgdGhlIGNvbXB1dGVkXG4gICAgICogICBpbmRleCBmb3IgYHN0b3BgIGlzIGxlc3MgdGhhbiBgc3RhcnRgLCB0aGVuIHRoZSBjb21wdXRlZCBpbmRleFxuICAgICAqICAgZm9yIGBzdGFydGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGFycmF5IG11c3QgYWxyZWFkeSBiZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGFjY29yZGluZyB0b1xuICAgICAqIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTG9nYXJpdGhtaWMuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIFNlYXJjaGluZyBhIHJhbmdlIHdoaWNoIGlzIG5vdCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQSBgc3RhcnRgIG9yIGBzdG9wYCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiBNb2RpZnlpbmcgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgd2hpbGUgc2VhcmNoaW5nLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICAgICAqXG4gICAgICogZnVuY3Rpb24gbnVtYmVyQ21wKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgKiAgIHJldHVybiBhIC0gYjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAzLCA0LCA3LCA3LCA5XTtcbiAgICAgKiBBcnJheUV4dC51cHBlckJvdW5kKGRhdGEsIDAsIG51bWJlckNtcCk7ICAgLy8gMVxuICAgICAqIEFycmF5RXh0LnVwcGVyQm91bmQoZGF0YSwgNiwgbnVtYmVyQ21wKTsgICAvLyAzXG4gICAgICogQXJyYXlFeHQudXBwZXJCb3VuZChkYXRhLCA3LCBudW1iZXJDbXApOyAgIC8vIDVcbiAgICAgKiBBcnJheUV4dC51cHBlckJvdW5kKGRhdGEsIC0xLCBudW1iZXJDbXApOyAgLy8gMFxuICAgICAqIEFycmF5RXh0LnVwcGVyQm91bmQoZGF0YSwgMTAsIG51bWJlckNtcCk7ICAvLyA2XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBwZXJCb3VuZChhcnJheSwgdmFsdWUsIGZuLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ICsgbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3AgPCAwKSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5tYXgoMCwgc3RvcCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWluKHN0b3AsIG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVnaW4gPSBzdGFydDtcbiAgICAgICAgdmFyIHNwYW4gPSBzdG9wIC0gc3RhcnQgKyAxO1xuICAgICAgICB3aGlsZSAoc3BhbiA+IDApIHtcbiAgICAgICAgICAgIHZhciBoYWxmID0gc3BhbiA+PiAxO1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IGJlZ2luICsgaGFsZjtcbiAgICAgICAgICAgIGlmIChmbihhcnJheVttaWRkbGVdLCB2YWx1ZSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3BhbiA9IGhhbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZWdpbiA9IG1pZGRsZSArIDE7XG4gICAgICAgICAgICAgICAgc3BhbiAtPSBoYWxmICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVnaW47XG4gICAgfVxuICAgIEFycmF5RXh0LnVwcGVyQm91bmQgPSB1cHBlckJvdW5kO1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0d28gYXJyYXlzIGFyZSBzaGFsbG93bHkgZXF1YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBhcnJheS1saWtlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgZWxlbWVudHMuIEl0XG4gICAgICogICBzaG91bGQgcmV0dXJuIGB0cnVlYCBpZiB0aGUgZWxlbWVudHMgYXJlIFwiZXF1YWxcIi4gVGhlIGRlZmF1bHRcbiAgICAgKiAgIGNvbXBhcmVzIGVsZW1lbnRzIHVzaW5nIHN0cmljdCBgPT09YCBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIHNoYWxsb3dseSBlcXVhbC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogTW9kaWZ5aW5nIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5cyB3aGlsZSBjb21wYXJpbmcuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZDEgPSBbMCwgMywgNCwgNywgNywgOV07XG4gICAgICogbGV0IGQyID0gWzAsIDMsIDQsIDcsIDcsIDldO1xuICAgICAqIGxldCBkMyA9IFs0Ml07XG4gICAgICogQXJyYXlFeHQuc2hhbGxvd0VxdWFsKGQxLCBkMik7ICAvLyB0cnVlXG4gICAgICogQXJyYXlFeHQuc2hhbGxvd0VxdWFsKGQyLCBkMyk7ICAvLyBmYWxzZVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhLCBiLCBmbikge1xuICAgICAgICAvLyBDaGVjayBmb3Igb2JqZWN0IGlkZW50aXR5IGZpcnN0LlxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgbGVuZ3RocyBhcmUgZGlmZmVyZW50LlxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBlYWNoIGVsZW1lbnQgZm9yIGVxdWFsaXR5LlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZm4gPyAhZm4oYVtpXSwgYltpXSkgOiBhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBhcnJheSBhcmUgc2hhbGxvd2x5IGVxdWFsLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgQXJyYXlFeHQuc2hhbGxvd0VxdWFsID0gc2hhbGxvd0VxdWFsO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNsaWNlIG9mIGFuIGFycmF5IHN1YmplY3QgdG8gYW4gb3B0aW9uYWwgc3RlcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSBzbGljZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEFuIGV4Y2VwdGlvbiBpZiB0aGUgc2xpY2UgYHN0ZXBgIGlzIGAwYC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQSBgc3RhcnRgLCBgc3RvcGAsIG9yIGBzdGVwYCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAzLCA0LCA3LCA3LCA5XTtcbiAgICAgKiBBcnJheUV4dC5zbGljZShkYXRhKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWzAsIDMsIDQsIDcsIDcsIDldXG4gICAgICogQXJyYXlFeHQuc2xpY2UoZGF0YSwgeyBzdGFydDogMiB9KTsgICAgICAgICAgIC8vIFs0LCA3LCA3LCA5XVxuICAgICAqIEFycmF5RXh0LnNsaWNlKGRhdGEsIHsgc3RhcnQ6IDAsIHN0b3A6IDQgfSk7ICAvLyBbMCwgMywgNCwgN11cbiAgICAgKiBBcnJheUV4dC5zbGljZShkYXRhLCB7IHN0ZXA6IDIgfSk7ICAgICAgICAgICAgLy8gWzAsIDQsIDddXG4gICAgICogQXJyYXlFeHQuc2xpY2UoZGF0YSwgeyBzdGVwOiAtMSB9KTsgICAgICAgICAgIC8vIFs5LCA3LCA3LCA0LCAzLCAwXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIG9wdGlvbnMuXG4gICAgICAgIHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQsIHN0b3AgPSBvcHRpb25zLnN0b3AsIHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgYHN0ZXBgIHZhbHVlLlxuICAgICAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc3RlcCBzaXplLlxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTbGljZSBgc3RlcGAgY2Fubm90IGJlIHplcm8uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgYHN0YXJ0YCB2YWx1ZS5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RlcCA8IDAgPyBuIC0gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0ICsgbiwgc3RlcCA8IDAgPyAtMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID49IG4pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RlcCA8IDAgPyBuIC0gMSA6IG47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHVwIHRoZSBgc3RvcGAgdmFsdWUuXG4gICAgICAgIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGVwIDwgMCA/IC0xIDogbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG9wIDwgMCkge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWF4KHN0b3AgKyBuLCBzdGVwIDwgMCA/IC0xIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcCA+PSBuKSB7XG4gICAgICAgICAgICBzdG9wID0gc3RlcCA8IDAgPyBuIC0gMSA6IG47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgc2xpY2UgbGVuZ3RoLlxuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICBpZiAoKHN0ZXAgPCAwICYmIHN0b3AgPj0gc3RhcnQpIHx8IChzdGVwID4gMCAmJiBzdGFydCA+PSBzdG9wKSkge1xuICAgICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC5mbG9vcigoc3RvcCAtIHN0YXJ0ICsgMSkgLyBzdGVwICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBNYXRoLmZsb29yKChzdG9wIC0gc3RhcnQgLSAxKSAvIHN0ZXAgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBzbGljZWQgcmVzdWx0LlxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGFycmF5W3N0YXJ0ICsgaSAqIHN0ZXBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBBcnJheUV4dC5zbGljZSA9IHNsaWNlO1xuICAgIC8qKlxuICAgICAqIE1vdmUgYW4gZWxlbWVudCBpbiBhbiBhcnJheSBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIG11dGFibGUgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIG1vdmUuIE5lZ2F0aXZlXG4gICAgICogICB2YWx1ZXMgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvSW5kZXggLSBUaGUgdGFyZ2V0IGluZGV4IG9mIHRoZSBlbGVtZW50LiBOZWdhdGl2ZVxuICAgICAqICAgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQSBgZnJvbUluZGV4YCBvciBgdG9JbmRleGAgd2hpY2ggaXMgbm9uLWludGVncmFsLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAxLCAyLCAzLCA0XTtcbiAgICAgKiBBcnJheUV4dC5tb3ZlKGRhdGEsIDEsIDIpOyAgLy8gWzAsIDIsIDEsIDMsIDRdXG4gICAgICogQXJyYXlFeHQubW92ZShkYXRhLCA0LCAyKTsgIC8vIFswLCAyLCA0LCAxLCAzXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vdmUoYXJyYXksIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgICAgICBmcm9tSW5kZXggPSBNYXRoLm1heCgwLCBmcm9tSW5kZXggKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb21JbmRleCA9IE1hdGgubWluKGZyb21JbmRleCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0luZGV4IDwgMCkge1xuICAgICAgICAgICAgdG9JbmRleCA9IE1hdGgubWF4KDAsIHRvSW5kZXggKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvSW5kZXggPSBNYXRoLm1pbih0b0luZGV4LCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2Zyb21JbmRleF07XG4gICAgICAgIHZhciBkID0gZnJvbUluZGV4IDwgdG9JbmRleCA/IDEgOiAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSAhPT0gdG9JbmRleDsgaSArPSBkKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyBkXTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVt0b0luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICBBcnJheUV4dC5tb3ZlID0gbW92ZTtcbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIGFuIGFycmF5IGluLXBsYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIG11dGFibGUgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICByZXZlcnNlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHJldmVyc2VkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyLlxuICAgICAqXG4gICAgICogIyMjIyBVbmRlZmluZWQgQmVoYXZpb3JcbiAgICAgKiBBIGBzdGFydGAgb3IgIGBzdG9wYCBpbmRleCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAxLCAyLCAzLCA0XTtcbiAgICAgKiBBcnJheUV4dC5yZXZlcnNlKGRhdGEsIDEsIDMpOyAgLy8gWzAsIDMsIDIsIDEsIDRdXG4gICAgICogQXJyYXlFeHQucmV2ZXJzZShkYXRhLCAzKTsgICAgIC8vIFswLCAzLCAyLCA0LCAxXVxuICAgICAqIEFycmF5RXh0LnJldmVyc2UoZGF0YSk7ICAgICAgICAvLyBbMSwgNCwgMiwgMywgMF1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5LCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ICsgbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3AgPCAwKSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5tYXgoMCwgc3RvcCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWluKHN0b3AsIG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhcnQgPCBzdG9wKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFycmF5W3N0YXJ0XTtcbiAgICAgICAgICAgIHZhciBiID0gYXJyYXlbc3RvcF07XG4gICAgICAgICAgICBhcnJheVtzdGFydCsrXSA9IGI7XG4gICAgICAgICAgICBhcnJheVtzdG9wLS1dID0gYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheUV4dC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICAvKipcbiAgICAgKiBSb3RhdGUgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IGluLXBsYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIG11dGFibGUgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgYW1vdW50IG9mIHJvdGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBlbGVtZW50cy4gQVxuICAgICAqICAgcG9zaXRpdmUgdmFsdWUgd2lsbCByb3RhdGUgdGhlIGVsZW1lbnRzIHRvIHRoZSBsZWZ0LiBBIG5lZ2F0aXZlXG4gICAgICogICB2YWx1ZSB3aWxsIHJvdGF0ZSB0aGUgZWxlbWVudHMgdG8gdGhlIHJpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgcm90YXRlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHJvdGF0ZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYC0xYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIEEgYGRlbHRhYCwgYHN0YXJ0YCwgb3IgYHN0b3BgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAgICAgKlxuICAgICAqIGxldCBkYXRhID0gWzAsIDEsIDIsIDMsIDRdO1xuICAgICAqIEFycmF5RXh0LnJvdGF0ZShkYXRhLCAyKTsgICAgICAgIC8vIFsyLCAzLCA0LCAwLCAxXVxuICAgICAqIEFycmF5RXh0LnJvdGF0ZShkYXRhLCAtMik7ICAgICAgIC8vIFswLCAxLCAyLCAzLCA0XVxuICAgICAqIEFycmF5RXh0LnJvdGF0ZShkYXRhLCAxMCk7ICAgICAgIC8vIFswLCAxLCAyLCAzLCA0XVxuICAgICAqIEFycmF5RXh0LnJvdGF0ZShkYXRhLCA5KTsgICAgICAgIC8vIFs0LCAwLCAxLCAyLCAzXVxuICAgICAqIEFycmF5RXh0LnJvdGF0ZShkYXRhLCAyLCAxLCAzKTsgIC8vIFs0LCAyLCAwLCAxLCAzXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZShhcnJheSwgZGVsdGEsIHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7IHN0b3AgPSAtMTsgfVxuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcCA8IDApIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1heCgwLCBzdG9wICsgbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5taW4oc3RvcCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA+PSBzdG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3AgLSBzdGFydCArIDE7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgJSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBkZWx0YSA9ICgoZGVsdGEgJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGl2b3QgPSBzdGFydCArIGRlbHRhO1xuICAgICAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgcGl2b3QgLSAxKTtcbiAgICAgICAgcmV2ZXJzZShhcnJheSwgcGl2b3QsIHN0b3ApO1xuICAgICAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgc3RvcCk7XG4gICAgfVxuICAgIEFycmF5RXh0LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgICAvKipcbiAgICAgKiBGaWxsIGFuIGFycmF5IHdpdGggYSBzdGF0aWMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgbXV0YWJsZSBhcnJheS1saWtlIG9iamVjdCB0byBmaWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0YXRpYyB2YWx1ZSB0byB1c2UgdG8gZmlsbCB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBmaWxsZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDBgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBmaWxsZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYC0xYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgYHN0b3AgPCBzdGFydGAgdGhlIGZpbGwgd2lsbCB3cmFwIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyLlxuICAgICAqXG4gICAgICogIyMjIyBVbmRlZmluZWQgQmVoYXZpb3JcbiAgICAgKiBBIGBzdGFydGAgb3IgYHN0b3BgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAgICAgKlxuICAgICAqIGxldCBkYXRhID0gWydvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInXTtcbiAgICAgKiBBcnJheUV4dC5maWxsKGRhdGEsICdyJyk7ICAgICAgICAvLyBbJ3InLCAncicsICdyJywgJ3InXVxuICAgICAqIEFycmF5RXh0LmZpbGwoZGF0YSwgJ2cnLCAxKTsgICAgIC8vIFsncicsICdnJywgJ2cnLCAnZyddXG4gICAgICogQXJyYXlFeHQuZmlsbChkYXRhLCAnYicsIDIsIDMpOyAgLy8gWydyJywgJ2cnLCAnYicsICdiJ11cbiAgICAgKiBBcnJheUV4dC5maWxsKGRhdGEsICd6JywgMywgMSk7ICAvLyBbJ3onLCAneicsICdiJywgJ3onXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wIDwgMCkge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWF4KDAsIHN0b3AgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1pbihzdG9wLCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwYW47XG4gICAgICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgICAgICAgIHNwYW4gPSAoc3RvcCArIDEpICsgKG4gLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGFuID0gc3RvcCAtIHN0YXJ0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47ICsraSkge1xuICAgICAgICAgICAgYXJyYXlbKHN0YXJ0ICsgaSkgJSBuXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5RXh0LmZpbGwgPSBmaWxsO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHZhbHVlIGludG8gYW4gYXJyYXkgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIHZhbHVlLiBOZWdhdGl2ZVxuICAgICAqICAgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAxLCAyXTtcbiAgICAgKiBBcnJheUV4dC5pbnNlcnQoZGF0YSwgMCwgLTEpOyAgLy8gWy0xLCAwLCAxLCAyXVxuICAgICAqIEFycmF5RXh0Lmluc2VydChkYXRhLCAyLCAxMik7ICAvLyBbLTEsIDAsIDEyLCAxLCAyXVxuICAgICAqIEFycmF5RXh0Lmluc2VydChkYXRhLCAtMSwgNyk7ICAvLyBbLTEsIDAsIDEyLCAxLCA3LCAyXVxuICAgICAqIEFycmF5RXh0Lmluc2VydChkYXRhLCA2LCAxOSk7ICAvLyBbLTEsIDAsIDEyLCAxLCA3LCAyLCAxOV1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBpbmRleCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiBpbmRleDsgLS1pKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgQXJyYXlFeHQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbmQgcmV0dXJuIGEgdmFsdWUgYXQgYSBzcGVjaWZpYyBpbmRleCBpbiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBvciBgdW5kZWZpbmVkYCBpZiB0aGVcbiAgICAgKiAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAxMiwgMjMsIDM5LCAxNCwgMTIsIDc1XTtcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVBdChkYXRhLCAyKTsgICAvLyAyM1xuICAgICAqIEFycmF5RXh0LnJlbW92ZUF0KGRhdGEsIC0yKTsgIC8vIDEyXG4gICAgICogQXJyYXlFeHQucmVtb3ZlQXQoZGF0YSwgMTApOyAgLy8gdW5kZWZpbmVkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUF0KGFycmF5LCBpbmRleCkge1xuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IG4pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBhcnJheVtpIC0gMV0gPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheS5sZW5ndGggPSBuIC0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBBcnJheUV4dC5yZW1vdmVBdCA9IHJlbW92ZUF0O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5LiBWYWx1ZXMgYXJlXG4gICAgICogICBjb21wYXJlZCB1c2luZyBzdHJpY3QgYD09PWAgZXF1YWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgMGAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSByZW1vdmVkIHZhbHVlLCBvciBgLTFgIGlmIHRoZSB2YWx1ZVxuICAgICAqICAgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgYHN0b3AgPCBzdGFydGAgdGhlIHNlYXJjaCB3aWxsIHdyYXAgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFswLCAxMiwgMjMsIDM5LCAxNCwgMTIsIDc1XTtcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVGaXJzdE9mKGRhdGEsIDEyKTsgICAgICAgIC8vIDFcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVGaXJzdE9mKGRhdGEsIDE3KTsgICAgICAgIC8vIC0xXG4gICAgICogQXJyYXlFeHQucmVtb3ZlRmlyc3RPZihkYXRhLCAzOSwgMyk7ICAgICAvLyAtMVxuICAgICAqIEFycmF5RXh0LnJlbW92ZUZpcnN0T2YoZGF0YSwgMzksIDMsIDIpOyAgLy8gMlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUZpcnN0T2YoYXJyYXksIHZhbHVlLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmlyc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgc3RhcnQsIHN0b3ApO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICByZW1vdmVBdChhcnJheSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgQXJyYXlFeHQucmVtb3ZlRmlyc3RPZiA9IHJlbW92ZUZpcnN0T2Y7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYSB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheS4gVmFsdWVzIGFyZVxuICAgICAqICAgY29tcGFyZWQgdXNpbmcgc3RyaWN0IGA9PT1gIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYC0xYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcCAtIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDBgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgcmVtb3ZlZCB2YWx1ZSwgb3IgYC0xYCBpZiB0aGUgdmFsdWVcbiAgICAgKiAgIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIGBzdGFydCA8IHN0b3BgIHRoZSBzZWFyY2ggd2lsbCB3cmFwIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICAgICAqXG4gICAgICogbGV0IGRhdGEgPSBbMCwgMTIsIDIzLCAzOSwgMTQsIDEyLCA3NV07XG4gICAgICogQXJyYXlFeHQucmVtb3ZlTGFzdE9mKGRhdGEsIDEyKTsgICAgICAgIC8vIDVcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVMYXN0T2YoZGF0YSwgMTcpOyAgICAgICAgLy8gLTFcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVMYXN0T2YoZGF0YSwgMzksIDIpOyAgICAgLy8gLTFcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVMYXN0T2YoZGF0YSwgMzksIDIsIDMpOyAgLy8gM1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUxhc3RPZihhcnJheSwgdmFsdWUsIHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gLTE7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gMDsgfVxuICAgICAgICB2YXIgaW5kZXggPSBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcmVtb3ZlQXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIEFycmF5RXh0LnJlbW92ZUxhc3RPZiA9IHJlbW92ZUxhc3RPZjtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGEgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZW1vdmUgZnJvbSB0aGUgYXJyYXkuIFZhbHVlcyBhcmVcbiAgICAgKiAgIGNvbXBhcmVkIHVzaW5nIHN0cmljdCBgPT09YCBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAwYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcCAtIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYC0xYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgYHN0b3AgPCBzdGFydGAgdGhlIHNlYXJjaCB3aWxsIGNvbmNlcHR1YWxseSB3cmFwIGF0IHRoZSBlbmQgb2ZcbiAgICAgKiB0aGUgYXJyYXksIGhvd2V2ZXIgdGhlIGFycmF5IHdpbGwgYmUgdHJhdmVyc2VkIGZyb250LXRvLWJhY2suXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBsZXQgZGF0YSA9IFsxNCwgMTIsIDIzLCAzOSwgMTQsIDEyLCAxOSwgMTRdO1xuICAgICAqIEFycmF5RXh0LnJlbW92ZUFsbE9mKGRhdGEsIDEyKTsgICAgICAgIC8vIDJcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVBbGxPZihkYXRhLCAxNyk7ICAgICAgICAvLyAwXG4gICAgICogQXJyYXlFeHQucmVtb3ZlQWxsT2YoZGF0YSwgMTQsIDEsIDQpOyAgLy8gMVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbE9mKGFycmF5LCB2YWx1ZSwgc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgICAgIGlmIChzdG9wID09PSB2b2lkIDApIHsgc3RvcCA9IC0xOyB9XG4gICAgICAgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCArIG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wIDwgMCkge1xuICAgICAgICAgICAgc3RvcCA9IE1hdGgubWF4KDAsIHN0b3AgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1pbihzdG9wLCBuIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBzdG9wICYmIChpID49IHN0YXJ0ICYmIGkgPD0gc3RvcCkgJiYgYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3AgPCBzdGFydCAmJiAoaSA8PSBzdG9wIHx8IGkgPj0gc3RhcnQpICYmIGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpIC0gY291bnRdID0gYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgYXJyYXkubGVuZ3RoID0gbiAtIGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgQXJyYXlFeHQucmVtb3ZlQWxsT2YgPSByZW1vdmVBbGxPZjtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSB2YWx1ZSB3aGljaCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDBgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXG4gICAgICogICBzZWFyY2hlZCwgaW5jbHVzaXZlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgLTFgLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiAgIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZW1vdmVkIGB7IGluZGV4LCB2YWx1ZSB9YCwgd2hpY2ggd2lsbCBiZSBgLTFgIGFuZFxuICAgICAqICAgYHVuZGVmaW5lZGAgaWYgdGhlIHZhbHVlIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIGBzdG9wIDwgc3RhcnRgIHRoZSBzZWFyY2ggd2lsbCB3cmFwIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IEFycmF5RXh0IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgKiAgIHJldHVybiB2YWx1ZSAlIDIgPT09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogbGV0IGRhdGEgPSBbMCwgMTIsIDIzLCAzOSwgMTQsIDEyLCA3NV07XG4gICAgICogQXJyYXlFeHQucmVtb3ZlRmlyc3RXaGVyZShkYXRhLCBpc0V2ZW4pOyAgICAgLy8geyBpbmRleDogMCwgdmFsdWU6IDAgfVxuICAgICAqIEFycmF5RXh0LnJlbW92ZUZpcnN0V2hlcmUoZGF0YSwgaXNFdmVuLCAyKTsgIC8vIHsgaW5kZXg6IDMsIHZhbHVlOiAxNCB9XG4gICAgICogQXJyYXlFeHQucmVtb3ZlRmlyc3RXaGVyZShkYXRhLCBpc0V2ZW4sIDQpOyAgLy8geyBpbmRleDogLTEsIHZhbHVlOiB1bmRlZmluZWQgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUZpcnN0V2hlcmUoYXJyYXksIGZuLCBzdGFydCwgc3RvcCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gLTE7IH1cbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kRmlyc3RJbmRleChhcnJheSwgZm4sIHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZW1vdmVBdChhcnJheSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGV4OiBpbmRleCwgdmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIEFycmF5RXh0LnJlbW92ZUZpcnN0V2hlcmUgPSByZW1vdmVGaXJzdFdoZXJlO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGEgdmFsdWUgd2hpY2ggbWF0Y2hlcyBhIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAtMWAuIE5lZ2F0aXZlIHZhbHVlc1xuICAgICAqICAgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAwYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCBgeyBpbmRleCwgdmFsdWUgfWAsIHdoaWNoIHdpbGwgYmUgYC0xYCBhbmRcbiAgICAgKiAgIGB1bmRlZmluZWRgIGlmIHRoZSB2YWx1ZSBpcyBub3QgY29udGFpbmVkIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiBgc3RhcnQgPCBzdG9wYCB0aGUgc2VhcmNoIHdpbGwgd3JhcCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbih2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICogICByZXR1cm4gdmFsdWUgJSAyID09PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGxldCBkYXRhID0gWzAsIDEyLCAyMywgMzksIDE0LCAxMiwgNzVdO1xuICAgICAqIEFycmF5RXh0LnJlbW92ZUxhc3RXaGVyZShkYXRhLCBpc0V2ZW4pOyAgICAgICAgLy8geyBpbmRleDogNSwgdmFsdWU6IDEyIH1cbiAgICAgKiBBcnJheUV4dC5yZW1vdmVMYXN0V2hlcmUoZGF0YSwgaXNFdmVuLCAyKTsgICAgIC8vIHsgaW5kZXg6IDEsIHZhbHVlOiAxMiB9XG4gICAgICogQXJyYXlFeHQucmVtb3ZlTGFzdFdoZXJlKGRhdGEsIGlzRXZlbiwgMiwgMSk7ICAvLyB7IGluZGV4OiAtMSwgdmFsdWU6IHVuZGVmaW5lZCB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGFzdFdoZXJlKGFycmF5LCBmbiwgc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAtMTsgfVxuICAgICAgICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7IHN0b3AgPSAwOyB9XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZExhc3RJbmRleChhcnJheSwgZm4sIHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZW1vdmVBdChhcnJheSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGluZGV4OiBpbmRleCwgdmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIEFycmF5RXh0LnJlbW92ZUxhc3RXaGVyZSA9IHJlbW92ZUxhc3RXaGVyZTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIHZhbHVlcyB3aGljaCBtYXRjaCBhIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcbiAgICAgKiAgIHNlYXJjaGVkLCBpbmNsdXNpdmUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAwYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcCAtIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxuICAgICAqICAgc2VhcmNoZWQsIGluY2x1c2l2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYC0xYC4gTmVnYXRpdmUgdmFsdWVzXG4gICAgICogICBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgYHN0b3AgPCBzdGFydGAgdGhlIHNlYXJjaCB3aWxsIGNvbmNlcHR1YWxseSB3cmFwIGF0IHRoZSBlbmQgb2ZcbiAgICAgKiB0aGUgYXJyYXksIGhvd2V2ZXIgdGhlIGFycmF5IHdpbGwgYmUgdHJhdmVyc2VkIGZyb250LXRvLWJhY2suXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4odmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAqICAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc05lZ2F0aXZlKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgKiAgIHJldHVybiB2YWx1ZSA8IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogbGV0IGRhdGEgPSBbMCwgMTIsIC0xMywgLTksIDIzLCAzOSwgMTQsIC0xNSwgMTIsIDc1XTtcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVBbGxXaGVyZShkYXRhLCBpc0V2ZW4pOyAgICAgICAgICAgIC8vIDRcbiAgICAgKiBBcnJheUV4dC5yZW1vdmVBbGxXaGVyZShkYXRhLCBpc05lZ2F0aXZlLCAwLCAzKTsgIC8vIDJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxXaGVyZShhcnJheSwgZm4sIHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7IHN0b3AgPSAtMTsgfVxuICAgICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgKyBuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcCA8IDApIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1heCgwLCBzdG9wICsgbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5taW4oc3RvcCwgbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gc3RvcCAmJiAoaSA+PSBzdGFydCAmJiBpIDw9IHN0b3ApICYmIGZuKGFycmF5W2ldLCBpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdG9wIDwgc3RhcnQgJiYgKGkgPD0gc3RvcCB8fCBpID49IHN0YXJ0KSAmJiBmbihhcnJheVtpXSwgaSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaSAtIGNvdW50XSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIGFycmF5Lmxlbmd0aCA9IG4gLSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIEFycmF5RXh0LnJlbW92ZUFsbFdoZXJlID0gcmVtb3ZlQWxsV2hlcmU7XG59KShBcnJheUV4dCB8fCAoQXJyYXlFeHQgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciBhbiBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBpdGVyYXRpb24gYWxnb3JpdGhtcyB0byBvcGVyYXRlIG9uIHVzZXItZGVmaW5lZFxuICogaXRlcmFibGUgdHlwZXMgYW5kIGJ1aWx0aW4gYXJyYXktbGlrZSBvYmplY3RzIGluIGEgdW5pZm9ybSBmYXNoaW9uLlxuICovXG5mdW5jdGlvbiBpdGVyKG9iamVjdCkge1xuICAgIHZhciBpdDtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5pdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGl0ID0gb2JqZWN0Lml0ZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGl0ID0gbmV3IEFycmF5SXRlcmF0b3Iob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0O1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIHRoZSBrZXlzIGluIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBmb3IgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiAjIyMjIENvbXBsZXhpdHlcbiAqIExpbmVhci5cbiAqXG4gKiAjIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVhY2gsIGtleXMgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gKlxuICogbGV0IGRhdGEgPSB7IG9uZTogMSwgdHdvOiAyLCB0aHJlZTogMyB9O1xuICpcbiAqIGVhY2goa2V5cyhkYXRhKSwga2V5ID0+IHsgY29uc29sZS5sb2coa2V5KTsgfSk7IC8vICdvbmUnLCAndHdvJywgJ3RocmVlJ1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGl0ZXJLZXlzKG9iamVjdCkge1xuICAgIHJldHVybiBuZXcgS2V5SXRlcmF0b3Iob2JqZWN0KTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWVzIGluIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBmb3IgdGhlIHZhbHVlcyBpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqICMjIyMgQ29tcGxleGl0eVxuICogTGluZWFyLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgZWFjaCwgdmFsdWVzIH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0geyBvbmU6IDEsIHR3bzogMiwgdGhyZWU6IDMgfTtcbiAqXG4gKiBlYWNoKHZhbHVlcyhkYXRhKSwgdmFsdWUgPT4geyBjb25zb2xlLmxvZyh2YWx1ZSk7IH0pOyAvLyAxLCAyLCAzXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gaXRlclZhbHVlcyhvYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IFZhbHVlSXRlcmF0b3Iob2JqZWN0KTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciB0aGUgaXRlbXMgaW4gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IG9mIGludGVyZXN0LlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIGZvciB0aGUgaXRlbXMgaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiAjIyMjIENvbXBsZXhpdHlcbiAqIExpbmVhci5cbiAqXG4gKiAjIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVhY2gsIGl0ZW1zIH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0geyBvbmU6IDEsIHR3bzogMiwgdGhyZWU6IDMgfTtcbiAqXG4gKiBlYWNoKGl0ZW1zKGRhdGEpLCB2YWx1ZSA9PiB7IGNvbnNvbGUubG9nKHZhbHVlKTsgfSk7IC8vIFsnb25lJywgMV0sIFsndHdvJywgMl0sIFsndGhyZWUnLCAzXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGl0ZXJJdGVtcyhvYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IEl0ZW1JdGVyYXRvcihvYmplY3QpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIGFuIGl0ZXJhdG9yLWxpa2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGZuIC0gQSBmdW5jdGlvbiB3aGljaCBiZWhhdmVzIGxpa2UgYW4gaXRlcmF0b3IgYG5leHRgIG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBmb3IgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoZSByZXR1cm5lZCBpdGVyYXRvciAqKmNhbm5vdCoqIGJlIGNsb25lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVhY2gsIGl0ZXJGbiB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAqXG4gKiBsZXQgaXQgPSBpdGVyRm4oKCgpID0+IHtcbiAqICAgbGV0IGkgPSAwO1xuICogICByZXR1cm4gKCkgPT4gaSA+IDMgPyB1bmRlZmluZWQgOiBpKys7XG4gKiB9KSgpKTtcbiAqXG4gKiBlYWNoKGl0LCB2ID0+IHsgY29uc29sZS5sb2codik7IH0pOyAvLyAwLCAxLCAyLCAzXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gaXRlckZuKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBGbkl0ZXJhdG9yKGZuKTtcbn1cbi8qKlxuICogSW52b2tlIGEgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUgaW4gYW4gaXRlcmFibGUuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHZhbHVlLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIEl0ZXJhdGlvbiBjYW4gYmUgdGVybWluYXRlZCBlYXJseSBieSByZXR1cm5pbmcgYGZhbHNlYCBmcm9tIHRoZVxuICogY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogIyMjIyBDb21wbGV4aXR5XG4gKiBMaW5lYXIuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlYWNoIH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWzUsIDcsIDAsIC0yLCA5XTtcbiAqXG4gKiBlYWNoKGRhdGEsIHZhbHVlID0+IHsgY29uc29sZS5sb2codmFsdWUpOyB9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlYWNoKG9iamVjdCwgZm4pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdCA9IGl0ZXIob2JqZWN0KTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIGluZGV4KyspID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYWxsIHZhbHVlcyBpbiBhbiBpdGVyYWJsZSBzYXRpc2Z5IGEgcHJlZGljYXRlLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgaXRlcmFibGUgb3IgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdmFsdWUuXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIGFsbCB2YWx1ZXMgcGFzcyB0aGUgdGVzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogSXRlcmF0aW9uIHRlcm1pbmF0ZXMgb24gdGhlIGZpcnN0IGBmYWxzZWAgcHJlZGljYXRlIHJlc3VsdC5cbiAqXG4gKiAjIyMjIENvbXBsZXhpdHlcbiAqIExpbmVhci5cbiAqXG4gKiAjIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGV2ZXJ5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWzUsIDcsIDFdO1xuICpcbiAqIGV2ZXJ5KGRhdGEsIHZhbHVlID0+IHZhbHVlICUgMiA9PT0gMCk7ICAvLyBmYWxzZVxuICogZXZlcnkoZGF0YSwgdmFsdWUgPT4gdmFsdWUgJSAyID09PSAxKTsgIC8vIHRydWVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBldmVyeShvYmplY3QsIGZuKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXQgPSBpdGVyKG9iamVjdCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIHdoaWxlICgodmFsdWUgPSBpdC5uZXh0KCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFmbih2YWx1ZSwgaW5kZXgrKykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFueSB2YWx1ZSBpbiBhbiBpdGVyYWJsZSBzYXRpc2ZpZXMgYSBwcmVkaWNhdGUuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHZhbHVlIHBhc3NlcyB0aGUgdGVzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogSXRlcmF0aW9uIHRlcm1pbmF0ZXMgb24gdGhlIGZpcnN0IGB0cnVlYCBwcmVkaWNhdGUgcmVzdWx0LlxuICpcbiAqICMjIyMgQ29tcGxleGl0eVxuICogTGluZWFyLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgc29tZSB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAqXG4gKiBsZXQgZGF0YSA9IFs1LCA3LCAxXTtcbiAqXG4gKiBzb21lKGRhdGEsIHZhbHVlID0+IHZhbHVlID09PSA3KTsgIC8vIHRydWVcbiAqIHNvbWUoZGF0YSwgdmFsdWUgPT4gdmFsdWUgPT09IDMpOyAgLy8gZmFsc2VcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzb21lKG9iamVjdCwgZm4pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdCA9IGl0ZXIob2JqZWN0KTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIGluZGV4KyspKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGFuIGl0ZXJhYmxlIG9mIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2Ugb2JqZWN0IG9mIGludGVyZXN0LlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBpdGVyLCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICpcbiAqIGxldCBzdHJlYW0gPSBpdGVyKGRhdGEpO1xuICpcbiAqIHRvQXJyYXkoc3RyZWFtKTsgIC8vIFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iamVjdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpdCA9IGl0ZXIob2JqZWN0KTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBmcm9tIGFuIGl0ZXJhYmxlIG9mIGtleS92YWx1ZSBwYWlycy5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2Ugb2JqZWN0IG9mIGludGVyZXN0LlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCBtYXBwaW5nIGtleXMgdG8gdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgdG9PYmplY3QgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gKlxuICogbGV0IGRhdGEgPSBbWydvbmUnLCAxXSwgWyd0d28nLCAyXSwgWyd0aHJlZScsIDNdXTtcbiAqXG4gKiB0b09iamVjdChkYXRhKTsgIC8vIHsgb25lOiAxLCB0d286IDIsIHRocmVlOiAzIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICB2YXIgaXQgPSBpdGVyKG9iamVjdCk7XG4gICAgdmFyIHBhaXI7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHdoaWxlICgocGFpciA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBbiBpdGVyYXRvciBmb3IgYW4gYXJyYXktbGlrZSBvYmplY3QuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhpcyBpdGVyYXRvciBjYW4gYmUgdXNlZCBmb3IgYW55IGJ1aWx0aW4gSlMgYXJyYXktbGlrZSBvYmplY3QuXG4gKi9cbnZhciBBcnJheUl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBhcnJheSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcihzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICovXG4gICAgQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXlJdGVyYXRvcih0aGlzLl9zb3VyY2UpO1xuICAgICAgICByZXN1bHQuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX3NvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVt0aGlzLl9pbmRleCsrXTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogQW4gaXRlcmF0b3IgZm9yIHRoZSBrZXlzIGluIGFuIG9iamVjdC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGl0ZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBhbnkgSlMgb2JqZWN0LlxuICovXG52YXIgS2V5SXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGtleSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleXMgLSBUaGUga2V5cyB0byBpdGVyYXRlLCBpZiBrbm93bi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBLZXlJdGVyYXRvcihzb3VyY2UsIGtleXMpIHtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkgeyBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgfVxuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBLZXlJdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIEtleUl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBLZXlJdGVyYXRvcih0aGlzLl9zb3VyY2UsIHRoaXMuX2tleXMpO1xuICAgICAgICByZXN1bHQuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgS2V5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5c1t0aGlzLl9pbmRleCsrXTtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEtleUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogQW4gaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZXMgaW4gYW4gb2JqZWN0LlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgaXRlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIGFueSBKUyBvYmplY3QuXG4gKi9cbnZhciBWYWx1ZUl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB2YWx1ZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleXMgLSBUaGUga2V5cyB0byBpdGVyYXRlLCBpZiBrbm93bi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYWx1ZUl0ZXJhdG9yKHNvdXJjZSwga2V5cykge1xuICAgICAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB9XG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGl0ZXJhdG9yIG92ZXIgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqL1xuICAgIFZhbHVlSXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKi9cbiAgICBWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBWYWx1ZUl0ZXJhdG9yKHRoaXMuX3NvdXJjZSwgdGhpcy5fa2V5cyk7XG4gICAgICAgIHJlc3VsdC5faW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleXNbdGhpcy5faW5kZXgrK107XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlSXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBBbiBpdGVyYXRvciBmb3IgdGhlIGl0ZW1zIGluIGFuIG9iamVjdC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGl0ZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBhbnkgSlMgb2JqZWN0LlxuICovXG52YXIgSXRlbUl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBpdGVtIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5cyAtIFRoZSBrZXlzIHRvIGl0ZXJhdGUsIGlmIGtub3duLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEl0ZW1JdGVyYXRvcihzb3VyY2UsIGtleXMpIHtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkgeyBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgfVxuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBJdGVtSXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKi9cbiAgICBJdGVtSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEl0ZW1JdGVyYXRvcih0aGlzLl9zb3VyY2UsIHRoaXMuX2tleXMpO1xuICAgICAgICByZXN1bHQuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgSXRlbUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleXNbdGhpcy5faW5kZXgrK107XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgdGhpcy5fc291cmNlW2tleV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICB9O1xuICAgIHJldHVybiBJdGVtSXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBBbiBpdGVyYXRvciBmb3IgYW4gaXRlcmF0b3ItbGlrZSBmdW5jdGlvbi5cbiAqL1xudmFyIEZuSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGZ1bmN0aW9uIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGl0ZXJhdG9yLWxpa2UgZnVuY3Rpb24gb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm5JdGVyYXRvcihmbikge1xuICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaXRlcmF0b3Igb3ZlciB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICovXG4gICAgRm5JdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIEZuSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGBGbkl0ZXJhdG9yYCBjYW5ub3QgYmUgY2xvbmVkLicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIEZuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbi5jYWxsKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm5JdGVyYXRvcjtcbn0oKSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBDaGFpbiB0b2dldGhlciBzZXZlcmFsIGl0ZXJhYmxlcy5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0cyAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdHMgb2YgaW50ZXJlc3QuXG4gKlxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSB2YWx1ZXMgb2YgdGhlIGl0ZXJhYmxlc1xuICogICBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmUgc3VwcGxpZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBjaGFpbiwgdG9BcnJheSB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAqXG4gKiBsZXQgZGF0YTEgPSBbMSwgMiwgM107XG4gKiBsZXQgZGF0YTIgPSBbNCwgNSwgNl07XG4gKlxuICogbGV0IHN0cmVhbSA9IGNoYWluKGRhdGExLCBkYXRhMik7XG4gKlxuICogdG9BcnJheShzdHJlYW0pOyAgLy8gWzEsIDIsIDMsIDQsIDUsIDZdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY2hhaW4oKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2hhaW5JdGVyYXRvcihpdGVyKG9iamVjdHMubWFwKGl0ZXIpKSk7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIGNoYWlucyB0b2dldGhlciBzZXZlcmFsIGl0ZXJhdG9ycy5cbiAqL1xudmFyIENoYWluSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGNoYWluIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBpdGVyYXRvciBvZiBpdGVyYXRvcnMgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2hhaW5JdGVyYXRvcihzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fY2xvbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaXRlcmF0b3Igb3ZlciB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICovXG4gICAgQ2hhaW5JdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIENoYWluSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IENoYWluSXRlcmF0b3IodGhpcy5fc291cmNlLmNsb25lKCkpO1xuICAgICAgICByZXN1bHQuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZSAmJiB0aGlzLl9hY3RpdmUuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9jbG9uZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbG9uZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIENoYWluSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuX3NvdXJjZS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fY2xvbmVkID8gYWN0aXZlLmNsb25lKCkgOiBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYWN0aXZlLm5leHQoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFpbkl0ZXJhdG9yO1xufSgpKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gZW1wdHkgaXRlcmF0b3IuXG4gKlxuICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igd2hpY2ggeWllbGRzIG5vdGhpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbXB0eSwgdG9BcnJheSB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAqXG4gKiBsZXQgc3RyZWFtID0gZW1wdHk8bnVtYmVyPigpO1xuICpcbiAqIHRvQXJyYXkoc3RyZWFtKTsgIC8vIFtdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eUl0ZXJhdG9yKCk7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIGlzIGFsd2F5cyBlbXB0eS5cbiAqL1xudmFyIEVtcHR5SXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGVtcHR5IGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVtcHR5SXRlcmF0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBFbXB0eUl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICovXG4gICAgRW1wdHlJdGVyYXRvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlJdGVyYXRvcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIEVtcHR5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlJdGVyYXRvcjtcbn0oKSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBFbnVtZXJhdGUgYW4gaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgaXRlcmFibGUgb3IgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gKlxuICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0aW5nIGVudW0gdmFsdWUuIFRoZSBkZWZhdWx0IGlzIGAwYC5cbiAqXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIGVudW1lcmF0ZWQgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgZW51bWVyYXRlLCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWydmb28nLCAnYmFyJywgJ2JheiddO1xuICpcbiAqIGxldCBzdHJlYW0gPSBlbnVtZXJhdGUoZGF0YSwgMSk7XG4gKlxuICogdG9BcnJheShzdHJlYW0pOyAgLy8gW1sxLCAnZm9vJ10sIFsyLCAnYmFyJ10sIFszLCAnYmF6J11dXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZW51bWVyYXRlKG9iamVjdCwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZUl0ZXJhdG9yKGl0ZXIob2JqZWN0KSwgc3RhcnQpO1xufVxuLyoqXG4gKiBBbiBpdGVyYXRvciB3aGljaCBlbnVtZXJhdGVzIHRoZSBzb3VyY2UgdmFsdWVzLlxuICovXG52YXIgRW51bWVyYXRlSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGVudW1lcmF0ZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgaXRlcmF0b3Igb2YgdmFsdWVzIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0aW5nIGVudW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRW51bWVyYXRlSXRlcmF0b3Ioc291cmNlLCBzdGFydCkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBFbnVtZXJhdGVJdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIEVudW1lcmF0ZUl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhdGVJdGVyYXRvcih0aGlzLl9zb3VyY2UuY2xvbmUoKSwgdGhpcy5faW5kZXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIEVudW1lcmF0ZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9zb3VyY2UubmV4dCgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMuX2luZGV4KyssIHZhbHVlXTtcbiAgICB9O1xuICAgIHJldHVybiBFbnVtZXJhdGVJdGVyYXRvcjtcbn0oKSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBGaWx0ZXIgYW4gaXRlcmFibGUgZm9yIHZhbHVlcyB3aGljaCBwYXNzIGEgdGVzdC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2Ugb2JqZWN0IG9mIGludGVyZXN0LlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHZhbHVlLlxuICpcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgdmFsdWVzIHdoaWNoIHBhc3MgdGhlIHRlc3QuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBmaWx0ZXIsIHRvQXJyYXkgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gKlxuICogbGV0IGRhdGEgPSBbMSwgMiwgMywgNCwgNSwgNl07XG4gKlxuICogbGV0IHN0cmVhbSA9IGZpbHRlcihkYXRhLCB2YWx1ZSA9PiB2YWx1ZSAlIDIgPT09IDApO1xuICpcbiAqIHRvQXJyYXkoc3RyZWFtKTsgIC8vIFsyLCA0LCA2XVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihvYmplY3QsIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJJdGVyYXRvcihpdGVyKG9iamVjdCksIGZuKTtcbn1cbi8qKlxuICogQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHZhbHVlcyB3aGljaCBwYXNzIGEgdGVzdC5cbiAqL1xudmFyIEZpbHRlckl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBmaWx0ZXIgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlIC0gVGhlIGl0ZXJhdG9yIG9mIHZhbHVlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZpbHRlckl0ZXJhdG9yKHNvdXJjZSwgZm4pIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBGaWx0ZXJJdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIEZpbHRlckl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBGaWx0ZXJJdGVyYXRvcih0aGlzLl9zb3VyY2UuY2xvbmUoKSwgdGhpcy5fZm4pO1xuICAgICAgICByZXN1bHQuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgRmlsdGVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgICAgICB2YXIgaXQgPSB0aGlzLl9zb3VyY2U7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGZuKHZhbHVlLCB0aGlzLl9pbmRleCsrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlckl0ZXJhdG9yO1xufSgpKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEZpbmQgdGhlIGZpcnN0IHZhbHVlIGluIGFuIGl0ZXJhYmxlIHdoaWNoIG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCB0byBzZWFyY2guXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICpcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBtYXRjaGluZyB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmdcbiAqICAgdmFsdWUgaXMgZm91bmQuXG4gKlxuICogIyMjIyBDb21wbGV4aXR5XG4gKiBMaW5lYXIuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBmaW5kIH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGludGVyZmFjZSBJQW5pbWFsIHsgc3BlY2llczogc3RyaW5nLCBuYW1lOiBzdHJpbmcgfTtcbiAqXG4gKiBmdW5jdGlvbiBpc0NhdCh2YWx1ZTogSUFuaW1hbCk6IGJvb2xlYW4ge1xuICogICByZXR1cm4gdmFsdWUuc3BlY2llcyA9PT0gJ2NhdCc7XG4gKiB9XG4gKlxuICogbGV0IGRhdGE6IElBbmltYWxbXSA9IFtcbiAqICAgeyBzcGVjaWVzOiAnZG9nJywgbmFtZTogJ3Nwb3QnIH0sXG4gKiAgIHsgc3BlY2llczogJ2NhdCcsIG5hbWU6ICdmbHVmZnknIH0sXG4gKiAgIHsgc3BlY2llczogJ2FsbGlnYXRvcicsIG5hbWU6ICdwb2NobycgfVxuICogXTtcbiAqXG4gKiBmaW5kKGRhdGEsIGlzQ2F0KS5uYW1lOyAgLy8gJ2ZsdWZmeSdcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBmaW5kKG9iamVjdCwgZm4pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdCA9IGl0ZXIob2JqZWN0KTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIGluZGV4KyspKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHZhbHVlIHdoaWNoIG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCB0byBzZWFyY2guXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICpcbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUsIG9yIGAtMWAgaWYgbm9cbiAqICAgbWF0Y2hpbmcgdmFsdWUgaXMgZm91bmQuXG4gKlxuICogIyMjIyBDb21wbGV4aXR5XG4gKiBMaW5lYXIuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBmaW5kSW5kZXggfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gKlxuICogaW50ZXJmYWNlIElBbmltYWwgeyBzcGVjaWVzOiBzdHJpbmcsIG5hbWU6IHN0cmluZyB9O1xuICpcbiAqIGZ1bmN0aW9uIGlzQ2F0KHZhbHVlOiBJQW5pbWFsKTogYm9vbGVhbiB7XG4gKiAgIHJldHVybiB2YWx1ZS5zcGVjaWVzID09PSAnY2F0JztcbiAqIH1cbiAqXG4gKiBsZXQgZGF0YTogSUFuaW1hbFtdID0gW1xuICogICB7IHNwZWNpZXM6ICdkb2cnLCBuYW1lOiAnc3BvdCcgfSxcbiAqICAgeyBzcGVjaWVzOiAnY2F0JywgbmFtZTogJ2ZsdWZmeScgfSxcbiAqICAgeyBzcGVjaWVzOiAnYWxsaWdhdG9yJywgbmFtZTogJ3BvY2hvJyB9XG4gKiBdO1xuICpcbiAqIGZpbmRJbmRleChkYXRhLCBpc0NhdCk7ICAvLyAxXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KG9iamVjdCwgZm4pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdCA9IGl0ZXIob2JqZWN0KTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIGluZGV4KyspKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogRmluZCB0aGUgbWluaW11bSB2YWx1ZSBpbiBhbiBpdGVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2Ugb2JqZWN0IHRvIHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgMy13YXkgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICogICBJdCBzaG91bGQgcmV0dXJuIGA8IDBgIGlmIHRoZSBmaXJzdCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZC5cbiAqICAgYDBgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIG9yIGA+IDBgIGlmIHRoZSBmaXJzdCB2YWx1ZSBpc1xuICogICBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgaXRlcmFibGUuIElmIG11bHRpcGxlIHZhbHVlcyBhcmVcbiAqICAgZXF1aXZhbGVudCB0byB0aGUgbWluaW11bSwgdGhlIGxlZnQtbW9zdCB2YWx1ZSBpcyByZXR1cm5lZC4gSWZcbiAqICAgdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCB0aGlzIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogIyMjIyBDb21wbGV4aXR5XG4gKiBMaW5lYXIuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBtaW4gfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gKlxuICogZnVuY3Rpb24gbnVtYmVyQ21wKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAqICAgcmV0dXJuIGEgLSBiO1xuICogfVxuICpcbiAqIG1pbihbNywgNCwgMCwgMywgOSwgNF0sIG51bWJlckNtcCk7ICAvLyAwXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gbWluKG9iamVjdCwgZm4pIHtcbiAgICB2YXIgaXQgPSBpdGVyKG9iamVjdCk7XG4gICAgdmFyIHZhbHVlID0gaXQubmV4dCgpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICB3aGlsZSAoKHZhbHVlID0gaXQubmV4dCgpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgcmVzdWx0KSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gaXRlcmFibGUuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCB0byBzZWFyY2guXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIDMtd2F5IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlcy5cbiAqICAgSXQgc2hvdWxkIHJldHVybiBgPCAwYCBpZiB0aGUgZmlyc3QgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQuXG4gKiAgIGAwYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBvciBgPiAwYCBpZiB0aGUgZmlyc3QgdmFsdWUgaXNcbiAqICAgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQuXG4gKlxuICogQHJldHVybnMgVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIGl0ZXJhYmxlLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlXG4gKiAgIGVxdWl2YWxlbnQgdG8gdGhlIG1heGltdW0sIHRoZSBsZWZ0LW1vc3QgdmFsdWUgaXMgcmV0dXJuZWQuIElmXG4gKiAgIHRoZSBpdGVyYWJsZSBpcyBlbXB0eSwgdGhpcyByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqICMjIyMgQ29tcGxleGl0eVxuICogTGluZWFyLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgbWF4IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGZ1bmN0aW9uIG51bWJlckNtcChhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gKiAgIHJldHVybiBhIC0gYjtcbiAqIH1cbiAqXG4gKiBtYXgoWzcsIDQsIDAsIDMsIDksIDRdLCBudW1iZXJDbXApOyAgLy8gOVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIG1heChvYmplY3QsIGZuKSB7XG4gICAgdmFyIGl0ID0gaXRlcihvYmplY3QpO1xuICAgIHZhciB2YWx1ZSA9IGl0Lm5leHQoKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IGl0Lm5leHQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIHJlc3VsdCkgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBpbiBhbiBpdGVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2Ugb2JqZWN0IHRvIHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgMy13YXkgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdmFsdWVzLlxuICogICBJdCBzaG91bGQgcmV0dXJuIGA8IDBgIGlmIHRoZSBmaXJzdCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZC5cbiAqICAgYDBgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIG9yIGA+IDBgIGlmIHRoZSBmaXJzdCB2YWx1ZSBpc1xuICogICBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqXG4gKiBAcmV0dXJucyBBIDItdHVwbGUgb2YgdGhlIGBbbWluLCBtYXhdYCB2YWx1ZXMgaW4gdGhlIGl0ZXJhYmxlLiBJZlxuICogICBtdWx0aXBsZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIHRoZSBsZWZ0LW1vc3QgdmFsdWVzIGFyZSByZXR1cm5lZC5cbiAqICAgSWYgdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCB0aGlzIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogIyMjIyBDb21wbGV4aXR5XG4gKiBMaW5lYXIuXG4gKlxuICogIyMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBtaW5tYXggfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG4gKlxuICogZnVuY3Rpb24gbnVtYmVyQ21wKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAqICAgcmV0dXJuIGEgLSBiO1xuICogfVxuICpcbiAqIG1pbm1heChbNywgNCwgMCwgMywgOSwgNF0sIG51bWJlckNtcCk7ICAvLyBbMCwgOV1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBtaW5tYXgob2JqZWN0LCBmbikge1xuICAgIHZhciBpdCA9IGl0ZXIob2JqZWN0KTtcbiAgICB2YXIgdmFsdWUgPSBpdC5uZXh0KCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHZtaW4gPSB2YWx1ZTtcbiAgICB2YXIgdm1heCA9IHZhbHVlO1xuICAgIHdoaWxlICgodmFsdWUgPSBpdC5uZXh0KCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCB2bWluKSA8IDApIHtcbiAgICAgICAgICAgIHZtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmbih2YWx1ZSwgdm1heCkgPiAwKSB7XG4gICAgICAgICAgICB2bWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt2bWluLCB2bWF4XTtcbn1cblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgdmFsdWVzIG9mIGFuIGl0ZXJhYmxlIHdpdGggYSBtYXBwaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgaXRlcmFibGUgb3IgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIG1hcHBpbmcgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHZhbHVlLlxuICpcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgdHJhbnNmb3JtZWQgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgbWFwLCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWzEsIDIsIDNdO1xuICpcbiAqIGxldCBzdHJlYW0gPSBtYXAoZGF0YSwgdmFsdWUgPT4gdmFsdWUgKiAyKTtcbiAqXG4gKiB0b0FycmF5KHN0cmVhbSk7ICAvLyBbMiwgNCwgNl1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBtYXAob2JqZWN0LCBmbikge1xuICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IoaXRlcihvYmplY3QpLCBmbik7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIHRyYW5zZm9ybXMgdmFsdWVzIHVzaW5nIGEgbWFwcGluZyBmdW5jdGlvbi5cbiAqL1xudmFyIE1hcEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBtYXAgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlIC0gVGhlIGl0ZXJhdG9yIG9mIHZhbHVlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBtYXBwaW5nIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihzb3VyY2UsIGZuKSB7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaXRlcmF0b3Igb3ZlciB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICovXG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKi9cbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwSXRlcmF0b3IodGhpcy5fc291cmNlLmNsb25lKCksIHRoaXMuX2ZuKTtcbiAgICAgICAgcmVzdWx0Ll9pbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9zb3VyY2UubmV4dCgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm4uY2FsbCh1bmRlZmluZWQsIHZhbHVlLCB0aGlzLl9pbmRleCsrKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBJdGVyYXRvcjtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG9mIGV2ZW5seSBzcGFjZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzdGFydCAtIFRoZSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHN0b3AgLSBUaGUgc3RvcHBpbmcgdmFsdWUgZm9yIHRoZSByYW5nZSwgZXhjbHVzaXZlLlxuICpcbiAqIEBwYXJhbSBzdGVwIC0gVGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCBwcm9kdWNlcyBldmVubHkgc3BhY2VkIHZhbHVlcy5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBJbiB0aGUgc2luZ2xlIGFyZ3VtZW50IGZvcm0gb2YgYHJhbmdlKHN0b3ApYCwgYHN0YXJ0YCBkZWZhdWx0cyB0b1xuICogYDBgIGFuZCBgc3RlcGAgZGVmYXVsdHMgdG8gYDFgLlxuICpcbiAqIEluIHRoZSB0d28gYXJndW1lbnQgZm9ybSBvZiBgcmFuZ2Uoc3RhcnQsIHN0b3ApYCwgYHN0ZXBgIGRlZmF1bHRzXG4gKiB0byBgMWAuXG4gKi9cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlSXRlcmF0b3IoMCwgc3RhcnQsIDEpO1xuICAgIH1cbiAgICBpZiAoc3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VJdGVyYXRvcihzdGFydCwgc3RvcCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmFuZ2VJdGVyYXRvcihzdGFydCwgc3RvcCwgc3RlcCk7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIHByb2R1Y2VzIGEgcmFuZ2Ugb2YgZXZlbmx5IHNwYWNlZCB2YWx1ZXMuXG4gKi9cbnZhciBSYW5nZUl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyByYW5nZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcCAtIFRoZSBzdG9wcGluZyB2YWx1ZSBmb3IgdGhlIHJhbmdlLCBleGNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RlcCAtIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2VJdGVyYXRvcihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX3N0b3AgPSBzdG9wO1xuICAgICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gUHJpdmF0ZS5yYW5nZUxlbmd0aChzdGFydCwgc3RvcCwgc3RlcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBSYW5nZUl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICovXG4gICAgUmFuZ2VJdGVyYXRvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLl9zdGFydCwgdGhpcy5fc3RvcCwgdGhpcy5fc3RlcCk7XG4gICAgICAgIHJlc3VsdC5faW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBSYW5nZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydCArIHRoaXMuX3N0ZXAgKiB0aGlzLl9pbmRleCsrO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlSXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIGxlbmd0aCBvZiBhIHJhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIHN0b3BwaW5nIHZhbHVlIGZvciB0aGUgcmFuZ2UsIGV4Y2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGVwIC0gVGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygc3RlcHMgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2VMZW5ndGgoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPiBzdG9wICYmIHN0ZXAgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCBzdG9wICYmIHN0ZXAgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCk7XG4gICAgfVxuICAgIFByaXZhdGUucmFuZ2VMZW5ndGggPSByYW5nZUxlbmd0aDtcbn0pKFByaXZhdGUgfHwgKFByaXZhdGUgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbmZ1bmN0aW9uIHJlZHVjZShvYmplY3QsIGZuLCBpbml0aWFsKSB7XG4gICAgLy8gU2V0dXAgdGhlIGl0ZXJhdG9yIGFuZCBmZXRjaCB0aGUgZmlyc3QgdmFsdWUuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXQgPSBpdGVyKG9iamVjdCk7XG4gICAgdmFyIGZpcnN0ID0gaXQubmV4dCgpO1xuICAgIC8vIEFuIGVtcHR5IGl0ZXJhdG9yIGFuZCBubyBpbml0aWFsIHZhbHVlIGlzIGFuIGVycm9yLlxuICAgIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkICYmIGluaXRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgaXRlcmFibGUgd2l0aCBubyBpbml0aWFsIHZhbHVlLicpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgaXRlcmF0b3IgaXMgZW1wdHksIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5pdGlhbDtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGl0ZXJhdG9yIGhhcyBhIHNpbmdsZSBpdGVtIGFuZCBubyBpbml0aWFsIHZhbHVlLCB0aGVcbiAgICAvLyByZWR1Y2VyIGlzIG5vdCBpbnZva2VkIGFuZCB0aGUgZmlyc3QgaXRlbSBpcyB0aGUgcmV0dXJuIHZhbHVlLlxuICAgIHZhciBzZWNvbmQgPSBpdC5uZXh0KCk7XG4gICAgaWYgKHNlY29uZCA9PT0gdW5kZWZpbmVkICYmIGluaXRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIC8vIElmIGl0ZXJhdG9yIGhhcyBhIHNpbmdsZSBpdGVtIGFuZCBhbiBpbml0aWFsIHZhbHVlIGlzIHByb3ZpZGVkLFxuICAgIC8vIHRoZSByZWR1Y2VyIGlzIGludm9rZWQgYW5kIHRoYXQgcmVzdWx0IGlzIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgaWYgKHNlY29uZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmbihpbml0aWFsLCBmaXJzdCwgaW5kZXgrKyk7XG4gICAgfVxuICAgIC8vIFNldHVwIHRoZSBpbml0aWFsIGFjY3VtbGF0ZWQgdmFsdWUuXG4gICAgdmFyIGFjY3VtdWxhdG9yO1xuICAgIGlmIChpbml0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBmbihmaXJzdCwgc2Vjb25kLCBpbmRleCsrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gZm4oZm4oaW5pdGlhbCwgZmlyc3QsIGluZGV4KyspLCBzZWNvbmQsIGluZGV4KyspO1xuICAgIH1cbiAgICAvLyBJdGVyYXRlIHRoZSByZXN0IG9mIHRoZSB2YWx1ZXMsIHVwZGF0aW5nIHRoZSBhY2N1bXVsYXRvci5cbiAgICB2YXIgbmV4dDtcbiAgICB3aGlsZSAoKG5leHQgPSBpdC5uZXh0KCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBmbihhY2N1bXVsYXRvciwgbmV4dCwgaW5kZXgrKyk7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgZmluYWwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBpdGVyYXRvciB3aGljaCByZXBlYXRzIGEgdmFsdWUgYSBudW1iZXIgb2YgdGltZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlcGVhdC5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igd2hpY2ggcmVwZWF0cyB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgcmVwZWF0LCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBzdHJlYW0gPSByZXBlYXQoNywgMyk7XG4gKlxuICogdG9BcnJheShzdHJlYW0pOyAgLy8gWzcsIDcsIDddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmVwZWF0KHZhbHVlLCBjb3VudCkge1xuICAgIHJldHVybiBuZXcgUmVwZWF0SXRlcmF0b3IodmFsdWUsIGNvdW50KTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyBhIHZhbHVlIGEgc2luZ2xlIHRpbWUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHdyYXAgaW4gYW4gaXRlcmF0b3IuXG4gKlxuICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSB2YWx1ZSBhIHNpbmdsZSB0aW1lLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgb25jZSwgdG9BcnJheSB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAqXG4gKiBsZXQgc3RyZWFtID0gb25jZSg3KTtcbiAqXG4gKiB0b0FycmF5KHN0cmVhbSk7ICAvLyBbN11cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBvbmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBSZXBlYXRJdGVyYXRvcih2YWx1ZSwgMSk7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIHJlcGVhdHMgYSB2YWx1ZSBhIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gKi9cbnZhciBSZXBlYXRJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcmVwZWF0IGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlcGVhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXBlYXRJdGVyYXRvcih2YWx1ZSwgY291bnQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGl0ZXJhdG9yIG92ZXIgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqL1xuICAgIFJlcGVhdEl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICovXG4gICAgUmVwZWF0SXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGVhdEl0ZXJhdG9yKHRoaXMuX3ZhbHVlLCB0aGlzLl9jb3VudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgUmVwZWF0SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvdW50LS07XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRJdGVyYXRvcjtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciBhIHJldHJvYWJsZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSByZXRyb2FibGUgb3IgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gKlxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggdHJhdmVyc2VzIHRoZSBvYmplY3QncyB2YWx1ZXMgaW4gcmV2ZXJzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHJldHJvLCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICpcbiAqIGxldCBzdHJlYW0gPSByZXRybyhkYXRhKTtcbiAqXG4gKiB0b0FycmF5KHN0cmVhbSk7ICAvLyBbNiwgNSwgNCwgMywgMiwgMV1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXRybyhvYmplY3QpIHtcbiAgICB2YXIgaXQ7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QucmV0cm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaXQgPSBvYmplY3QucmV0cm8oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGl0ID0gbmV3IFJldHJvQXJyYXlJdGVyYXRvcihvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gaXQ7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIHRyYXZlcnNlcyBhbiBhcnJheS1saWtlIG9iamVjdCBpbiByZXZlcnNlLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgaXRlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIGFueSBidWlsdGluIEpTIGFycmF5LWxpa2Ugb2JqZWN0LlxuICovXG52YXIgUmV0cm9BcnJheUl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyByZXRybyBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmV0cm9BcnJheUl0ZXJhdG9yKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBSZXRyb0FycmF5SXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKi9cbiAgICBSZXRyb0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJldHJvQXJyYXlJdGVyYXRvcih0aGlzLl9zb3VyY2UpO1xuICAgICAgICByZXN1bHQuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgUmV0cm9BcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCAwIHx8IHRoaXMuX2luZGV4ID49IHRoaXMuX3NvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVt0aGlzLl9pbmRleC0tXTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyb0FycmF5SXRlcmF0b3I7XG59KCkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8qKlxuICogVG9wb2xvZ2ljYWxseSBzb3J0IGFuIGl0ZXJhYmxlIG9mIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBlZGdlcyB0byBzb3J0LlxuICogICBBbiBlZGdlIGlzIHJlcHJlc2VudGVkIGFzIGEgMi10dXBsZSBvZiBgW2Zyb21Ob2RlLCB0b05vZGVdYC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgYXJyYXkgb2Ygbm9kZXMuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogSWYgYSBjeWNsZSBpcyBwcmVzZW50IGluIHRoZSBncmFwaCwgdGhlIGN5Y2xlIHdpbGwgYmUgaWdub3JlZCBhbmRcbiAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBvbmx5IGFwcHJveGltYXRlbHkgc29ydGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgdG9wb2xvZ2ljU29ydCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbiAqXG4gKiBsZXQgZGF0YSA9IFtcbiAqICAgWydkJywgJ2UnXSxcbiAqICAgWydjJywgJ2QnXSxcbiAqICAgWydhJywgJ2InXSxcbiAqICAgWydiJywgJ2MnXVxuICogXTtcbiAqXG4gKiB0b3BvbG9naWNTb3J0KGRhdGEpOyAgLy8gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHRvcG9sb2dpY1NvcnQoZWRnZXMpIHtcbiAgICAvLyBTZXR1cCB0aGUgc2hhcmVkIHNvcnRpbmcgc3RhdGUuXG4gICAgdmFyIHNvcnRlZCA9IFtdO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBncmFwaCA9IG5ldyBNYXAoKTtcbiAgICAvLyBBZGQgdGhlIGVkZ2VzIHRvIHRoZSBncmFwaC5cbiAgICBlYWNoKGVkZ2VzLCBhZGRFZGdlKTtcbiAgICAvLyBWaXNpdCBlYWNoIG5vZGUgaW4gdGhlIGdyYXBoLlxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgdmlzaXQoayk7IH0pO1xuICAgIC8vIFJldHVybiB0aGUgc29ydGVkIHJlc3VsdHMuXG4gICAgcmV0dXJuIHNvcnRlZDtcbiAgICAvLyBBZGQgYW4gZWRnZSB0byB0aGUgZ3JhcGguXG4gICAgZnVuY3Rpb24gYWRkRWRnZShlZGdlKSB7XG4gICAgICAgIHZhciBmcm9tTm9kZSA9IGVkZ2VbMF0sIHRvTm9kZSA9IGVkZ2VbMV07XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGdyYXBoLmdldCh0b05vZGUpO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZnJvbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JhcGguc2V0KHRvTm9kZSwgW2Zyb21Ob2RlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgdmlzaXQgdGhlIG5vZGUuXG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgICAgICBpZiAodmlzaXRlZC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZ3JhcGguZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2godmlzaXQpO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRlZC5wdXNoKG5vZGUpO1xuICAgIH1cbn1cblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBpdGVyYWJsZSB1c2luZyBhIHN0ZXBwZWQgaW5jcmVtZW50LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgaXRlcmFibGUgb3IgYXJyYXktbGlrZSBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gKlxuICogQHBhcmFtIHN0ZXAgLSBUaGUgZGlzdGFuY2UgdG8gc3RlcCBvbiBlYWNoIGl0ZXJhdGlvbi4gQSB2YWx1ZVxuICogICBvZiBsZXNzIHRoYW4gYDFgIHdpbGwgYmVoYXZlIHRoZSBzYW1lIGFzIGEgdmFsdWUgb2YgYDFgLlxuICpcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHRyYXZlcnNlcyB0aGUgaXRlcmFibGUgc3RlcC13aXNlLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgc3RyaWRlLCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICpcbiAqIGxldCBzdHJlYW0gPSBzdHJpZGUoZGF0YSwgMik7XG4gKlxuICogdG9BcnJheShzdHJlYW0pOyAgLy8gWzEsIDMsIDVdO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHN0cmlkZShvYmplY3QsIHN0ZXApIHtcbiAgICByZXR1cm4gbmV3IFN0cmlkZUl0ZXJhdG9yKGl0ZXIob2JqZWN0KSwgc3RlcCk7XG59XG4vKipcbiAqIEFuIGl0ZXJhdG9yIHdoaWNoIHRyYXZlcnNlcyBhIHNvdXJjZSBpdGVyYXRvciBzdGVwLXdpc2UuXG4gKi9cbnZhciBTdHJpZGVJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaWRlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBpdGVyYXRvciBvZiB2YWx1ZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RlcCAtIFRoZSBkaXN0YW5jZSB0byBzdGVwIG9uIGVhY2ggaXRlcmF0aW9uLiBBIHZhbHVlXG4gICAgICogICBvZiBsZXNzIHRoYW4gYDFgIHdpbGwgYmVoYXZlIHRoZSBzYW1lIGFzIGEgdmFsdWUgb2YgYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0cmlkZUl0ZXJhdG9yKHNvdXJjZSwgc3RlcCkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaXRlcmF0b3Igb3ZlciB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICovXG4gICAgU3RyaWRlSXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgKi9cbiAgICBTdHJpZGVJdGVyYXRvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaWRlSXRlcmF0b3IodGhpcy5fc291cmNlLmNsb25lKCksIHRoaXMuX3N0ZXApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIFN0cmlkZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9zb3VyY2UubmV4dCgpO1xuICAgICAgICBmb3IgKHZhciBuID0gdGhpcy5fc3RlcCAtIDE7IG4gPiAwOyAtLW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmlkZUl0ZXJhdG9yO1xufSgpKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgUGhvc3Bob3JKUyBDb250cmlidXRvcnNcbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBMSUNFTlNFLCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHN0cmluZy1zcGVjaWZpYyBhbGdvcml0aG1zLlxuICovXG52YXIgU3RyaW5nRXh0O1xuKGZ1bmN0aW9uIChTdHJpbmdFeHQpIHtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBpbmRpY2VzIG9mIGNoYXJhY3RlcnMgaW4gYSBzb3VyY2UgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIHRleHQgd2hpY2ggc2hvdWxkIGJlIHNlYXJjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIGNoYXJhY3RlcnMgdG8gbG9jYXRlIGluIHRoZSBzb3VyY2UgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG1hdGNoZWQgaW5kaWNlcywgb3IgYG51bGxgIGlmIHRoZXJlIGlzIG5vIG1hdGNoLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyIG9uIGBzb3VyY2VUZXh0YC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJbiBvcmRlciBmb3IgdGhlcmUgdG8gYmUgYSBtYXRjaCwgYWxsIG9mIHRoZSBjaGFyYWN0ZXJzIGluIGBxdWVyeWBcbiAgICAgKiAqKm11c3QqKiBhcHBlYXIgaW4gYHNvdXJjZWAgaW4gdGhlIG9yZGVyIGdpdmVuIGJ5IGBxdWVyeWAuXG4gICAgICpcbiAgICAgKiBDaGFyYWN0ZXJzIGFyZSBtYXRjaGVkIHVzaW5nIHN0cmljdCBgPT09YCBlcXVhbGl0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kaWNlcyhzb3VyY2UsIHF1ZXJ5LCBzdGFydCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgQXJyYXkocXVlcnkubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBzdGFydCwgbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IG47ICsraSwgKytqKSB7XG4gICAgICAgICAgICBqID0gc291cmNlLmluZGV4T2YocXVlcnlbaV0sIGopO1xuICAgICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9XG4gICAgU3RyaW5nRXh0LmZpbmRJbmRpY2VzID0gZmluZEluZGljZXM7XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgbWF0Y2hlciB3aGljaCB1c2VzIGEgc3VtLW9mLXNxdWFyZXMgYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2UgdGV4dCB3aGljaCBzaG91bGQgYmUgc2VhcmNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgY2hhcmFjdGVycyB0byBsb2NhdGUgaW4gdGhlIHNvdXJjZSB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0Y2ggcmVzdWx0LCBvciBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gbWF0Y2guXG4gICAgICogICBBIGxvd2VyIGBzY29yZWAgcmVwcmVzZW50cyBhIHN0cm9uZ2VyIG1hdGNoLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyIG9uIGBzb3VyY2VUZXh0YC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHNjb3JpbmcgYWxnb3JpdGhtIHVzZXMgYSBzdW0tb2Ytc3F1YXJlcyBhcHByb2FjaCB0byBkZXRlcm1pbmVcbiAgICAgKiB0aGUgc2NvcmUuIEluIG9yZGVyIGZvciB0aGVyZSB0byBiZSBhIG1hdGNoLCBhbGwgb2YgdGhlIGNoYXJhY3RlcnNcbiAgICAgKiBpbiBgcXVlcnlgICoqbXVzdCoqIGFwcGVhciBpbiBgc291cmNlYCBpbiBvcmRlci4gVGhlIGluZGV4IG9mIGVhY2hcbiAgICAgKiBtYXRjaGluZyBjaGFyYWN0ZXIgaXMgc3F1YXJlZCBhbmQgYWRkZWQgdG8gdGhlIHNjb3JlLiBUaGlzIG1lYW5zXG4gICAgICogdGhhdCBlYXJseSBhbmQgY29uc2VjdXRpdmUgY2hhcmFjdGVyIG1hdGNoZXMgYXJlIHByZWZlcnJlZCwgd2hpbGVcbiAgICAgKiBsYXRlIG1hdGNoZXMgYXJlIGhlYXZpbHkgcGVuYWxpemVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoU3VtT2ZTcXVhcmVzKHNvdXJjZSwgcXVlcnksIHN0YXJ0KSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICB2YXIgaW5kaWNlcyA9IGZpbmRJbmRpY2VzKHNvdXJjZSwgcXVlcnksIHN0YXJ0KTtcbiAgICAgICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcmUgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGluZGljZXNbaV0gLSBzdGFydDtcbiAgICAgICAgICAgIHNjb3JlICs9IGogKiBqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNjb3JlOiBzY29yZSwgaW5kaWNlczogaW5kaWNlcyB9O1xuICAgIH1cbiAgICBTdHJpbmdFeHQubWF0Y2hTdW1PZlNxdWFyZXMgPSBtYXRjaFN1bU9mU3F1YXJlcztcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyBtYXRjaGVyIHdoaWNoIHVzZXMgYSBzdW0tb2YtZGVsdGFzIGFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIHRleHQgd2hpY2ggc2hvdWxkIGJlIHNlYXJjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIGNoYXJhY3RlcnMgdG8gbG9jYXRlIGluIHRoZSBzb3VyY2UgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG1hdGNoIHJlc3VsdCwgb3IgYG51bGxgIGlmIHRoZXJlIGlzIG5vIG1hdGNoLlxuICAgICAqICAgQSBsb3dlciBgc2NvcmVgIHJlcHJlc2VudHMgYSBzdHJvbmdlciBtYXRjaC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhciBvbiBgc291cmNlVGV4dGAuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBzY29yaW5nIGFsZ29yaXRobSB1c2VzIGEgc3VtLW9mLWRlbHRhcyBhcHByb2FjaCB0byBkZXRlcm1pbmVcbiAgICAgKiB0aGUgc2NvcmUuIEluIG9yZGVyIGZvciB0aGVyZSB0byBiZSBhIG1hdGNoLCBhbGwgb2YgdGhlIGNoYXJhY3RlcnNcbiAgICAgKiBpbiBgcXVlcnlgICoqbXVzdCoqIGFwcGVhciBpbiBgc291cmNlYCBpbiBvcmRlci4gVGhlIGRlbHRhIGJldHdlZW5cbiAgICAgKiB0aGUgaW5kaWNlcyBhcmUgc3VtbWVkIHRvIGNyZWF0ZSB0aGUgc2NvcmUuIFRoaXMgbWVhbnMgdGhhdCBncm91cHNcbiAgICAgKiBvZiBtYXRjaGVkIGNoYXJhY3RlcnMgYXJlIHByZWZlcnJlZCwgd2hpbGUgZnJhZ21lbnRlZCBtYXRjaGVzIGFyZVxuICAgICAqIHBlbmFsaXplZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaFN1bU9mRGVsdGFzKHNvdXJjZSwgcXVlcnksIHN0YXJ0KSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICB2YXIgaW5kaWNlcyA9IGZpbmRJbmRpY2VzKHNvdXJjZSwgcXVlcnksIHN0YXJ0KTtcbiAgICAgICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcmUgPSAwO1xuICAgICAgICB2YXIgbGFzdCA9IHN0YXJ0IC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgc2NvcmUgKz0gaiAtIGxhc3QgLSAxO1xuICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2NvcmU6IHNjb3JlLCBpbmRpY2VzOiBpbmRpY2VzIH07XG4gICAgfVxuICAgIFN0cmluZ0V4dC5tYXRjaFN1bU9mRGVsdGFzID0gbWF0Y2hTdW1PZkRlbHRhcztcbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHQgdGhlIG1hdGNoZWQgY2hhcmFjdGVycyBvZiBhIHNvdXJjZSB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSB0ZXh0IHdoaWNoIHNob3VsZCBiZSBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRpY2VzIC0gVGhlIGluZGljZXMgb2YgdGhlIG1hdGNoZWQgY2hhcmFjdGVycy4gVGhleSBtdXN0XG4gICAgICogICBhcHBlYXIgaW4gaW5jcmVhc2luZyBvcmRlciBhbmQgbXVzdCBiZSBpbiBib3VuZHMgb2YgdGhlIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgbWF0Y2hlZCBjaHVua3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bm1hdGNoZWQgYW5kIGhpZ2hsaWdodGVkIGNodW5rcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoaWdobGlnaHQoc291cmNlLCBpbmRpY2VzLCBmbikge1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHJlc3VsdCBhcnJheS5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGNvdW50ZXIgdmFyaWFibGVzLlxuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIHZhciBsYXN0ID0gMDtcbiAgICAgICAgdmFyIG4gPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgLy8gSXRlcmF0b3Igb3ZlciBlYWNoIGluZGV4LlxuICAgICAgICB3aGlsZSAoayA8IG4pIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgY2h1bmsgaW5kaWNlcy5cbiAgICAgICAgICAgIHZhciBpID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgIHZhciBqID0gaW5kaWNlc1trXTtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIHJpZ2h0IGNodW5rIGluZGV4IHVudGlsIGl0J3Mgbm9uLWNvbnRpZ3VvdXMuXG4gICAgICAgICAgICB3aGlsZSAoKytrIDwgbiAmJiBpbmRpY2VzW2tdID09PSBqICsgMSkge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHVubWF0Y2hlZCB0ZXh0LlxuICAgICAgICAgICAgaWYgKGxhc3QgPCBpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc291cmNlLnNsaWNlKGxhc3QsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYW5kIGhpZ2hsaWdodCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgICAgICAgICAgaWYgKGkgPCBqICsgMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuKHNvdXJjZS5zbGljZShpLCBqICsgMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCB2aXNpdGVkIGluZGV4LlxuICAgICAgICAgICAgbGFzdCA9IGogKyAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgYW55IHJlbWFpbmluZyB1bm1hdGNoZWQgdGV4dC5cbiAgICAgICAgaWYgKGxhc3QgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzb3VyY2Uuc2xpY2UobGFzdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgaGlnaGxpZ2h0ZWQgcmVzdWx0LlxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTdHJpbmdFeHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgIC8qKlxuICAgICAqIEEgMy13YXkgc3RyaW5nIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBzdHJpbmcgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBzZWNvbmQgc3RyaW5nIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYC0xYCBpZiBgYSA8IGJgLCBlbHNlIGAxYCBpZiBgYSA+IGJgLCBlbHNlIGAwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbXAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgfVxuICAgIFN0cmluZ0V4dC5jbXAgPSBjbXA7XG59KShTdHJpbmdFeHQgfHwgKFN0cmluZ0V4dCA9IHt9KSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBUYWtlIGEgZml4ZWQgbnVtYmVyIG9mIGl0ZW1zIGZyb20gYW4gaXRlcmFibGUuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHRha2UgZnJvbSB0aGUgaXRlcmFibGUuXG4gKlxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGl0ZW1zXG4gKiAgIGZyb20gdGhlIHNvdXJjZSBpdGVyYWJsZS5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGUgcmV0dXJuZWQgaXRlcmF0b3Igd2lsbCBleGhhdXN0IGVhcmx5IGlmIHRoZSBzb3VyY2UgaXRlcmFibGVcbiAqIGNvbnRhaW5zIGFuIGluc3VmZmljaWVudCBudW1iZXIgb2YgaXRlbXMuXG4gKi9cbmZ1bmN0aW9uIHRha2Uob2JqZWN0LCBjb3VudCkge1xuICAgIHJldHVybiBuZXcgVGFrZUl0ZXJhdG9yKGl0ZXIob2JqZWN0KSwgY291bnQpO1xufVxuLyoqXG4gKiBBbiBpdGVyYXRvciB3aGljaCB0YWtlcyBhIGZpeGVkIG51bWJlciBvZiBpdGVtcyBmcm9tIGEgc291cmNlLlxuICovXG52YXIgVGFrZUl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB0YWtlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBpdGVyYXRvciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gdGFrZSBmcm9tIHRoZSBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFrZUl0ZXJhdG9yKHNvdXJjZSwgY291bnQpIHtcbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaXRlcmF0b3Igb3ZlciB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICovXG4gICAgVGFrZUl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICovXG4gICAgVGFrZUl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWtlSXRlcmF0b3IodGhpcy5fc291cmNlLmNsb25lKCksIHRoaXMuX2NvdW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBUYWtlSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3NvdXJjZS5uZXh0KCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvdW50LS07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlSXRlcmF0b3I7XG59KCkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8qKlxuICogSXRlcmF0ZSBzZXZlcmFsIGl0ZXJhYmxlcyBpbiBsb2Nrc3RlcC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0cyAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdHMgb2YgaW50ZXJlc3QuXG4gKlxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHN1Y2Nlc3NpdmUgdHVwbGVzIG9mIHZhbHVlcyB3aGVyZVxuICogICBlYWNoIHZhbHVlIGlzIHRha2VuIGluIHR1cm4gZnJvbSB0aGUgcHJvdmlkZWQgaXRlcmFibGVzLiBJdCB3aWxsXG4gKiAgIGJlIGFzIGxvbmcgYXMgdGhlIHNob3J0ZXN0IHByb3ZpZGVkIGl0ZXJhYmxlLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgemlwLCB0b0FycmF5IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuICpcbiAqIGxldCBkYXRhMSA9IFsxLCAyLCAzXTtcbiAqIGxldCBkYXRhMiA9IFs0LCA1LCA2XTtcbiAqXG4gKiBsZXQgc3RyZWFtID0gemlwKGRhdGExLCBkYXRhMik7XG4gKlxuICogdG9BcnJheShzdHJlYW0pOyAgLy8gW1sxLCA0XSwgWzIsIDVdLCBbMywgNl1dXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gemlwKCkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JqZWN0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFppcEl0ZXJhdG9yKG9iamVjdHMubWFwKGl0ZXIpKTtcbn1cbi8qKlxuICogQW4gaXRlcmF0b3Igd2hpY2ggaXRlcmF0ZXMgc2V2ZXJhbCBzb3VyY2VzIGluIGxvY2tzdGVwLlxuICovXG52YXIgWmlwSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHppcCBpdGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgaXRlcmF0b3JzIG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcEl0ZXJhdG9yKHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBaaXBJdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIFppcEl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBaaXBJdGVyYXRvcih0aGlzLl9zb3VyY2UubWFwKGZ1bmN0aW9uIChpdCkgeyByZXR1cm4gaXQuY2xvbmUoKTsgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIFppcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMuX3NvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX3NvdXJjZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3NvdXJjZVtpXS5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFppcEl0ZXJhdG9yO1xufSgpKTtcblxuZXhwb3J0IHsgQXJyYXlFeHQsIEFycmF5SXRlcmF0b3IsIENoYWluSXRlcmF0b3IsIEVtcHR5SXRlcmF0b3IsIEVudW1lcmF0ZUl0ZXJhdG9yLCBGaWx0ZXJJdGVyYXRvciwgRm5JdGVyYXRvciwgSXRlbUl0ZXJhdG9yLCBLZXlJdGVyYXRvciwgTWFwSXRlcmF0b3IsIFJhbmdlSXRlcmF0b3IsIFJlcGVhdEl0ZXJhdG9yLCBSZXRyb0FycmF5SXRlcmF0b3IsIFN0cmlkZUl0ZXJhdG9yLCBTdHJpbmdFeHQsIFRha2VJdGVyYXRvciwgVmFsdWVJdGVyYXRvciwgWmlwSXRlcmF0b3IsIGNoYWluLCBlYWNoLCBlbXB0eSwgZW51bWVyYXRlLCBldmVyeSwgZmlsdGVyLCBmaW5kLCBmaW5kSW5kZXgsIGl0ZXIsIGl0ZXJGbiwgaXRlckl0ZW1zLCBpdGVyS2V5cywgaXRlclZhbHVlcywgbWFwLCBtYXgsIG1pbiwgbWlubWF4LCBvbmNlLCByYW5nZSwgcmVkdWNlLCByZXBlYXQsIHJldHJvLCBzb21lLCBzdHJpZGUsIHRha2UsIHRvQXJyYXksIHRvT2JqZWN0LCB0b3BvbG9naWNTb3J0LCB6aXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lumino/algorithm/dist/index.es6.js\n")},"./node_modules/@lumino/collections/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BPlusTree": () => (/* binding */ BPlusTree),\n/* harmony export */   "LinkedList": () => (/* binding */ LinkedList)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@lumino/algorithm/dist/index.es6.js");\n\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A generic B+ tree.\n *\n * #### Notes\n * Most operations have `O(log32 n)` or better complexity.\n */\nvar BPlusTree = /** @class */ (function () {\n    /**\n     * Construct a new B+ tree.\n     *\n     * @param cmp - The item comparison function for the tree.\n     */\n    function BPlusTree(cmp) {\n        this._root = new Private.LeafNode();\n        this.cmp = cmp;\n    }\n    Object.defineProperty(BPlusTree.prototype, "isEmpty", {\n        /**\n         * Whether the tree is empty.\n         *\n         * #### Complexity\n         * `O(1)`\n         */\n        get: function () {\n            return this._root.size === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BPlusTree.prototype, "size", {\n        /**\n         * The size of the tree.\n         *\n         * #### Complexity\n         * `O(1)`\n         */\n        get: function () {\n            return this._root.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BPlusTree.prototype, "first", {\n        /**\n         * The first item in the tree.\n         *\n         * This is `undefined` if the tree is empty.\n         *\n         * #### Complexity\n         * `O(log32 n)`\n         */\n        get: function () {\n            var node = Private.firstLeaf(this._root);\n            return node.size > 0 ? node.items[0] : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BPlusTree.prototype, "last", {\n        /**\n         * The last item in the tree.\n         *\n         * This is `undefined` if the tree is empty.\n         *\n         * #### Complexity\n         * `O(log32 n)`\n         */\n        get: function () {\n            var node = Private.lastLeaf(this._root);\n            return node.size > 0 ? node.items[node.size - 1] : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over the items in the tree.\n     *\n     * @returns A new iterator starting with the first item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.iter = function () {\n        return Private.iterItems(this._root);\n    };\n    /**\n     * Create a reverse iterator over the items in the tree.\n     *\n     * @returns A new iterator starting with the last item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.retro = function () {\n        return Private.retroItems(this._root);\n    };\n    /**\n     * Create an iterator for a slice of items in the tree.\n     *\n     * @param start - The index of the first item, inclusive. This\n     *   should be `< stop`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `0`.\n     *\n     * @param stop - The index of the last item, exclusive. This\n     *   should be `> start`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `size`.\n     *\n     * @returns A new iterator starting with the specified item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.slice = function (start, stop) {\n        return Private.sliceItems(this._root, start, stop);\n    };\n    /**\n     * Create a reverse iterator for a slice of items in the tree.\n     *\n     * @param start - The index of the first item, inclusive. This\n     *   should be `> stop`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `size - 1`.\n     *\n     * @param stop - The index of the last item, exclusive. This\n     *   should be `< start`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `-size - 1`.\n     *\n     * @returns A new reverse iterator starting with the specified item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.retroSlice = function (start, stop) {\n        return Private.retroSliceItems(this._root, start, stop);\n    };\n    /**\n     * Get the item at a particular index.\n     *\n     * @param index - The index of the item of interest. Negative\n     *   values are taken as an offset from the end of the tree.\n     *\n     * @returns The item at the specified index, or `undefined` if\n     *   the index is out of range.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.at = function (index) {\n        return Private.itemAt(this._root, index);\n    };\n    /**\n     * Test whether the tree has an item which matches a key.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - A function which compares an item against the key.\n     *\n     * @returns `true` if the tree has an item which matches the given\n     *   key, `false` otherwise.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.has = function (key, cmp) {\n        return Private.hasItem(this._root, key, cmp);\n    };\n    /**\n     * Get the index of an item which matches a key.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - A function which compares an item against the key.\n     *\n     * @returns The index of the item which matches the given key. A\n     *   negative value means that a matching item does not exist in\n     *   the tree, but if one did it would reside at `-index - 1`.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.indexOf = function (key, cmp) {\n        return Private.indexOf(this._root, key, cmp);\n    };\n    /**\n     * Get the item which matches a key.\n     *\n     * @param item - The key of interest.\n     *\n     * @param cmp - A function which compares an item against the key.\n     *\n     * @returns The item which matches the given key, or `undefined` if\n     *   the tree does not have a matching item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.get = function (key, cmp) {\n        return Private.getItem(this._root, key, cmp);\n    };\n    /**\n     * Assign new items to the tree, replacing all current items.\n     *\n     * @param items - The items to assign to the tree.\n     *\n     * #### Complexity\n     * `O(n log32 n)`\n     */\n    BPlusTree.prototype.assign = function (items) {\n        this.clear();\n        this.update(items);\n    };\n    /**\n     * Insert an item into the tree.\n     *\n     * @param item - The item of interest.\n     *\n     * @returns If the given item matches an existing item in the tree,\n     *   the given item will replace it, and the existing item will be\n     *   returned. Otherwise, this method returns `undefined`.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.insert = function (item) {\n        var existing = Private.insertItem(this._root, item, this.cmp);\n        this._root = Private.maybeSplitRoot(this._root);\n        return existing;\n    };\n    /**\n     * Update the tree with multiple items.\n     *\n     * @param items - The items to insert into the tree.\n     *\n     * #### Complexity\n     * `O(k log32 n)`\n     */\n    BPlusTree.prototype.update = function (items) {\n        var _this = this;\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(items, function (item) { _this.insert(item); });\n    };\n    /**\n     * Delete an item which matches a particular key.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - A function which compares an item against the key.\n     *\n     * @returns The item removed from the tree, or `undefined` if no\n     *   item matched the given key.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.delete = function (key, cmp) {\n        var item = Private.deleteItem(this._root, key, cmp);\n        this._root = Private.maybeExtractRoot(this._root);\n        return item;\n    };\n    /**\n     * Remove an item at a particular index.\n     *\n     * @param index - The index of the item to remove. Negative\n     *   values are taken as an offset from the end of the tree.\n     *\n     * @returns The item removed from the tree, or `undefined` if\n     *   the given index is out of range.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    BPlusTree.prototype.remove = function (index) {\n        var item = Private.removeItem(this._root, index);\n        this._root = Private.maybeExtractRoot(this._root);\n        return item;\n    };\n    /**\n     * Clear the contents of the tree.\n     *\n     * #### Complexity\n     * `O(n)`\n     */\n    BPlusTree.prototype.clear = function () {\n        Private.clear(this._root);\n        this._root = new Private.LeafNode();\n    };\n    return BPlusTree;\n}());\n/**\n * The namespace for the `BPlusTree` class statics.\n */\n(function (BPlusTree) {\n    /**\n     * Create a new B+ tree populated with the given items.\n     *\n     * @param items - The items to add to the tree.\n     *\n     * @param cmp - The item comparison function for the tree.\n     *\n     * @returns A new B+ tree populated with the given items.\n     *\n     * #### Complexity\n     * `O(n log32 n)`\n     */\n    function from(items, cmp) {\n        var tree = new BPlusTree(cmp);\n        tree.assign(items);\n        return tree;\n    }\n    BPlusTree.from = from;\n})(BPlusTree || (BPlusTree = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A branch node in a B+ tree.\n     */\n    var BranchNode = /** @class */ (function () {\n        function BranchNode() {\n            /**\n             * The left-most item of each child subtree.\n             */\n            this.items = [];\n            /**\n             * The cumulative sizes of each child subtree.\n             */\n            this.sizes = [];\n            /**\n             * The child nodes of this branch node.\n             */\n            this.children = [];\n        }\n        Object.defineProperty(BranchNode.prototype, "type", {\n            /**\n             * The discriminated type of the node.\n             */\n            get: function () {\n                return 0 /* Branch */;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BranchNode.prototype, "size", {\n            /**\n             * The total number of items in the subtree.\n             */\n            get: function () {\n                return this.sizes[this.sizes.length - 1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BranchNode.prototype, "width", {\n            /**\n             * The tree width of the node.\n             */\n            get: function () {\n                return this.children.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return BranchNode;\n    }());\n    Private.BranchNode = BranchNode;\n    /**\n     * A leaf node in a B+ tree.\n     */\n    var LeafNode = /** @class */ (function () {\n        function LeafNode() {\n            /**\n             * The next sibling leaf node of this leaf node.\n             */\n            this.next = null;\n            /**\n             * The previous sibling leaf node of this leaf node.\n             */\n            this.prev = null;\n            /**\n             * The items of the leaf.\n             */\n            this.items = [];\n        }\n        Object.defineProperty(LeafNode.prototype, "type", {\n            /**\n             * The discriminated type of the node.\n             */\n            get: function () {\n                return 1 /* Leaf */;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LeafNode.prototype, "size", {\n            /**\n             * The total number of items in the leaf.\n             */\n            get: function () {\n                return this.items.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LeafNode.prototype, "width", {\n            /**\n             * The tree width of the node.\n             */\n            get: function () {\n                return this.items.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return LeafNode;\n    }());\n    Private.LeafNode = LeafNode;\n    /**\n     * Get the first leaf node in the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @returns The first leaf node in the tree.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function firstLeaf(node) {\n        while (node.type === 0 /* Branch */) {\n            node = node.children[0];\n        }\n        return node;\n    }\n    Private.firstLeaf = firstLeaf;\n    /**\n     * Get the last leaf node in the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @returns The last leaf node in the tree.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function lastLeaf(node) {\n        while (node.type === 0 /* Branch */) {\n            node = node.children[node.children.length - 1];\n        }\n        return node;\n    }\n    Private.lastLeaf = lastLeaf;\n    /**\n     * Create a forward iterator for the items in the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @returns A new forward iterator starting with the first item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function iterItems(node) {\n        var leaf = firstLeaf(node);\n        return new ForwardIterator(leaf, 0, -1);\n    }\n    Private.iterItems = iterItems;\n    /**\n     * Create a reverse iterator for the items in the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @returns A new reverse iterator starting with the last item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function retroItems(node) {\n        var leaf = lastLeaf(node);\n        return new RetroIterator(leaf, leaf.size - 1, -1);\n    }\n    Private.retroItems = retroItems;\n    /**\n     * Create an iterator for a slice of items in the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @param start - The index of the first item, inclusive. This\n     *   should be `< stop`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `0`.\n     *\n     * @param stop - The index of the last item, exclusive. This\n     *   should be `> start`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `size`.\n     *\n     * @returns A new iterator starting with the specified item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function sliceItems(node, start, stop) {\n        // Normalize the start index.\n        if (start === undefined) {\n            start = 0;\n        }\n        else if (start < 0) {\n            start = Math.max(0, start + node.size);\n        }\n        else {\n            start = Math.min(start, node.size);\n        }\n        // Normalize the stop index.\n        if (stop === undefined) {\n            stop = node.size;\n        }\n        else if (stop < 0) {\n            stop = Math.max(0, stop + node.size);\n        }\n        else {\n            stop = Math.min(stop, node.size);\n        }\n        // Compute effective count.\n        var count = Math.max(0, stop - start);\n        // Bail early if there is nothing to iterate.\n        if (count === 0) {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n        }\n        // Find the starting leaf node and local index.\n        while (node.type === 0 /* Branch */) {\n            var i = findPivotIndexByIndex(node.sizes, start);\n            if (i > 0)\n                start -= node.sizes[i - 1];\n            node = node.children[i];\n        }\n        // Return the forward iterator for the range.\n        return new ForwardIterator(node, start, count);\n    }\n    Private.sliceItems = sliceItems;\n    /**\n     * Create a reverse iterator for a slice of items in the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @param start - The index of the first item, inclusive. This\n     *   should be `> stop`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `size - 1`.\n     *\n     * @param stop - The index of the last item, exclusive. This\n     *   should be `< start`. Negative values are taken as an offset\n     *   from the end of the tree. The default is `-size - 1`.\n     *\n     * @returns A new reverse iterator starting with the specified item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function retroSliceItems(node, start, stop) {\n        // Normalize the start index.\n        if (start === undefined) {\n            start = node.size - 1;\n        }\n        else if (start < 0) {\n            start = Math.max(-1, start + node.size);\n        }\n        else {\n            start = Math.min(start, node.size - 1);\n        }\n        // Normalize the stop index.\n        if (stop === undefined) {\n            stop = -1;\n        }\n        else if (stop < 0) {\n            stop = Math.max(-1, stop + node.size);\n        }\n        else {\n            stop = Math.min(stop, node.size - 1);\n        }\n        // Compute the effective count.\n        var count = Math.max(0, start - stop);\n        // Bail early if there is nothing to iterate.\n        if (count === 0) {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n        }\n        // Find the starting leaf node and local index.\n        while (node.type === 0 /* Branch */) {\n            var i = findPivotIndexByIndex(node.sizes, start);\n            if (i > 0)\n                start -= node.sizes[i - 1];\n            node = node.children[i];\n        }\n        // Return the retro iterator for the range.\n        return new RetroIterator(node, start, count);\n    }\n    Private.retroSliceItems = retroSliceItems;\n    /**\n     * Get the item at the specified index.\n     *\n     * @param node - The root node of interest.\n     *\n     * @param index - The index of the item of interest. Negative\n     *   values are taken as an offset from the end of the tree.\n     *\n     * @returns The item at the specified index, or `undefined` if\n     *   the index is out of range.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function itemAt(node, index) {\n        // Wrap negative indices.\n        if (index < 0) {\n            index += node.size;\n        }\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= node.size) {\n            return undefined;\n        }\n        // Find the containing leaf node and local index.\n        while (node.type === 0 /* Branch */) {\n            var i = findPivotIndexByIndex(node.sizes, index);\n            if (i > 0)\n                index -= node.sizes[i - 1];\n            node = node.children[i];\n        }\n        // Return the item at the specified index.\n        return node.items[index];\n    }\n    Private.itemAt = itemAt;\n    /**\n     * Test whether the tree contains an item which matches a key.\n     *\n     * @param node - The root node of interest.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - The key comparison function.\n     *\n     * @returns Whether the tree contains a matching item.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function hasItem(node, key, cmp) {\n        // Find the containing leaf node.\n        while (node.type === 0 /* Branch */) {\n            var i_1 = findPivotIndexByKey(node.items, key, cmp);\n            node = node.children[i_1];\n        }\n        // Find the key index.\n        var i = findKeyIndex(node.items, key, cmp);\n        // Return whether or not the node contains a matching item.\n        return i >= 0;\n    }\n    Private.hasItem = hasItem;\n    /**\n     * Get the index of the item which matches a key.\n     *\n     * @param node - The node of interest.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - The key comparison function.\n     *\n     * @returns The index of the item which matches the given key. A\n     *   negative value means that a matching item does not exist in\n     *   the tree, but if one did it would reside at `-index - 1`.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function indexOf(node, key, cmp) {\n        // Set up the global index.\n        var index = 0;\n        // Find the containing leaf node and global index.\n        while (node.type === 0 /* Branch */) {\n            var i_2 = findPivotIndexByKey(node.items, key, cmp);\n            if (i_2 > 0)\n                index += node.sizes[i_2 - 1];\n            node = node.children[i_2];\n        }\n        // Find the key index.\n        var i = findKeyIndex(node.items, key, cmp);\n        // Return the final computed index.\n        return i >= 0 ? index + i : -index + i;\n    }\n    Private.indexOf = indexOf;\n    /**\n     * Get the item for a particular key.\n     *\n     * @param node - The node of interest.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - The key comparison function.\n     *\n     * @returns The item for the specified key, or `undefined` if\n     *   the tree does not have a matching item for the key.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     */\n    function getItem(node, key, cmp) {\n        // Find the containing leaf node.\n        while (node.type === 0 /* Branch */) {\n            var i_3 = findPivotIndexByKey(node.items, key, cmp);\n            node = node.children[i_3];\n        }\n        // Find the key index.\n        var i = findKeyIndex(node.items, key, cmp);\n        // Return the item for the given key.\n        return i >= 0 ? node.items[i] : undefined;\n    }\n    Private.getItem = getItem;\n    /**\n     * Insert an item into the tree.\n     *\n     * @param node - The root node of interest.\n     *\n     * @param item - The item of interest.\n     *\n     * @param cmp - The item comparison function.\n     *\n     * @returns If the given item matches an existing item in the tree,\n     *   the given item will replace it, and the existing item will be\n     *   returned. Otherwise, this function returns `undefined`.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     *\n     * #### Notes\n     * The root may be overfull after calling this function.\n     */\n    function insertItem(node, item, cmp) {\n        // Handle leaf nodes first.\n        if (node.type === 1 /* Leaf */) {\n            // Find the index for the given item.\n            var i_4 = findKeyIndex(node.items, item, cmp);\n            // Fetch the existing item and insert the new item.\n            var existing_1;\n            if (i_4 >= 0) {\n                existing_1 = node.items[i_4];\n                node.items[i_4] = item;\n            }\n            else {\n                existing_1 = undefined;\n                _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(node.items, -i_4 - 1, item);\n            }\n            // Return the existing item.\n            return existing_1;\n        }\n        // Find the pivot index for the insert.\n        var i = findPivotIndexByKey(node.items, item, cmp);\n        // Fetch the pivot child.\n        var child = node.children[i];\n        // Fetch the current size of the child.\n        var prevSize = child.size;\n        // Recursively insert the item into the child.\n        var existing = insertItem(child, item, cmp);\n        // Fetch the updated size of the child.\n        var currSize = child.size;\n        // Update the item state of the branch.\n        node.items[i] = child.items[0];\n        // Bail early if the child size did not change.\n        if (prevSize === currSize) {\n            return existing;\n        }\n        // Split the child if it\'s overfull.\n        if (child.width > MAX_NODE_WIDTH) {\n            var next = splitNode(child);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(node.children, i + 1, next);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(node.items, i + 1, next.items[0]);\n        }\n        // Update the dirty sizes of the branch.\n        updateSizes(node, i);\n        // Return the existing item.\n        return existing;\n    }\n    Private.insertItem = insertItem;\n    /**\n     * Delete an item in the tree.\n     *\n     * @param node - The node of interest.\n     *\n     * @param key - The key of interest.\n     *\n     * @param cmp - The key comparison function.\n     *\n     * @returns The deleted item or `undefined`.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     *\n     * #### Notes\n     * The root may be underfull after calling this function.\n     */\n    function deleteItem(node, key, cmp) {\n        // Handle leaf nodes first.\n        if (node.type === 1 /* Leaf */) {\n            // Find the index for the given key.\n            var i_5 = findKeyIndex(node.items, key, cmp);\n            // Bail early if the item does not exist.\n            if (i_5 < 0) {\n                return undefined;\n            }\n            // Remove the item at the computed index.\n            return _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.items, i_5);\n        }\n        // Find the pivot index for the delete.\n        var i = findPivotIndexByKey(node.items, key, cmp);\n        // Fetch the pivot child.\n        var child = node.children[i];\n        // Fetch the current size of the child.\n        var prevSize = child.size;\n        // Recursively remove the item from the child.\n        var item = deleteItem(child, key, cmp);\n        // Fetch the updated size of the child.\n        var currSize = child.size;\n        // Bail early if the child size did not change.\n        if (prevSize === currSize) {\n            return item;\n        }\n        // Update the item state of the branch.\n        node.items[i] = child.items[0];\n        // Join the child if it\'s underfull.\n        if (child.width < MIN_NODE_WIDTH) {\n            i = joinChild(node, i);\n        }\n        // Update the dirty sizes of the branch.\n        updateSizes(node, i);\n        // Return the deleted item.\n        return item;\n    }\n    Private.deleteItem = deleteItem;\n    /**\n     * Remove an item from the tree.\n     *\n     * @param node - The node of interest.\n     *\n     * @param index - The index of interest.\n     *\n     * @returns The removed item or `undefined`.\n     *\n     * #### Complexity\n     * `O(log32 n)`\n     *\n     * #### Notes\n     * The root may be underfull after calling this function.\n     */\n    function removeItem(node, index) {\n        // Wrap negative indices.\n        if (index < 0) {\n            index += node.size;\n        }\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= node.size) {\n            return undefined;\n        }\n        // Handle leaf nodes first.\n        if (node.type === 1 /* Leaf */) {\n            return _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.items, index);\n        }\n        // Find the pivot index for the remove.\n        var i = findPivotIndexByIndex(node.sizes, index);\n        if (i > 0)\n            index -= node.sizes[i];\n        // Fetch the pivot child.\n        var child = node.children[i];\n        // Recursively remove the item from the child.\n        var item = removeItem(child, index);\n        // Update the item state of the branch.\n        node.items[i] = child.items[0];\n        // Join the child if it\'s underfull.\n        if (child.width < MIN_NODE_WIDTH) {\n            i = joinChild(node, i);\n        }\n        // Update the dirty sizes of the branch.\n        updateSizes(node, i);\n        // Return the removed item.\n        return item;\n    }\n    Private.removeItem = removeItem;\n    /**\n     * Recursively clear the contents of a node.\n     *\n     * @param node - The node of interest.\n     *\n     * #### Complexity\n     * `O(n)`\n     */\n    function clear(node) {\n        if (node.type === 0 /* Branch */) {\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(node.children, clear);\n            node.children.length = 0;\n            node.sizes.length = 0;\n            node.items.length = 0;\n        }\n        else {\n            node.items.length = 0;\n            node.next = null;\n            node.prev = null;\n        }\n    }\n    Private.clear = clear;\n    /**\n     * Split a root node and create a new root, if needed.\n     *\n     * @param node - The root node of interest.\n     *\n     * @returns The new root node.\n     */\n    function maybeSplitRoot(node) {\n        // Bail early if the current root is not overfull.\n        if (node.width <= MAX_NODE_WIDTH) {\n            return node;\n        }\n        // Create a new root branch node.\n        var root = new BranchNode();\n        // Split the node to the right and create a new sibling.\n        var next = splitNode(node);\n        // Add the sizes to the root.\n        root.sizes[0] = node.size;\n        root.sizes[1] = node.size + next.size;\n        // Add the children to the root.\n        root.children[0] = node;\n        root.children[1] = next;\n        // Add the items to the root.\n        root.items[0] = node.items[0];\n        root.items[1] = next.items[0];\n        // Return the new root node.\n        return root;\n    }\n    Private.maybeSplitRoot = maybeSplitRoot;\n    /**\n     * Extract a single node child as a new root, if needed.\n     *\n     * @param node - The root node of interest.\n     *\n     * @returns The new root node.\n     */\n    function maybeExtractRoot(node) {\n        // Bail early if the node it already a leaf.\n        if (node.type === 1 /* Leaf */) {\n            return node;\n        }\n        // Bail early if the branch has more than one child.\n        if (node.children.length > 1) {\n            return node;\n        }\n        // Extract the sole remaining child as the new root.\n        var root = node.children.pop();\n        // Clear the rest of the node state.\n        clear(node);\n        // Return the new root.\n        return root;\n    }\n    Private.maybeExtractRoot = maybeExtractRoot;\n    /**\n     * The maximum width for a node in the tree.\n     */\n    var MAX_NODE_WIDTH = 32;\n    /**\n     * The minimum width for a node in the tree.\n     */\n    var MIN_NODE_WIDTH = MAX_NODE_WIDTH >> 1;\n    /**\n     * A forward iterator for a B+ tree.\n     */\n    var ForwardIterator = /** @class */ (function () {\n        /**\n         * Construct a new forward iterator.\n         *\n         * @param node - The first leaf node in the chain.\n         *\n         * @param index - The local index of the first item.\n         *\n         * @param count - The number of items to iterate. A value `< 0`\n         *   will iterate all available items.\n         */\n        function ForwardIterator(node, index, count) {\n            this._node = node;\n            this._index = index;\n            this._count = count;\n        }\n        /**\n         * Get an iterator over the object\'s values.\n         *\n         * @returns An iterator which yields the object\'s values.\n         */\n        ForwardIterator.prototype.iter = function () {\n            return this;\n        };\n        /**\n         * Create an independent clone of the iterator.\n         *\n         * @returns A new independent clone of the iterator.\n         */\n        ForwardIterator.prototype.clone = function () {\n            return new ForwardIterator(this._node, this._index, this._count);\n        };\n        /**\n         * Get the next value from the iterator.\n         *\n         * @returns The next value from the iterator, or `undefined`.\n         */\n        ForwardIterator.prototype.next = function () {\n            if (this._node === null || this._count === 0) {\n                return undefined;\n            }\n            if (this._index >= this._node.size) {\n                this._node = this._node.next;\n                this._index = 0;\n                return this.next();\n            }\n            if (this._count > 0) {\n                this._count--;\n            }\n            return this._node.items[this._index++];\n        };\n        return ForwardIterator;\n    }());\n    /**\n     * A reverse iterator for a B+ tree.\n     */\n    var RetroIterator = /** @class */ (function () {\n        /**\n         * Construct a new retro iterator.\n         *\n         * @param node - The last leaf node in the chain.\n         *\n         * @param index - The local index of the last item.\n         *\n         * @param count - The number of items to iterate. A value `< 0`\n         *   will iterate all available items.\n         */\n        function RetroIterator(node, index, count) {\n            this._node = node;\n            this._index = index;\n            this._count = count;\n        }\n        /**\n         * Get an iterator over the object\'s values.\n         *\n         * @returns An iterator which yields the object\'s values.\n         */\n        RetroIterator.prototype.iter = function () {\n            return this;\n        };\n        /**\n         * Create an independent clone of the iterator.\n         *\n         * @returns A new independent clone of the iterator.\n         */\n        RetroIterator.prototype.clone = function () {\n            return new RetroIterator(this._node, this._index, this._count);\n        };\n        /**\n         * Get the next value from the iterator.\n         *\n         * @returns The next value from the iterator, or `undefined`.\n         */\n        RetroIterator.prototype.next = function () {\n            if (this._node === null || this._count === 0) {\n                return undefined;\n            }\n            if (this._index >= this._node.size) {\n                this._index = this._node.size - 1;\n            }\n            if (this._index < 0) {\n                this._node = this._node.prev;\n                this._index = this._node ? this._node.size - 1 : -1;\n                return this.next();\n            }\n            if (this._count > 0) {\n                this._count--;\n            }\n            return this._node.items[this._index--];\n        };\n        return RetroIterator;\n    }());\n    /**\n     * Find the pivot index for a particular local index.\n     */\n    function findPivotIndexByIndex(sizes, index) {\n        var n = sizes.length;\n        for (var i = 0; i < n; ++i) {\n            if (sizes[i] > index) {\n                return i;\n            }\n        }\n        return n - 1;\n    }\n    /**\n     * Find the pivot index for a particular key.\n     */\n    function findPivotIndexByKey(items, key, cmp) {\n        var n = items.length;\n        for (var i = 1; i < n; ++i) {\n            if (cmp(items[i], key) > 0) {\n                return i - 1;\n            }\n        }\n        return n - 1;\n    }\n    /**\n     * Find the key index for a particular key.\n     */\n    function findKeyIndex(items, key, cmp) {\n        var n = items.length;\n        for (var i = 0; i < n; ++i) {\n            var c = cmp(items[i], key);\n            if (c === 0) {\n                return i;\n            }\n            if (c > 0) {\n                return -i - 1;\n            }\n        }\n        return -n - 1;\n    }\n    /**\n     * Update the sizes of a branch node starting at the given index.\n     */\n    function updateSizes(node, i) {\n        var sizes = node.sizes, children = node.children;\n        var last = i > 0 ? sizes[i - 1] : 0;\n        for (var n = children.length; i < n; ++i) {\n            last = sizes[i] = last + children[i].size;\n        }\n        sizes.length = children.length;\n    }\n    /**\n     * Split a node and return its new next sibling.\n     *\n     * @param node - The node of interest.\n     *\n     * @returns The new next sibling node.\n     */\n    function splitNode(node) {\n        // Handle leaf nodes first.\n        if (node.type === 1 /* Leaf */) {\n            // Create the new sibling leaf node.\n            var next_1 = new LeafNode();\n            // Move the items to the new sibling.\n            var v1_1 = node.items;\n            var v2_1 = next_1.items;\n            for (var i = MIN_NODE_WIDTH, n = v1_1.length; i < n; ++i) {\n                v2_1.push(v1_1[i]);\n            }\n            v1_1.length = MIN_NODE_WIDTH;\n            // Patch up the sibling links.\n            if (node.next)\n                node.next.prev = next_1;\n            next_1.next = node.next;\n            next_1.prev = node;\n            node.next = next_1;\n            // Return the new next sibling.\n            return next_1;\n        }\n        // Create the new sibling branch node.\n        var next = new BranchNode();\n        // Move the children to the new sibling.\n        var c1 = node.children;\n        var c2 = next.children;\n        for (var i = MIN_NODE_WIDTH, n = c1.length; i < n; ++i) {\n            c2.push(c1[i]);\n        }\n        c1.length = MIN_NODE_WIDTH;\n        // Move the items to the new sibling.\n        var v1 = node.items;\n        var v2 = next.items;\n        for (var i = MIN_NODE_WIDTH, n = v1.length; i < n; ++i) {\n            v2.push(v1[i]);\n        }\n        v1.length = MIN_NODE_WIDTH;\n        // Update the dirty sizes of the nodes.\n        updateSizes(node, MIN_NODE_WIDTH);\n        updateSizes(next, 0);\n        // Return the new next sibling.\n        return next;\n    }\n    /**\n     * Join a child node of a branch with one of its siblings.\n     *\n     * @param node - The branch node of interest.\n     *\n     * @param i - The index of the child node of interest.\n     *\n     * @returns The first modified index.\n     *\n     * #### Notes\n     * This may cause the branch to become underfull.\n     */\n    function joinChild(node, i) {\n        var _a, _b, _c, _d, _e, _f;\n        // Fetch the child to be joined.\n        var child = node.children[i];\n        // Fetch the relevant sibling.\n        var sibling = i === 0 ? node.children[i + 1] : node.children[i - 1];\n        // Compute the flags which control the join behavior.\n        var hasNext = i === 0;\n        var isLeaf = child.type === 1 /* Leaf */;\n        var hasExtra = sibling.width > MIN_NODE_WIDTH;\n        // Join case #1: steal from next sibling leaf\n        if (isLeaf && hasExtra && hasNext) {\n            // Cast the children as leaves.\n            var c = child;\n            var s = sibling;\n            // Steal an item.\n            c.items.push(s.items.shift());\n            // Update the branch items.\n            node.items[i + 1] = s.items[0];\n            // Return the first modified index.\n            return i;\n        }\n        // Join case #2: steal from previous sibling leaf\n        if (isLeaf && hasExtra && !hasNext) {\n            // Cast the children as leaves.\n            var c = child;\n            var s = sibling;\n            // Steal an item.\n            c.items.unshift(s.items.pop());\n            // Update the branch items.\n            node.items[i] = c.items[0];\n            // Return the first modified index.\n            return i - 1;\n        }\n        // Join case #3: merge with next sibling leaf\n        if (isLeaf && !hasExtra && hasNext) {\n            // Cast the children as leaves.\n            var c = child;\n            var s = sibling;\n            // Merge items.\n            (_a = s.items).unshift.apply(_a, c.items);\n            // Remove the old branch child.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.children, i);\n            // Remove the stale branch item.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.items, i + 1);\n            // Patch up the sibling links.\n            if (c.prev)\n                c.prev.next = s;\n            s.prev = c.prev;\n            // Clear the original child.\n            clear(c);\n            // Return the first modified index.\n            return i;\n        }\n        // Join case #4: merge with previous sibling leaf\n        if (isLeaf && !hasExtra && !hasNext) {\n            // Cast the children as leaves.\n            var c = child;\n            var s = sibling;\n            // Merge items.\n            (_b = s.items).push.apply(_b, c.items);\n            // Remove the old branch child.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.children, i);\n            // Remove the stale branch item.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.items, i);\n            // Patch up the sibling links.\n            if (c.next)\n                c.next.prev = s;\n            s.next = c.next;\n            // Clear the original child.\n            clear(c);\n            // Return the first modified index.\n            return i - 1;\n        }\n        // Join case #5: steal from next sibling branch\n        if (!isLeaf && hasExtra && hasNext) {\n            // Cast the children to branches.\n            var c = child;\n            var s = sibling;\n            // Steal a child from the next sibling.\n            c.children.push(s.children.shift());\n            // Steal an item from the next sibling.\n            c.items.push(s.items.shift());\n            // Update the branch items.\n            node.items[i + 1] = s.items[0];\n            // Update the sibling sizes.\n            updateSizes(c, c.width - 1);\n            updateSizes(s, 0);\n            // Return the first modified index.\n            return i;\n        }\n        // Join case #6: steal from previous sibling branch\n        if (!isLeaf && hasExtra && !hasNext) {\n            // Cast the children to branches.\n            var c = child;\n            var s = sibling;\n            // Steal a child from the previous sibling.\n            c.children.unshift(s.children.pop());\n            // Steal an item from the previous sibling.\n            c.items.unshift(s.items.pop());\n            // Update the branch items.\n            node.items[i] = c.items[0];\n            // Update the sibling sizes.\n            updateSizes(c, 0);\n            updateSizes(s, s.width - 1);\n            // Return the first modified index.\n            return i - 1;\n        }\n        // Join case #7: merge with next sibling branch\n        if (!isLeaf && !hasExtra && hasNext) {\n            // Cast the children to branches.\n            var c = child;\n            var s = sibling;\n            // Merge the children with the next sibling.\n            (_c = s.children).unshift.apply(_c, c.children);\n            // Merge the items with the next sibling.\n            (_d = s.items).unshift.apply(_d, c.items);\n            // Remove the old branch child.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.children, i);\n            // Remove the stale branch item.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.items, i + 1);\n            // Update the sibling sizes.\n            updateSizes(s, 0);\n            // Clear the original child but, not its children.\n            c.children.length = 0;\n            clear(c);\n            // Return the first modified index.\n            return i;\n        }\n        // Join case #8: merge with previous sibling branch\n        if (!isLeaf && !hasExtra && !hasNext) {\n            // Cast the children to branches.\n            var c = child;\n            var s = sibling;\n            // Merge the children with the previous sibling.\n            (_e = s.children).push.apply(_e, c.children);\n            // Merge the items with the previous sibling.\n            (_f = s.items).push.apply(_f, c.items);\n            // Remove the old branch child.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.children, i);\n            // Remove the stale branch item.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(node.items, i);\n            // Update the sibling sizes.\n            updateSizes(s, 0);\n            // Clear the original child, but not its children.\n            c.children.length = 0;\n            clear(c);\n            // Return the first modified index.\n            return i - 1;\n        }\n        // One of the above cases must match.\n        throw \'unreachable\';\n    }\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A generic doubly-linked list.\n */\nvar LinkedList = /** @class */ (function () {\n    /**\n     * Construct a new linked list.\n     */\n    function LinkedList() {\n        this._first = null;\n        this._last = null;\n        this._size = 0;\n    }\n    Object.defineProperty(LinkedList.prototype, "isEmpty", {\n        /**\n         * Whether the list is empty.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._size === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedList.prototype, "size", {\n        /**\n         * The size of the list.\n         *\n         * #### Complexity\n         * `O(1)`\n         *\n         * #### Notes\n         * This is equivalent to `length`.\n         */\n        get: function () {\n            return this._size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedList.prototype, "length", {\n        /**\n         * The length of the list.\n         *\n         * #### Complexity\n         * Constant.\n         *\n         * #### Notes\n         * This is equivalent to `size`.\n         *\n         * This property is deprecated.\n         */\n        get: function () {\n            return this._size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedList.prototype, "first", {\n        /**\n         * The first value in the list.\n         *\n         * This is `undefined` if the list is empty.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._first ? this._first.value : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedList.prototype, "last", {\n        /**\n         * The last value in the list.\n         *\n         * This is `undefined` if the list is empty.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._last ? this._last.value : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedList.prototype, "firstNode", {\n        /**\n         * The first node in the list.\n         *\n         * This is `null` if the list is empty.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._first;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedList.prototype, "lastNode", {\n        /**\n         * The last node in the list.\n         *\n         * This is `null` if the list is empty.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._last;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over the values in the list.\n     *\n     * @returns A new iterator starting with the first value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.iter = function () {\n        return new LinkedList.ForwardValueIterator(this._first);\n    };\n    /**\n     * Create a reverse iterator over the values in the list.\n     *\n     * @returns A new iterator starting with the last value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.retro = function () {\n        return new LinkedList.RetroValueIterator(this._last);\n    };\n    /**\n     * Create an iterator over the nodes in the list.\n     *\n     * @returns A new iterator starting with the first node.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.nodes = function () {\n        return new LinkedList.ForwardNodeIterator(this._first);\n    };\n    /**\n     * Create a reverse iterator over the nodes in the list.\n     *\n     * @returns A new iterator starting with the last node.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.retroNodes = function () {\n        return new LinkedList.RetroNodeIterator(this._last);\n    };\n    /**\n     * Assign new values to the list, replacing all current values.\n     *\n     * @param values - The values to assign to the list.\n     *\n     * #### Complexity\n     * Linear.\n     */\n    LinkedList.prototype.assign = function (values) {\n        var _this = this;\n        this.clear();\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(values, function (value) { _this.addLast(value); });\n    };\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `addLast`.\n     */\n    LinkedList.prototype.push = function (value) {\n        this.addLast(value);\n    };\n    /**\n     * Remove and return the value at the end of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `removeLast`.\n     */\n    LinkedList.prototype.pop = function () {\n        return this.removeLast();\n    };\n    /**\n     * Add a value to the beginning of the list.\n     *\n     * @param value - The value to add to the beginning of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `addFirst`.\n     */\n    LinkedList.prototype.shift = function (value) {\n        this.addFirst(value);\n    };\n    /**\n     * Remove and return the value at the beginning of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `removeFirst`.\n     */\n    LinkedList.prototype.unshift = function () {\n        return this.removeFirst();\n    };\n    /**\n     * Add a value to the beginning of the list.\n     *\n     * @param value - The value to add to the beginning of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.addFirst = function (value) {\n        var node = new Private$1.LinkedListNode(this, value);\n        if (!this._first) {\n            this._first = node;\n            this._last = node;\n        }\n        else {\n            node.next = this._first;\n            this._first.prev = node;\n            this._first = node;\n        }\n        this._size++;\n        return node;\n    };\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.addLast = function (value) {\n        var node = new Private$1.LinkedListNode(this, value);\n        if (!this._last) {\n            this._first = node;\n            this._last = node;\n        }\n        else {\n            node.prev = this._last;\n            this._last.next = node;\n            this._last = node;\n        }\n        this._size++;\n        return node;\n    };\n    /**\n     * Insert a value before a specific node in the list.\n     *\n     * @param value - The value to insert before the reference node.\n     *\n     * @param ref - The reference node of interest. If this is `null`,\n     *   the value will be added to the beginning of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Notes\n     * The reference node must be owned by the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.insertBefore = function (value, ref) {\n        if (!ref || ref === this._first) {\n            return this.addFirst(value);\n        }\n        if (!(ref instanceof Private$1.LinkedListNode) || ref.list !== this) {\n            throw new Error(\'Reference node is not owned by the list.\');\n        }\n        var node = new Private$1.LinkedListNode(this, value);\n        var _ref = ref;\n        var prev = _ref.prev;\n        node.next = _ref;\n        node.prev = prev;\n        _ref.prev = node;\n        prev.next = node;\n        this._size++;\n        return node;\n    };\n    /**\n     * Insert a value after a specific node in the list.\n     *\n     * @param value - The value to insert after the reference node.\n     *\n     * @param ref - The reference node of interest. If this is `null`,\n     *   the value will be added to the end of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Notes\n     * The reference node must be owned by the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.insertAfter = function (value, ref) {\n        if (!ref || ref === this._last) {\n            return this.addLast(value);\n        }\n        if (!(ref instanceof Private$1.LinkedListNode) || ref.list !== this) {\n            throw new Error(\'Reference node is not owned by the list.\');\n        }\n        var node = new Private$1.LinkedListNode(this, value);\n        var _ref = ref;\n        var next = _ref.next;\n        node.next = next;\n        node.prev = _ref;\n        _ref.next = node;\n        next.prev = node;\n        this._size++;\n        return node;\n    };\n    /**\n     * Remove and return the value at the beginning of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.removeFirst = function () {\n        var node = this._first;\n        if (!node) {\n            return undefined;\n        }\n        if (node === this._last) {\n            this._first = null;\n            this._last = null;\n        }\n        else {\n            this._first = node.next;\n            this._first.prev = null;\n        }\n        node.list = null;\n        node.next = null;\n        node.prev = null;\n        this._size--;\n        return node.value;\n    };\n    /**\n     * Remove and return the value at the end of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    LinkedList.prototype.removeLast = function () {\n        var node = this._last;\n        if (!node) {\n            return undefined;\n        }\n        if (node === this._first) {\n            this._first = null;\n            this._last = null;\n        }\n        else {\n            this._last = node.prev;\n            this._last.next = null;\n        }\n        node.list = null;\n        node.next = null;\n        node.prev = null;\n        this._size--;\n        return node.value;\n    };\n    /**\n     * Remove a specific node from the list.\n     *\n     * @param node - The node to remove from the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * The node must be owned by the list.\n     */\n    LinkedList.prototype.removeNode = function (node) {\n        if (!(node instanceof Private$1.LinkedListNode) || node.list !== this) {\n            throw new Error(\'Node is not owned by the list.\');\n        }\n        var _node = node;\n        if (_node === this._first && _node === this._last) {\n            this._first = null;\n            this._last = null;\n        }\n        else if (_node === this._first) {\n            this._first = _node.next;\n            this._first.prev = null;\n        }\n        else if (_node === this._last) {\n            this._last = _node.prev;\n            this._last.next = null;\n        }\n        else {\n            _node.next.prev = _node.prev;\n            _node.prev.next = _node.next;\n        }\n        _node.list = null;\n        _node.next = null;\n        _node.prev = null;\n        this._size--;\n    };\n    /**\n     * Remove all values from the list.\n     *\n     * #### Complexity\n     * Linear.\n     */\n    LinkedList.prototype.clear = function () {\n        var node = this._first;\n        while (node) {\n            var next = node.next;\n            node.list = null;\n            node.prev = null;\n            node.next = null;\n            node = next;\n        }\n        this._first = null;\n        this._last = null;\n        this._size = 0;\n    };\n    return LinkedList;\n}());\n/**\n * The namespace for the `LinkedList` class statics.\n */\n(function (LinkedList) {\n    /**\n     * Create a linked list from an iterable of values.\n     *\n     * @param values - The iterable or array-like object of interest.\n     *\n     * @returns A new linked list initialized with the given values.\n     *\n     * #### Complexity\n     * Linear.\n     */\n    function from(values) {\n        var list = new LinkedList();\n        list.assign(values);\n        return list;\n    }\n    LinkedList.from = from;\n    /**\n     * A forward iterator for values in a linked list.\n     */\n    var ForwardValueIterator = /** @class */ (function () {\n        /**\n         * Construct a forward value iterator.\n         *\n         * @param node - The first node in the list.\n         */\n        function ForwardValueIterator(node) {\n            this._node = node;\n        }\n        /**\n         * Get an iterator over the object\'s values.\n         *\n         * @returns An iterator which yields the object\'s values.\n         */\n        ForwardValueIterator.prototype.iter = function () {\n            return this;\n        };\n        /**\n         * Create an independent clone of the iterator.\n         *\n         * @returns A new independent clone of the iterator.\n         */\n        ForwardValueIterator.prototype.clone = function () {\n            return new ForwardValueIterator(this._node);\n        };\n        /**\n         * Get the next value from the iterator.\n         *\n         * @returns The next value from the iterator, or `undefined`.\n         */\n        ForwardValueIterator.prototype.next = function () {\n            if (!this._node) {\n                return undefined;\n            }\n            var node = this._node;\n            this._node = node.next;\n            return node.value;\n        };\n        return ForwardValueIterator;\n    }());\n    LinkedList.ForwardValueIterator = ForwardValueIterator;\n    /**\n     * A reverse iterator for values in a linked list.\n     */\n    var RetroValueIterator = /** @class */ (function () {\n        /**\n         * Construct a retro value iterator.\n         *\n         * @param node - The last node in the list.\n         */\n        function RetroValueIterator(node) {\n            this._node = node;\n        }\n        /**\n         * Get an iterator over the object\'s values.\n         *\n         * @returns An iterator which yields the object\'s values.\n         */\n        RetroValueIterator.prototype.iter = function () {\n            return this;\n        };\n        /**\n         * Create an independent clone of the iterator.\n         *\n         * @returns A new independent clone of the iterator.\n         */\n        RetroValueIterator.prototype.clone = function () {\n            return new RetroValueIterator(this._node);\n        };\n        /**\n         * Get the next value from the iterator.\n         *\n         * @returns The next value from the iterator, or `undefined`.\n         */\n        RetroValueIterator.prototype.next = function () {\n            if (!this._node) {\n                return undefined;\n            }\n            var node = this._node;\n            this._node = node.prev;\n            return node.value;\n        };\n        return RetroValueIterator;\n    }());\n    LinkedList.RetroValueIterator = RetroValueIterator;\n    /**\n     * A forward iterator for nodes in a linked list.\n     */\n    var ForwardNodeIterator = /** @class */ (function () {\n        /**\n         * Construct a forward node iterator.\n         *\n         * @param node - The first node in the list.\n         */\n        function ForwardNodeIterator(node) {\n            this._node = node;\n        }\n        /**\n         * Get an iterator over the object\'s values.\n         *\n         * @returns An iterator which yields the object\'s values.\n         */\n        ForwardNodeIterator.prototype.iter = function () {\n            return this;\n        };\n        /**\n         * Create an independent clone of the iterator.\n         *\n         * @returns A new independent clone of the iterator.\n         */\n        ForwardNodeIterator.prototype.clone = function () {\n            return new ForwardNodeIterator(this._node);\n        };\n        /**\n         * Get the next value from the iterator.\n         *\n         * @returns The next value from the iterator, or `undefined`.\n         */\n        ForwardNodeIterator.prototype.next = function () {\n            if (!this._node) {\n                return undefined;\n            }\n            var node = this._node;\n            this._node = node.next;\n            return node;\n        };\n        return ForwardNodeIterator;\n    }());\n    LinkedList.ForwardNodeIterator = ForwardNodeIterator;\n    /**\n     * A reverse iterator for nodes in a linked list.\n     */\n    var RetroNodeIterator = /** @class */ (function () {\n        /**\n         * Construct a retro node iterator.\n         *\n         * @param node - The last node in the list.\n         */\n        function RetroNodeIterator(node) {\n            this._node = node;\n        }\n        /**\n         * Get an iterator over the object\'s values.\n         *\n         * @returns An iterator which yields the object\'s values.\n         */\n        RetroNodeIterator.prototype.iter = function () {\n            return this;\n        };\n        /**\n         * Create an independent clone of the iterator.\n         *\n         * @returns A new independent clone of the iterator.\n         */\n        RetroNodeIterator.prototype.clone = function () {\n            return new RetroNodeIterator(this._node);\n        };\n        /**\n         * Get the next value from the iterator.\n         *\n         * @returns The next value from the iterator, or `undefined`.\n         */\n        RetroNodeIterator.prototype.next = function () {\n            if (!this._node) {\n                return undefined;\n            }\n            var node = this._node;\n            this._node = node.prev;\n            return node;\n        };\n        return RetroNodeIterator;\n    }());\n    LinkedList.RetroNodeIterator = RetroNodeIterator;\n})(LinkedList || (LinkedList = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$1;\n(function (Private) {\n    /**\n     * The internal linked list node implementation.\n     */\n    var LinkedListNode = /** @class */ (function () {\n        /**\n         * Construct a new linked list node.\n         *\n         * @param list - The list which owns the node.\n         *\n         * @param value - The value for the link.\n         */\n        function LinkedListNode(list, value) {\n            /**\n             * The linked list which created and owns the node.\n             */\n            this.list = null;\n            /**\n             * The next node in the list.\n             */\n            this.next = null;\n            /**\n             * The previous node in the list.\n             */\n            this.prev = null;\n            this.list = list;\n            this.value = value;\n        }\n        return LinkedListNode;\n    }());\n    Private.LinkedListNode = LinkedListNode;\n})(Private$1 || (Private$1 = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9jb2xsZWN0aW9ucy9kaXN0L2luZGV4LmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUksMEJBQTBCLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFlO0FBQzNCLFlBQVksOERBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWlCO0FBQzdCO0FBQ0EsWUFBWSxnRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWlCO0FBQzdCO0FBQ0EsWUFBWSxnRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWlCO0FBQzdCO0FBQ0EsWUFBWSxnRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBaUI7QUFDN0I7QUFDQSxZQUFZLGdFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUksNEJBQTRCLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsOEJBQThCOztBQUVFO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vY29sbGVjdGlvbnMvZGlzdC9pbmRleC5lczYuanM/M2Y1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlYWNoLCBlbXB0eSwgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBBIGdlbmVyaWMgQisgdHJlZS5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBNb3N0IG9wZXJhdGlvbnMgaGF2ZSBgTyhsb2czMiBuKWAgb3IgYmV0dGVyIGNvbXBsZXhpdHkuXG4gKi9cbnZhciBCUGx1c1RyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IEIrIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY21wIC0gVGhlIGl0ZW0gY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQlBsdXNUcmVlKGNtcCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbmV3IFByaXZhdGUuTGVhZk5vZGUoKTtcbiAgICAgICAgdGhpcy5jbXAgPSBjbXA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCUGx1c1RyZWUucHJvdG90eXBlLCBcImlzRW1wdHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdHJlZSBpcyBlbXB0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICAgICAqIGBPKDEpYFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5zaXplID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQlBsdXNUcmVlLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgICAgICogYE8oMSlgXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290LnNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCUGx1c1RyZWUucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaXJzdCBpdGVtIGluIHRoZSB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGB1bmRlZmluZWRgIGlmIHRoZSB0cmVlIGlzIGVtcHR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgICAgICogYE8obG9nMzIgbilgXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gUHJpdmF0ZS5maXJzdExlYWYodGhpcy5fcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zaXplID4gMCA/IG5vZGUuaXRlbXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCUGx1c1RyZWUucHJvdG90eXBlLCBcImxhc3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhc3QgaXRlbSBpbiB0aGUgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBgdW5kZWZpbmVkYCBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IFByaXZhdGUubGFzdExlYWYodGhpcy5fcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zaXplID4gMCA/IG5vZGUuaXRlbXNbbm9kZS5zaXplIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpdGVyYXRvciBvdmVyIHRoZSBpdGVtcyBpbiB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IGl0ZW0uXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKi9cbiAgICBCUGx1c1RyZWUucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlLml0ZXJJdGVtcyh0aGlzLl9yb290KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgaXRlbXMgaW4gdGhlIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBzdGFydGluZyB3aXRoIHRoZSBsYXN0IGl0ZW0uXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKi9cbiAgICBCUGx1c1RyZWUucHJvdG90eXBlLnJldHJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5yZXRyb0l0ZW1zKHRoaXMuX3Jvb3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciBhIHNsaWNlIG9mIGl0ZW1zIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLCBpbmNsdXNpdmUuIFRoaXNcbiAgICAgKiAgIHNob3VsZCBiZSBgPCBzdG9wYC4gTmVnYXRpdmUgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXRcbiAgICAgKiAgIGZyb20gdGhlIGVuZCBvZiB0aGUgdHJlZS4gVGhlIGRlZmF1bHQgaXMgYDBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSwgZXhjbHVzaXZlLiBUaGlzXG4gICAgICogICBzaG91bGQgYmUgYD4gc3RhcnRgLiBOZWdhdGl2ZSB2YWx1ZXMgYXJlIHRha2VuIGFzIGFuIG9mZnNldFxuICAgICAqICAgZnJvbSB0aGUgZW5kIG9mIHRoZSB0cmVlLiBUaGUgZGVmYXVsdCBpcyBgc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBzdGFydGluZyB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIEJQbHVzVHJlZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIFByaXZhdGUuc2xpY2VJdGVtcyh0aGlzLl9yb290LCBzdGFydCwgc3RvcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZXZlcnNlIGl0ZXJhdG9yIGZvciBhIHNsaWNlIG9mIGl0ZW1zIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLCBpbmNsdXNpdmUuIFRoaXNcbiAgICAgKiAgIHNob3VsZCBiZSBgPiBzdG9wYC4gTmVnYXRpdmUgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXRcbiAgICAgKiAgIGZyb20gdGhlIGVuZCBvZiB0aGUgdHJlZS4gVGhlIGRlZmF1bHQgaXMgYHNpemUgLSAxYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9wIC0gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0sIGV4Y2x1c2l2ZS4gVGhpc1xuICAgICAqICAgc2hvdWxkIGJlIGA8IHN0YXJ0YC4gTmVnYXRpdmUgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXRcbiAgICAgKiAgIGZyb20gdGhlIGVuZCBvZiB0aGUgdHJlZS4gVGhlIGRlZmF1bHQgaXMgYC1zaXplIC0gMWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyByZXZlcnNlIGl0ZXJhdG9yIHN0YXJ0aW5nIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogYE8obG9nMzIgbilgXG4gICAgICovXG4gICAgQlBsdXNUcmVlLnByb3RvdHlwZS5yZXRyb1NsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlLnJldHJvU2xpY2VJdGVtcyh0aGlzLl9yb290LCBzdGFydCwgc3RvcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGl0ZW0gYXQgYSBwYXJ0aWN1bGFyIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIG9mIGludGVyZXN0LiBOZWdhdGl2ZVxuICAgICAqICAgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleCwgb3IgYHVuZGVmaW5lZGAgaWZcbiAgICAgKiAgIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKi9cbiAgICBCUGx1c1RyZWUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlLml0ZW1BdCh0aGlzLl9yb290LCBpbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIHRyZWUgaGFzIGFuIGl0ZW0gd2hpY2ggbWF0Y2hlcyBhIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNtcCAtIEEgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgYW4gaXRlbSBhZ2FpbnN0IHRoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRyZWUgaGFzIGFuIGl0ZW0gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAgICAgKiAgIGtleSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKi9cbiAgICBCUGx1c1RyZWUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXksIGNtcCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5oYXNJdGVtKHRoaXMuX3Jvb3QsIGtleSwgY21wKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgYW4gaXRlbSB3aGljaCBtYXRjaGVzIGEga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY21wIC0gQSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyBhbiBpdGVtIGFnYWluc3QgdGhlIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgaXRlbSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBrZXkuIEFcbiAgICAgKiAgIG5lZ2F0aXZlIHZhbHVlIG1lYW5zIHRoYXQgYSBtYXRjaGluZyBpdGVtIGRvZXMgbm90IGV4aXN0IGluXG4gICAgICogICB0aGUgdHJlZSwgYnV0IGlmIG9uZSBkaWQgaXQgd291bGQgcmVzaWRlIGF0IGAtaW5kZXggLSAxYC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIEJQbHVzVHJlZS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChrZXksIGNtcCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5pbmRleE9mKHRoaXMuX3Jvb3QsIGtleSwgY21wKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXRlbSB3aGljaCBtYXRjaGVzIGEga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW0gLSBUaGUga2V5IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNtcCAtIEEgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgYW4gaXRlbSBhZ2FpbnN0IHRoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBrZXksIG9yIGB1bmRlZmluZWRgIGlmXG4gICAgICogICB0aGUgdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcgaXRlbS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIEJQbHVzVHJlZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgY21wKSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlLmdldEl0ZW0odGhpcy5fcm9vdCwga2V5LCBjbXApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXNzaWduIG5ldyBpdGVtcyB0byB0aGUgdHJlZSwgcmVwbGFjaW5nIGFsbCBjdXJyZW50IGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIGl0ZW1zIHRvIGFzc2lnbiB0byB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKG4gbG9nMzIgbilgXG4gICAgICovXG4gICAgQlBsdXNUcmVlLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZShpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYW4gaXRlbSBpbnRvIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIHRoZSBnaXZlbiBpdGVtIG1hdGNoZXMgYW4gZXhpc3RpbmcgaXRlbSBpbiB0aGUgdHJlZSxcbiAgICAgKiAgIHRoZSBnaXZlbiBpdGVtIHdpbGwgcmVwbGFjZSBpdCwgYW5kIHRoZSBleGlzdGluZyBpdGVtIHdpbGwgYmVcbiAgICAgKiAgIHJldHVybmVkLiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKi9cbiAgICBCUGx1c1RyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IFByaXZhdGUuaW5zZXJ0SXRlbSh0aGlzLl9yb290LCBpdGVtLCB0aGlzLmNtcCk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBQcml2YXRlLm1heWJlU3BsaXRSb290KHRoaXMuX3Jvb3QpO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHRyZWUgd2l0aCBtdWx0aXBsZSBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyAtIFRoZSBpdGVtcyB0byBpbnNlcnQgaW50byB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGsgbG9nMzIgbilgXG4gICAgICovXG4gICAgQlBsdXNUcmVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHsgX3RoaXMuaW5zZXJ0KGl0ZW0pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBpdGVtIHdoaWNoIG1hdGNoZXMgYSBwYXJ0aWN1bGFyIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNtcCAtIEEgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgYW4gaXRlbSBhZ2FpbnN0IHRoZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSByZW1vdmVkIGZyb20gdGhlIHRyZWUsIG9yIGB1bmRlZmluZWRgIGlmIG5vXG4gICAgICogICBpdGVtIG1hdGNoZWQgdGhlIGdpdmVuIGtleS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIEJQbHVzVHJlZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSwgY21wKSB7XG4gICAgICAgIHZhciBpdGVtID0gUHJpdmF0ZS5kZWxldGVJdGVtKHRoaXMuX3Jvb3QsIGtleSwgY21wKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IFByaXZhdGUubWF5YmVFeHRyYWN0Um9vdCh0aGlzLl9yb290KTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gaXRlbSBhdCBhIHBhcnRpY3VsYXIgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLiBOZWdhdGl2ZVxuICAgICAqICAgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLCBvciBgdW5kZWZpbmVkYCBpZlxuICAgICAqICAgdGhlIGdpdmVuIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIEJQbHVzVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpdGVtID0gUHJpdmF0ZS5yZW1vdmVJdGVtKHRoaXMuX3Jvb3QsIGluZGV4KTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IFByaXZhdGUubWF5YmVFeHRyYWN0Um9vdCh0aGlzLl9yb290KTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY29udGVudHMgb2YgdGhlIHRyZWUuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhuKWBcbiAgICAgKi9cbiAgICBCUGx1c1RyZWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBQcml2YXRlLmNsZWFyKHRoaXMuX3Jvb3QpO1xuICAgICAgICB0aGlzLl9yb290ID0gbmV3IFByaXZhdGUuTGVhZk5vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBCUGx1c1RyZWU7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYEJQbHVzVHJlZWAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChCUGx1c1RyZWUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQisgdHJlZSBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gYWRkIHRvIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNtcCAtIFRoZSBpdGVtIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgQisgdHJlZSBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gaXRlbXMuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhuIGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb20oaXRlbXMsIGNtcCkge1xuICAgICAgICB2YXIgdHJlZSA9IG5ldyBCUGx1c1RyZWUoY21wKTtcbiAgICAgICAgdHJlZS5hc3NpZ24oaXRlbXMpO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgQlBsdXNUcmVlLmZyb20gPSBmcm9tO1xufSkoQlBsdXNUcmVlIHx8IChCUGx1c1RyZWUgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQSBicmFuY2ggbm9kZSBpbiBhIEIrIHRyZWUuXG4gICAgICovXG4gICAgdmFyIEJyYW5jaE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJyYW5jaE5vZGUoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBsZWZ0LW1vc3QgaXRlbSBvZiBlYWNoIGNoaWxkIHN1YnRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGN1bXVsYXRpdmUgc2l6ZXMgb2YgZWFjaCBjaGlsZCBzdWJ0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNpemVzID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIGJyYW5jaCBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyYW5jaE5vZGUucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGlzY3JpbWluYXRlZCB0eXBlIG9mIHRoZSBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBCcmFuY2ggKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyYW5jaE5vZGUucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdWJ0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplc1t0aGlzLnNpemVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcmFuY2hOb2RlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB0cmVlIHdpZHRoIG9mIHRoZSBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEJyYW5jaE5vZGU7XG4gICAgfSgpKTtcbiAgICBQcml2YXRlLkJyYW5jaE5vZGUgPSBCcmFuY2hOb2RlO1xuICAgIC8qKlxuICAgICAqIEEgbGVhZiBub2RlIGluIGEgQisgdHJlZS5cbiAgICAgKi9cbiAgICB2YXIgTGVhZk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExlYWZOb2RlKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbmV4dCBzaWJsaW5nIGxlYWYgbm9kZSBvZiB0aGlzIGxlYWYgbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHByZXZpb3VzIHNpYmxpbmcgbGVhZiBub2RlIG9mIHRoaXMgbGVhZiBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaXRlbXMgb2YgdGhlIGxlYWYuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVhZk5vZGUucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGlzY3JpbWluYXRlZCB0eXBlIG9mIHRoZSBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBMZWFmICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZWFmTm9kZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxlYWYuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVhZk5vZGUucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHRyZWUgd2lkdGggb2YgdGhlIG5vZGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTGVhZk5vZGU7XG4gICAgfSgpKTtcbiAgICBQcml2YXRlLkxlYWZOb2RlID0gTGVhZk5vZGU7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCBsZWFmIG5vZGUgaW4gdGhlIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSByb290IG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgbGVhZiBub2RlIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogYE8obG9nMzIgbilgXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3RMZWFmKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUudHlwZSA9PT0gMCAvKiBCcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBQcml2YXRlLmZpcnN0TGVhZiA9IGZpcnN0TGVhZjtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhc3QgbGVhZiBub2RlIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgcm9vdCBub2RlIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxhc3QgbGVhZiBub2RlIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogYE8obG9nMzIgbilgXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdExlYWYobm9kZSkge1xuICAgICAgICB3aGlsZSAobm9kZS50eXBlID09PSAwIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgUHJpdmF0ZS5sYXN0TGVhZiA9IGxhc3RMZWFmO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZvcndhcmQgaXRlcmF0b3IgZm9yIHRoZSBpdGVtcyBpbiB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIHJvb3Qgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGZvcndhcmQgaXRlcmF0b3Igc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3QgaXRlbS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJJdGVtcyhub2RlKSB7XG4gICAgICAgIHZhciBsZWFmID0gZmlyc3RMZWFmKG5vZGUpO1xuICAgICAgICByZXR1cm4gbmV3IEZvcndhcmRJdGVyYXRvcihsZWFmLCAwLCAtMSk7XG4gICAgfVxuICAgIFByaXZhdGUuaXRlckl0ZW1zID0gaXRlckl0ZW1zO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJldmVyc2UgaXRlcmF0b3IgZm9yIHRoZSBpdGVtcyBpbiB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIHJvb3Qgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IHJldmVyc2UgaXRlcmF0b3Igc3RhcnRpbmcgd2l0aCB0aGUgbGFzdCBpdGVtLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogYE8obG9nMzIgbilgXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cm9JdGVtcyhub2RlKSB7XG4gICAgICAgIHZhciBsZWFmID0gbGFzdExlYWYobm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmV0cm9JdGVyYXRvcihsZWFmLCBsZWFmLnNpemUgLSAxLCAtMSk7XG4gICAgfVxuICAgIFByaXZhdGUucmV0cm9JdGVtcyA9IHJldHJvSXRlbXM7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciBhIHNsaWNlIG9mIGl0ZW1zIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgcm9vdCBub2RlIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLCBpbmNsdXNpdmUuIFRoaXNcbiAgICAgKiAgIHNob3VsZCBiZSBgPCBzdG9wYC4gTmVnYXRpdmUgdmFsdWVzIGFyZSB0YWtlbiBhcyBhbiBvZmZzZXRcbiAgICAgKiAgIGZyb20gdGhlIGVuZCBvZiB0aGUgdHJlZS4gVGhlIGRlZmF1bHQgaXMgYDBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3AgLSBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSwgZXhjbHVzaXZlLiBUaGlzXG4gICAgICogICBzaG91bGQgYmUgYD4gc3RhcnRgLiBOZWdhdGl2ZSB2YWx1ZXMgYXJlIHRha2VuIGFzIGFuIG9mZnNldFxuICAgICAqICAgZnJvbSB0aGUgZW5kIG9mIHRoZSB0cmVlLiBUaGUgZGVmYXVsdCBpcyBgc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBzdGFydGluZyB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlSXRlbXMobm9kZSwgc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgKyBub2RlLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbm9kZS5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHN0b3AgaW5kZXguXG4gICAgICAgIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0b3AgPSBub2RlLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcCA8IDApIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1heCgwLCBzdG9wICsgbm9kZS5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1pbihzdG9wLCBub2RlLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIGNvdW50LlxuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgwLCBzdG9wIC0gc3RhcnQpO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gaXRlcmF0ZS5cbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBzdGFydGluZyBsZWFmIG5vZGUgYW5kIGxvY2FsIGluZGV4LlxuICAgICAgICB3aGlsZSAobm9kZS50eXBlID09PSAwIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgdmFyIGkgPSBmaW5kUGl2b3RJbmRleEJ5SW5kZXgobm9kZS5zaXplcywgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgICAgIHN0YXJ0IC09IG5vZGUuc2l6ZXNbaSAtIDFdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBmb3J3YXJkIGl0ZXJhdG9yIGZvciB0aGUgcmFuZ2UuXG4gICAgICAgIHJldHVybiBuZXcgRm9yd2FyZEl0ZXJhdG9yKG5vZGUsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIFByaXZhdGUuc2xpY2VJdGVtcyA9IHNsaWNlSXRlbXM7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmV2ZXJzZSBpdGVyYXRvciBmb3IgYSBzbGljZSBvZiBpdGVtcyBpbiB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIHJvb3Qgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSwgaW5jbHVzaXZlLiBUaGlzXG4gICAgICogICBzaG91bGQgYmUgYD4gc3RvcGAuIE5lZ2F0aXZlIHZhbHVlcyBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0XG4gICAgICogICBmcm9tIHRoZSBlbmQgb2YgdGhlIHRyZWUuIFRoZSBkZWZhdWx0IGlzIGBzaXplIC0gMWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcCAtIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBpdGVtLCBleGNsdXNpdmUuIFRoaXNcbiAgICAgKiAgIHNob3VsZCBiZSBgPCBzdGFydGAuIE5lZ2F0aXZlIHZhbHVlcyBhcmUgdGFrZW4gYXMgYW4gb2Zmc2V0XG4gICAgICogICBmcm9tIHRoZSBlbmQgb2YgdGhlIHRyZWUuIFRoZSBkZWZhdWx0IGlzIGAtc2l6ZSAtIDFgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgcmV2ZXJzZSBpdGVyYXRvciBzdGFydGluZyB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJvU2xpY2VJdGVtcyhub2RlLCBzdGFydCwgc3RvcCkge1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBub2RlLnNpemUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgtMSwgc3RhcnQgKyBub2RlLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbm9kZS5zaXplIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzdG9wIGluZGV4LlxuICAgICAgICBpZiAoc3RvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdG9wID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcCA8IDApIHtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLm1heCgtMSwgc3RvcCArIG5vZGUuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG9wID0gTWF0aC5taW4oc3RvcCwgbm9kZS5zaXplIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIGNvdW50LlxuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgwLCBzdGFydCAtIHN0b3ApO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gaXRlcmF0ZS5cbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBzdGFydGluZyBsZWFmIG5vZGUgYW5kIGxvY2FsIGluZGV4LlxuICAgICAgICB3aGlsZSAobm9kZS50eXBlID09PSAwIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgdmFyIGkgPSBmaW5kUGl2b3RJbmRleEJ5SW5kZXgobm9kZS5zaXplcywgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgICAgIHN0YXJ0IC09IG5vZGUuc2l6ZXNbaSAtIDFdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXRybyBpdGVyYXRvciBmb3IgdGhlIHJhbmdlLlxuICAgICAgICByZXR1cm4gbmV3IFJldHJvSXRlcmF0b3Iobm9kZSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgUHJpdmF0ZS5yZXRyb1NsaWNlSXRlbXMgPSByZXRyb1NsaWNlSXRlbXM7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSByb290IG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gb2YgaW50ZXJlc3QuIE5lZ2F0aXZlXG4gICAgICogICB2YWx1ZXMgYXJlIHRha2VuIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBvciBgdW5kZWZpbmVkYCBpZlxuICAgICAqICAgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZW1BdChub2RlLCBpbmRleCkge1xuICAgICAgICAvLyBXcmFwIG5lZ2F0aXZlIGluZGljZXMuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IG5vZGUuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gbm9kZS5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGNvbnRhaW5pbmcgbGVhZiBub2RlIGFuZCBsb2NhbCBpbmRleC5cbiAgICAgICAgd2hpbGUgKG5vZGUudHlwZSA9PT0gMCAvKiBCcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIHZhciBpID0gZmluZFBpdm90SW5kZXhCeUluZGV4KG5vZGUuc2l6ZXMsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgICBpbmRleCAtPSBub2RlLnNpemVzW2kgLSAxXTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAgICByZXR1cm4gbm9kZS5pdGVtc1tpbmRleF07XG4gICAgfVxuICAgIFByaXZhdGUuaXRlbUF0ID0gaXRlbUF0O1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGUgdHJlZSBjb250YWlucyBhbiBpdGVtIHdoaWNoIG1hdGNoZXMgYSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSByb290IG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbXAgLSBUaGUga2V5IGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0cmVlIGNvbnRhaW5zIGEgbWF0Y2hpbmcgaXRlbS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0l0ZW0obm9kZSwga2V5LCBjbXApIHtcbiAgICAgICAgLy8gRmluZCB0aGUgY29udGFpbmluZyBsZWFmIG5vZGUuXG4gICAgICAgIHdoaWxlIChub2RlLnR5cGUgPT09IDAgLyogQnJhbmNoICovKSB7XG4gICAgICAgICAgICB2YXIgaV8xID0gZmluZFBpdm90SW5kZXhCeUtleShub2RlLml0ZW1zLCBrZXksIGNtcCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltpXzFdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGtleSBpbmRleC5cbiAgICAgICAgdmFyIGkgPSBmaW5kS2V5SW5kZXgobm9kZS5pdGVtcywga2V5LCBjbXApO1xuICAgICAgICAvLyBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIG5vZGUgY29udGFpbnMgYSBtYXRjaGluZyBpdGVtLlxuICAgICAgICByZXR1cm4gaSA+PSAwO1xuICAgIH1cbiAgICBQcml2YXRlLmhhc0l0ZW0gPSBoYXNJdGVtO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gd2hpY2ggbWF0Y2hlcyBhIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbXAgLSBUaGUga2V5IGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LiBBXG4gICAgICogICBuZWdhdGl2ZSB2YWx1ZSBtZWFucyB0aGF0IGEgbWF0Y2hpbmcgaXRlbSBkb2VzIG5vdCBleGlzdCBpblxuICAgICAqICAgdGhlIHRyZWUsIGJ1dCBpZiBvbmUgZGlkIGl0IHdvdWxkIHJlc2lkZSBhdCBgLWluZGV4IC0gMWAuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKG5vZGUsIGtleSwgY21wKSB7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZ2xvYmFsIGluZGV4LlxuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAvLyBGaW5kIHRoZSBjb250YWluaW5nIGxlYWYgbm9kZSBhbmQgZ2xvYmFsIGluZGV4LlxuICAgICAgICB3aGlsZSAobm9kZS50eXBlID09PSAwIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgdmFyIGlfMiA9IGZpbmRQaXZvdEluZGV4QnlLZXkobm9kZS5pdGVtcywga2V5LCBjbXApO1xuICAgICAgICAgICAgaWYgKGlfMiA+IDApXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gbm9kZS5zaXplc1tpXzIgLSAxXTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2lfMl07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUga2V5IGluZGV4LlxuICAgICAgICB2YXIgaSA9IGZpbmRLZXlJbmRleChub2RlLml0ZW1zLCBrZXksIGNtcCk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZmluYWwgY29tcHV0ZWQgaW5kZXguXG4gICAgICAgIHJldHVybiBpID49IDAgPyBpbmRleCArIGkgOiAtaW5kZXggKyBpO1xuICAgIH1cbiAgICBQcml2YXRlLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXRlbSBmb3IgYSBwYXJ0aWN1bGFyIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbXAgLSBUaGUga2V5IGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBmb3IgdGhlIHNwZWNpZmllZCBrZXksIG9yIGB1bmRlZmluZWRgIGlmXG4gICAgICogICB0aGUgdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcgaXRlbSBmb3IgdGhlIGtleS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIGBPKGxvZzMyIG4pYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZW0obm9kZSwga2V5LCBjbXApIHtcbiAgICAgICAgLy8gRmluZCB0aGUgY29udGFpbmluZyBsZWFmIG5vZGUuXG4gICAgICAgIHdoaWxlIChub2RlLnR5cGUgPT09IDAgLyogQnJhbmNoICovKSB7XG4gICAgICAgICAgICB2YXIgaV8zID0gZmluZFBpdm90SW5kZXhCeUtleShub2RlLml0ZW1zLCBrZXksIGNtcCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltpXzNdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGtleSBpbmRleC5cbiAgICAgICAgdmFyIGkgPSBmaW5kS2V5SW5kZXgobm9kZS5pdGVtcywga2V5LCBjbXApO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGl0ZW0gZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAgICAgIHJldHVybiBpID49IDAgPyBub2RlLml0ZW1zW2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBQcml2YXRlLmdldEl0ZW0gPSBnZXRJdGVtO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhbiBpdGVtIGludG8gdGhlIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSByb290IG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNtcCAtIFRoZSBpdGVtIGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgZ2l2ZW4gaXRlbSBtYXRjaGVzIGFuIGV4aXN0aW5nIGl0ZW0gaW4gdGhlIHRyZWUsXG4gICAgICogICB0aGUgZ2l2ZW4gaXRlbSB3aWxsIHJlcGxhY2UgaXQsIGFuZCB0aGUgZXhpc3RpbmcgaXRlbSB3aWxsIGJlXG4gICAgICogICByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcm9vdCBtYXkgYmUgb3ZlcmZ1bGwgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydEl0ZW0obm9kZSwgaXRlbSwgY21wKSB7XG4gICAgICAgIC8vIEhhbmRsZSBsZWFmIG5vZGVzIGZpcnN0LlxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIExlYWYgKi8pIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IGZvciB0aGUgZ2l2ZW4gaXRlbS5cbiAgICAgICAgICAgIHZhciBpXzQgPSBmaW5kS2V5SW5kZXgobm9kZS5pdGVtcywgaXRlbSwgY21wKTtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBleGlzdGluZyBpdGVtIGFuZCBpbnNlcnQgdGhlIG5ldyBpdGVtLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nXzE7XG4gICAgICAgICAgICBpZiAoaV80ID49IDApIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ18xID0gbm9kZS5pdGVtc1tpXzRdO1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXNbaV80XSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ18xID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIEFycmF5RXh0Lmluc2VydChub2RlLml0ZW1zLCAtaV80IC0gMSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGV4aXN0aW5nIGl0ZW0uXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdfMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBwaXZvdCBpbmRleCBmb3IgdGhlIGluc2VydC5cbiAgICAgICAgdmFyIGkgPSBmaW5kUGl2b3RJbmRleEJ5S2V5KG5vZGUuaXRlbXMsIGl0ZW0sIGNtcCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBwaXZvdCBjaGlsZC5cbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgY2hpbGQuXG4gICAgICAgIHZhciBwcmV2U2l6ZSA9IGNoaWxkLnNpemU7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCB0aGUgaXRlbSBpbnRvIHRoZSBjaGlsZC5cbiAgICAgICAgdmFyIGV4aXN0aW5nID0gaW5zZXJ0SXRlbShjaGlsZCwgaXRlbSwgY21wKTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHVwZGF0ZWQgc2l6ZSBvZiB0aGUgY2hpbGQuXG4gICAgICAgIHZhciBjdXJyU2l6ZSA9IGNoaWxkLnNpemU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaXRlbSBzdGF0ZSBvZiB0aGUgYnJhbmNoLlxuICAgICAgICBub2RlLml0ZW1zW2ldID0gY2hpbGQuaXRlbXNbMF07XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGNoaWxkIHNpemUgZGlkIG5vdCBjaGFuZ2UuXG4gICAgICAgIGlmIChwcmV2U2l6ZSA9PT0gY3VyclNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCB0aGUgY2hpbGQgaWYgaXQncyBvdmVyZnVsbC5cbiAgICAgICAgaWYgKGNoaWxkLndpZHRoID4gTUFYX05PREVfV0lEVEgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gc3BsaXROb2RlKGNoaWxkKTtcbiAgICAgICAgICAgIEFycmF5RXh0Lmluc2VydChub2RlLmNoaWxkcmVuLCBpICsgMSwgbmV4dCk7XG4gICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQobm9kZS5pdGVtcywgaSArIDEsIG5leHQuaXRlbXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGlydHkgc2l6ZXMgb2YgdGhlIGJyYW5jaC5cbiAgICAgICAgdXBkYXRlU2l6ZXMobm9kZSwgaSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZXhpc3RpbmcgaXRlbS5cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICBQcml2YXRlLmluc2VydEl0ZW0gPSBpbnNlcnRJdGVtO1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBpdGVtIGluIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNtcCAtIFRoZSBrZXkgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWxldGVkIGl0ZW0gb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcm9vdCBtYXkgYmUgdW5kZXJmdWxsIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxldGVJdGVtKG5vZGUsIGtleSwgY21wKSB7XG4gICAgICAgIC8vIEhhbmRsZSBsZWFmIG5vZGVzIGZpcnN0LlxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIExlYWYgKi8pIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAgICAgICAgdmFyIGlfNSA9IGZpbmRLZXlJbmRleChub2RlLml0ZW1zLCBrZXksIGNtcCk7XG4gICAgICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBpdGVtIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgaWYgKGlfNSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGF0IHRoZSBjb21wdXRlZCBpbmRleC5cbiAgICAgICAgICAgIHJldHVybiBBcnJheUV4dC5yZW1vdmVBdChub2RlLml0ZW1zLCBpXzUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIHBpdm90IGluZGV4IGZvciB0aGUgZGVsZXRlLlxuICAgICAgICB2YXIgaSA9IGZpbmRQaXZvdEluZGV4QnlLZXkobm9kZS5pdGVtcywga2V5LCBjbXApO1xuICAgICAgICAvLyBGZXRjaCB0aGUgcGl2b3QgY2hpbGQuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIC8vIEZldGNoIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGNoaWxkLlxuICAgICAgICB2YXIgcHJldlNpemUgPSBjaGlsZC5zaXplO1xuICAgICAgICAvLyBSZWN1cnNpdmVseSByZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgY2hpbGQuXG4gICAgICAgIHZhciBpdGVtID0gZGVsZXRlSXRlbShjaGlsZCwga2V5LCBjbXApO1xuICAgICAgICAvLyBGZXRjaCB0aGUgdXBkYXRlZCBzaXplIG9mIHRoZSBjaGlsZC5cbiAgICAgICAgdmFyIGN1cnJTaXplID0gY2hpbGQuc2l6ZTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgY2hpbGQgc2l6ZSBkaWQgbm90IGNoYW5nZS5cbiAgICAgICAgaWYgKHByZXZTaXplID09PSBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpdGVtIHN0YXRlIG9mIHRoZSBicmFuY2guXG4gICAgICAgIG5vZGUuaXRlbXNbaV0gPSBjaGlsZC5pdGVtc1swXTtcbiAgICAgICAgLy8gSm9pbiB0aGUgY2hpbGQgaWYgaXQncyB1bmRlcmZ1bGwuXG4gICAgICAgIGlmIChjaGlsZC53aWR0aCA8IE1JTl9OT0RFX1dJRFRIKSB7XG4gICAgICAgICAgICBpID0gam9pbkNoaWxkKG5vZGUsIGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGlydHkgc2l6ZXMgb2YgdGhlIGJyYW5jaC5cbiAgICAgICAgdXBkYXRlU2l6ZXMobm9kZSwgaSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZGVsZXRlZCBpdGVtLlxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgUHJpdmF0ZS5kZWxldGVJdGVtID0gZGVsZXRlSXRlbTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZW1vdmVkIGl0ZW0gb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhsb2czMiBuKWBcbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcm9vdCBtYXkgYmUgdW5kZXJmdWxsIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVJdGVtKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIC8vIFdyYXAgbmVnYXRpdmUgaW5kaWNlcy5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gbm9kZS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBub2RlLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGxlYWYgbm9kZXMgZmlyc3QuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTGVhZiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5RXh0LnJlbW92ZUF0KG5vZGUuaXRlbXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBwaXZvdCBpbmRleCBmb3IgdGhlIHJlbW92ZS5cbiAgICAgICAgdmFyIGkgPSBmaW5kUGl2b3RJbmRleEJ5SW5kZXgobm9kZS5zaXplcywgaW5kZXgpO1xuICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICBpbmRleCAtPSBub2RlLnNpemVzW2ldO1xuICAgICAgICAvLyBGZXRjaCB0aGUgcGl2b3QgY2hpbGQuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHJlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBjaGlsZC5cbiAgICAgICAgdmFyIGl0ZW0gPSByZW1vdmVJdGVtKGNoaWxkLCBpbmRleCk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaXRlbSBzdGF0ZSBvZiB0aGUgYnJhbmNoLlxuICAgICAgICBub2RlLml0ZW1zW2ldID0gY2hpbGQuaXRlbXNbMF07XG4gICAgICAgIC8vIEpvaW4gdGhlIGNoaWxkIGlmIGl0J3MgdW5kZXJmdWxsLlxuICAgICAgICBpZiAoY2hpbGQud2lkdGggPCBNSU5fTk9ERV9XSURUSCkge1xuICAgICAgICAgICAgaSA9IGpvaW5DaGlsZChub2RlLCBpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGRpcnR5IHNpemVzIG9mIHRoZSBicmFuY2guXG4gICAgICAgIHVwZGF0ZVNpemVzKG5vZGUsIGkpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlbW92ZWQgaXRlbS5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIFByaXZhdGUucmVtb3ZlSXRlbSA9IHJlbW92ZUl0ZW07XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgY2xlYXIgdGhlIGNvbnRlbnRzIG9mIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBgTyhuKWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhcihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDAgLyogQnJhbmNoICovKSB7XG4gICAgICAgICAgICBlYWNoKG5vZGUuY2hpbGRyZW4sIGNsZWFyKTtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIG5vZGUuc2l6ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIG5vZGUuaXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuaXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaXZhdGUuY2xlYXIgPSBjbGVhcjtcbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHJvb3Qgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IHJvb3QsIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIHJvb3Qgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgcm9vdCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heWJlU3BsaXRSb290KG5vZGUpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgY3VycmVudCByb290IGlzIG5vdCBvdmVyZnVsbC5cbiAgICAgICAgaWYgKG5vZGUud2lkdGggPD0gTUFYX05PREVfV0lEVEgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyByb290IGJyYW5jaCBub2RlLlxuICAgICAgICB2YXIgcm9vdCA9IG5ldyBCcmFuY2hOb2RlKCk7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBub2RlIHRvIHRoZSByaWdodCBhbmQgY3JlYXRlIGEgbmV3IHNpYmxpbmcuXG4gICAgICAgIHZhciBuZXh0ID0gc3BsaXROb2RlKG5vZGUpO1xuICAgICAgICAvLyBBZGQgdGhlIHNpemVzIHRvIHRoZSByb290LlxuICAgICAgICByb290LnNpemVzWzBdID0gbm9kZS5zaXplO1xuICAgICAgICByb290LnNpemVzWzFdID0gbm9kZS5zaXplICsgbmV4dC5zaXplO1xuICAgICAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIHRvIHRoZSByb290LlxuICAgICAgICByb290LmNoaWxkcmVuWzBdID0gbm9kZTtcbiAgICAgICAgcm9vdC5jaGlsZHJlblsxXSA9IG5leHQ7XG4gICAgICAgIC8vIEFkZCB0aGUgaXRlbXMgdG8gdGhlIHJvb3QuXG4gICAgICAgIHJvb3QuaXRlbXNbMF0gPSBub2RlLml0ZW1zWzBdO1xuICAgICAgICByb290Lml0ZW1zWzFdID0gbmV4dC5pdGVtc1swXTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgcm9vdCBub2RlLlxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgUHJpdmF0ZS5tYXliZVNwbGl0Um9vdCA9IG1heWJlU3BsaXRSb290O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYSBzaW5nbGUgbm9kZSBjaGlsZCBhcyBhIG5ldyByb290LCBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSByb290IG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHJvb3Qgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXliZUV4dHJhY3RSb290KG5vZGUpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgbm9kZSBpdCBhbHJlYWR5IGEgbGVhZi5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBMZWFmICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBicmFuY2ggaGFzIG1vcmUgdGhhbiBvbmUgY2hpbGQuXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHNvbGUgcmVtYWluaW5nIGNoaWxkIGFzIHRoZSBuZXcgcm9vdC5cbiAgICAgICAgdmFyIHJvb3QgPSBub2RlLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICAvLyBDbGVhciB0aGUgcmVzdCBvZiB0aGUgbm9kZSBzdGF0ZS5cbiAgICAgICAgY2xlYXIobm9kZSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgbmV3IHJvb3QuXG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBQcml2YXRlLm1heWJlRXh0cmFjdFJvb3QgPSBtYXliZUV4dHJhY3RSb290O1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHdpZHRoIGZvciBhIG5vZGUgaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgdmFyIE1BWF9OT0RFX1dJRFRIID0gMzI7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gd2lkdGggZm9yIGEgbm9kZSBpbiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICB2YXIgTUlOX05PREVfV0lEVEggPSBNQVhfTk9ERV9XSURUSCA+PiAxO1xuICAgIC8qKlxuICAgICAqIEEgZm9yd2FyZCBpdGVyYXRvciBmb3IgYSBCKyB0cmVlLlxuICAgICAqL1xuICAgIHZhciBGb3J3YXJkSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgZm9yd2FyZCBpdGVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5vZGUgLSBUaGUgZmlyc3QgbGVhZiBub2RlIGluIHRoZSBjaGFpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGxvY2FsIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGl0ZXJhdGUuIEEgdmFsdWUgYDwgMGBcbiAgICAgICAgICogICB3aWxsIGl0ZXJhdGUgYWxsIGF2YWlsYWJsZSBpdGVtcy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEZvcndhcmRJdGVyYXRvcihub2RlLCBpbmRleCwgY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9yd2FyZEl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBGb3J3YXJkSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3J3YXJkSXRlcmF0b3IodGhpcy5fbm9kZSwgdGhpcy5faW5kZXgsIHRoaXMuX2NvdW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9yd2FyZEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGUgPT09IG51bGwgfHwgdGhpcy5fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX25vZGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUgPSB0aGlzLl9ub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUuaXRlbXNbdGhpcy5faW5kZXgrK107XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3J3YXJkSXRlcmF0b3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIHJldmVyc2UgaXRlcmF0b3IgZm9yIGEgQisgdHJlZS5cbiAgICAgKi9cbiAgICB2YXIgUmV0cm9JdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyByZXRybyBpdGVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbGFzdCBsZWFmIG5vZGUgaW4gdGhlIGNoYWluLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgbG9jYWwgaW5kZXggb2YgdGhlIGxhc3QgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiBpdGVtcyB0byBpdGVyYXRlLiBBIHZhbHVlIGA8IDBgXG4gICAgICAgICAqICAgd2lsbCBpdGVyYXRlIGFsbCBhdmFpbGFibGUgaXRlbXMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZXRyb0l0ZXJhdG9yKG5vZGUsIGluZGV4LCBjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIGl0ZXJhdG9yIG92ZXIgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBSZXRyb0l0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBSZXRyb0l0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmV0cm9JdGVyYXRvcih0aGlzLl9ub2RlLCB0aGlzLl9pbmRleCwgdGhpcy5fY291bnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICAgICAqL1xuICAgICAgICBSZXRyb0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vZGUgPT09IG51bGwgfHwgdGhpcy5fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX25vZGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fbm9kZS5zaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlID0gdGhpcy5fbm9kZS5wcmV2O1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fbm9kZSA/IHRoaXMuX25vZGUuc2l6ZSAtIDEgOiAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlLml0ZW1zW3RoaXMuX2luZGV4LS1dO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmV0cm9JdGVyYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHBpdm90IGluZGV4IGZvciBhIHBhcnRpY3VsYXIgbG9jYWwgaW5kZXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFBpdm90SW5kZXhCeUluZGV4KHNpemVzLCBpbmRleCkge1xuICAgICAgICB2YXIgbiA9IHNpemVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzaXplc1tpXSA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4gLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBwaXZvdCBpbmRleCBmb3IgYSBwYXJ0aWN1bGFyIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kUGl2b3RJbmRleEJ5S2V5KGl0ZW1zLCBrZXksIGNtcCkge1xuICAgICAgICB2YXIgbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjbXAoaXRlbXNbaV0sIGtleSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUga2V5IGluZGV4IGZvciBhIHBhcnRpY3VsYXIga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXlJbmRleChpdGVtcywga2V5LCBjbXApIHtcbiAgICAgICAgdmFyIG4gPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNtcChpdGVtc1tpXSwga2V5KTtcbiAgICAgICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLWkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtbiAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2l6ZXMgb2YgYSBicmFuY2ggbm9kZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l6ZXMobm9kZSwgaSkge1xuICAgICAgICB2YXIgc2l6ZXMgPSBub2RlLnNpemVzLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIHZhciBsYXN0ID0gaSA+IDAgPyBzaXplc1tpIC0gMV0gOiAwO1xuICAgICAgICBmb3IgKHZhciBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBsYXN0ID0gc2l6ZXNbaV0gPSBsYXN0ICsgY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzaXplcy5sZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXcgbmV4dCBzaWJsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgbmV4dCBzaWJsaW5nIG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXROb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gSGFuZGxlIGxlYWYgbm9kZXMgZmlyc3QuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTGVhZiAqLykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgc2libGluZyBsZWFmIG5vZGUuXG4gICAgICAgICAgICB2YXIgbmV4dF8xID0gbmV3IExlYWZOb2RlKCk7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBpdGVtcyB0byB0aGUgbmV3IHNpYmxpbmcuXG4gICAgICAgICAgICB2YXIgdjFfMSA9IG5vZGUuaXRlbXM7XG4gICAgICAgICAgICB2YXIgdjJfMSA9IG5leHRfMS5pdGVtcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBNSU5fTk9ERV9XSURUSCwgbiA9IHYxXzEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdjJfMS5wdXNoKHYxXzFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdjFfMS5sZW5ndGggPSBNSU5fTk9ERV9XSURUSDtcbiAgICAgICAgICAgIC8vIFBhdGNoIHVwIHRoZSBzaWJsaW5nIGxpbmtzLlxuICAgICAgICAgICAgaWYgKG5vZGUubmV4dClcbiAgICAgICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5leHRfMTtcbiAgICAgICAgICAgIG5leHRfMS5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbmV4dF8xLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5uZXh0ID0gbmV4dF8xO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgbmV4dCBzaWJsaW5nLlxuICAgICAgICAgICAgcmV0dXJuIG5leHRfMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBzaWJsaW5nIGJyYW5jaCBub2RlLlxuICAgICAgICB2YXIgbmV4dCA9IG5ldyBCcmFuY2hOb2RlKCk7XG4gICAgICAgIC8vIE1vdmUgdGhlIGNoaWxkcmVuIHRvIHRoZSBuZXcgc2libGluZy5cbiAgICAgICAgdmFyIGMxID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGMyID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IE1JTl9OT0RFX1dJRFRILCBuID0gYzEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjMi5wdXNoKGMxW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjMS5sZW5ndGggPSBNSU5fTk9ERV9XSURUSDtcbiAgICAgICAgLy8gTW92ZSB0aGUgaXRlbXMgdG8gdGhlIG5ldyBzaWJsaW5nLlxuICAgICAgICB2YXIgdjEgPSBub2RlLml0ZW1zO1xuICAgICAgICB2YXIgdjIgPSBuZXh0Lml0ZW1zO1xuICAgICAgICBmb3IgKHZhciBpID0gTUlOX05PREVfV0lEVEgsIG4gPSB2MS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHYyLnB1c2godjFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHYxLmxlbmd0aCA9IE1JTl9OT0RFX1dJRFRIO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGRpcnR5IHNpemVzIG9mIHRoZSBub2Rlcy5cbiAgICAgICAgdXBkYXRlU2l6ZXMobm9kZSwgTUlOX05PREVfV0lEVEgpO1xuICAgICAgICB1cGRhdGVTaXplcyhuZXh0LCAwKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgbmV4dCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiBhIGNoaWxkIG5vZGUgb2YgYSBicmFuY2ggd2l0aCBvbmUgb2YgaXRzIHNpYmxpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgYnJhbmNoIG5vZGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaSAtIFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgbm9kZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBmaXJzdCBtb2RpZmllZCBpbmRleC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1heSBjYXVzZSB0aGUgYnJhbmNoIHRvIGJlY29tZSB1bmRlcmZ1bGwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbkNoaWxkKG5vZGUsIGkpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIEZldGNoIHRoZSBjaGlsZCB0byBiZSBqb2luZWQuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIC8vIEZldGNoIHRoZSByZWxldmFudCBzaWJsaW5nLlxuICAgICAgICB2YXIgc2libGluZyA9IGkgPT09IDAgPyBub2RlLmNoaWxkcmVuW2kgKyAxXSA6IG5vZGUuY2hpbGRyZW5baSAtIDFdO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBmbGFncyB3aGljaCBjb250cm9sIHRoZSBqb2luIGJlaGF2aW9yLlxuICAgICAgICB2YXIgaGFzTmV4dCA9IGkgPT09IDA7XG4gICAgICAgIHZhciBpc0xlYWYgPSBjaGlsZC50eXBlID09PSAxIC8qIExlYWYgKi87XG4gICAgICAgIHZhciBoYXNFeHRyYSA9IHNpYmxpbmcud2lkdGggPiBNSU5fTk9ERV9XSURUSDtcbiAgICAgICAgLy8gSm9pbiBjYXNlICMxOiBzdGVhbCBmcm9tIG5leHQgc2libGluZyBsZWFmXG4gICAgICAgIGlmIChpc0xlYWYgJiYgaGFzRXh0cmEgJiYgaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gYXMgbGVhdmVzLlxuICAgICAgICAgICAgdmFyIGMgPSBjaGlsZDtcbiAgICAgICAgICAgIHZhciBzID0gc2libGluZztcbiAgICAgICAgICAgIC8vIFN0ZWFsIGFuIGl0ZW0uXG4gICAgICAgICAgICBjLml0ZW1zLnB1c2gocy5pdGVtcy5zaGlmdCgpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYnJhbmNoIGl0ZW1zLlxuICAgICAgICAgICAgbm9kZS5pdGVtc1tpICsgMV0gPSBzLml0ZW1zWzBdO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RpZmllZCBpbmRleC5cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpvaW4gY2FzZSAjMjogc3RlYWwgZnJvbSBwcmV2aW91cyBzaWJsaW5nIGxlYWZcbiAgICAgICAgaWYgKGlzTGVhZiAmJiBoYXNFeHRyYSAmJiAhaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gYXMgbGVhdmVzLlxuICAgICAgICAgICAgdmFyIGMgPSBjaGlsZDtcbiAgICAgICAgICAgIHZhciBzID0gc2libGluZztcbiAgICAgICAgICAgIC8vIFN0ZWFsIGFuIGl0ZW0uXG4gICAgICAgICAgICBjLml0ZW1zLnVuc2hpZnQocy5pdGVtcy5wb3AoKSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGJyYW5jaCBpdGVtcy5cbiAgICAgICAgICAgIG5vZGUuaXRlbXNbaV0gPSBjLml0ZW1zWzBdO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RpZmllZCBpbmRleC5cbiAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIGNhc2UgIzM6IG1lcmdlIHdpdGggbmV4dCBzaWJsaW5nIGxlYWZcbiAgICAgICAgaWYgKGlzTGVhZiAmJiAhaGFzRXh0cmEgJiYgaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gYXMgbGVhdmVzLlxuICAgICAgICAgICAgdmFyIGMgPSBjaGlsZDtcbiAgICAgICAgICAgIHZhciBzID0gc2libGluZztcbiAgICAgICAgICAgIC8vIE1lcmdlIGl0ZW1zLlxuICAgICAgICAgICAgKF9hID0gcy5pdGVtcykudW5zaGlmdC5hcHBseShfYSwgYy5pdGVtcyk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBicmFuY2ggY2hpbGQuXG4gICAgICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChub2RlLmNoaWxkcmVuLCBpKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhbGUgYnJhbmNoIGl0ZW0uXG4gICAgICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChub2RlLml0ZW1zLCBpICsgMSk7XG4gICAgICAgICAgICAvLyBQYXRjaCB1cCB0aGUgc2libGluZyBsaW5rcy5cbiAgICAgICAgICAgIGlmIChjLnByZXYpXG4gICAgICAgICAgICAgICAgYy5wcmV2Lm5leHQgPSBzO1xuICAgICAgICAgICAgcy5wcmV2ID0gYy5wcmV2O1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIG9yaWdpbmFsIGNoaWxkLlxuICAgICAgICAgICAgY2xlYXIoYyk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGlmaWVkIGluZGV4LlxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiBjYXNlICM0OiBtZXJnZSB3aXRoIHByZXZpb3VzIHNpYmxpbmcgbGVhZlxuICAgICAgICBpZiAoaXNMZWFmICYmICFoYXNFeHRyYSAmJiAhaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gYXMgbGVhdmVzLlxuICAgICAgICAgICAgdmFyIGMgPSBjaGlsZDtcbiAgICAgICAgICAgIHZhciBzID0gc2libGluZztcbiAgICAgICAgICAgIC8vIE1lcmdlIGl0ZW1zLlxuICAgICAgICAgICAgKF9iID0gcy5pdGVtcykucHVzaC5hcHBseShfYiwgYy5pdGVtcyk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBicmFuY2ggY2hpbGQuXG4gICAgICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChub2RlLmNoaWxkcmVuLCBpKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhbGUgYnJhbmNoIGl0ZW0uXG4gICAgICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChub2RlLml0ZW1zLCBpKTtcbiAgICAgICAgICAgIC8vIFBhdGNoIHVwIHRoZSBzaWJsaW5nIGxpbmtzLlxuICAgICAgICAgICAgaWYgKGMubmV4dClcbiAgICAgICAgICAgICAgICBjLm5leHQucHJldiA9IHM7XG4gICAgICAgICAgICBzLm5leHQgPSBjLm5leHQ7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgb3JpZ2luYWwgY2hpbGQuXG4gICAgICAgICAgICBjbGVhcihjKTtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kaWZpZWQgaW5kZXguXG4gICAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiBjYXNlICM1OiBzdGVhbCBmcm9tIG5leHQgc2libGluZyBicmFuY2hcbiAgICAgICAgaWYgKCFpc0xlYWYgJiYgaGFzRXh0cmEgJiYgaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gdG8gYnJhbmNoZXMuXG4gICAgICAgICAgICB2YXIgYyA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIHMgPSBzaWJsaW5nO1xuICAgICAgICAgICAgLy8gU3RlYWwgYSBjaGlsZCBmcm9tIHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICAgICAgICBjLmNoaWxkcmVuLnB1c2gocy5jaGlsZHJlbi5zaGlmdCgpKTtcbiAgICAgICAgICAgIC8vIFN0ZWFsIGFuIGl0ZW0gZnJvbSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgICAgICAgYy5pdGVtcy5wdXNoKHMuaXRlbXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGJyYW5jaCBpdGVtcy5cbiAgICAgICAgICAgIG5vZGUuaXRlbXNbaSArIDFdID0gcy5pdGVtc1swXTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2libGluZyBzaXplcy5cbiAgICAgICAgICAgIHVwZGF0ZVNpemVzKGMsIGMud2lkdGggLSAxKTtcbiAgICAgICAgICAgIHVwZGF0ZVNpemVzKHMsIDApO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RpZmllZCBpbmRleC5cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpvaW4gY2FzZSAjNjogc3RlYWwgZnJvbSBwcmV2aW91cyBzaWJsaW5nIGJyYW5jaFxuICAgICAgICBpZiAoIWlzTGVhZiAmJiBoYXNFeHRyYSAmJiAhaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gdG8gYnJhbmNoZXMuXG4gICAgICAgICAgICB2YXIgYyA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIHMgPSBzaWJsaW5nO1xuICAgICAgICAgICAgLy8gU3RlYWwgYSBjaGlsZCBmcm9tIHRoZSBwcmV2aW91cyBzaWJsaW5nLlxuICAgICAgICAgICAgYy5jaGlsZHJlbi51bnNoaWZ0KHMuY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgLy8gU3RlYWwgYW4gaXRlbSBmcm9tIHRoZSBwcmV2aW91cyBzaWJsaW5nLlxuICAgICAgICAgICAgYy5pdGVtcy51bnNoaWZ0KHMuaXRlbXMucG9wKCkpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBicmFuY2ggaXRlbXMuXG4gICAgICAgICAgICBub2RlLml0ZW1zW2ldID0gYy5pdGVtc1swXTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2libGluZyBzaXplcy5cbiAgICAgICAgICAgIHVwZGF0ZVNpemVzKGMsIDApO1xuICAgICAgICAgICAgdXBkYXRlU2l6ZXMocywgcy53aWR0aCAtIDEpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RpZmllZCBpbmRleC5cbiAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIGNhc2UgIzc6IG1lcmdlIHdpdGggbmV4dCBzaWJsaW5nIGJyYW5jaFxuICAgICAgICBpZiAoIWlzTGVhZiAmJiAhaGFzRXh0cmEgJiYgaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gdG8gYnJhbmNoZXMuXG4gICAgICAgICAgICB2YXIgYyA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIHMgPSBzaWJsaW5nO1xuICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIGNoaWxkcmVuIHdpdGggdGhlIG5leHQgc2libGluZy5cbiAgICAgICAgICAgIChfYyA9IHMuY2hpbGRyZW4pLnVuc2hpZnQuYXBwbHkoX2MsIGMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIGl0ZW1zIHdpdGggdGhlIG5leHQgc2libGluZy5cbiAgICAgICAgICAgIChfZCA9IHMuaXRlbXMpLnVuc2hpZnQuYXBwbHkoX2QsIGMuaXRlbXMpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgYnJhbmNoIGNoaWxkLlxuICAgICAgICAgICAgQXJyYXlFeHQucmVtb3ZlQXQobm9kZS5jaGlsZHJlbiwgaSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YWxlIGJyYW5jaCBpdGVtLlxuICAgICAgICAgICAgQXJyYXlFeHQucmVtb3ZlQXQobm9kZS5pdGVtcywgaSArIDEpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzaWJsaW5nIHNpemVzLlxuICAgICAgICAgICAgdXBkYXRlU2l6ZXMocywgMCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgb3JpZ2luYWwgY2hpbGQgYnV0LCBub3QgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgYy5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgY2xlYXIoYyk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGlmaWVkIGluZGV4LlxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiBjYXNlICM4OiBtZXJnZSB3aXRoIHByZXZpb3VzIHNpYmxpbmcgYnJhbmNoXG4gICAgICAgIGlmICghaXNMZWFmICYmICFoYXNFeHRyYSAmJiAhaGFzTmV4dCkge1xuICAgICAgICAgICAgLy8gQ2FzdCB0aGUgY2hpbGRyZW4gdG8gYnJhbmNoZXMuXG4gICAgICAgICAgICB2YXIgYyA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIHMgPSBzaWJsaW5nO1xuICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHByZXZpb3VzIHNpYmxpbmcuXG4gICAgICAgICAgICAoX2UgPSBzLmNoaWxkcmVuKS5wdXNoLmFwcGx5KF9lLCBjLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBpdGVtcyB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nLlxuICAgICAgICAgICAgKF9mID0gcy5pdGVtcykucHVzaC5hcHBseShfZiwgYy5pdGVtcyk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBicmFuY2ggY2hpbGQuXG4gICAgICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChub2RlLmNoaWxkcmVuLCBpKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhbGUgYnJhbmNoIGl0ZW0uXG4gICAgICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChub2RlLml0ZW1zLCBpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2libGluZyBzaXplcy5cbiAgICAgICAgICAgIHVwZGF0ZVNpemVzKHMsIDApO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIG9yaWdpbmFsIGNoaWxkLCBidXQgbm90IGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgIGMuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGNsZWFyKGMpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RpZmllZCBpbmRleC5cbiAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmUgb2YgdGhlIGFib3ZlIGNhc2VzIG11c3QgbWF0Y2guXG4gICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgfVxufSkoUHJpdmF0ZSB8fCAoUHJpdmF0ZSA9IHt9KSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBBIGdlbmVyaWMgZG91Ymx5LWxpbmtlZCBsaXN0LlxuICovXG52YXIgTGlua2VkTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgbGlua2VkIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdCgpIHtcbiAgICAgICAgdGhpcy5fZmlyc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rZWRMaXN0LnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxpc3QgaXMgZW1wdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAgICAgKiBDb25zdGFudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rZWRMaXN0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgICAgICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBsZW5ndGhgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZExpc3QucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgICAgICogQ29uc3RhbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBzaXplYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZExpc3QucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBgdW5kZWZpbmVkYCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICAgICAqIENvbnN0YW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3QgPyB0aGlzLl9maXJzdC52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZExpc3QucHJvdG90eXBlLCBcImxhc3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhc3QgdmFsdWUgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYHVuZGVmaW5lZGAgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAgICAgKiBDb25zdGFudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3QgPyB0aGlzLl9sYXN0LnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlua2VkTGlzdC5wcm90b3R5cGUsIFwiZmlyc3ROb2RlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaXJzdCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGBudWxsYCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICAgICAqIENvbnN0YW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rZWRMaXN0LnByb3RvdHlwZSwgXCJsYXN0Tm9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGBudWxsYCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICAgICAqIENvbnN0YW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFzdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHZhbHVlcyBpbiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogQ29uc3RhbnQuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rZWRMaXN0LkZvcndhcmRWYWx1ZUl0ZXJhdG9yKHRoaXMuX2ZpcnN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igc3RhcnRpbmcgd2l0aCB0aGUgbGFzdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIENvbnN0YW50LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJldHJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmtlZExpc3QuUmV0cm9WYWx1ZUl0ZXJhdG9yKHRoaXMuX2xhc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIG5vZGVzIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIENvbnN0YW50LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmtlZExpc3QuRm9yd2FyZE5vZGVJdGVyYXRvcih0aGlzLl9maXJzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZXZlcnNlIGl0ZXJhdG9yIG92ZXIgdGhlIG5vZGVzIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igc3RhcnRpbmcgd2l0aCB0aGUgbGFzdCBub2RlLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogQ29uc3RhbnQuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmV0cm9Ob2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rZWRMaXN0LlJldHJvTm9kZUl0ZXJhdG9yKHRoaXMuX2xhc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXNzaWduIG5ldyB2YWx1ZXMgdG8gdGhlIGxpc3QsIHJlcGxhY2luZyBhbGwgY3VycmVudCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBhc3NpZ24gdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMaW5lYXIuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGVhY2godmFsdWVzLCBmdW5jdGlvbiAodmFsdWUpIHsgX3RoaXMuYWRkTGFzdCh2YWx1ZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgdmFsdWUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIENvbnN0YW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgYWRkTGFzdGAuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZExhc3QodmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIHZhbHVlIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYHJlbW92ZUxhc3RgLlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGFzdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgdmFsdWUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIENvbnN0YW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgYWRkRmlyc3RgLlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkRmlyc3QodmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIHZhbHVlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYHJlbW92ZUZpcnN0YC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVGaXJzdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgdmFsdWUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG5vZGUgd2hpY2ggaG9sZHMgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogQ29uc3RhbnQuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuYWRkRmlyc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgUHJpdmF0ZSQxLkxpbmtlZExpc3ROb2RlKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJzdCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLm5leHQgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0LnByZXYgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB2YWx1ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpc3Qgbm9kZSB3aGljaCBob2xkcyB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGRMYXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IFByaXZhdGUkMS5MaW5rZWRMaXN0Tm9kZSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fbGFzdCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnByZXYgPSB0aGlzLl9sYXN0O1xuICAgICAgICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSB2YWx1ZSBiZWZvcmUgYSBzcGVjaWZpYyBub2RlIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc2VydCBiZWZvcmUgdGhlIHJlZmVyZW5jZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZiAtIFRoZSByZWZlcmVuY2Ugbm9kZSBvZiBpbnRlcmVzdC4gSWYgdGhpcyBpcyBgbnVsbGAsXG4gICAgICogICB0aGUgdmFsdWUgd2lsbCBiZSBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpc3Qgbm9kZSB3aGljaCBob2xkcyB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIHJlZmVyZW5jZSBub2RlIG11c3QgYmUgb3duZWQgYnkgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xuICAgICAgICBpZiAoIXJlZiB8fCByZWYgPT09IHRoaXMuX2ZpcnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRGaXJzdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVmIGluc3RhbmNlb2YgUHJpdmF0ZSQxLkxpbmtlZExpc3ROb2RlKSB8fCByZWYubGlzdCAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2Ugbm9kZSBpcyBub3Qgb3duZWQgYnkgdGhlIGxpc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgUHJpdmF0ZSQxLkxpbmtlZExpc3ROb2RlKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgdmFyIF9yZWYgPSByZWY7XG4gICAgICAgIHZhciBwcmV2ID0gX3JlZi5wcmV2O1xuICAgICAgICBub2RlLm5leHQgPSBfcmVmO1xuICAgICAgICBub2RlLnByZXYgPSBwcmV2O1xuICAgICAgICBfcmVmLnByZXYgPSBub2RlO1xuICAgICAgICBwcmV2Lm5leHQgPSBub2RlO1xuICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgdmFsdWUgYWZ0ZXIgYSBzcGVjaWZpYyBub2RlIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc2VydCBhZnRlciB0aGUgcmVmZXJlbmNlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVmIC0gVGhlIHJlZmVyZW5jZSBub2RlIG9mIGludGVyZXN0LiBJZiB0aGlzIGlzIGBudWxsYCxcbiAgICAgKiAgIHRoZSB2YWx1ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGlzdCBub2RlIHdoaWNoIGhvbGRzIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcmVmZXJlbmNlIG5vZGUgbXVzdCBiZSBvd25lZCBieSB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIENvbnN0YW50LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcbiAgICAgICAgaWYgKCFyZWYgfHwgcmVmID09PSB0aGlzLl9sYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMYXN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZWYgaW5zdGFuY2VvZiBQcml2YXRlJDEuTGlua2VkTGlzdE5vZGUpIHx8IHJlZi5saXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZSBub2RlIGlzIG5vdCBvd25lZCBieSB0aGUgbGlzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBQcml2YXRlJDEuTGlua2VkTGlzdE5vZGUodGhpcywgdmFsdWUpO1xuICAgICAgICB2YXIgX3JlZiA9IHJlZjtcbiAgICAgICAgdmFyIG5leHQgPSBfcmVmLm5leHQ7XG4gICAgICAgIG5vZGUubmV4dCA9IG5leHQ7XG4gICAgICAgIG5vZGUucHJldiA9IF9yZWY7XG4gICAgICAgIF9yZWYubmV4dCA9IG5vZGU7XG4gICAgICAgIG5leHQucHJldiA9IG5vZGU7XG4gICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgdmFsdWUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZW1vdmVkIHZhbHVlLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIENvbnN0YW50LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZUZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2ZpcnN0O1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuX2xhc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB0aGlzLl9maXJzdC5wcmV2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmxpc3QgPSBudWxsO1xuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuICAgICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIHZhbHVlIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2xhc3Q7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fZmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5saXN0ID0gbnVsbDtcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNwZWNpZmljIG5vZGUgZnJvbSB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgbm9kZSBtdXN0IGJlIG93bmVkIGJ5IHRoZSBsaXN0LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgUHJpdmF0ZSQxLkxpbmtlZExpc3ROb2RlKSB8fCBub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBub3Qgb3duZWQgYnkgdGhlIGxpc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZTtcbiAgICAgICAgaWYgKF9ub2RlID09PSB0aGlzLl9maXJzdCAmJiBfbm9kZSA9PT0gdGhpcy5fbGFzdCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX25vZGUgPT09IHRoaXMuX2ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IF9ub2RlLm5leHQ7XG4gICAgICAgICAgICB0aGlzLl9maXJzdC5wcmV2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfbm9kZSA9PT0gdGhpcy5fbGFzdCkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IF9ub2RlLnByZXY7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Lm5leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX25vZGUubmV4dC5wcmV2ID0gX25vZGUucHJldjtcbiAgICAgICAgICAgIF9ub2RlLnByZXYubmV4dCA9IF9ub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgX25vZGUubGlzdCA9IG51bGw7XG4gICAgICAgIF9ub2RlLm5leHQgPSBudWxsO1xuICAgICAgICBfbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB2YWx1ZXMgZnJvbSB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhci5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5saXN0ID0gbnVsbDtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IG51bGw7XG4gICAgICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgTGlua2VkTGlzdGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChMaW5rZWRMaXN0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbGlua2VkIGxpc3QgZnJvbSBhbiBpdGVyYWJsZSBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIGl0ZXJhYmxlIG9yIGFycmF5LWxpa2Ugb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgbGlua2VkIGxpc3QgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTGluZWFyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb20odmFsdWVzKSB7XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgbGlzdC5hc3NpZ24odmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIExpbmtlZExpc3QuZnJvbSA9IGZyb207XG4gICAgLyoqXG4gICAgICogQSBmb3J3YXJkIGl0ZXJhdG9yIGZvciB2YWx1ZXMgaW4gYSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICB2YXIgRm9yd2FyZFZhbHVlSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBmb3J3YXJkIHZhbHVlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBmaXJzdCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9yd2FyZFZhbHVlSXRlcmF0b3Iobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9yd2FyZFZhbHVlSXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIEZvcndhcmRWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9yd2FyZFZhbHVlSXRlcmF0b3IodGhpcy5fbm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcndhcmRWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcndhcmRWYWx1ZUl0ZXJhdG9yO1xuICAgIH0oKSk7XG4gICAgTGlua2VkTGlzdC5Gb3J3YXJkVmFsdWVJdGVyYXRvciA9IEZvcndhcmRWYWx1ZUl0ZXJhdG9yO1xuICAgIC8qKlxuICAgICAqIEEgcmV2ZXJzZSBpdGVyYXRvciBmb3IgdmFsdWVzIGluIGEgbGlua2VkIGxpc3QuXG4gICAgICovXG4gICAgdmFyIFJldHJvVmFsdWVJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIHJldHJvIHZhbHVlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBsYXN0IG5vZGUgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZXRyb1ZhbHVlSXRlcmF0b3Iobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBpdGVyYXRvciBvdmVyIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHdoaWNoIHlpZWxkcyB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV0cm9WYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBSZXRyb1ZhbHVlSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXRyb1ZhbHVlSXRlcmF0b3IodGhpcy5fbm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLCBvciBgdW5kZWZpbmVkYC5cbiAgICAgICAgICovXG4gICAgICAgIFJldHJvVmFsdWVJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG4gICAgICAgICAgICB0aGlzLl9ub2RlID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXRyb1ZhbHVlSXRlcmF0b3I7XG4gICAgfSgpKTtcbiAgICBMaW5rZWRMaXN0LlJldHJvVmFsdWVJdGVyYXRvciA9IFJldHJvVmFsdWVJdGVyYXRvcjtcbiAgICAvKipcbiAgICAgKiBBIGZvcndhcmQgaXRlcmF0b3IgZm9yIG5vZGVzIGluIGEgbGlua2VkIGxpc3QuXG4gICAgICovXG4gICAgdmFyIEZvcndhcmROb2RlSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBmb3J3YXJkIG5vZGUgaXRlcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIGZpcnN0IG5vZGUgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGb3J3YXJkTm9kZUl0ZXJhdG9yKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gaXRlcmF0b3Igb3ZlciB0aGUgb2JqZWN0J3MgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBpdGVyYXRvciB3aGljaCB5aWVsZHMgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIEZvcndhcmROb2RlSXRlcmF0b3IucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBpbmRlcGVuZGVudCBjbG9uZSBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgbmV3IGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIEZvcndhcmROb2RlSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3J3YXJkTm9kZUl0ZXJhdG9yKHRoaXMuX25vZGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBuZXh0IHZhbHVlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvciwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3J3YXJkTm9kZUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcndhcmROb2RlSXRlcmF0b3I7XG4gICAgfSgpKTtcbiAgICBMaW5rZWRMaXN0LkZvcndhcmROb2RlSXRlcmF0b3IgPSBGb3J3YXJkTm9kZUl0ZXJhdG9yO1xuICAgIC8qKlxuICAgICAqIEEgcmV2ZXJzZSBpdGVyYXRvciBmb3Igbm9kZXMgaW4gYSBsaW5rZWQgbGlzdC5cbiAgICAgKi9cbiAgICB2YXIgUmV0cm9Ob2RlSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSByZXRybyBub2RlIGl0ZXJhdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBsYXN0IG5vZGUgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZXRyb05vZGVJdGVyYXRvcihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIGl0ZXJhdG9yIG92ZXIgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igd2hpY2ggeWllbGRzIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBSZXRyb05vZGVJdGVyYXRvci5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGluZGVwZW5kZW50IGNsb25lIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQSBuZXcgaW5kZXBlbmRlbnQgY2xvbmUgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV0cm9Ob2RlSXRlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXRyb05vZGVJdGVyYXRvcih0aGlzLl9ub2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbmV4dCB2YWx1ZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUgZnJvbSB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgLlxuICAgICAgICAgKi9cbiAgICAgICAgUmV0cm9Ob2RlSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX25vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmV0cm9Ob2RlSXRlcmF0b3I7XG4gICAgfSgpKTtcbiAgICBMaW5rZWRMaXN0LlJldHJvTm9kZUl0ZXJhdG9yID0gUmV0cm9Ob2RlSXRlcmF0b3I7XG59KShMaW5rZWRMaXN0IHx8IChMaW5rZWRMaXN0ID0ge30pKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSQxO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIGxpbmtlZCBsaXN0IG5vZGUgaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgdmFyIExpbmtlZExpc3ROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IGxpbmtlZCBsaXN0IG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBsaXN0IC0gVGhlIGxpc3Qgd2hpY2ggb3ducyB0aGUgbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciB0aGUgbGluay5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIExpbmtlZExpc3ROb2RlKGxpc3QsIHZhbHVlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBsaW5rZWQgbGlzdCB3aGljaCBjcmVhdGVkIGFuZCBvd25zIHRoZSBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxpc3QgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbmV4dCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcHJldmlvdXMgbm9kZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExpbmtlZExpc3ROb2RlO1xuICAgIH0oKSk7XG4gICAgUHJpdmF0ZS5MaW5rZWRMaXN0Tm9kZSA9IExpbmtlZExpc3ROb2RlO1xufSkoUHJpdmF0ZSQxIHx8IChQcml2YXRlJDEgPSB7fSkpO1xuXG5leHBvcnQgeyBCUGx1c1RyZWUsIExpbmtlZExpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lumino/collections/dist/index.es6.js\n')},"./node_modules/@lumino/commands/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CommandRegistry\": () => (/* binding */ CommandRegistry)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/algorithm/dist/index.es6.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/@lumino/coreutils/dist/index.es6.js\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/@lumino/disposable/dist/index.es6.js\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/@lumino/domutils/dist/index.es6.js\");\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/@lumino/keyboard/dist/index.es6.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/@lumino/signaling/dist/index.es6.js\");\n\n\n\n\n\n\n\n// Copyright (c) Jupyter Development Team.\n/**\n * An object which manages a collection of commands.\n *\n * #### Notes\n * A command registry can be used to populate a variety of action-based\n * widgets, such as command palettes, menus, and toolbars.\n */\nvar CommandRegistry = /** @class */ (function () {\n    /**\n     * Construct a new command registry.\n     */\n    function CommandRegistry() {\n        this._timerID = 0;\n        this._replaying = false;\n        this._keystrokes = [];\n        this._keydownEvents = [];\n        this._keyBindings = [];\n        this._exactKeyMatch = null;\n        this._commands = Object.create(null);\n        this._commandChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_5__.Signal(this);\n        this._commandExecuted = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_5__.Signal(this);\n        this._keyBindingChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_5__.Signal(this);\n    }\n    Object.defineProperty(CommandRegistry.prototype, \"commandChanged\", {\n        /**\n         * A signal emitted when a command has changed.\n         *\n         * #### Notes\n         * This signal is useful for visual representations of commands which\n         * need to refresh when the state of a relevant command has changed.\n         */\n        get: function () {\n            return this._commandChanged;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandRegistry.prototype, \"commandExecuted\", {\n        /**\n         * A signal emitted when a command has executed.\n         *\n         * #### Notes\n         * Care should be taken when consuming this signal. The command system is used\n         * by many components for many user actions. Handlers registered with this\n         * signal must return quickly to ensure the overall application remains responsive.\n         */\n        get: function () {\n            return this._commandExecuted;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandRegistry.prototype, \"keyBindingChanged\", {\n        /**\n         * A signal emitted when a key binding is changed.\n         */\n        get: function () {\n            return this._keyBindingChanged;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandRegistry.prototype, \"keyBindings\", {\n        /**\n         * A read-only array of the key bindings in the registry.\n         */\n        get: function () {\n            return this._keyBindings;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * List the ids of the registered commands.\n     *\n     * @returns A new array of the registered command ids.\n     */\n    CommandRegistry.prototype.listCommands = function () {\n        return Object.keys(this._commands);\n    };\n    /**\n     * Test whether a specific command is registered.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @returns `true` if the command is registered, `false` otherwise.\n     */\n    CommandRegistry.prototype.hasCommand = function (id) {\n        return id in this._commands;\n    };\n    /**\n     * Add a command to the registry.\n     *\n     * @param id - The unique id of the command.\n     *\n     * @param options - The options for the command.\n     *\n     * @returns A disposable which will remove the command.\n     *\n     * @throws An error if the given `id` is already registered.\n     */\n    CommandRegistry.prototype.addCommand = function (id, options) {\n        var _this = this;\n        // Throw an error if the id is already registered.\n        if (id in this._commands) {\n            throw new Error(\"Command '\" + id + \"' already registered.\");\n        }\n        // Add the command to the registry.\n        this._commands[id] = Private.createCommand(options);\n        // Emit the `commandChanged` signal.\n        this._commandChanged.emit({ id: id, type: 'added' });\n        // Return a disposable which will remove the command.\n        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_2__.DisposableDelegate(function () {\n            // Remove the command from the registry.\n            delete _this._commands[id];\n            // Emit the `commandChanged` signal.\n            _this._commandChanged.emit({ id: id, type: 'removed' });\n        });\n    };\n    /**\n     * Notify listeners that the state of a command has changed.\n     *\n     * @param id - The id of the command which has changed. If more than\n     *   one command has changed, this argument should be omitted.\n     *\n     * @throws An error if the given `id` is not registered.\n     *\n     * #### Notes\n     * This method should be called by the command author whenever the\n     * application state changes such that the results of the command\n     * metadata functions may have changed.\n     *\n     * This will cause the `commandChanged` signal to be emitted.\n     */\n    CommandRegistry.prototype.notifyCommandChanged = function (id) {\n        if (id !== undefined && !(id in this._commands)) {\n            throw new Error(\"Command '\" + id + \"' is not registered.\");\n        }\n        this._commandChanged.emit({ id: id, type: id ? 'changed' : 'many-changed' });\n    };\n    /**\n     * Get the display label for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The display label for the command, or an empty string\n     *   if the command is not registered.\n     */\n    CommandRegistry.prototype.label = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.label.call(undefined, args) : '';\n    };\n    /**\n     * Get the mnemonic index for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The mnemonic index for the command, or `-1` if the\n     *   command is not registered.\n     */\n    CommandRegistry.prototype.mnemonic = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.mnemonic.call(undefined, args) : -1;\n    };\n    /**\n     * Get the icon renderer for a specific command.\n     *\n     * DEPRECATED: if set to a string value, the .icon field will\n     * function as an alias for the .iconClass field, for backwards\n     * compatibility. In the future when this is removed, the default\n     * return type will become undefined.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The icon renderer for the command, or\n     *   an empty string if the command is not registered.\n     */\n    CommandRegistry.prototype.icon = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.icon.call(undefined, args) : /* <DEPRECATED> */ '' /* </DEPRECATED> */ /* <FUTURE> undefined </FUTURE> */;\n    };\n    /**\n     * Get the icon class for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The icon class for the command, or an empty string if\n     *   the command is not registered.\n     */\n    CommandRegistry.prototype.iconClass = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.iconClass.call(undefined, args) : '';\n    };\n    /**\n     * Get the icon label for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The icon label for the command, or an empty string if\n     *   the command is not registered.\n     */\n    CommandRegistry.prototype.iconLabel = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.iconLabel.call(undefined, args) : '';\n    };\n    /**\n     * Get the short form caption for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The caption for the command, or an empty string if the\n     *   command is not registered.\n     */\n    CommandRegistry.prototype.caption = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.caption.call(undefined, args) : '';\n    };\n    /**\n     * Get the usage help text for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The usage text for the command, or an empty string if\n     *   the command is not registered.\n     */\n    CommandRegistry.prototype.usage = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.usage.call(undefined, args) : '';\n    };\n    /**\n     * Get the extra class name for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The class name for the command, or an empty string if\n     *   the command is not registered.\n     */\n    CommandRegistry.prototype.className = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.className.call(undefined, args) : '';\n    };\n    /**\n     * Get the dataset for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The dataset for the command, or an empty dataset if\n     *   the command is not registered.\n     */\n    CommandRegistry.prototype.dataset = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.dataset.call(undefined, args) : {};\n    };\n    /**\n     * Test whether a specific command is enabled.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is enabled,\n     *   or `false` if the command is not registered.\n     */\n    CommandRegistry.prototype.isEnabled = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.isEnabled.call(undefined, args) : false;\n    };\n    /**\n     * Test whether a specific command is toggled.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is toggled,\n     *   or `false` if the command is not registered.\n     */\n    CommandRegistry.prototype.isToggled = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.isToggled.call(undefined, args) : false;\n    };\n    /**\n     * Test whether a specific command is toggleable.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is toggleable,\n     *   or `false` if the command is not registered.\n     */\n    CommandRegistry.prototype.isToggleable = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.isToggleable : false;\n    };\n    /**\n     * Test whether a specific command is visible.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is visible,\n     *   or `false` if the command is not registered.\n     */\n    CommandRegistry.prototype.isVisible = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        var cmd = this._commands[id];\n        return cmd ? cmd.isVisible.call(undefined, args) : false;\n    };\n    /**\n     * Execute a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A promise which resolves with the result of the command.\n     *\n     * #### Notes\n     * The promise will reject if the command throws an exception,\n     * or if the command is not registered.\n     */\n    CommandRegistry.prototype.execute = function (id, args) {\n        if (args === void 0) { args = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject; }\n        // Reject if the command is not registered.\n        var cmd = this._commands[id];\n        if (!cmd) {\n            return Promise.reject(new Error(\"Command '\" + id + \"' not registered.\"));\n        }\n        // Execute the command and reject if an exception is thrown.\n        var value;\n        try {\n            value = cmd.execute.call(undefined, args);\n        }\n        catch (err) {\n            value = Promise.reject(err);\n        }\n        // Create the return promise which resolves the result.\n        var result = Promise.resolve(value);\n        // Emit the command executed signal.\n        this._commandExecuted.emit({ id: id, args: args, result: result });\n        // Return the result promise to the caller.\n        return result;\n    };\n    /**\n     * Add a key binding to the registry.\n     *\n     * @param options - The options for creating the key binding.\n     *\n     * @returns A disposable which removes the added key binding.\n     *\n     * #### Notes\n     * If multiple key bindings are registered for the same sequence, the\n     * binding with the highest selector specificity is executed first. A\n     * tie is broken by using the most recently added key binding.\n     *\n     * Ambiguous key bindings are resolved with a timeout. As an example,\n     * suppose two key bindings are registered: one with the key sequence\n     * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user\n     * presses `Ctrl D`, the first binding cannot be immediately executed\n     * since the user may intend to complete the chord with `Ctrl W`. For\n     * such cases, a timer is used to allow the chord to be completed. If\n     * the chord is not completed before the timeout, the first binding\n     * is executed.\n     */\n    CommandRegistry.prototype.addKeyBinding = function (options) {\n        var _this = this;\n        // Create the binding for the given options.\n        var binding = Private.createKeyBinding(options);\n        // Add the key binding to the bindings array.\n        this._keyBindings.push(binding);\n        // Emit the `bindingChanged` signal.\n        this._keyBindingChanged.emit({ binding: binding, type: 'added' });\n        // Return a disposable which will remove the binding.\n        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_2__.DisposableDelegate(function () {\n            // Remove the binding from the array.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeFirstOf(_this._keyBindings, binding);\n            // Emit the `bindingChanged` signal.\n            _this._keyBindingChanged.emit({ binding: binding, type: 'removed' });\n        });\n    };\n    /**\n     * Process a `'keydown'` event and invoke a matching key binding.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     *\n     * #### Notes\n     * This should be called in response to a `'keydown'` event in order\n     * to invoke the command for the best matching key binding.\n     *\n     * The registry **does not** install its own listener for `'keydown'`\n     * events. This allows the application full control over the nodes\n     * and phase for which the registry processes `'keydown'` events.\n     *\n     * When the keydown event is processed, if the event target or any of its\n     * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown\n     * events will not invoke commands.\n     */\n    CommandRegistry.prototype.processKeydownEvent = function (event) {\n        // Bail immediately if playing back keystrokes.\n        if (this._replaying) {\n            return;\n        }\n        // Get the normalized keystroke for the event.\n        var keystroke = CommandRegistry.keystrokeForKeydownEvent(event);\n        // If the keystroke is not valid for the keyboard layout, replay\n        // any suppressed events and clear the pending state.\n        if (!keystroke) {\n            this._replayKeydownEvents();\n            this._clearPendingState();\n            return;\n        }\n        // Add the keystroke to the current key sequence.\n        this._keystrokes.push(keystroke);\n        // Find the exact and partial matches for the key sequence.\n        var _a = Private.matchKeyBinding(this._keyBindings, this._keystrokes, event), exact = _a.exact, partial = _a.partial;\n        // If there is no exact match and no partial match, replay\n        // any suppressed events and clear the pending state.\n        if (!exact && !partial) {\n            this._replayKeydownEvents();\n            this._clearPendingState();\n            return;\n        }\n        // Stop propagation of the event. If there is only a partial match,\n        // the event will be replayed if a final exact match never occurs.\n        event.preventDefault();\n        event.stopPropagation();\n        // If there is an exact match but no partial match, the exact match\n        // can be dispatched immediately. The pending state is cleared so\n        // the next key press starts from the default state.\n        if (exact && !partial) {\n            this._executeKeyBinding(exact);\n            this._clearPendingState();\n            return;\n        }\n        // If there is both an exact match and a partial match, the exact\n        // match is stored for future dispatch in case the timer expires\n        // before a more specific match is triggered.\n        if (exact) {\n            this._exactKeyMatch = exact;\n        }\n        // Store the event for possible playback in the future.\n        this._keydownEvents.push(event);\n        // (Re)start the timer to dispatch the most recent exact match\n        // in case the partial match fails to result in an exact match.\n        this._startTimer();\n    };\n    /**\n     * Start or restart the pending timeout.\n     */\n    CommandRegistry.prototype._startTimer = function () {\n        var _this = this;\n        this._clearTimer();\n        this._timerID = window.setTimeout(function () {\n            _this._onPendingTimeout();\n        }, Private.CHORD_TIMEOUT);\n    };\n    /**\n     * Clear the pending timeout.\n     */\n    CommandRegistry.prototype._clearTimer = function () {\n        if (this._timerID !== 0) {\n            clearTimeout(this._timerID);\n            this._timerID = 0;\n        }\n    };\n    /**\n     * Replay the keydown events which were suppressed.\n     */\n    CommandRegistry.prototype._replayKeydownEvents = function () {\n        if (this._keydownEvents.length === 0) {\n            return;\n        }\n        this._replaying = true;\n        this._keydownEvents.forEach(Private.replayKeyEvent);\n        this._replaying = false;\n    };\n    /**\n     * Execute the command for the given key binding.\n     *\n     * If the command is missing or disabled, a warning will be logged.\n     */\n    CommandRegistry.prototype._executeKeyBinding = function (binding) {\n        var command = binding.command, args = binding.args;\n        if (!this.hasCommand(command) || !this.isEnabled(command, args)) {\n            var word = this.hasCommand(command) ? 'enabled' : 'registered';\n            var keys = binding.keys.join(', ');\n            var msg1 = \"Cannot execute key binding '\" + keys + \"':\";\n            var msg2 = \"command '\" + command + \"' is not \" + word + \".\";\n            console.warn(msg1 + \" \" + msg2);\n            return;\n        }\n        this.execute(command, args);\n    };\n    /**\n     * Clear the internal pending state.\n     */\n    CommandRegistry.prototype._clearPendingState = function () {\n        this._clearTimer();\n        this._exactKeyMatch = null;\n        this._keystrokes.length = 0;\n        this._keydownEvents.length = 0;\n    };\n    /**\n     * Handle the partial match timeout.\n     */\n    CommandRegistry.prototype._onPendingTimeout = function () {\n        this._timerID = 0;\n        if (this._exactKeyMatch) {\n            this._executeKeyBinding(this._exactKeyMatch);\n        }\n        else {\n            this._replayKeydownEvents();\n        }\n        this._clearPendingState();\n    };\n    return CommandRegistry;\n}());\n/**\n * The namespace for the `CommandRegistry` class statics.\n */\n(function (CommandRegistry) {\n    /**\n     * Parse a keystroke into its constituent components.\n     *\n     * @param keystroke - The keystroke of interest.\n     *\n     * @returns The parsed components of the keystroke.\n     *\n     * #### Notes\n     * The keystroke should be of the form:\n     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`\n     *\n     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and\n     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and\n     * `Ctrl` on all other platforms.\n     *\n     * The parsing is tolerant and will not throw exceptions. Notably:\n     *   - Duplicate modifiers are ignored.\n     *   - Extra primary keys are ignored.\n     *   - The order of modifiers and primary key is irrelevant.\n     *   - The keystroke parts should be separated by whitespace.\n     *   - The keystroke is case sensitive.\n     */\n    function parseKeystroke(keystroke) {\n        var key = '';\n        var alt = false;\n        var cmd = false;\n        var ctrl = false;\n        var shift = false;\n        for (var _i = 0, _a = keystroke.split(/\\s+/); _i < _a.length; _i++) {\n            var token = _a[_i];\n            if (token === 'Accel') {\n                if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Platform.IS_MAC) {\n                    cmd = true;\n                }\n                else {\n                    ctrl = true;\n                }\n            }\n            else if (token === 'Alt') {\n                alt = true;\n            }\n            else if (token === 'Cmd') {\n                cmd = true;\n            }\n            else if (token === 'Ctrl') {\n                ctrl = true;\n            }\n            else if (token === 'Shift') {\n                shift = true;\n            }\n            else if (token.length > 0) {\n                key = token;\n            }\n        }\n        return { cmd: cmd, ctrl: ctrl, alt: alt, shift: shift, key: key };\n    }\n    CommandRegistry.parseKeystroke = parseKeystroke;\n    /**\n     * Normalize a keystroke into a canonical representation.\n     *\n     * @param keystroke - The keystroke of interest.\n     *\n     * @returns The normalized representation of the keystroke.\n     *\n     * #### Notes\n     * This normalizes the keystroke by removing duplicate modifiers and\n     * extra primary keys, and assembling the parts in a canonical order.\n     *\n     * The `Cmd` modifier is ignored on non-Mac platforms.\n     */\n    function normalizeKeystroke(keystroke) {\n        var mods = '';\n        var parts = parseKeystroke(keystroke);\n        if (parts.ctrl) {\n            mods += 'Ctrl ';\n        }\n        if (parts.alt) {\n            mods += 'Alt ';\n        }\n        if (parts.shift) {\n            mods += 'Shift ';\n        }\n        if (parts.cmd && _lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Platform.IS_MAC) {\n            mods += 'Cmd ';\n        }\n        return mods + parts.key;\n    }\n    CommandRegistry.normalizeKeystroke = normalizeKeystroke;\n    /**\n     * Get the platform-specific normalized keys for an options object.\n     *\n     * @param options - The options for the key binding.\n     *\n     * @returns Array of combined, normalized keys.\n     */\n    function normalizeKeys(options) {\n        var keys;\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Platform.IS_WIN) {\n            keys = options.winKeys || options.keys;\n        }\n        else if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Platform.IS_MAC) {\n            keys = options.macKeys || options.keys;\n        }\n        else {\n            keys = options.linuxKeys || options.keys;\n        }\n        return keys.map(normalizeKeystroke);\n    }\n    CommandRegistry.normalizeKeys = normalizeKeys;\n    /**\n     * Format a keystroke for display on the local system.\n     */\n    function formatKeystroke(keystroke) {\n        var mods = '';\n        var parts = parseKeystroke(keystroke);\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Platform.IS_MAC) {\n            if (parts.ctrl) {\n                mods += '\\u2303 ';\n            }\n            if (parts.alt) {\n                mods += '\\u2325 ';\n            }\n            if (parts.shift) {\n                mods += '\\u21E7 ';\n            }\n            if (parts.cmd) {\n                mods += '\\u2318 ';\n            }\n        }\n        else {\n            if (parts.ctrl) {\n                mods += 'Ctrl+';\n            }\n            if (parts.alt) {\n                mods += 'Alt+';\n            }\n            if (parts.shift) {\n                mods += 'Shift+';\n            }\n        }\n        return mods + parts.key;\n    }\n    CommandRegistry.formatKeystroke = formatKeystroke;\n    /**\n     * Create a normalized keystroke for a `'keydown'` event.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     *\n     * @returns A normalized keystroke, or an empty string if the event\n     *   does not represent a valid keystroke for the given layout.\n     */\n    function keystrokeForKeydownEvent(event) {\n        var key = (0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_4__.getKeyboardLayout)().keyForKeydownEvent(event);\n        if (!key) {\n            return '';\n        }\n        var mods = '';\n        if (event.ctrlKey) {\n            mods += 'Ctrl ';\n        }\n        if (event.altKey) {\n            mods += 'Alt ';\n        }\n        if (event.shiftKey) {\n            mods += 'Shift ';\n        }\n        if (event.metaKey && _lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Platform.IS_MAC) {\n            mods += 'Cmd ';\n        }\n        return mods + key;\n    }\n    CommandRegistry.keystrokeForKeydownEvent = keystrokeForKeydownEvent;\n})(CommandRegistry || (CommandRegistry = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The timeout in ms for triggering a key binding chord.\n     */\n    Private.CHORD_TIMEOUT = 1000;\n    /**\n     * Create a normalized command from an options object.\n     */\n    function createCommand(options) {\n        var icon;\n        var iconClass;\n        /* <DEPRECATED> */\n        if (!(options.icon) || typeof options.icon === 'string') {\n            // alias icon to iconClass\n            iconClass = asFunc(options.iconClass || options.icon, emptyStringFunc);\n            icon = iconClass;\n        }\n        else {\n            /* /<DEPRECATED> */\n            iconClass = asFunc(options.iconClass, emptyStringFunc);\n            icon = asFunc(options.icon, undefinedFunc);\n            /* <DEPRECATED> */\n        }\n        /* </DEPRECATED> */\n        return {\n            execute: options.execute,\n            label: asFunc(options.label, emptyStringFunc),\n            mnemonic: asFunc(options.mnemonic, negativeOneFunc),\n            icon: icon,\n            iconClass: iconClass,\n            iconLabel: asFunc(options.iconLabel, emptyStringFunc),\n            caption: asFunc(options.caption, emptyStringFunc),\n            usage: asFunc(options.usage, emptyStringFunc),\n            className: asFunc(options.className, emptyStringFunc),\n            dataset: asFunc(options.dataset, emptyDatasetFunc),\n            isEnabled: options.isEnabled || trueFunc,\n            isToggled: options.isToggled || falseFunc,\n            isToggleable: options.isToggleable || !!options.isToggled,\n            isVisible: options.isVisible || trueFunc\n        };\n    }\n    Private.createCommand = createCommand;\n    /**\n     * Create a key binding object from key binding options.\n     */\n    function createKeyBinding(options) {\n        return {\n            keys: CommandRegistry.normalizeKeys(options),\n            selector: validateSelector(options),\n            command: options.command,\n            args: options.args || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.JSONExt.emptyObject\n        };\n    }\n    Private.createKeyBinding = createKeyBinding;\n    /**\n     * Find the key bindings which match a key sequence.\n     *\n     * This returns a match result which contains the best exact matching\n     * binding, and a flag which indicates if there are partial matches.\n     */\n    function matchKeyBinding(bindings, keys, event) {\n        // The current best exact match.\n        var exact = null;\n        // Whether a partial match has been found.\n        var partial = false;\n        // The match distance for the exact match.\n        var distance = Infinity;\n        // The specificity for the exact match.\n        var specificity = 0;\n        // Iterate over the bindings and search for the best match.\n        for (var i = 0, n = bindings.length; i < n; ++i) {\n            // Lookup the current binding.\n            var binding = bindings[i];\n            // Check whether the key binding sequence is a match.\n            var sqm = matchSequence(binding.keys, keys);\n            // If there is no match, the binding is ignored.\n            if (sqm === 0 /* None */) {\n                continue;\n            }\n            // If it is a partial match and no other partial match has been\n            // found, ensure the selector matches and set the partial flag.\n            if (sqm === 2 /* Partial */) {\n                if (!partial && targetDistance(binding.selector, event) !== -1) {\n                    partial = true;\n                }\n                continue;\n            }\n            // Ignore the match if the selector doesn't match, or if the\n            // matched node is farther away than the current best match.\n            var td = targetDistance(binding.selector, event);\n            if (td === -1 || td > distance) {\n                continue;\n            }\n            // Get the specificity for the selector.\n            var sp = _lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Selector.calculateSpecificity(binding.selector);\n            // Update the best match if this match is stronger.\n            if (!exact || td < distance || sp >= specificity) {\n                exact = binding;\n                distance = td;\n                specificity = sp;\n            }\n        }\n        // Return the match result.\n        return { exact: exact, partial: partial };\n    }\n    Private.matchKeyBinding = matchKeyBinding;\n    /**\n     * Replay a keyboard event.\n     *\n     * This synthetically dispatches a clone of the keyboard event.\n     */\n    function replayKeyEvent(event) {\n        event.target.dispatchEvent(cloneKeyboardEvent(event));\n    }\n    Private.replayKeyEvent = replayKeyEvent;\n    /**\n     * A singleton empty string function.\n     */\n    var emptyStringFunc = function () { return ''; };\n    /**\n     * A singleton `-1` number function\n     */\n    var negativeOneFunc = function () { return -1; };\n    /**\n     * A singleton true boolean function.\n     */\n    var trueFunc = function () { return true; };\n    /**\n     * A singleton false boolean function.\n     */\n    var falseFunc = function () { return false; };\n    /**\n     * A singleton empty dataset function.\n     */\n    var emptyDatasetFunc = function () { return ({}); };\n    /**\n     * A singleton undefined function\n     */\n    var undefinedFunc = function () { return undefined; };\n    /**\n     * Cast a value or command func to a command func.\n     */\n    function asFunc(value, dfault) {\n        if (value === undefined) {\n            return dfault;\n        }\n        if (typeof value === 'function') {\n            return value;\n        }\n        return function () { return value; };\n    }\n    /**\n     * Validate the selector for an options object.\n     *\n     * This returns the validated selector, or throws if the selector is\n     * invalid or contains commas.\n     */\n    function validateSelector(options) {\n        if (options.selector.indexOf(',') !== -1) {\n            throw new Error(\"Selector cannot contain commas: \" + options.selector);\n        }\n        if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Selector.isValid(options.selector)) {\n            throw new Error(\"Invalid selector: \" + options.selector);\n        }\n        return options.selector;\n    }\n    /**\n     * Test whether a key binding sequence matches a key sequence.\n     *\n     * Returns a `SequenceMatch` value indicating the type of match.\n     */\n    function matchSequence(bindKeys, userKeys) {\n        if (bindKeys.length < userKeys.length) {\n            return 0 /* None */;\n        }\n        for (var i = 0, n = userKeys.length; i < n; ++i) {\n            if (bindKeys[i] !== userKeys[i]) {\n                return 0 /* None */;\n            }\n        }\n        if (bindKeys.length > userKeys.length) {\n            return 2 /* Partial */;\n        }\n        return 1 /* Exact */;\n    }\n    /**\n     * Find the distance from the target node to the first matching node.\n     *\n     * This traverses the event path from `target` to `currentTarget` and\n     * computes the distance from `target` to the first node which matches\n     * the CSS selector. If no match is found, `-1` is returned.\n     */\n    function targetDistance(selector, event) {\n        var targ = event.target;\n        var curr = event.currentTarget;\n        for (var dist = 0; targ !== null; targ = targ.parentElement, ++dist) {\n            if (targ.hasAttribute('data-lm-suppress-shortcuts')) {\n                return -1;\n            }\n            /* <DEPRECATED> */\n            if (targ.hasAttribute('data-p-suppress-shortcuts')) {\n                return -1;\n            }\n            /* </DEPRECATED> */\n            if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_3__.Selector.matches(targ, selector)) {\n                return dist;\n            }\n            if (targ === curr) {\n                return -1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Clone a keyboard event.\n     */\n    function cloneKeyboardEvent(event) {\n        // A custom event is required because Chrome nulls out the\n        // `keyCode` field in user-generated `KeyboardEvent` types.\n        var clone = document.createEvent('Event');\n        var bubbles = event.bubbles || true;\n        var cancelable = event.cancelable || true;\n        clone.initEvent(event.type || 'keydown', bubbles, cancelable);\n        clone.key = event.key || '';\n        clone.keyCode = event.keyCode || 0;\n        clone.which = event.keyCode || 0;\n        clone.ctrlKey = event.ctrlKey || false;\n        clone.altKey = event.altKey || false;\n        clone.shiftKey = event.shiftKey || false;\n        clone.metaKey = event.metaKey || false;\n        clone.view = event.view || window;\n        return clone;\n    }\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9jb21tYW5kcy9kaXN0L2luZGV4LmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTZDO0FBQ0Q7QUFDWTtBQUNGO0FBQ0Q7QUFDVjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBTTtBQUN6QyxvQ0FBb0MscURBQU07QUFDMUMsc0NBQXNDLHFEQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQSxtQkFBbUIsa0VBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQStDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sa0VBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sa0VBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxrRUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sa0VBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxrRUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sa0VBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxrRUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sa0VBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxrRUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGtFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0EsbUJBQW1CLGtFQUFrQjtBQUNyQztBQUNBLFlBQVkscUVBQXNCO0FBQ2xDO0FBQ0EsNENBQTRDLG1DQUFtQztBQUMvRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUFlO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkVBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOERBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUVBO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vY29tbWFuZHMvZGlzdC9pbmRleC5lczYuanM/MDAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbmltcG9ydCB7IEpTT05FeHQgfSBmcm9tICdAbHVtaW5vL2NvcmV1dGlscyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlRGVsZWdhdGUgfSBmcm9tICdAbHVtaW5vL2Rpc3Bvc2FibGUnO1xuaW1wb3J0IHsgUGxhdGZvcm0sIFNlbGVjdG9yIH0gZnJvbSAnQGx1bWluby9kb211dGlscyc7XG5pbXBvcnQgeyBnZXRLZXlib2FyZExheW91dCB9IGZyb20gJ0BsdW1pbm8va2V5Ym9hcmQnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8qKlxuICogQW4gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYSBjb2xsZWN0aW9uIG9mIGNvbW1hbmRzLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIEEgY29tbWFuZCByZWdpc3RyeSBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIHZhcmlldHkgb2YgYWN0aW9uLWJhc2VkXG4gKiB3aWRnZXRzLCBzdWNoIGFzIGNvbW1hbmQgcGFsZXR0ZXMsIG1lbnVzLCBhbmQgdG9vbGJhcnMuXG4gKi9cbnZhciBDb21tYW5kUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGNvbW1hbmQgcmVnaXN0cnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tbWFuZFJlZ2lzdHJ5KCkge1xuICAgICAgICB0aGlzLl90aW1lcklEID0gMDtcbiAgICAgICAgdGhpcy5fcmVwbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2tleXN0cm9rZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlCaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9leGFjdEtleU1hdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29tbWFuZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9jb21tYW5kQ2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRFeGVjdXRlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2tleUJpbmRpbmdDaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUsIFwiY29tbWFuZENoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIGEgY29tbWFuZCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHNpZ25hbCBpcyB1c2VmdWwgZm9yIHZpc3VhbCByZXByZXNlbnRhdGlvbnMgb2YgY29tbWFuZHMgd2hpY2hcbiAgICAgICAgICogbmVlZCB0byByZWZyZXNoIHdoZW4gdGhlIHN0YXRlIG9mIGEgcmVsZXZhbnQgY29tbWFuZCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRDaGFuZ2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJjb21tYW5kRXhlY3V0ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIGEgY29tbWFuZCBoYXMgZXhlY3V0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogQ2FyZSBzaG91bGQgYmUgdGFrZW4gd2hlbiBjb25zdW1pbmcgdGhpcyBzaWduYWwuIFRoZSBjb21tYW5kIHN5c3RlbSBpcyB1c2VkXG4gICAgICAgICAqIGJ5IG1hbnkgY29tcG9uZW50cyBmb3IgbWFueSB1c2VyIGFjdGlvbnMuIEhhbmRsZXJzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzXG4gICAgICAgICAqIHNpZ25hbCBtdXN0IHJldHVybiBxdWlja2x5IHRvIGVuc3VyZSB0aGUgb3ZlcmFsbCBhcHBsaWNhdGlvbiByZW1haW5zIHJlc3BvbnNpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kRXhlY3V0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLCBcImtleUJpbmRpbmdDaGFuZ2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiBhIGtleSBiaW5kaW5nIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlCaW5kaW5nQ2hhbmdlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUsIFwia2V5QmluZGluZ3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIGtleSBiaW5kaW5ncyBpbiB0aGUgcmVnaXN0cnkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlCaW5kaW5ncztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgaWRzIG9mIHRoZSByZWdpc3RlcmVkIGNvbW1hbmRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgYXJyYXkgb2YgdGhlIHJlZ2lzdGVyZWQgY29tbWFuZCBpZHMuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5saXN0Q29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tYW5kcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBzcGVjaWZpYyBjb21tYW5kIGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbW1hbmQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbW1hbmQgaXMgcmVnaXN0ZXJlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNDb21tYW5kID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCBpbiB0aGlzLl9jb21tYW5kcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbW1hbmQgdG8gdGhlIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBpZCBvZiB0aGUgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBkaXNwb3NhYmxlIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgZ2l2ZW4gYGlkYCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRDb21tYW5kID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBpZCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAgICAgIGlmIChpZCBpbiB0aGlzLl9jb21tYW5kcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWFuZCAnXCIgKyBpZCArIFwiJyBhbHJlYWR5IHJlZ2lzdGVyZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgcmVnaXN0cnkuXG4gICAgICAgIHRoaXMuX2NvbW1hbmRzW2lkXSA9IFByaXZhdGUuY3JlYXRlQ29tbWFuZChvcHRpb25zKTtcbiAgICAgICAgLy8gRW1pdCB0aGUgYGNvbW1hbmRDaGFuZ2VkYCBzaWduYWwuXG4gICAgICAgIHRoaXMuX2NvbW1hbmRDaGFuZ2VkLmVtaXQoeyBpZDogaWQsIHR5cGU6ICdhZGRlZCcgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIGRpc3Bvc2FibGUgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGNvbW1hbmQuXG4gICAgICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZURlbGVnYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgY29tbWFuZCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fY29tbWFuZHNbaWRdO1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgYGNvbW1hbmRDaGFuZ2VkYCBzaWduYWwuXG4gICAgICAgICAgICBfdGhpcy5fY29tbWFuZENoYW5nZWQuZW1pdCh7IGlkOiBpZCwgdHlwZTogJ3JlbW92ZWQnIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vdGlmeSBsaXN0ZW5lcnMgdGhhdCB0aGUgc3RhdGUgb2YgYSBjb21tYW5kIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBjb21tYW5kIHdoaWNoIGhhcyBjaGFuZ2VkLiBJZiBtb3JlIHRoYW5cbiAgICAgKiAgIG9uZSBjb21tYW5kIGhhcyBjaGFuZ2VkLCB0aGlzIGFyZ3VtZW50IHNob3VsZCBiZSBvbWl0dGVkLlxuICAgICAqXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgZ2l2ZW4gYGlkYCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGJ5IHRoZSBjb21tYW5kIGF1dGhvciB3aGVuZXZlciB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiBzdGF0ZSBjaGFuZ2VzIHN1Y2ggdGhhdCB0aGUgcmVzdWx0cyBvZiB0aGUgY29tbWFuZFxuICAgICAqIG1ldGFkYXRhIGZ1bmN0aW9ucyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNhdXNlIHRoZSBgY29tbWFuZENoYW5nZWRgIHNpZ25hbCB0byBiZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUubm90aWZ5Q29tbWFuZENoYW5nZWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgIShpZCBpbiB0aGlzLl9jb21tYW5kcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgJ1wiICsgaWQgKyBcIicgaXMgbm90IHJlZ2lzdGVyZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbW1hbmRDaGFuZ2VkLmVtaXQoeyBpZDogaWQsIHR5cGU6IGlkID8gJ2NoYW5nZWQnIDogJ21hbnktY2hhbmdlZCcgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRpc3BsYXkgbGFiZWwgZm9yIGEgc3BlY2lmaWMgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlzcGxheSBsYWJlbCBmb3IgdGhlIGNvbW1hbmQsIG9yIGFuIGVtcHR5IHN0cmluZ1xuICAgICAqICAgaWYgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLl9jb21tYW5kc1tpZF07XG4gICAgICAgIHJldHVybiBjbWQgPyBjbWQubGFiZWwuY2FsbCh1bmRlZmluZWQsIGFyZ3MpIDogJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1uZW1vbmljIGluZGV4IGZvciBhIHNwZWNpZmljIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbW1hbmQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG1uZW1vbmljIGluZGV4IGZvciB0aGUgY29tbWFuZCwgb3IgYC0xYCBpZiB0aGVcbiAgICAgKiAgIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5tbmVtb25pYyA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLl9jb21tYW5kc1tpZF07XG4gICAgICAgIHJldHVybiBjbWQgPyBjbWQubW5lbW9uaWMuY2FsbCh1bmRlZmluZWQsIGFyZ3MpIDogLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGljb24gcmVuZGVyZXIgZm9yIGEgc3BlY2lmaWMgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIERFUFJFQ0FURUQ6IGlmIHNldCB0byBhIHN0cmluZyB2YWx1ZSwgdGhlIC5pY29uIGZpZWxkIHdpbGxcbiAgICAgKiBmdW5jdGlvbiBhcyBhbiBhbGlhcyBmb3IgdGhlIC5pY29uQ2xhc3MgZmllbGQsIGZvciBiYWNrd2FyZHNcbiAgICAgKiBjb21wYXRpYmlsaXR5LiBJbiB0aGUgZnV0dXJlIHdoZW4gdGhpcyBpcyByZW1vdmVkLCB0aGUgZGVmYXVsdFxuICAgICAqIHJldHVybiB0eXBlIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaWNvbiByZW5kZXJlciBmb3IgdGhlIGNvbW1hbmQsIG9yXG4gICAgICogICBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5pY29uID0gZnVuY3Rpb24gKGlkLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IEpTT05FeHQuZW1wdHlPYmplY3Q7IH1cbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuX2NvbW1hbmRzW2lkXTtcbiAgICAgICAgcmV0dXJuIGNtZCA/IGNtZC5pY29uLmNhbGwodW5kZWZpbmVkLCBhcmdzKSA6IC8qIDxERVBSRUNBVEVEPiAqLyAnJyAvKiA8L0RFUFJFQ0FURUQ+ICovIC8qIDxGVVRVUkU+IHVuZGVmaW5lZCA8L0ZVVFVSRT4gKi87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGljb24gY2xhc3MgZm9yIGEgc3BlY2lmaWMgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaWNvbiBjbGFzcyBmb3IgdGhlIGNvbW1hbmQsIG9yIGFuIGVtcHR5IHN0cmluZyBpZlxuICAgICAqICAgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5pY29uQ2xhc3MgPSBmdW5jdGlvbiAoaWQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gSlNPTkV4dC5lbXB0eU9iamVjdDsgfVxuICAgICAgICB2YXIgY21kID0gdGhpcy5fY29tbWFuZHNbaWRdO1xuICAgICAgICByZXR1cm4gY21kID8gY21kLmljb25DbGFzcy5jYWxsKHVuZGVmaW5lZCwgYXJncykgOiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWNvbiBsYWJlbCBmb3IgYSBzcGVjaWZpYyBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBjb21tYW5kIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpY29uIGxhYmVsIGZvciB0aGUgY29tbWFuZCwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmXG4gICAgICogICB0aGUgY29tbWFuZCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLmljb25MYWJlbCA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLl9jb21tYW5kc1tpZF07XG4gICAgICAgIHJldHVybiBjbWQgPyBjbWQuaWNvbkxhYmVsLmNhbGwodW5kZWZpbmVkLCBhcmdzKSA6ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaG9ydCBmb3JtIGNhcHRpb24gZm9yIGEgc3BlY2lmaWMgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FwdGlvbiBmb3IgdGhlIGNvbW1hbmQsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiB0aGVcbiAgICAgKiAgIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5jYXB0aW9uID0gZnVuY3Rpb24gKGlkLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IEpTT05FeHQuZW1wdHlPYmplY3Q7IH1cbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuX2NvbW1hbmRzW2lkXTtcbiAgICAgICAgcmV0dXJuIGNtZCA/IGNtZC5jYXB0aW9uLmNhbGwodW5kZWZpbmVkLCBhcmdzKSA6ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1c2FnZSBoZWxwIHRleHQgZm9yIGEgc3BlY2lmaWMgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdXNhZ2UgdGV4dCBmb3IgdGhlIGNvbW1hbmQsIG9yIGFuIGVtcHR5IHN0cmluZyBpZlxuICAgICAqICAgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS51c2FnZSA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLl9jb21tYW5kc1tpZF07XG4gICAgICAgIHJldHVybiBjbWQgPyBjbWQudXNhZ2UuY2FsbCh1bmRlZmluZWQsIGFyZ3MpIDogJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV4dHJhIGNsYXNzIG5hbWUgZm9yIGEgc3BlY2lmaWMgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2xhc3MgbmFtZSBmb3IgdGhlIGNvbW1hbmQsIG9yIGFuIGVtcHR5IHN0cmluZyBpZlxuICAgICAqICAgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5jbGFzc05hbWUgPSBmdW5jdGlvbiAoaWQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gSlNPTkV4dC5lbXB0eU9iamVjdDsgfVxuICAgICAgICB2YXIgY21kID0gdGhpcy5fY29tbWFuZHNbaWRdO1xuICAgICAgICByZXR1cm4gY21kID8gY21kLmNsYXNzTmFtZS5jYWxsKHVuZGVmaW5lZCwgYXJncykgOiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGF0YXNldCBmb3IgYSBzcGVjaWZpYyBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBjb21tYW5kIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhc2V0IGZvciB0aGUgY29tbWFuZCwgb3IgYW4gZW1wdHkgZGF0YXNldCBpZlxuICAgICAqICAgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5kYXRhc2V0ID0gZnVuY3Rpb24gKGlkLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IEpTT05FeHQuZW1wdHlPYmplY3Q7IH1cbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuX2NvbW1hbmRzW2lkXTtcbiAgICAgICAgcmV0dXJuIGNtZCA/IGNtZC5kYXRhc2V0LmNhbGwodW5kZWZpbmVkLCBhcmdzKSA6IHt9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEgc3BlY2lmaWMgY29tbWFuZCBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBjb21tYW5kIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbW1hbmQgaXMgZW5hYmxlZCxcbiAgICAgKiAgIG9yIGBmYWxzZWAgaWYgdGhlIGNvbW1hbmQgaXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoaWQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gSlNPTkV4dC5lbXB0eU9iamVjdDsgfVxuICAgICAgICB2YXIgY21kID0gdGhpcy5fY29tbWFuZHNbaWRdO1xuICAgICAgICByZXR1cm4gY21kID8gY21kLmlzRW5hYmxlZC5jYWxsKHVuZGVmaW5lZCwgYXJncykgOiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIHNwZWNpZmljIGNvbW1hbmQgaXMgdG9nZ2xlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgY29tbWFuZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb21tYW5kIGlzIHRvZ2dsZWQsXG4gICAgICogICBvciBgZmFsc2VgIGlmIHRoZSBjb21tYW5kIGlzIG5vdCByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUuaXNUb2dnbGVkID0gZnVuY3Rpb24gKGlkLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IEpTT05FeHQuZW1wdHlPYmplY3Q7IH1cbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuX2NvbW1hbmRzW2lkXTtcbiAgICAgICAgcmV0dXJuIGNtZCA/IGNtZC5pc1RvZ2dsZWQuY2FsbCh1bmRlZmluZWQsIGFyZ3MpIDogZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBzcGVjaWZpYyBjb21tYW5kIGlzIHRvZ2dsZWFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbW1hbmQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29tbWFuZCBpcyB0b2dnbGVhYmxlLFxuICAgICAqICAgb3IgYGZhbHNlYCBpZiB0aGUgY29tbWFuZCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLmlzVG9nZ2xlYWJsZSA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLl9jb21tYW5kc1tpZF07XG4gICAgICAgIHJldHVybiBjbWQgPyBjbWQuaXNUb2dnbGVhYmxlIDogZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBzcGVjaWZpYyBjb21tYW5kIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbW1hbmQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29tbWFuZCBpcyB2aXNpYmxlLFxuICAgICAqICAgb3IgYGZhbHNlYCBpZiB0aGUgY29tbWFuZCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLl9jb21tYW5kc1tpZF07XG4gICAgICAgIHJldHVybiBjbWQgPyBjbWQuaXNWaXNpYmxlLmNhbGwodW5kZWZpbmVkLCBhcmdzKSA6IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIHNwZWNpZmljIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbW1hbmQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb21tYW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgY29tbWFuZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcHJvbWlzZSB3aWxsIHJlamVjdCBpZiB0aGUgY29tbWFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uLFxuICAgICAqIG9yIGlmIHRoZSBjb21tYW5kIGlzIG5vdCByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChpZCwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7IGFyZ3MgPSBKU09ORXh0LmVtcHR5T2JqZWN0OyB9XG4gICAgICAgIC8vIFJlamVjdCBpZiB0aGUgY29tbWFuZCBpcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuX2NvbW1hbmRzW2lkXTtcbiAgICAgICAgaWYgKCFjbWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDb21tYW5kICdcIiArIGlkICsgXCInIG5vdCByZWdpc3RlcmVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY29tbWFuZCBhbmQgcmVqZWN0IGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gY21kLmV4ZWN1dGUuY2FsbCh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHJldHVybiBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRoZSByZXN1bHQuXG4gICAgICAgIHZhciByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAvLyBFbWl0IHRoZSBjb21tYW5kIGV4ZWN1dGVkIHNpZ25hbC5cbiAgICAgICAgdGhpcy5fY29tbWFuZEV4ZWN1dGVkLmVtaXQoeyBpZDogaWQsIGFyZ3M6IGFyZ3MsIHJlc3VsdDogcmVzdWx0IH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBwcm9taXNlIHRvIHRoZSBjYWxsZXIuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkgYmluZGluZyB0byB0aGUgcmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUga2V5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGRpc3Bvc2FibGUgd2hpY2ggcmVtb3ZlcyB0aGUgYWRkZWQga2V5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgbXVsdGlwbGUga2V5IGJpbmRpbmdzIGFyZSByZWdpc3RlcmVkIGZvciB0aGUgc2FtZSBzZXF1ZW5jZSwgdGhlXG4gICAgICogYmluZGluZyB3aXRoIHRoZSBoaWdoZXN0IHNlbGVjdG9yIHNwZWNpZmljaXR5IGlzIGV4ZWN1dGVkIGZpcnN0LiBBXG4gICAgICogdGllIGlzIGJyb2tlbiBieSB1c2luZyB0aGUgbW9zdCByZWNlbnRseSBhZGRlZCBrZXkgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEFtYmlndW91cyBrZXkgYmluZGluZ3MgYXJlIHJlc29sdmVkIHdpdGggYSB0aW1lb3V0LiBBcyBhbiBleGFtcGxlLFxuICAgICAqIHN1cHBvc2UgdHdvIGtleSBiaW5kaW5ncyBhcmUgcmVnaXN0ZXJlZDogb25lIHdpdGggdGhlIGtleSBzZXF1ZW5jZVxuICAgICAqIGBbJ0N0cmwgRCddYCwgYW5kIGFub3RoZXIgd2l0aCBgWydDdHJsIEQnLCAnQ3RybCBXJ11gLiBJZiB0aGUgdXNlclxuICAgICAqIHByZXNzZXMgYEN0cmwgRGAsIHRoZSBmaXJzdCBiaW5kaW5nIGNhbm5vdCBiZSBpbW1lZGlhdGVseSBleGVjdXRlZFxuICAgICAqIHNpbmNlIHRoZSB1c2VyIG1heSBpbnRlbmQgdG8gY29tcGxldGUgdGhlIGNob3JkIHdpdGggYEN0cmwgV2AuIEZvclxuICAgICAqIHN1Y2ggY2FzZXMsIGEgdGltZXIgaXMgdXNlZCB0byBhbGxvdyB0aGUgY2hvcmQgdG8gYmUgY29tcGxldGVkLiBJZlxuICAgICAqIHRoZSBjaG9yZCBpcyBub3QgY29tcGxldGVkIGJlZm9yZSB0aGUgdGltZW91dCwgdGhlIGZpcnN0IGJpbmRpbmdcbiAgICAgKiBpcyBleGVjdXRlZC5cbiAgICAgKi9cbiAgICBDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLmFkZEtleUJpbmRpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGJpbmRpbmcgZm9yIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAgICB2YXIgYmluZGluZyA9IFByaXZhdGUuY3JlYXRlS2V5QmluZGluZyhvcHRpb25zKTtcbiAgICAgICAgLy8gQWRkIHRoZSBrZXkgYmluZGluZyB0byB0aGUgYmluZGluZ3MgYXJyYXkuXG4gICAgICAgIHRoaXMuX2tleUJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gICAgICAgIC8vIEVtaXQgdGhlIGBiaW5kaW5nQ2hhbmdlZGAgc2lnbmFsLlxuICAgICAgICB0aGlzLl9rZXlCaW5kaW5nQ2hhbmdlZC5lbWl0KHsgYmluZGluZzogYmluZGluZywgdHlwZTogJ2FkZGVkJyB9KTtcbiAgICAgICAgLy8gUmV0dXJuIGEgZGlzcG9zYWJsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgYmluZGluZy5cbiAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NhYmxlRGVsZWdhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBiaW5kaW5nIGZyb20gdGhlIGFycmF5LlxuICAgICAgICAgICAgQXJyYXlFeHQucmVtb3ZlRmlyc3RPZihfdGhpcy5fa2V5QmluZGluZ3MsIGJpbmRpbmcpO1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgYGJpbmRpbmdDaGFuZ2VkYCBzaWduYWwuXG4gICAgICAgICAgICBfdGhpcy5fa2V5QmluZGluZ0NoYW5nZWQuZW1pdCh7IGJpbmRpbmc6IGJpbmRpbmcsIHR5cGU6ICdyZW1vdmVkJyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgYCdrZXlkb3duJ2AgZXZlbnQgYW5kIGludm9rZSBhIG1hdGNoaW5nIGtleSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBmb3IgYSBgJ2tleWRvd24nYCBldmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYSBgJ2tleWRvd24nYCBldmVudCBpbiBvcmRlclxuICAgICAqIHRvIGludm9rZSB0aGUgY29tbWFuZCBmb3IgdGhlIGJlc3QgbWF0Y2hpbmcga2V5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgcmVnaXN0cnkgKipkb2VzIG5vdCoqIGluc3RhbGwgaXRzIG93biBsaXN0ZW5lciBmb3IgYCdrZXlkb3duJ2BcbiAgICAgKiBldmVudHMuIFRoaXMgYWxsb3dzIHRoZSBhcHBsaWNhdGlvbiBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgbm9kZXNcbiAgICAgKiBhbmQgcGhhc2UgZm9yIHdoaWNoIHRoZSByZWdpc3RyeSBwcm9jZXNzZXMgYCdrZXlkb3duJ2AgZXZlbnRzLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUga2V5ZG93biBldmVudCBpcyBwcm9jZXNzZWQsIGlmIHRoZSBldmVudCB0YXJnZXQgb3IgYW55IG9mIGl0c1xuICAgICAqIGFuY2VzdG9yIG5vZGVzIGhhcyBhIGBkYXRhLWxtLXN1cHByZXNzLXNob3J0Y3V0c2AgYXR0cmlidXRlLCBpdHMga2V5ZG93blxuICAgICAqIGV2ZW50cyB3aWxsIG5vdCBpbnZva2UgY29tbWFuZHMuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5wcm9jZXNzS2V5ZG93bkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEJhaWwgaW1tZWRpYXRlbHkgaWYgcGxheWluZyBiYWNrIGtleXN0cm9rZXMuXG4gICAgICAgIGlmICh0aGlzLl9yZXBsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQga2V5c3Ryb2tlIGZvciB0aGUgZXZlbnQuXG4gICAgICAgIHZhciBrZXlzdHJva2UgPSBDb21tYW5kUmVnaXN0cnkua2V5c3Ryb2tlRm9yS2V5ZG93bkV2ZW50KGV2ZW50KTtcbiAgICAgICAgLy8gSWYgdGhlIGtleXN0cm9rZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBrZXlib2FyZCBsYXlvdXQsIHJlcGxheVxuICAgICAgICAvLyBhbnkgc3VwcHJlc3NlZCBldmVudHMgYW5kIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXRlLlxuICAgICAgICBpZiAoIWtleXN0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwbGF5S2V5ZG93bkV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGtleXN0cm9rZSB0byB0aGUgY3VycmVudCBrZXkgc2VxdWVuY2UuXG4gICAgICAgIHRoaXMuX2tleXN0cm9rZXMucHVzaChrZXlzdHJva2UpO1xuICAgICAgICAvLyBGaW5kIHRoZSBleGFjdCBhbmQgcGFydGlhbCBtYXRjaGVzIGZvciB0aGUga2V5IHNlcXVlbmNlLlxuICAgICAgICB2YXIgX2EgPSBQcml2YXRlLm1hdGNoS2V5QmluZGluZyh0aGlzLl9rZXlCaW5kaW5ncywgdGhpcy5fa2V5c3Ryb2tlcywgZXZlbnQpLCBleGFjdCA9IF9hLmV4YWN0LCBwYXJ0aWFsID0gX2EucGFydGlhbDtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2ggYW5kIG5vIHBhcnRpYWwgbWF0Y2gsIHJlcGxheVxuICAgICAgICAvLyBhbnkgc3VwcHJlc3NlZCBldmVudHMgYW5kIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXRlLlxuICAgICAgICBpZiAoIWV4YWN0ICYmICFwYXJ0aWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYXlLZXlkb3duRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclBlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LiBJZiB0aGVyZSBpcyBvbmx5IGEgcGFydGlhbCBtYXRjaCxcbiAgICAgICAgLy8gdGhlIGV2ZW50IHdpbGwgYmUgcmVwbGF5ZWQgaWYgYSBmaW5hbCBleGFjdCBtYXRjaCBuZXZlciBvY2N1cnMuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGFjdCBtYXRjaCBidXQgbm8gcGFydGlhbCBtYXRjaCwgdGhlIGV4YWN0IG1hdGNoXG4gICAgICAgIC8vIGNhbiBiZSBkaXNwYXRjaGVkIGltbWVkaWF0ZWx5LiBUaGUgcGVuZGluZyBzdGF0ZSBpcyBjbGVhcmVkIHNvXG4gICAgICAgIC8vIHRoZSBuZXh0IGtleSBwcmVzcyBzdGFydHMgZnJvbSB0aGUgZGVmYXVsdCBzdGF0ZS5cbiAgICAgICAgaWYgKGV4YWN0ICYmICFwYXJ0aWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlS2V5QmluZGluZyhleGFjdCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclBlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGJvdGggYW4gZXhhY3QgbWF0Y2ggYW5kIGEgcGFydGlhbCBtYXRjaCwgdGhlIGV4YWN0XG4gICAgICAgIC8vIG1hdGNoIGlzIHN0b3JlZCBmb3IgZnV0dXJlIGRpc3BhdGNoIGluIGNhc2UgdGhlIHRpbWVyIGV4cGlyZXNcbiAgICAgICAgLy8gYmVmb3JlIGEgbW9yZSBzcGVjaWZpYyBtYXRjaCBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGlmIChleGFjdCkge1xuICAgICAgICAgICAgdGhpcy5fZXhhY3RLZXlNYXRjaCA9IGV4YWN0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBldmVudCBmb3IgcG9zc2libGUgcGxheWJhY2sgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgLy8gKFJlKXN0YXJ0IHRoZSB0aW1lciB0byBkaXNwYXRjaCB0aGUgbW9zdCByZWNlbnQgZXhhY3QgbWF0Y2hcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFydGlhbCBtYXRjaCBmYWlscyB0byByZXN1bHQgaW4gYW4gZXhhY3QgbWF0Y2guXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9yIHJlc3RhcnQgdGhlIHBlbmRpbmcgdGltZW91dC5cbiAgICAgKi9cbiAgICBDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLl9zdGFydFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMuX3RpbWVySUQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25QZW5kaW5nVGltZW91dCgpO1xuICAgICAgICB9LCBQcml2YXRlLkNIT1JEX1RJTUVPVVQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHBlbmRpbmcgdGltZW91dC5cbiAgICAgKi9cbiAgICBDb21tYW5kUmVnaXN0cnkucHJvdG90eXBlLl9jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGltZXJJRCAhPT0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVySUQpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXJJRCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxheSB0aGUga2V5ZG93biBldmVudHMgd2hpY2ggd2VyZSBzdXBwcmVzc2VkLlxuICAgICAqL1xuICAgIENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUuX3JlcGxheUtleWRvd25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9rZXlkb3duRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcGxheWluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleWRvd25FdmVudHMuZm9yRWFjaChQcml2YXRlLnJlcGxheUtleUV2ZW50KTtcbiAgICAgICAgdGhpcy5fcmVwbGF5aW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBjb21tYW5kIGZvciB0aGUgZ2l2ZW4ga2V5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29tbWFuZCBpcyBtaXNzaW5nIG9yIGRpc2FibGVkLCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgQ29tbWFuZFJlZ2lzdHJ5LnByb3RvdHlwZS5fZXhlY3V0ZUtleUJpbmRpbmcgPSBmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGJpbmRpbmcuY29tbWFuZCwgYXJncyA9IGJpbmRpbmcuYXJncztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NvbW1hbmQoY29tbWFuZCkgfHwgIXRoaXMuaXNFbmFibGVkKGNvbW1hbmQsIGFyZ3MpKSB7XG4gICAgICAgICAgICB2YXIgd29yZCA9IHRoaXMuaGFzQ29tbWFuZChjb21tYW5kKSA/ICdlbmFibGVkJyA6ICdyZWdpc3RlcmVkJztcbiAgICAgICAgICAgIHZhciBrZXlzID0gYmluZGluZy5rZXlzLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB2YXIgbXNnMSA9IFwiQ2Fubm90IGV4ZWN1dGUga2V5IGJpbmRpbmcgJ1wiICsga2V5cyArIFwiJzpcIjtcbiAgICAgICAgICAgIHZhciBtc2cyID0gXCJjb21tYW5kICdcIiArIGNvbW1hbmQgKyBcIicgaXMgbm90IFwiICsgd29yZCArIFwiLlwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZzEgKyBcIiBcIiArIG1zZzIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0ZShjb21tYW5kLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBpbnRlcm5hbCBwZW5kaW5nIHN0YXRlLlxuICAgICAqL1xuICAgIENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUuX2NsZWFyUGVuZGluZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gICAgICAgIHRoaXMuX2V4YWN0S2V5TWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXlzdHJva2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2tleWRvd25FdmVudHMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcGFydGlhbCBtYXRjaCB0aW1lb3V0LlxuICAgICAqL1xuICAgIENvbW1hbmRSZWdpc3RyeS5wcm90b3R5cGUuX29uUGVuZGluZ1RpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RpbWVySUQgPSAwO1xuICAgICAgICBpZiAodGhpcy5fZXhhY3RLZXlNYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUtleUJpbmRpbmcodGhpcy5fZXhhY3RLZXlNYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYXlLZXlkb3duRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYXJQZW5kaW5nU3RhdGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tYW5kUmVnaXN0cnk7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYENvbW1hbmRSZWdpc3RyeWAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChDb21tYW5kUmVnaXN0cnkpIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIGtleXN0cm9rZSBpbnRvIGl0cyBjb25zdGl0dWVudCBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleXN0cm9rZSAtIFRoZSBrZXlzdHJva2Ugb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIGNvbXBvbmVudHMgb2YgdGhlIGtleXN0cm9rZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUga2V5c3Ryb2tlIHNob3VsZCBiZSBvZiB0aGUgZm9ybTpcbiAgICAgKiAgIGBbPG1vZGlmaWVyIDE+IFs8bW9kaWZpZXIgMj4gWzxtb2RpZmllciBOPiBdXV08cHJpbWFyeSBrZXk+YFxuICAgICAqXG4gICAgICogVGhlIHN1cHBvcnRlZCBtb2RpZmllcnMgYXJlOiBgQWNjZWxgLCBgQWx0YCwgYENtZGAsIGBDdHJsYCwgYW5kXG4gICAgICogYFNoaWZ0YC4gVGhlIGBBY2NlbGAgbW9kaWZpZXIgaXMgdHJhbnNsYXRlZCB0byBgQ21kYCBvbiBNYWMgYW5kXG4gICAgICogYEN0cmxgIG9uIGFsbCBvdGhlciBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBUaGUgcGFyc2luZyBpcyB0b2xlcmFudCBhbmQgd2lsbCBub3QgdGhyb3cgZXhjZXB0aW9ucy4gTm90YWJseTpcbiAgICAgKiAgIC0gRHVwbGljYXRlIG1vZGlmaWVycyBhcmUgaWdub3JlZC5cbiAgICAgKiAgIC0gRXh0cmEgcHJpbWFyeSBrZXlzIGFyZSBpZ25vcmVkLlxuICAgICAqICAgLSBUaGUgb3JkZXIgb2YgbW9kaWZpZXJzIGFuZCBwcmltYXJ5IGtleSBpcyBpcnJlbGV2YW50LlxuICAgICAqICAgLSBUaGUga2V5c3Ryb2tlIHBhcnRzIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS5cbiAgICAgKiAgIC0gVGhlIGtleXN0cm9rZSBpcyBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUtleXN0cm9rZShrZXlzdHJva2UpIHtcbiAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICB2YXIgYWx0ID0gZmFsc2U7XG4gICAgICAgIHZhciBjbWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN0cmwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNoaWZ0ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBrZXlzdHJva2Uuc3BsaXQoL1xccysvKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ0FjY2VsJykge1xuICAgICAgICAgICAgICAgIGlmIChQbGF0Zm9ybS5JU19NQUMpIHtcbiAgICAgICAgICAgICAgICAgICAgY21kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSAnQWx0Jykge1xuICAgICAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJ0NtZCcpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdDdHJsJykge1xuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdTaGlmdCcpIHtcbiAgICAgICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY21kOiBjbWQsIGN0cmw6IGN0cmwsIGFsdDogYWx0LCBzaGlmdDogc2hpZnQsIGtleToga2V5IH07XG4gICAgfVxuICAgIENvbW1hbmRSZWdpc3RyeS5wYXJzZUtleXN0cm9rZSA9IHBhcnNlS2V5c3Ryb2tlO1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIGtleXN0cm9rZSBpbnRvIGEgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleXN0cm9rZSAtIFRoZSBrZXlzdHJva2Ugb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUga2V5c3Ryb2tlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbm9ybWFsaXplcyB0aGUga2V5c3Ryb2tlIGJ5IHJlbW92aW5nIGR1cGxpY2F0ZSBtb2RpZmllcnMgYW5kXG4gICAgICogZXh0cmEgcHJpbWFyeSBrZXlzLCBhbmQgYXNzZW1ibGluZyB0aGUgcGFydHMgaW4gYSBjYW5vbmljYWwgb3JkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgYENtZGAgbW9kaWZpZXIgaXMgaWdub3JlZCBvbiBub24tTWFjIHBsYXRmb3Jtcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVLZXlzdHJva2Uoa2V5c3Ryb2tlKSB7XG4gICAgICAgIHZhciBtb2RzID0gJyc7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhcnNlS2V5c3Ryb2tlKGtleXN0cm9rZSk7XG4gICAgICAgIGlmIChwYXJ0cy5jdHJsKSB7XG4gICAgICAgICAgICBtb2RzICs9ICdDdHJsICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLmFsdCkge1xuICAgICAgICAgICAgbW9kcyArPSAnQWx0ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLnNoaWZ0KSB7XG4gICAgICAgICAgICBtb2RzICs9ICdTaGlmdCAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5jbWQgJiYgUGxhdGZvcm0uSVNfTUFDKSB7XG4gICAgICAgICAgICBtb2RzICs9ICdDbWQgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kcyArIHBhcnRzLmtleTtcbiAgICB9XG4gICAgQ29tbWFuZFJlZ2lzdHJ5Lm5vcm1hbGl6ZUtleXN0cm9rZSA9IG5vcm1hbGl6ZUtleXN0cm9rZTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBsYXRmb3JtLXNwZWNpZmljIG5vcm1hbGl6ZWQga2V5cyBmb3IgYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUga2V5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBjb21iaW5lZCwgbm9ybWFsaXplZCBrZXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleXMob3B0aW9ucykge1xuICAgICAgICB2YXIga2V5cztcbiAgICAgICAgaWYgKFBsYXRmb3JtLklTX1dJTikge1xuICAgICAgICAgICAga2V5cyA9IG9wdGlvbnMud2luS2V5cyB8fCBvcHRpb25zLmtleXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUGxhdGZvcm0uSVNfTUFDKSB7XG4gICAgICAgICAgICBrZXlzID0gb3B0aW9ucy5tYWNLZXlzIHx8IG9wdGlvbnMua2V5cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBvcHRpb25zLmxpbnV4S2V5cyB8fCBvcHRpb25zLmtleXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXMubWFwKG5vcm1hbGl6ZUtleXN0cm9rZSk7XG4gICAgfVxuICAgIENvbW1hbmRSZWdpc3RyeS5ub3JtYWxpemVLZXlzID0gbm9ybWFsaXplS2V5cztcbiAgICAvKipcbiAgICAgKiBGb3JtYXQgYSBrZXlzdHJva2UgZm9yIGRpc3BsYXkgb24gdGhlIGxvY2FsIHN5c3RlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRLZXlzdHJva2Uoa2V5c3Ryb2tlKSB7XG4gICAgICAgIHZhciBtb2RzID0gJyc7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhcnNlS2V5c3Ryb2tlKGtleXN0cm9rZSk7XG4gICAgICAgIGlmIChQbGF0Zm9ybS5JU19NQUMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5jdHJsKSB7XG4gICAgICAgICAgICAgICAgbW9kcyArPSAnXFx1MjMwMyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRzLmFsdCkge1xuICAgICAgICAgICAgICAgIG1vZHMgKz0gJ1xcdTIzMjUgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cy5zaGlmdCkge1xuICAgICAgICAgICAgICAgIG1vZHMgKz0gJ1xcdTIxRTcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cy5jbWQpIHtcbiAgICAgICAgICAgICAgICBtb2RzICs9ICdcXHUyMzE4ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFydHMuY3RybCkge1xuICAgICAgICAgICAgICAgIG1vZHMgKz0gJ0N0cmwrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cy5hbHQpIHtcbiAgICAgICAgICAgICAgICBtb2RzICs9ICdBbHQrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cy5zaGlmdCkge1xuICAgICAgICAgICAgICAgIG1vZHMgKz0gJ1NoaWZ0Kyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHMgKyBwYXJ0cy5rZXk7XG4gICAgfVxuICAgIENvbW1hbmRSZWdpc3RyeS5mb3JtYXRLZXlzdHJva2UgPSBmb3JtYXRLZXlzdHJva2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbm9ybWFsaXplZCBrZXlzdHJva2UgZm9yIGEgYCdrZXlkb3duJ2AgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGZvciBhIGAna2V5ZG93bidgIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBub3JtYWxpemVkIGtleXN0cm9rZSwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBldmVudFxuICAgICAqICAgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsaWQga2V5c3Ryb2tlIGZvciB0aGUgZ2l2ZW4gbGF5b3V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXN0cm9rZUZvcktleWRvd25FdmVudChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZ2V0S2V5Ym9hcmRMYXlvdXQoKS5rZXlGb3JLZXlkb3duRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RzID0gJyc7XG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICBtb2RzICs9ICdDdHJsICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgbW9kcyArPSAnQWx0ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBtb2RzICs9ICdTaGlmdCAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5tZXRhS2V5ICYmIFBsYXRmb3JtLklTX01BQykge1xuICAgICAgICAgICAgbW9kcyArPSAnQ21kICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHMgKyBrZXk7XG4gICAgfVxuICAgIENvbW1hbmRSZWdpc3RyeS5rZXlzdHJva2VGb3JLZXlkb3duRXZlbnQgPSBrZXlzdHJva2VGb3JLZXlkb3duRXZlbnQ7XG59KShDb21tYW5kUmVnaXN0cnkgfHwgKENvbW1hbmRSZWdpc3RyeSA9IHt9KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGU7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZW91dCBpbiBtcyBmb3IgdHJpZ2dlcmluZyBhIGtleSBiaW5kaW5nIGNob3JkLlxuICAgICAqL1xuICAgIFByaXZhdGUuQ0hPUkRfVElNRU9VVCA9IDEwMDA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbm9ybWFsaXplZCBjb21tYW5kIGZyb20gYW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tbWFuZChvcHRpb25zKSB7XG4gICAgICAgIHZhciBpY29uO1xuICAgICAgICB2YXIgaWNvbkNsYXNzO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgaWYgKCEob3B0aW9ucy5pY29uKSB8fCB0eXBlb2Ygb3B0aW9ucy5pY29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gYWxpYXMgaWNvbiB0byBpY29uQ2xhc3NcbiAgICAgICAgICAgIGljb25DbGFzcyA9IGFzRnVuYyhvcHRpb25zLmljb25DbGFzcyB8fCBvcHRpb25zLmljb24sIGVtcHR5U3RyaW5nRnVuYyk7XG4gICAgICAgICAgICBpY29uID0gaWNvbkNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogLzxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgaWNvbkNsYXNzID0gYXNGdW5jKG9wdGlvbnMuaWNvbkNsYXNzLCBlbXB0eVN0cmluZ0Z1bmMpO1xuICAgICAgICAgICAgaWNvbiA9IGFzRnVuYyhvcHRpb25zLmljb24sIHVuZGVmaW5lZEZ1bmMpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhlY3V0ZTogb3B0aW9ucy5leGVjdXRlLFxuICAgICAgICAgICAgbGFiZWw6IGFzRnVuYyhvcHRpb25zLmxhYmVsLCBlbXB0eVN0cmluZ0Z1bmMpLFxuICAgICAgICAgICAgbW5lbW9uaWM6IGFzRnVuYyhvcHRpb25zLm1uZW1vbmljLCBuZWdhdGl2ZU9uZUZ1bmMpLFxuICAgICAgICAgICAgaWNvbjogaWNvbixcbiAgICAgICAgICAgIGljb25DbGFzczogaWNvbkNsYXNzLFxuICAgICAgICAgICAgaWNvbkxhYmVsOiBhc0Z1bmMob3B0aW9ucy5pY29uTGFiZWwsIGVtcHR5U3RyaW5nRnVuYyksXG4gICAgICAgICAgICBjYXB0aW9uOiBhc0Z1bmMob3B0aW9ucy5jYXB0aW9uLCBlbXB0eVN0cmluZ0Z1bmMpLFxuICAgICAgICAgICAgdXNhZ2U6IGFzRnVuYyhvcHRpb25zLnVzYWdlLCBlbXB0eVN0cmluZ0Z1bmMpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBhc0Z1bmMob3B0aW9ucy5jbGFzc05hbWUsIGVtcHR5U3RyaW5nRnVuYyksXG4gICAgICAgICAgICBkYXRhc2V0OiBhc0Z1bmMob3B0aW9ucy5kYXRhc2V0LCBlbXB0eURhdGFzZXRGdW5jKSxcbiAgICAgICAgICAgIGlzRW5hYmxlZDogb3B0aW9ucy5pc0VuYWJsZWQgfHwgdHJ1ZUZ1bmMsXG4gICAgICAgICAgICBpc1RvZ2dsZWQ6IG9wdGlvbnMuaXNUb2dnbGVkIHx8IGZhbHNlRnVuYyxcbiAgICAgICAgICAgIGlzVG9nZ2xlYWJsZTogb3B0aW9ucy5pc1RvZ2dsZWFibGUgfHwgISFvcHRpb25zLmlzVG9nZ2xlZCxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogb3B0aW9ucy5pc1Zpc2libGUgfHwgdHJ1ZUZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVDb21tYW5kID0gY3JlYXRlQ29tbWFuZDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBrZXkgYmluZGluZyBvYmplY3QgZnJvbSBrZXkgYmluZGluZyBvcHRpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUtleUJpbmRpbmcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5czogQ29tbWFuZFJlZ2lzdHJ5Lm5vcm1hbGl6ZUtleXMob3B0aW9ucyksXG4gICAgICAgICAgICBzZWxlY3RvcjogdmFsaWRhdGVTZWxlY3RvcihvcHRpb25zKSxcbiAgICAgICAgICAgIGNvbW1hbmQ6IG9wdGlvbnMuY29tbWFuZCxcbiAgICAgICAgICAgIGFyZ3M6IG9wdGlvbnMuYXJncyB8fCBKU09ORXh0LmVtcHR5T2JqZWN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlS2V5QmluZGluZyA9IGNyZWF0ZUtleUJpbmRpbmc7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUga2V5IGJpbmRpbmdzIHdoaWNoIG1hdGNoIGEga2V5IHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIGEgbWF0Y2ggcmVzdWx0IHdoaWNoIGNvbnRhaW5zIHRoZSBiZXN0IGV4YWN0IG1hdGNoaW5nXG4gICAgICogYmluZGluZywgYW5kIGEgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlcmUgYXJlIHBhcnRpYWwgbWF0Y2hlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaEtleUJpbmRpbmcoYmluZGluZ3MsIGtleXMsIGV2ZW50KSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGJlc3QgZXhhY3QgbWF0Y2guXG4gICAgICAgIHZhciBleGFjdCA9IG51bGw7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBwYXJ0aWFsIG1hdGNoIGhhcyBiZWVuIGZvdW5kLlxuICAgICAgICB2YXIgcGFydGlhbCA9IGZhbHNlO1xuICAgICAgICAvLyBUaGUgbWF0Y2ggZGlzdGFuY2UgZm9yIHRoZSBleGFjdCBtYXRjaC5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIC8vIFRoZSBzcGVjaWZpY2l0eSBmb3IgdGhlIGV4YWN0IG1hdGNoLlxuICAgICAgICB2YXIgc3BlY2lmaWNpdHkgPSAwO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGJpbmRpbmdzIGFuZCBzZWFyY2ggZm9yIHRoZSBiZXN0IG1hdGNoLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSBjdXJyZW50IGJpbmRpbmcuXG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUga2V5IGJpbmRpbmcgc2VxdWVuY2UgaXMgYSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBzcW0gPSBtYXRjaFNlcXVlbmNlKGJpbmRpbmcua2V5cywga2V5cyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBtYXRjaCwgdGhlIGJpbmRpbmcgaXMgaWdub3JlZC5cbiAgICAgICAgICAgIGlmIChzcW0gPT09IDAgLyogTm9uZSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBwYXJ0aWFsIG1hdGNoIGFuZCBubyBvdGhlciBwYXJ0aWFsIG1hdGNoIGhhcyBiZWVuXG4gICAgICAgICAgICAvLyBmb3VuZCwgZW5zdXJlIHRoZSBzZWxlY3RvciBtYXRjaGVzIGFuZCBzZXQgdGhlIHBhcnRpYWwgZmxhZy5cbiAgICAgICAgICAgIGlmIChzcW0gPT09IDIgLyogUGFydGlhbCAqLykge1xuICAgICAgICAgICAgICAgIGlmICghcGFydGlhbCAmJiB0YXJnZXREaXN0YW5jZShiaW5kaW5nLnNlbGVjdG9yLCBldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgbWF0Y2ggaWYgdGhlIHNlbGVjdG9yIGRvZXNuJ3QgbWF0Y2gsIG9yIGlmIHRoZVxuICAgICAgICAgICAgLy8gbWF0Y2hlZCBub2RlIGlzIGZhcnRoZXIgYXdheSB0aGFuIHRoZSBjdXJyZW50IGJlc3QgbWF0Y2guXG4gICAgICAgICAgICB2YXIgdGQgPSB0YXJnZXREaXN0YW5jZShiaW5kaW5nLnNlbGVjdG9yLCBldmVudCk7XG4gICAgICAgICAgICBpZiAodGQgPT09IC0xIHx8IHRkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY2lmaWNpdHkgZm9yIHRoZSBzZWxlY3Rvci5cbiAgICAgICAgICAgIHZhciBzcCA9IFNlbGVjdG9yLmNhbGN1bGF0ZVNwZWNpZmljaXR5KGJpbmRpbmcuc2VsZWN0b3IpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBiZXN0IG1hdGNoIGlmIHRoaXMgbWF0Y2ggaXMgc3Ryb25nZXIuXG4gICAgICAgICAgICBpZiAoIWV4YWN0IHx8IHRkIDwgZGlzdGFuY2UgfHwgc3AgPj0gc3BlY2lmaWNpdHkpIHtcbiAgICAgICAgICAgICAgICBleGFjdCA9IGJpbmRpbmc7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSB0ZDtcbiAgICAgICAgICAgICAgICBzcGVjaWZpY2l0eSA9IHNwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgbWF0Y2ggcmVzdWx0LlxuICAgICAgICByZXR1cm4geyBleGFjdDogZXhhY3QsIHBhcnRpYWw6IHBhcnRpYWwgfTtcbiAgICB9XG4gICAgUHJpdmF0ZS5tYXRjaEtleUJpbmRpbmcgPSBtYXRjaEtleUJpbmRpbmc7XG4gICAgLyoqXG4gICAgICogUmVwbGF5IGEga2V5Ym9hcmQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHN5bnRoZXRpY2FsbHkgZGlzcGF0Y2hlcyBhIGNsb25lIG9mIHRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYXlLZXlFdmVudChldmVudCkge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzcGF0Y2hFdmVudChjbG9uZUtleWJvYXJkRXZlbnQoZXZlbnQpKTtcbiAgICB9XG4gICAgUHJpdmF0ZS5yZXBsYXlLZXlFdmVudCA9IHJlcGxheUtleUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEEgc2luZ2xldG9uIGVtcHR5IHN0cmluZyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgZW1wdHlTdHJpbmdGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH07XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGV0b24gYC0xYCBudW1iZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB2YXIgbmVnYXRpdmVPbmVGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTE7IH07XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGV0b24gdHJ1ZSBib29sZWFuIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciB0cnVlRnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGV0b24gZmFsc2UgYm9vbGVhbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgZmFsc2VGdW5jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGV0b24gZW1wdHkgZGF0YXNldCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgZW1wdHlEYXRhc2V0RnVuYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7fSk7IH07XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGV0b24gdW5kZWZpbmVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmFyIHVuZGVmaW5lZEZ1bmMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgLyoqXG4gICAgICogQ2FzdCBhIHZhbHVlIG9yIGNvbW1hbmQgZnVuYyB0byBhIGNvbW1hbmQgZnVuYy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc0Z1bmModmFsdWUsIGRmYXVsdCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0b3IgZm9yIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIHRoZSB2YWxpZGF0ZWQgc2VsZWN0b3IsIG9yIHRocm93cyBpZiB0aGUgc2VsZWN0b3IgaXNcbiAgICAgKiBpbnZhbGlkIG9yIGNvbnRhaW5zIGNvbW1hcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVNlbGVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2VsZWN0b3IuaW5kZXhPZignLCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3IgY2Fubm90IGNvbnRhaW4gY29tbWFzOiBcIiArIG9wdGlvbnMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU2VsZWN0b3IuaXNWYWxpZChvcHRpb25zLnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvcjogXCIgKyBvcHRpb25zLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5zZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEga2V5IGJpbmRpbmcgc2VxdWVuY2UgbWF0Y2hlcyBhIGtleSBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBgU2VxdWVuY2VNYXRjaGAgdmFsdWUgaW5kaWNhdGluZyB0aGUgdHlwZSBvZiBtYXRjaC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaFNlcXVlbmNlKGJpbmRLZXlzLCB1c2VyS2V5cykge1xuICAgICAgICBpZiAoYmluZEtleXMubGVuZ3RoIDwgdXNlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdXNlcktleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYmluZEtleXNbaV0gIT09IHVzZXJLZXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZEtleXMubGVuZ3RoID4gdXNlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBQYXJ0aWFsICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxIC8qIEV4YWN0ICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0YXJnZXQgbm9kZSB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgdHJhdmVyc2VzIHRoZSBldmVudCBwYXRoIGZyb20gYHRhcmdldGAgdG8gYGN1cnJlbnRUYXJnZXRgIGFuZFxuICAgICAqIGNvbXB1dGVzIHRoZSBkaXN0YW5jZSBmcm9tIGB0YXJnZXRgIHRvIHRoZSBmaXJzdCBub2RlIHdoaWNoIG1hdGNoZXNcbiAgICAgKiB0aGUgQ1NTIHNlbGVjdG9yLiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgYC0xYCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXJnZXREaXN0YW5jZShzZWxlY3RvciwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmcgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBjdXJyID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgZm9yICh2YXIgZGlzdCA9IDA7IHRhcmcgIT09IG51bGw7IHRhcmcgPSB0YXJnLnBhcmVudEVsZW1lbnQsICsrZGlzdCkge1xuICAgICAgICAgICAgaWYgKHRhcmcuaGFzQXR0cmlidXRlKCdkYXRhLWxtLXN1cHByZXNzLXNob3J0Y3V0cycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAodGFyZy5oYXNBdHRyaWJ1dGUoJ2RhdGEtcC1zdXBwcmVzcy1zaG9ydGN1dHMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIGlmIChTZWxlY3Rvci5tYXRjaGVzKHRhcmcsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmcgPT09IGN1cnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSBhIGtleWJvYXJkIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lS2V5Ym9hcmRFdmVudChldmVudCkge1xuICAgICAgICAvLyBBIGN1c3RvbSBldmVudCBpcyByZXF1aXJlZCBiZWNhdXNlIENocm9tZSBudWxscyBvdXQgdGhlXG4gICAgICAgIC8vIGBrZXlDb2RlYCBmaWVsZCBpbiB1c2VyLWdlbmVyYXRlZCBgS2V5Ym9hcmRFdmVudGAgdHlwZXMuXG4gICAgICAgIHZhciBjbG9uZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICB2YXIgYnViYmxlcyA9IGV2ZW50LmJ1YmJsZXMgfHwgdHJ1ZTtcbiAgICAgICAgdmFyIGNhbmNlbGFibGUgPSBldmVudC5jYW5jZWxhYmxlIHx8IHRydWU7XG4gICAgICAgIGNsb25lLmluaXRFdmVudChldmVudC50eXBlIHx8ICdrZXlkb3duJywgYnViYmxlcywgY2FuY2VsYWJsZSk7XG4gICAgICAgIGNsb25lLmtleSA9IGV2ZW50LmtleSB8fCAnJztcbiAgICAgICAgY2xvbmUua2V5Q29kZSA9IGV2ZW50LmtleUNvZGUgfHwgMDtcbiAgICAgICAgY2xvbmUud2hpY2ggPSBldmVudC5rZXlDb2RlIHx8IDA7XG4gICAgICAgIGNsb25lLmN0cmxLZXkgPSBldmVudC5jdHJsS2V5IHx8IGZhbHNlO1xuICAgICAgICBjbG9uZS5hbHRLZXkgPSBldmVudC5hbHRLZXkgfHwgZmFsc2U7XG4gICAgICAgIGNsb25lLnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXkgfHwgZmFsc2U7XG4gICAgICAgIGNsb25lLm1ldGFLZXkgPSBldmVudC5tZXRhS2V5IHx8IGZhbHNlO1xuICAgICAgICBjbG9uZS52aWV3ID0gZXZlbnQudmlldyB8fCB3aW5kb3c7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcblxuZXhwb3J0IHsgQ29tbWFuZFJlZ2lzdHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/commands/dist/index.es6.js\n")},"./node_modules/@lumino/coreutils/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"JSONExt\": () => (/* binding */ JSONExt),\n/* harmony export */   \"MimeData\": () => (/* binding */ MimeData),\n/* harmony export */   \"PromiseDelegate\": () => (/* binding */ PromiseDelegate),\n/* harmony export */   \"Random\": () => (/* binding */ Random),\n/* harmony export */   \"Token\": () => (/* binding */ Token),\n/* harmony export */   \"UUID\": () => (/* binding */ UUID)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for JSON-specific functions.\n */\nvar JSONExt;\n(function (JSONExt) {\n    /**\n     * A shared frozen empty JSONObject\n     */\n    JSONExt.emptyObject = Object.freeze({});\n    /**\n     * A shared frozen empty JSONArray\n     */\n    JSONExt.emptyArray = Object.freeze([]);\n    /**\n     * Test whether a JSON value is a primitive.\n     *\n     * @param value - The JSON value of interest.\n     *\n     * @returns `true` if the value is a primitive,`false` otherwise.\n     */\n    function isPrimitive(value) {\n        return (value === null ||\n            typeof value === 'boolean' ||\n            typeof value === 'number' ||\n            typeof value === 'string');\n    }\n    JSONExt.isPrimitive = isPrimitive;\n    function isArray(value) {\n        return Array.isArray(value);\n    }\n    JSONExt.isArray = isArray;\n    function isObject(value) {\n        return !isPrimitive(value) && !isArray(value);\n    }\n    JSONExt.isObject = isObject;\n    /**\n     * Compare two JSON values for deep equality.\n     *\n     * @param first - The first JSON value of interest.\n     *\n     * @param second - The second JSON value of interest.\n     *\n     * @returns `true` if the values are equivalent, `false` otherwise.\n     */\n    function deepEqual(first, second) {\n        // Check referential and primitive equality first.\n        if (first === second) {\n            return true;\n        }\n        // If one is a primitive, the `===` check ruled out the other.\n        if (isPrimitive(first) || isPrimitive(second)) {\n            return false;\n        }\n        // Test whether they are arrays.\n        var a1 = isArray(first);\n        var a2 = isArray(second);\n        // Bail if the types are different.\n        if (a1 !== a2) {\n            return false;\n        }\n        // If they are both arrays, compare them.\n        if (a1 && a2) {\n            return deepArrayEqual(first, second);\n        }\n        // At this point, they must both be objects.\n        return deepObjectEqual(first, second);\n    }\n    JSONExt.deepEqual = deepEqual;\n    /**\n     * Create a deep copy of a JSON value.\n     *\n     * @param value - The JSON value to copy.\n     *\n     * @returns A deep copy of the given JSON value.\n     */\n    function deepCopy(value) {\n        // Do nothing for primitive values.\n        if (isPrimitive(value)) {\n            return value;\n        }\n        // Deep copy an array.\n        if (isArray(value)) {\n            return deepArrayCopy(value);\n        }\n        // Deep copy an object.\n        return deepObjectCopy(value);\n    }\n    JSONExt.deepCopy = deepCopy;\n    /**\n     * Compare two JSON arrays for deep equality.\n     */\n    function deepArrayEqual(first, second) {\n        // Check referential equality first.\n        if (first === second) {\n            return true;\n        }\n        // Test the arrays for equal length.\n        if (first.length !== second.length) {\n            return false;\n        }\n        // Compare the values for equality.\n        for (var i = 0, n = first.length; i < n; ++i) {\n            if (!deepEqual(first[i], second[i])) {\n                return false;\n            }\n        }\n        // At this point, the arrays are equal.\n        return true;\n    }\n    /**\n     * Compare two JSON objects for deep equality.\n     */\n    function deepObjectEqual(first, second) {\n        // Check referential equality first.\n        if (first === second) {\n            return true;\n        }\n        // Check for the first object's keys in the second object.\n        for (var key in first) {\n            if (first[key] !== undefined && !(key in second)) {\n                return false;\n            }\n        }\n        // Check for the second object's keys in the first object.\n        for (var key in second) {\n            if (second[key] !== undefined && !(key in first)) {\n                return false;\n            }\n        }\n        // Compare the values for equality.\n        for (var key in first) {\n            // Get the values.\n            var firstValue = first[key];\n            var secondValue = second[key];\n            // If both are undefined, ignore the key.\n            if (firstValue === undefined && secondValue === undefined) {\n                continue;\n            }\n            // If only one value is undefined, the objects are not equal.\n            if (firstValue === undefined || secondValue === undefined) {\n                return false;\n            }\n            // Compare the values.\n            if (!deepEqual(firstValue, secondValue)) {\n                return false;\n            }\n        }\n        // At this point, the objects are equal.\n        return true;\n    }\n    /**\n     * Create a deep copy of a JSON array.\n     */\n    function deepArrayCopy(value) {\n        var result = new Array(value.length);\n        for (var i = 0, n = value.length; i < n; ++i) {\n            result[i] = deepCopy(value[i]);\n        }\n        return result;\n    }\n    /**\n     * Create a deep copy of a JSON object.\n     */\n    function deepObjectCopy(value) {\n        var result = {};\n        for (var key in value) {\n            // Ignore undefined values.\n            var subvalue = value[key];\n            if (subvalue === undefined) {\n                continue;\n            }\n            result[key] = deepCopy(subvalue);\n        }\n        return result;\n    }\n})(JSONExt || (JSONExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * An object which stores MIME data for general application use.\n *\n * #### Notes\n * This class does not attempt to enforce \"correctness\" of MIME types\n * and their associated data. Since this class is designed to transfer\n * arbitrary data and objects within the same application, it assumes\n * that the user provides correct and accurate data.\n */\nvar MimeData = /** @class */ (function () {\n    function MimeData() {\n        this._types = [];\n        this._values = [];\n    }\n    /**\n     * Get an array of the MIME types contained within the dataset.\n     *\n     * @returns A new array of the MIME types, in order of insertion.\n     */\n    MimeData.prototype.types = function () {\n        return this._types.slice();\n    };\n    /**\n     * Test whether the dataset has an entry for the given type.\n     *\n     * @param mime - The MIME type of interest.\n     *\n     * @returns `true` if the dataset contains a value for the given\n     *   MIME type, `false` otherwise.\n     */\n    MimeData.prototype.hasData = function (mime) {\n        return this._types.indexOf(mime) !== -1;\n    };\n    /**\n     * Get the data value for the given MIME type.\n     *\n     * @param mime - The MIME type of interest.\n     *\n     * @returns The value for the given MIME type, or `undefined` if\n     *   the dataset does not contain a value for the type.\n     */\n    MimeData.prototype.getData = function (mime) {\n        var i = this._types.indexOf(mime);\n        return i !== -1 ? this._values[i] : undefined;\n    };\n    /**\n     * Set the data value for the given MIME type.\n     *\n     * @param mime - The MIME type of interest.\n     *\n     * @param data - The data value for the given MIME type.\n     *\n     * #### Notes\n     * This will overwrite any previous entry for the MIME type.\n     */\n    MimeData.prototype.setData = function (mime, data) {\n        this.clearData(mime);\n        this._types.push(mime);\n        this._values.push(data);\n    };\n    /**\n     * Remove the data entry for the given MIME type.\n     *\n     * @param mime - The MIME type of interest.\n     *\n     * #### Notes\n     * This is a no-op if there is no entry for the given MIME type.\n     */\n    MimeData.prototype.clearData = function (mime) {\n        var i = this._types.indexOf(mime);\n        if (i !== -1) {\n            this._types.splice(i, 1);\n            this._values.splice(i, 1);\n        }\n    };\n    /**\n     * Remove all data entries from the dataset.\n     */\n    MimeData.prototype.clear = function () {\n        this._types.length = 0;\n        this._values.length = 0;\n    };\n    return MimeData;\n}());\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A class which wraps a promise into a delegate object.\n *\n * #### Notes\n * This class is useful when the logic to resolve or reject a promise\n * cannot be defined at the point where the promise is created.\n */\nvar PromiseDelegate = /** @class */ (function () {\n    /**\n     * Construct a new promise delegate.\n     */\n    function PromiseDelegate() {\n        var _this = this;\n        this.promise = new Promise(function (resolve, reject) {\n            _this._resolve = resolve;\n            _this._reject = reject;\n        });\n    }\n    /**\n     * Resolve the wrapped promise with the given value.\n     *\n     * @param value - The value to use for resolving the promise.\n     */\n    PromiseDelegate.prototype.resolve = function (value) {\n        var resolve = this._resolve;\n        resolve(value);\n    };\n    /**\n     * Reject the wrapped promise with the given value.\n     *\n     * @reason - The reason for rejecting the promise.\n     */\n    PromiseDelegate.prototype.reject = function (reason) {\n        var reject = this._reject;\n        reject(reason);\n    };\n    return PromiseDelegate;\n}());\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for random number related functionality.\n */\nvar Random;\n(function (Random) {\n    /**\n     * A function which generates random bytes.\n     *\n     * @param buffer - The `Uint8Array` to fill with random bytes.\n     *\n     * #### Notes\n     * A cryptographically strong random number generator will be used if\n     * available. Otherwise, `Math.random` will be used as a fallback for\n     * randomness.\n     *\n     * The following RNGs are supported, listed in order of precedence:\n     *   - `window.crypto.getRandomValues`\n     *   - `window.msCrypto.getRandomValues`\n     *   - `require('crypto').randomFillSync\n     *   - `require('crypto').randomBytes\n     *   - `Math.random`\n     */\n    Random.getRandomValues = (function () {\n        // Look up the crypto module if available.\n        var crypto = ((typeof window !== 'undefined' && (window.crypto || window.msCrypto)) ||\n            ( true && __webpack_require__(\"?b7e7\")) || null);\n        // Modern browsers and IE 11\n        if (crypto && typeof crypto.getRandomValues === 'function') {\n            return function getRandomValues(buffer) {\n                return crypto.getRandomValues(buffer);\n            };\n        }\n        // Node 7+\n        if (crypto && typeof crypto.randomFillSync === 'function') {\n            return function getRandomValues(buffer) {\n                return crypto.randomFillSync(buffer);\n            };\n        }\n        // Node 0.10+\n        if (crypto && typeof crypto.randomBytes === 'function') {\n            return function getRandomValues(buffer) {\n                var bytes = crypto.randomBytes(buffer.length);\n                for (var i = 0, n = bytes.length; i < n; ++i) {\n                    buffer[i] = bytes[i];\n                }\n            };\n        }\n        // Fallback\n        return function getRandomValues(buffer) {\n            var value = 0;\n            for (var i = 0, n = buffer.length; i < n; ++i) {\n                if (i % 4 === 0) {\n                    value = Math.random() * 0xFFFFFFFF >>> 0;\n                }\n                buffer[i] = value & 0xFF;\n                value >>>= 8;\n            }\n        };\n    })();\n})(Random || (Random = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A runtime object which captures compile-time type information.\n *\n * #### Notes\n * A token captures the compile-time type of an interface or class in\n * an object which can be used at runtime in a type-safe fashion.\n */\nvar Token = /** @class */ (function () {\n    /**\n     * Construct a new token.\n     *\n     * @param name - A human readable name for the token.\n     */\n    function Token(name) {\n        this.name = name;\n        this._tokenStructuralPropertyT = null;\n    }\n    return Token;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * The namespace for UUID related functionality.\n */\nvar UUID;\n(function (UUID) {\n    /**\n     * A function which generates UUID v4 identifiers.\n     *\n     * @returns A new UUID v4 string.\n     *\n     * #### Notes\n     * This implementation complies with RFC 4122.\n     *\n     * This uses `Random.getRandomValues()` for random bytes, which in\n     * turn will use the underlying `crypto` module of the platform if\n     * it is available. The fallback for randomness is `Math.random`.\n     */\n    UUID.uuid4 = (function () {\n        // Create a 16 byte array to hold the random values.\n        var bytes = new Uint8Array(16);\n        // Create a look up table from bytes to hex strings.\n        var lut = new Array(256);\n        // Pad the single character hex digits with a leading zero.\n        for (var i = 0; i < 16; ++i) {\n            lut[i] = '0' + i.toString(16);\n        }\n        // Populate the rest of the hex digits.\n        for (var i = 16; i < 256; ++i) {\n            lut[i] = i.toString(16);\n        }\n        // Return a function which generates the UUID.\n        return function uuid4() {\n            // Get a new batch of random values.\n            Random.getRandomValues(bytes);\n            // Set the UUID version number to 4.\n            bytes[6] = 0x40 | (bytes[6] & 0x0F);\n            // Set the clock sequence bit to the RFC spec.\n            bytes[8] = 0x80 | (bytes[8] & 0x3F);\n            // Assemble the UUID string.\n            return (lut[bytes[0]] +\n                lut[bytes[1]] +\n                lut[bytes[2]] +\n                lut[bytes[3]] +\n                '-' +\n                lut[bytes[4]] +\n                lut[bytes[5]] +\n                '-' +\n                lut[bytes[6]] +\n                lut[bytes[7]] +\n                '-' +\n                lut[bytes[8]] +\n                lut[bytes[9]] +\n                '-' +\n                lut[bytes[10]] +\n                lut[bytes[11]] +\n                lut[bytes[12]] +\n                lut[bytes[13]] +\n                lut[bytes[14]] +\n                lut[bytes[15]]);\n        };\n    })();\n})(UUID || (UUID = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9jb3JldXRpbHMvZGlzdC9pbmRleC5lczYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUE4QixJQUFJLG1CQUFPLENBQUMsT0FBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyx3QkFBd0I7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLG9CQUFvQjs7QUFFOEM7QUFDbkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWZzaGluL2xpZmUvLi9ub2RlX21vZHVsZXMvQGx1bWluby9jb3JldXRpbHMvZGlzdC9pbmRleC5lczYuanM/OWQ2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgSlNPTi1zcGVjaWZpYyBmdW5jdGlvbnMuXG4gKi9cbnZhciBKU09ORXh0O1xuKGZ1bmN0aW9uIChKU09ORXh0KSB7XG4gICAgLyoqXG4gICAgICogQSBzaGFyZWQgZnJvemVuIGVtcHR5IEpTT05PYmplY3RcbiAgICAgKi9cbiAgICBKU09ORXh0LmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyoqXG4gICAgICogQSBzaGFyZWQgZnJvemVuIGVtcHR5IEpTT05BcnJheVxuICAgICAqL1xuICAgIEpTT05FeHQuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pO1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIEpTT04gdmFsdWUgaXMgYSBwcmltaXRpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgSlNPTiB2YWx1ZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBwcmltaXRpdmUsYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xuICAgIH1cbiAgICBKU09ORXh0LmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIEpTT05FeHQuaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICFpc1ByaW1pdGl2ZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBKU09ORXh0LmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gSlNPTiB2YWx1ZXMgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlyc3QgLSBUaGUgZmlyc3QgSlNPTiB2YWx1ZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWNvbmQgLSBUaGUgc2Vjb25kIEpTT04gdmFsdWUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcEVxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgLy8gQ2hlY2sgcmVmZXJlbnRpYWwgYW5kIHByaW1pdGl2ZSBlcXVhbGl0eSBmaXJzdC5cbiAgICAgICAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIGA9PT1gIGNoZWNrIHJ1bGVkIG91dCB0aGUgb3RoZXIuXG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZShmaXJzdCkgfHwgaXNQcmltaXRpdmUoc2Vjb25kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGV5IGFyZSBhcnJheXMuXG4gICAgICAgIHZhciBhMSA9IGlzQXJyYXkoZmlyc3QpO1xuICAgICAgICB2YXIgYTIgPSBpc0FycmF5KHNlY29uZCk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIHR5cGVzIGFyZSBkaWZmZXJlbnQuXG4gICAgICAgIGlmIChhMSAhPT0gYTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGV5IGFyZSBib3RoIGFycmF5cywgY29tcGFyZSB0aGVtLlxuICAgICAgICBpZiAoYTEgJiYgYTIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwQXJyYXlFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGV5IG11c3QgYm90aCBiZSBvYmplY3RzLlxuICAgICAgICByZXR1cm4gZGVlcE9iamVjdEVxdWFsKGZpcnN0LCBzZWNvbmQpO1xuICAgIH1cbiAgICBKU09ORXh0LmRlZXBFcXVhbCA9IGRlZXBFcXVhbDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgYSBKU09OIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIEpTT04gdmFsdWUgdG8gY29weS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWVwIGNvcHkgYW4gYXJyYXkuXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBBcnJheUNvcHkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZXAgY29weSBhbiBvYmplY3QuXG4gICAgICAgIHJldHVybiBkZWVwT2JqZWN0Q29weSh2YWx1ZSk7XG4gICAgfVxuICAgIEpTT05FeHQuZGVlcENvcHkgPSBkZWVwQ29weTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBKU09OIGFycmF5cyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwQXJyYXlFcXVhbChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIC8vIENoZWNrIHJlZmVyZW50aWFsIGVxdWFsaXR5IGZpcnN0LlxuICAgICAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCB0aGUgYXJyYXlzIGZvciBlcXVhbCBsZW5ndGguXG4gICAgICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIHRoZSB2YWx1ZXMgZm9yIGVxdWFsaXR5LlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGZpcnN0Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGFycmF5cyBhcmUgZXF1YWwuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBKU09OIG9iamVjdHMgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcE9iamVjdEVxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgLy8gQ2hlY2sgcmVmZXJlbnRpYWwgZXF1YWxpdHkgZmlyc3QuXG4gICAgICAgIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGZpcnN0IG9iamVjdCdzIGtleXMgaW4gdGhlIHNlY29uZCBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0W2tleV0gIT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBzZWNvbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgc2Vjb25kIG9iamVjdCdzIGtleXMgaW4gdGhlIGZpcnN0IG9iamVjdC5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNlY29uZCkge1xuICAgICAgICAgICAgaWYgKHNlY29uZFtrZXldICE9PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBhcmUgdGhlIHZhbHVlcyBmb3IgZXF1YWxpdHkuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZXMuXG4gICAgICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGZpcnN0W2tleV07XG4gICAgICAgICAgICB2YXIgc2Vjb25kVmFsdWUgPSBzZWNvbmRba2V5XTtcbiAgICAgICAgICAgIC8vIElmIGJvdGggYXJlIHVuZGVmaW5lZCwgaWdub3JlIHRoZSBrZXkuXG4gICAgICAgICAgICBpZiAoZmlyc3RWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHNlY29uZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIHZhbHVlIGlzIHVuZGVmaW5lZCwgdGhlIG9iamVjdHMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgICAgIGlmIChmaXJzdFZhbHVlID09PSB1bmRlZmluZWQgfHwgc2Vjb25kVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXBhcmUgdGhlIHZhbHVlcy5cbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGZpcnN0VmFsdWUsIHNlY29uZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgb2JqZWN0cyBhcmUgZXF1YWwuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgYSBKU09OIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBBcnJheUNvcHkodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZhbHVlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gZGVlcENvcHkodmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiBhIEpTT04gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBPYmplY3RDb3B5KHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdW5kZWZpbmVkIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBzdWJ2YWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICBpZiAoc3VidmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwQ29weShzdWJ2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KShKU09ORXh0IHx8IChKU09ORXh0ID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgUGhvc3Bob3JKUyBDb250cmlidXRvcnNcbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBMSUNFTlNFLCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEFuIG9iamVjdCB3aGljaCBzdG9yZXMgTUlNRSBkYXRhIGZvciBnZW5lcmFsIGFwcGxpY2F0aW9uIHVzZS5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGNsYXNzIGRvZXMgbm90IGF0dGVtcHQgdG8gZW5mb3JjZSBcImNvcnJlY3RuZXNzXCIgb2YgTUlNRSB0eXBlc1xuICogYW5kIHRoZWlyIGFzc29jaWF0ZWQgZGF0YS4gU2luY2UgdGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byB0cmFuc2ZlclxuICogYXJiaXRyYXJ5IGRhdGEgYW5kIG9iamVjdHMgd2l0aGluIHRoZSBzYW1lIGFwcGxpY2F0aW9uLCBpdCBhc3N1bWVzXG4gKiB0aGF0IHRoZSB1c2VyIHByb3ZpZGVzIGNvcnJlY3QgYW5kIGFjY3VyYXRlIGRhdGEuXG4gKi9cbnZhciBNaW1lRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaW1lRGF0YSgpIHtcbiAgICAgICAgdGhpcy5fdHlwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhcnJheSBvZiB0aGUgTUlNRSB0eXBlcyBjb250YWluZWQgd2l0aGluIHRoZSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgYXJyYXkgb2YgdGhlIE1JTUUgdHlwZXMsIGluIG9yZGVyIG9mIGluc2VydGlvbi5cbiAgICAgKi9cbiAgICBNaW1lRGF0YS5wcm90b3R5cGUudHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlcy5zbGljZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoZSBkYXRhc2V0IGhhcyBhbiBlbnRyeSBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWltZSAtIFRoZSBNSU1FIHR5cGUgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRhdGFzZXQgY29udGFpbnMgYSB2YWx1ZSBmb3IgdGhlIGdpdmVuXG4gICAgICogICBNSU1FIHR5cGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIE1pbWVEYXRhLnByb3RvdHlwZS5oYXNEYXRhID0gZnVuY3Rpb24gKG1pbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVzLmluZGV4T2YobWltZSkgIT09IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXRhIHZhbHVlIGZvciB0aGUgZ2l2ZW4gTUlNRSB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbWUgLSBUaGUgTUlNRSB0eXBlIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gTUlNRSB0eXBlLCBvciBgdW5kZWZpbmVkYCBpZlxuICAgICAqICAgdGhlIGRhdGFzZXQgZG9lcyBub3QgY29udGFpbiBhIHZhbHVlIGZvciB0aGUgdHlwZS5cbiAgICAgKi9cbiAgICBNaW1lRGF0YS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChtaW1lKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fdHlwZXMuaW5kZXhPZihtaW1lKTtcbiAgICAgICAgcmV0dXJuIGkgIT09IC0xID8gdGhpcy5fdmFsdWVzW2ldIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkYXRhIHZhbHVlIGZvciB0aGUgZ2l2ZW4gTUlNRSB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbWUgLSBUaGUgTUlNRSB0eXBlIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB2YWx1ZSBmb3IgdGhlIGdpdmVuIE1JTUUgdHlwZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBlbnRyeSBmb3IgdGhlIE1JTUUgdHlwZS5cbiAgICAgKi9cbiAgICBNaW1lRGF0YS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChtaW1lLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEYXRhKG1pbWUpO1xuICAgICAgICB0aGlzLl90eXBlcy5wdXNoKG1pbWUpO1xuICAgICAgICB0aGlzLl92YWx1ZXMucHVzaChkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZGF0YSBlbnRyeSBmb3IgdGhlIGdpdmVuIE1JTUUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW1lIC0gVGhlIE1JTUUgdHlwZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoZSBnaXZlbiBNSU1FIHR5cGUuXG4gICAgICovXG4gICAgTWltZURhdGEucHJvdG90eXBlLmNsZWFyRGF0YSA9IGZ1bmN0aW9uIChtaW1lKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fdHlwZXMuaW5kZXhPZihtaW1lKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGRhdGEgZW50cmllcyBmcm9tIHRoZSBkYXRhc2V0LlxuICAgICAqL1xuICAgIE1pbWVEYXRhLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gTWltZURhdGE7XG59KCkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQSBjbGFzcyB3aGljaCB3cmFwcyBhIHByb21pc2UgaW50byBhIGRlbGVnYXRlIG9iamVjdC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWZ1bCB3aGVuIHRoZSBsb2dpYyB0byByZXNvbHZlIG9yIHJlamVjdCBhIHByb21pc2VcbiAqIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgcHJvbWlzZSBpcyBjcmVhdGVkLlxuICovXG52YXIgUHJvbWlzZURlbGVnYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBwcm9taXNlIGRlbGVnYXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb21pc2VEZWxlZ2F0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgX3RoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIHdyYXBwZWQgcHJvbWlzZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB1c2UgZm9yIHJlc29sdmluZyB0aGUgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBQcm9taXNlRGVsZWdhdGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc29sdmUgPSB0aGlzLl9yZXNvbHZlO1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlamVjdCB0aGUgd3JhcHBlZCBwcm9taXNlIHdpdGggdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJlYXNvbiAtIFRoZSByZWFzb24gZm9yIHJlamVjdGluZyB0aGUgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBQcm9taXNlRGVsZWdhdGUucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdmFyIHJlamVjdCA9IHRoaXMuX3JlamVjdDtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZURlbGVnYXRlO1xufSgpKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgUGhvc3Bob3JKUyBDb250cmlidXRvcnNcbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBMSUNFTlNFLCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHJhbmRvbSBudW1iZXIgcmVsYXRlZCBmdW5jdGlvbmFsaXR5LlxuICovXG52YXIgUmFuZG9tO1xuKGZ1bmN0aW9uIChSYW5kb20pIHtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyByYW5kb20gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGBVaW50OEFycmF5YCB0byBmaWxsIHdpdGggcmFuZG9tIGJ5dGVzLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIEEgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHdpbGwgYmUgdXNlZCBpZlxuICAgICAqIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBgTWF0aC5yYW5kb21gIHdpbGwgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGZvclxuICAgICAqIHJhbmRvbW5lc3MuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIFJOR3MgYXJlIHN1cHBvcnRlZCwgbGlzdGVkIGluIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gICAgICogICAtIGB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc2BcbiAgICAgKiAgIC0gYHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXNgXG4gICAgICogICAtIGByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21GaWxsU3luY1xuICAgICAqICAgLSBgcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXNcbiAgICAgKiAgIC0gYE1hdGgucmFuZG9tYFxuICAgICAqL1xuICAgIFJhbmRvbS5nZXRSYW5kb21WYWx1ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMb29rIHVwIHRoZSBjcnlwdG8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgdmFyIGNyeXB0byA9ICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZSgnY3J5cHRvJykpIHx8IG51bGwpO1xuICAgICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgYW5kIElFIDExXG4gICAgICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRSYW5kb21WYWx1ZXMoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmZmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9kZSA3K1xuICAgICAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8ucmFuZG9tRmlsbFN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRSYW5kb21WYWx1ZXMoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21GaWxsU3luYyhidWZmZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb2RlIDAuMTArXG4gICAgICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldFJhbmRvbVZhbHVlcyhidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBieXRlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzKGJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYnVmZmVyLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChpICUgNCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGID4+PiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSB2YWx1ZSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKCk7XG59KShSYW5kb20gfHwgKFJhbmRvbSA9IHt9KSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIFBob3NwaG9ySlMgQ29udHJpYnV0b3JzXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgTElDRU5TRSwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBBIHJ1bnRpbWUgb2JqZWN0IHdoaWNoIGNhcHR1cmVzIGNvbXBpbGUtdGltZSB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIEEgdG9rZW4gY2FwdHVyZXMgdGhlIGNvbXBpbGUtdGltZSB0eXBlIG9mIGFuIGludGVyZmFjZSBvciBjbGFzcyBpblxuICogYW4gb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIGF0IHJ1bnRpbWUgaW4gYSB0eXBlLXNhZmUgZmFzaGlvbi5cbiAqL1xudmFyIFRva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gQSBodW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW4obmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl90b2tlblN0cnVjdHVyYWxQcm9wZXJ0eVQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW47XG59KCkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgVVVJRCByZWxhdGVkIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbnZhciBVVUlEO1xuKGZ1bmN0aW9uIChVVUlEKSB7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgVVVJRCB2NCBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFVVSUQgdjQgc3RyaW5nLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY29tcGxpZXMgd2l0aCBSRkMgNDEyMi5cbiAgICAgKlxuICAgICAqIFRoaXMgdXNlcyBgUmFuZG9tLmdldFJhbmRvbVZhbHVlcygpYCBmb3IgcmFuZG9tIGJ5dGVzLCB3aGljaCBpblxuICAgICAqIHR1cm4gd2lsbCB1c2UgdGhlIHVuZGVybHlpbmcgYGNyeXB0b2AgbW9kdWxlIG9mIHRoZSBwbGF0Zm9ybSBpZlxuICAgICAqIGl0IGlzIGF2YWlsYWJsZS4gVGhlIGZhbGxiYWNrIGZvciByYW5kb21uZXNzIGlzIGBNYXRoLnJhbmRvbWAuXG4gICAgICovXG4gICAgVVVJRC51dWlkNCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIDE2IGJ5dGUgYXJyYXkgdG8gaG9sZCB0aGUgcmFuZG9tIHZhbHVlcy5cbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAvLyBDcmVhdGUgYSBsb29rIHVwIHRhYmxlIGZyb20gYnl0ZXMgdG8gaGV4IHN0cmluZ3MuXG4gICAgICAgIHZhciBsdXQgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgICAgLy8gUGFkIHRoZSBzaW5nbGUgY2hhcmFjdGVyIGhleCBkaWdpdHMgd2l0aCBhIGxlYWRpbmcgemVyby5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICBsdXRbaV0gPSAnMCcgKyBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgcmVzdCBvZiB0aGUgaGV4IGRpZ2l0cy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE2OyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgICAgIGx1dFtpXSA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB0aGUgVVVJRC5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHV1aWQ0KCkge1xuICAgICAgICAgICAgLy8gR2V0IGEgbmV3IGJhdGNoIG9mIHJhbmRvbSB2YWx1ZXMuXG4gICAgICAgICAgICBSYW5kb20uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgVVVJRCB2ZXJzaW9uIG51bWJlciB0byA0LlxuICAgICAgICAgICAgYnl0ZXNbNl0gPSAweDQwIHwgKGJ5dGVzWzZdICYgMHgwRik7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNsb2NrIHNlcXVlbmNlIGJpdCB0byB0aGUgUkZDIHNwZWMuXG4gICAgICAgICAgICBieXRlc1s4XSA9IDB4ODAgfCAoYnl0ZXNbOF0gJiAweDNGKTtcbiAgICAgICAgICAgIC8vIEFzc2VtYmxlIHRoZSBVVUlEIHN0cmluZy5cbiAgICAgICAgICAgIHJldHVybiAobHV0W2J5dGVzWzBdXSArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzFdXSArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzJdXSArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzNdXSArXG4gICAgICAgICAgICAgICAgJy0nICtcbiAgICAgICAgICAgICAgICBsdXRbYnl0ZXNbNF1dICtcbiAgICAgICAgICAgICAgICBsdXRbYnl0ZXNbNV1dICtcbiAgICAgICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgICAgIGx1dFtieXRlc1s2XV0gK1xuICAgICAgICAgICAgICAgIGx1dFtieXRlc1s3XV0gK1xuICAgICAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzhdXSArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzldXSArXG4gICAgICAgICAgICAgICAgJy0nICtcbiAgICAgICAgICAgICAgICBsdXRbYnl0ZXNbMTBdXSArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzExXV0gK1xuICAgICAgICAgICAgICAgIGx1dFtieXRlc1sxMl1dICtcbiAgICAgICAgICAgICAgICBsdXRbYnl0ZXNbMTNdXSArXG4gICAgICAgICAgICAgICAgbHV0W2J5dGVzWzE0XV0gK1xuICAgICAgICAgICAgICAgIGx1dFtieXRlc1sxNV1dKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufSkoVVVJRCB8fCAoVVVJRCA9IHt9KSk7XG5cbmV4cG9ydCB7IEpTT05FeHQsIE1pbWVEYXRhLCBQcm9taXNlRGVsZWdhdGUsIFJhbmRvbSwgVG9rZW4sIFVVSUQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lumino/coreutils/dist/index.es6.js\n")},"./node_modules/@lumino/datagrid/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasicKeyHandler\": () => (/* binding */ BasicKeyHandler),\n/* harmony export */   \"BasicMouseHandler\": () => (/* binding */ BasicMouseHandler),\n/* harmony export */   \"BasicSelectionModel\": () => (/* binding */ BasicSelectionModel),\n/* harmony export */   \"BooleanCellEditor\": () => (/* binding */ BooleanCellEditor),\n/* harmony export */   \"CellEditor\": () => (/* binding */ CellEditor),\n/* harmony export */   \"CellRenderer\": () => (/* binding */ CellRenderer),\n/* harmony export */   \"DataGrid\": () => (/* binding */ DataGrid),\n/* harmony export */   \"DataModel\": () => (/* binding */ DataModel),\n/* harmony export */   \"DateCellEditor\": () => (/* binding */ DateCellEditor),\n/* harmony export */   \"DynamicOptionCellEditor\": () => (/* binding */ DynamicOptionCellEditor),\n/* harmony export */   \"GraphicsContext\": () => (/* binding */ GraphicsContext),\n/* harmony export */   \"InputCellEditor\": () => (/* binding */ InputCellEditor),\n/* harmony export */   \"IntegerCellEditor\": () => (/* binding */ IntegerCellEditor),\n/* harmony export */   \"IntegerInputValidator\": () => (/* binding */ IntegerInputValidator),\n/* harmony export */   \"JSONModel\": () => (/* binding */ JSONModel),\n/* harmony export */   \"MutableDataModel\": () => (/* binding */ MutableDataModel),\n/* harmony export */   \"NumberCellEditor\": () => (/* binding */ NumberCellEditor),\n/* harmony export */   \"NumberInputValidator\": () => (/* binding */ NumberInputValidator),\n/* harmony export */   \"OptionCellEditor\": () => (/* binding */ OptionCellEditor),\n/* harmony export */   \"PassInputValidator\": () => (/* binding */ PassInputValidator),\n/* harmony export */   \"Private\": () => (/* binding */ Private),\n/* harmony export */   \"RendererMap\": () => (/* binding */ RendererMap),\n/* harmony export */   \"SelectionModel\": () => (/* binding */ SelectionModel),\n/* harmony export */   \"TextCellEditor\": () => (/* binding */ TextCellEditor),\n/* harmony export */   \"TextInputValidator\": () => (/* binding */ TextInputValidator),\n/* harmony export */   \"TextRenderer\": () => (/* binding */ TextRenderer)\n/* harmony export */ });\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/domutils/dist/index.es6.js\");\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/@lumino/keyboard/dist/index.es6.js\");\n/* harmony import */ var _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/@lumino/dragdrop/dist/index.es6.js\");\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/@lumino/algorithm/dist/index.es6.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/@lumino/widgets/dist/index.es6.js\");\n/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/@lumino/messaging/dist/index.es6.js\");\n\n\n\n\n\n\n\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A basic implementation of a data grid key handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nvar BasicKeyHandler = /** @class */ (function () {\n    function BasicKeyHandler() {\n        this._disposed = false;\n    }\n    Object.defineProperty(BasicKeyHandler.prototype, \"isDisposed\", {\n        /**\n         * Whether the key handler is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the resources held by the key handler.\n     */\n    BasicKeyHandler.prototype.dispose = function () {\n        this._disposed = true;\n    };\n    /**\n     * Handle the key down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keydown event of interest.\n     *\n     * #### Notes\n     * This will not be called if the mouse button is pressed.\n     */\n    BasicKeyHandler.prototype.onKeyDown = function (grid, event) {\n        // if grid is editable and cell selection available, start cell editing\n        // on key press (letters, numbers and space only)\n        if (grid.editable &&\n            grid.selectionModel.cursorRow !== -1 &&\n            grid.selectionModel.cursorColumn !== -1) {\n            var input = String.fromCharCode(event.keyCode);\n            if (/[a-zA-Z0-9-_ ]/.test(input)) {\n                var row = grid.selectionModel.cursorRow;\n                var column = grid.selectionModel.cursorColumn;\n                var cell = {\n                    grid: grid,\n                    row: row,\n                    column: column\n                };\n                grid.editorController.edit(cell);\n                if ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event) === 'Space') {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n                return;\n            }\n        }\n        switch ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event)) {\n            case 'ArrowLeft':\n                this.onArrowLeft(grid, event);\n                break;\n            case 'ArrowRight':\n                this.onArrowRight(grid, event);\n                break;\n            case 'ArrowUp':\n                this.onArrowUp(grid, event);\n                break;\n            case 'ArrowDown':\n                this.onArrowDown(grid, event);\n                break;\n            case 'PageUp':\n                this.onPageUp(grid, event);\n                break;\n            case 'PageDown':\n                this.onPageDown(grid, event);\n                break;\n            case 'Escape':\n                this.onEscape(grid, event);\n                break;\n            case 'Delete':\n                this.onDelete(grid, event);\n                break;\n            case 'C':\n                this.onKeyC(grid, event);\n                break;\n            case 'Enter':\n                if (grid.selectionModel) {\n                    grid.moveCursor(event.shiftKey ? 'up' : 'down');\n                    grid.scrollToCursor();\n                }\n                break;\n            case 'Tab':\n                if (grid.selectionModel) {\n                    grid.moveCursor(event.shiftKey ? 'left' : 'right');\n                    grid.scrollToCursor();\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n                break;\n        }\n    };\n    /**\n     * Handle the `'ArrowLeft'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onArrowLeft = function (grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Fetch the modifier flags.\n        var shift = event.shiftKey;\n        var accel = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(0, grid.scrollY);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('left');\n            return;\n        }\n        // Fetch the selection mode.\n        var mode = model.selectionMode;\n        // Handle the row selection mode with accel key.\n        if (mode === 'row' && accel) {\n            grid.scrollTo(0, grid.scrollY);\n            return;\n        }\n        // Handle the row selection mode with no modifier. (ignore shift)\n        if (mode === 'row') {\n            grid.scrollByStep('left');\n            return;\n        }\n        // Fetch the cursor and selection.\n        var r = model.cursorRow;\n        var c = model.cursorColumn;\n        var cs = model.currentSelection();\n        // Set up the selection variables.\n        var r1;\n        var r2;\n        var c1;\n        var c2;\n        var cr;\n        var cc;\n        var clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 - 1 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = r;\n            r2 = r;\n            c1 = 0;\n            c2 = 0;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r;\n            r2 = r;\n            c1 = c - 1;\n            c2 = c - 1;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cr, cursorColumn: cc, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'column') {\n            grid.scrollToColumn(cs.c2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    };\n    /**\n     * Handle the `'ArrowRight'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onArrowRight = function (grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Fetch the modifier flags.\n        var shift = event.shiftKey;\n        var accel = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(grid.maxScrollX, grid.scrollY);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('right');\n            return;\n        }\n        // Fetch the selection mode.\n        var mode = model.selectionMode;\n        // Handle the row selection model with accel key.\n        if (mode === 'row' && accel) {\n            grid.scrollTo(grid.maxScrollX, grid.scrollY);\n            return;\n        }\n        // Handle the row selection mode with no modifier. (ignore shift)\n        if (mode === 'row') {\n            grid.scrollByStep('right');\n            return;\n        }\n        // Fetch the cursor and selection.\n        var r = model.cursorRow;\n        var c = model.cursorColumn;\n        var cs = model.currentSelection();\n        // Set up the selection variables.\n        var r1;\n        var r2;\n        var c1;\n        var c2;\n        var cr;\n        var cc;\n        var clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = Infinity;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 + 1 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = r;\n            r2 = r;\n            c1 = Infinity;\n            c2 = Infinity;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r;\n            r2 = r;\n            c1 = c + 1;\n            c2 = c + 1;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cr, cursorColumn: cc, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'column') {\n            grid.scrollToColumn(cs.c2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    };\n    /**\n     * Handle the `'ArrowUp'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onArrowUp = function (grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Fetch the modifier flags.\n        var shift = event.shiftKey;\n        var accel = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(grid.scrollX, 0);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('up');\n            return;\n        }\n        // Fetch the selection mode.\n        var mode = model.selectionMode;\n        // Handle the column selection mode with accel key.\n        if (mode === 'column' && accel) {\n            grid.scrollTo(grid.scrollX, 0);\n            return;\n        }\n        // Handle the column selection mode with no modifier. (ignore shift)\n        if (mode === 'column') {\n            grid.scrollByStep('up');\n            return;\n        }\n        // Fetch the cursor and selection.\n        var r = model.cursorRow;\n        var c = model.cursorColumn;\n        var cs = model.currentSelection();\n        // Set up the selection variables.\n        var r1;\n        var r2;\n        var c1;\n        var c2;\n        var cr;\n        var cc;\n        var clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 - 1 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = 0;\n            r2 = 0;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r - 1;\n            r2 = r - 1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cr, cursorColumn: cc, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'row') {\n            grid.scrollToRow(cs.r2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    };\n    /**\n     * Handle the `'ArrowDown'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onArrowDown = function (grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Fetch the modifier flags.\n        var shift = event.shiftKey;\n        var accel = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(grid.scrollX, grid.maxScrollY);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('down');\n            return;\n        }\n        // Fetch the selection mode.\n        var mode = model.selectionMode;\n        // Handle the column selection mode with accel key.\n        if (mode === 'column' && accel) {\n            grid.scrollTo(grid.scrollX, grid.maxScrollY);\n            return;\n        }\n        // Handle the column selection mode with no modifier. (ignore shift)\n        if (mode === 'column') {\n            grid.scrollByStep('down');\n            return;\n        }\n        // Fetch the cursor and selection.\n        var r = model.cursorRow;\n        var c = model.cursorColumn;\n        var cs = model.currentSelection();\n        // Set up the selection variables.\n        var r1;\n        var r2;\n        var c1;\n        var c2;\n        var cr;\n        var cc;\n        var clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = Infinity;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 + 1 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = Infinity;\n            r2 = Infinity;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r + 1;\n            r2 = r + 1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cr, cursorColumn: cc, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'row') {\n            grid.scrollToRow(cs.r2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    };\n    /**\n     * Handle the `'PageUp'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onPageUp = function (grid, event) {\n        // Ignore the event if the accel key is pressed.\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event)) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Scroll by page if there is no selection model.\n        if (!model || model.selectionMode === 'column') {\n            grid.scrollByPage('up');\n            return;\n        }\n        // Get the normal number of cells in the page height.\n        var n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n        // Fetch the cursor and selection.\n        var r = model.cursorRow;\n        var c = model.cursorColumn;\n        var cs = model.currentSelection();\n        // Set up the selection variables.\n        var r1;\n        var r2;\n        var c1;\n        var c2;\n        var cr;\n        var cc;\n        var clear;\n        // Select or resize as needed.\n        if (event.shiftKey) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 - n : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else {\n            r1 = cs ? cs.r1 - n : 0;\n            r2 = r1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cr, cursorColumn: cc, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        grid.scrollToRow(cs.r2);\n    };\n    /**\n     * Handle the `'PageDown'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onPageDown = function (grid, event) {\n        // Ignore the event if the accel key is pressed.\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event)) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Scroll by page if there is no selection model.\n        if (!model || model.selectionMode === 'column') {\n            grid.scrollByPage('down');\n            return;\n        }\n        // Get the normal number of cells in the page height.\n        var n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n        // Fetch the cursor and selection.\n        var r = model.cursorRow;\n        var c = model.cursorColumn;\n        var cs = model.currentSelection();\n        // Set up the selection variables.\n        var r1;\n        var r2;\n        var c1;\n        var c2;\n        var cr;\n        var cc;\n        var clear;\n        // Select or resize as needed.\n        if (event.shiftKey) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 + n : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else {\n            r1 = cs ? cs.r1 + n : 0;\n            r2 = r1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cr, cursorColumn: cc, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        grid.scrollToRow(cs.r2);\n    };\n    /**\n     * Handle the `'Escape'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onEscape = function (grid, event) {\n        if (grid.selectionModel) {\n            grid.selectionModel.clear();\n        }\n    };\n    /**\n     * Handle the `'Delete'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onDelete = function (grid, event) {\n        if (grid.editable &&\n            !grid.selectionModel.isEmpty) {\n            var dataModel = grid.dataModel;\n            // Fetch the max row and column.\n            var maxRow = dataModel.rowCount('body') - 1;\n            var maxColumn = dataModel.columnCount('body') - 1;\n            var it = grid.selectionModel.selections();\n            var s = void 0;\n            while ((s = it.next()) !== undefined) {\n                // Clamp the cell to the model bounds.\n                var sr1 = Math.max(0, Math.min(s.r1, maxRow));\n                var sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n                var sr2 = Math.max(0, Math.min(s.r2, maxRow));\n                var sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n                for (var r = sr1; r <= sr2; ++r) {\n                    for (var c = sc1; c <= sc2; ++c) {\n                        dataModel.setData('body', r, c, null);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Handle the `'C'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    BasicKeyHandler.prototype.onKeyC = function (grid, event) {\n        // Bail early if the modifiers aren't correct for copy.\n        if (event.shiftKey || !_lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event)) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Copy the current selection to the clipboard.\n        grid.copyToClipboard();\n    };\n    return BasicKeyHandler;\n}());\n\n/**\n * A basic implementation of a data grid mouse handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nvar BasicMouseHandler = /** @class */ (function () {\n    function BasicMouseHandler() {\n        this._disposed = false;\n        this._pressData = null;\n    }\n    /**\n     * Dispose of the resources held by the mouse handler.\n     */\n    BasicMouseHandler.prototype.dispose = function () {\n        // Bail early if the handler is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        // Release any held resources.\n        this.release();\n        // Mark the handler as disposed.\n        this._disposed = true;\n    };\n    Object.defineProperty(BasicMouseHandler.prototype, \"isDisposed\", {\n        /**\n         * Whether the mouse handler is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Release the resources held by the handler.\n     */\n    BasicMouseHandler.prototype.release = function () {\n        // Bail early if the is no press data.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the autoselect timeout.\n        if (this._pressData.type === 'select') {\n            this._pressData.timeout = -1;\n        }\n        // Clear the press data.\n        this._pressData.override.dispose();\n        this._pressData = null;\n    };\n    /**\n     * Handle the mouse hover event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    BasicMouseHandler.prototype.onMouseHover = function (grid, event) {\n        // Hit test the grid.\n        var hit = grid.hitTest(event.clientX, event.clientY);\n        // Get the resize handle for the hit test.\n        var handle = Private.resizeHandleForHitTest(hit);\n        // Fetch the cursor for the handle.\n        var cursor = this.cursorForHandle(handle);\n        // Update the viewport cursor based on the part.\n        grid.viewport.node.style.cursor = cursor;\n        // TODO support user-defined hover items\n    };\n    /**\n     * Handle the mouse leave event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    BasicMouseHandler.prototype.onMouseLeave = function (grid, event) {\n        // TODO support user-defined hover popups.\n        // Clear the viewport cursor.\n        grid.viewport.node.style.cursor = '';\n    };\n    /**\n     * Handle the mouse down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse down event of interest.\n     */\n    BasicMouseHandler.prototype.onMouseDown = function (grid, event) {\n        // Unpack the event.\n        var clientX = event.clientX, clientY = event.clientY;\n        // Hit test the grid.\n        var hit = grid.hitTest(clientX, clientY);\n        // Unpack the hit test.\n        var region = hit.region, row = hit.row, column = hit.column;\n        // Bail if the hit test is on an uninteresting region.\n        if (region === 'void') {\n            return;\n        }\n        // Fetch the modifier flags.\n        var shift = event.shiftKey;\n        var accel = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event);\n        // If the hit test is the body region, the only option is select.\n        if (region === 'body') {\n            // Fetch the selection model.\n            var model_1 = grid.selectionModel;\n            // Bail early if there is no selection model.\n            if (!model_1) {\n                return;\n            }\n            // Override the document cursor.\n            var override_1 = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__.Drag.overrideCursor('default');\n            // Set up the press data.\n            this._pressData = {\n                type: 'select', region: region, row: row, column: column, override: override_1,\n                localX: -1, localY: -1, timeout: -1\n            };\n            // Set up the selection variables.\n            var r1_1;\n            var c1_1;\n            var r2_1;\n            var c2_1;\n            var cursorRow_1;\n            var cursorColumn_1;\n            var clear_1;\n            // Accel == new selection, keep old selections.\n            if (accel) {\n                r1_1 = row;\n                r2_1 = row;\n                c1_1 = column;\n                c2_1 = column;\n                cursorRow_1 = row;\n                cursorColumn_1 = column;\n                clear_1 = 'none';\n            }\n            else if (shift) {\n                r1_1 = model_1.cursorRow;\n                r2_1 = row;\n                c1_1 = model_1.cursorColumn;\n                c2_1 = column;\n                cursorRow_1 = model_1.cursorRow;\n                cursorColumn_1 = model_1.cursorColumn;\n                clear_1 = 'current';\n            }\n            else {\n                r1_1 = row;\n                r2_1 = row;\n                c1_1 = column;\n                c2_1 = column;\n                cursorRow_1 = row;\n                cursorColumn_1 = column;\n                clear_1 = 'all';\n            }\n            // Use selection mode 'cell'\n            model_1.selectionMode = 'cell';\n            // Make the selection.\n            model_1.select({ r1: r1_1, c1: c1_1, r2: r2_1, c2: c2_1, cursorRow: cursorRow_1, cursorColumn: cursorColumn_1, clear: clear_1 });\n            // Done.\n            return;\n        }\n        // Otherwise, the hit test is on a header region.\n        // Convert the hit test into a part.\n        var handle = Private.resizeHandleForHitTest(hit);\n        // Fetch the cursor for the handle.\n        var cursor = this.cursorForHandle(handle);\n        // Handle horizontal resize.\n        if (handle === 'left' || handle === 'right') {\n            // Set up the resize data type.\n            var type = 'column-resize';\n            // Determine the column region.\n            var rgn = (region === 'column-header' ? 'body' : 'row-header');\n            // Determine the section index.\n            var index = handle === 'left' ? column - 1 : column;\n            // Fetch the section size.\n            var size = grid.columnSize(rgn, index);\n            // Override the document cursor.\n            var override_2 = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__.Drag.overrideCursor(cursor);\n            // Create the temporary press data.\n            this._pressData = { type: type, region: rgn, index: index, size: size, clientX: clientX, override: override_2 };\n            // Done.\n            return;\n        }\n        // Handle vertical resize\n        if (handle === 'top' || handle === 'bottom') {\n            // Set up the resize data type.\n            var type = 'row-resize';\n            // Determine the row region.\n            var rgn = (region === 'row-header' ? 'body' : 'column-header');\n            // Determine the section index.\n            var index = handle === 'top' ? row - 1 : row;\n            // Fetch the section size.\n            var size = grid.rowSize(rgn, index);\n            // Override the document cursor.\n            var override_3 = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__.Drag.overrideCursor(cursor);\n            // Create the temporary press data.\n            this._pressData = { type: type, region: rgn, index: index, size: size, clientY: clientY, override: override_3 };\n            // Done.\n            return;\n        }\n        // Otherwise, the only option is select.\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Bail if there is no selection model.\n        if (!model) {\n            return;\n        }\n        // Override the document cursor.\n        var override = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_2__.Drag.overrideCursor('default');\n        // Set up the press data.\n        this._pressData = {\n            type: 'select', region: region, row: row, column: column, override: override,\n            localX: -1, localY: -1, timeout: -1\n        };\n        // Set up the selection variables.\n        var r1;\n        var c1;\n        var r2;\n        var c2;\n        var cursorRow;\n        var cursorColumn;\n        var clear;\n        // Compute the selection based on the pressed region.\n        if (region === 'corner-header') {\n            r1 = 0;\n            r2 = Infinity;\n            c1 = 0;\n            c2 = Infinity;\n            cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n            cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        else if (region === 'row-header') {\n            r1 = accel ? row : shift ? model.cursorRow : row;\n            r2 = row;\n            c1 = 0;\n            c2 = Infinity;\n            cursorRow = accel ? row : shift ? model.cursorRow : row;\n            cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        else if (region === 'column-header') {\n            r1 = 0;\n            r2 = Infinity;\n            c1 = accel ? column : shift ? model.cursorColumn : column;\n            c2 = column;\n            cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n            cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        else {\n            r1 = accel ? row : shift ? model.cursorRow : row;\n            r2 = row;\n            c1 = accel ? column : shift ? model.cursorColumn : column;\n            c2 = column;\n            cursorRow = accel ? row : shift ? model.cursorRow : row;\n            cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        // Set selection mode based on region\n        switch (region) {\n            case 'column-header':\n                model.selectionMode = 'column';\n                break;\n            case 'row-header':\n                model.selectionMode = 'row';\n                break;\n            default:\n                model.selectionMode = 'cell';\n                break;\n        }\n        // Make the selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cursorRow, cursorColumn: cursorColumn, clear: clear });\n    };\n    /**\n     * Handle the mouse move event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse move event of interest.\n     */\n    BasicMouseHandler.prototype.onMouseMove = function (grid, event) {\n        // Fetch the press data.\n        var data = this._pressData;\n        // Bail early if there is no press data.\n        if (!data) {\n            return;\n        }\n        // Handle a row resize.\n        if (data.type === 'row-resize') {\n            var dy = event.clientY - data.clientY;\n            grid.resizeRow(data.region, data.index, data.size + dy);\n            return;\n        }\n        // Handle a column resize.\n        if (data.type === 'column-resize') {\n            var dx = event.clientX - data.clientX;\n            grid.resizeColumn(data.region, data.index, data.size + dx);\n            return;\n        }\n        // Otherwise, it's a select.\n        // Mouse moves during a corner header press are a no-op.\n        if (data.region === 'corner-header') {\n            return;\n        }\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Bail early if the selection model was removed.\n        if (!model) {\n            return;\n        }\n        // Map to local coordinates.\n        var _a = grid.mapToLocal(event.clientX, event.clientY), lx = _a.lx, ly = _a.ly;\n        // Update the local mouse coordinates in the press data.\n        data.localX = lx;\n        data.localY = ly;\n        // Fetch the grid geometry.\n        var hw = grid.headerWidth;\n        var hh = grid.headerHeight;\n        var vpw = grid.viewportWidth;\n        var vph = grid.viewportHeight;\n        var sx = grid.scrollX;\n        var sy = grid.scrollY;\n        var msx = grid.maxScrollY;\n        var msy = grid.maxScrollY;\n        // Fetch the selection mode.\n        var mode = model.selectionMode;\n        // Set up the timeout variable.\n        var timeout = -1;\n        // Compute the timemout based on hit region and mouse position.\n        if (data.region === 'row-header' || mode === 'row') {\n            if (ly < hh && sy > 0) {\n                timeout = Private.computeTimeout(hh - ly);\n            }\n            else if (ly >= vph && sy < msy) {\n                timeout = Private.computeTimeout(ly - vph);\n            }\n        }\n        else if (data.region === 'column-header' || mode === 'column') {\n            if (lx < hw && sx > 0) {\n                timeout = Private.computeTimeout(hw - lx);\n            }\n            else if (lx >= vpw && sx < msx) {\n                timeout = Private.computeTimeout(lx - vpw);\n            }\n        }\n        else {\n            if (lx < hw && sx > 0) {\n                timeout = Private.computeTimeout(hw - lx);\n            }\n            else if (lx >= vpw && sx < msx) {\n                timeout = Private.computeTimeout(lx - vpw);\n            }\n            else if (ly < hh && sy > 0) {\n                timeout = Private.computeTimeout(hh - ly);\n            }\n            else if (ly >= vph && sy < msy) {\n                timeout = Private.computeTimeout(ly - vph);\n            }\n        }\n        // Update or initiate the autoselect if needed.\n        if (timeout >= 0) {\n            if (data.timeout < 0) {\n                data.timeout = timeout;\n                setTimeout(function () { Private.autoselect(grid, data); }, timeout);\n            }\n            else {\n                data.timeout = timeout;\n            }\n            return;\n        }\n        // Otherwise, clear the autoselect timeout.\n        data.timeout = -1;\n        // Map the position to virtual coordinates.\n        var _b = grid.mapToVirtual(event.clientX, event.clientY), vx = _b.vx, vy = _b.vy;\n        // Clamp the coordinates to the limits.\n        vx = Math.max(0, Math.min(vx, grid.bodyWidth - 1));\n        vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));\n        // Set up the selection variables.\n        var r1;\n        var c1;\n        var r2;\n        var c2;\n        var cursorRow = model.cursorRow;\n        var cursorColumn = model.cursorColumn;\n        var clear = 'current';\n        // Compute the selection based pressed region.\n        if (data.region === 'row-header' || mode === 'row') {\n            r1 = data.row;\n            r2 = grid.rowAt('body', vy);\n            c1 = 0;\n            c2 = Infinity;\n        }\n        else if (data.region === 'column-header' || mode === 'column') {\n            r1 = 0;\n            r2 = Infinity;\n            c1 = data.column;\n            c2 = grid.columnAt('body', vx);\n        }\n        else {\n            r1 = cursorRow;\n            r2 = grid.rowAt('body', vy);\n            c1 = cursorColumn;\n            c2 = grid.columnAt('body', vx);\n        }\n        // Make the selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cursorRow, cursorColumn: cursorColumn, clear: clear });\n    };\n    /**\n     * Handle the mouse up event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    BasicMouseHandler.prototype.onMouseUp = function (grid, event) {\n        this.release();\n    };\n    /**\n     * Handle the mouse double click event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    BasicMouseHandler.prototype.onMouseDoubleClick = function (grid, event) {\n        if (!grid.dataModel) {\n            this.release();\n            return;\n        }\n        // Unpack the event.\n        var clientX = event.clientX, clientY = event.clientY;\n        // Hit test the grid.\n        var hit = grid.hitTest(clientX, clientY);\n        // Unpack the hit test.\n        var region = hit.region, row = hit.row, column = hit.column;\n        if (region === 'void') {\n            this.release();\n            return;\n        }\n        if (region === 'body') {\n            if (grid.editable) {\n                var cell = {\n                    grid: grid,\n                    row: row,\n                    column: column\n                };\n                grid.editorController.edit(cell);\n            }\n        }\n        this.release();\n    };\n    /**\n     * Handle the context menu event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The context menu event of interest.\n     */\n    BasicMouseHandler.prototype.onContextMenu = function (grid, event) {\n        // TODO support user-defined context menus\n    };\n    /**\n     * Handle the wheel event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The wheel event of interest.\n     */\n    BasicMouseHandler.prototype.onWheel = function (grid, event) {\n        // Bail if a mouse press is in progress.\n        if (this._pressData) {\n            return;\n        }\n        // Extract the delta X and Y movement.\n        var dx = event.deltaX;\n        var dy = event.deltaY;\n        // Convert the delta values to pixel values.\n        switch (event.deltaMode) {\n            case 0: // DOM_DELTA_PIXEL\n                break;\n            case 1: // DOM_DELTA_LINE\n                var ds = grid.defaultSizes;\n                dx *= ds.columnWidth;\n                dy *= ds.rowHeight;\n                break;\n            case 2: // DOM_DELTA_PAGE\n                dx *= grid.pageWidth;\n                dy *= grid.pageHeight;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Scroll by the desired amount.\n        grid.scrollBy(dx, dy);\n    };\n    /**\n     * Convert a resize handle into a cursor.\n     */\n    BasicMouseHandler.prototype.cursorForHandle = function (handle) {\n        return Private.cursorMap[handle];\n    };\n    Object.defineProperty(BasicMouseHandler.prototype, \"pressData\", {\n        /**\n         * Get the current pressData\n         */\n        get: function () {\n            return this._pressData;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return BasicMouseHandler;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get the resize handle for a grid hit test.\n     */\n    function resizeHandleForHitTest(hit) {\n        // Fetch the row and column.\n        var r = hit.row;\n        var c = hit.column;\n        // Fetch the leading and trailing sizes.\n        var lw = hit.x;\n        var lh = hit.y;\n        var tw = hit.width - hit.x;\n        var th = hit.height - hit.y;\n        // Set up the result variable.\n        var result;\n        // Dispatch based on hit test region.\n        switch (hit.region) {\n            case 'corner-header':\n                if (c > 0 && lw <= 5) {\n                    result = 'left';\n                }\n                else if (tw <= 6) {\n                    result = 'right';\n                }\n                else if (r > 0 && lh <= 5) {\n                    result = 'top';\n                }\n                else if (th <= 6) {\n                    result = 'bottom';\n                }\n                else {\n                    result = 'none';\n                }\n                break;\n            case 'column-header':\n                if (c > 0 && lw <= 5) {\n                    result = 'left';\n                }\n                else if (tw <= 6) {\n                    result = 'right';\n                }\n                else if (r > 0 && lh <= 5) {\n                    result = 'top';\n                }\n                else if (th <= 6) {\n                    result = 'bottom';\n                }\n                else {\n                    result = 'none';\n                }\n                break;\n            case 'row-header':\n                if (c > 0 && lw <= 5) {\n                    result = 'left';\n                }\n                else if (tw <= 6) {\n                    result = 'right';\n                }\n                else if (r > 0 && lh <= 5) {\n                    result = 'top';\n                }\n                else if (th <= 6) {\n                    result = 'bottom';\n                }\n                else {\n                    result = 'none';\n                }\n                break;\n            case 'body':\n                result = 'none';\n                break;\n            case 'void':\n                result = 'none';\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Return the result.\n        return result;\n    }\n    Private.resizeHandleForHitTest = resizeHandleForHitTest;\n    /**\n     * A timer callback for the autoselect loop.\n     *\n     * @param grid - The datagrid of interest.\n     *\n     * @param data - The select data of interest.\n     */\n    function autoselect(grid, data) {\n        // Bail early if the timeout has been reset.\n        if (data.timeout < 0) {\n            return;\n        }\n        // Fetch the selection model.\n        var model = grid.selectionModel;\n        // Bail early if the selection model has been removed.\n        if (!model) {\n            return;\n        }\n        // Fetch the current selection.\n        var cs = model.currentSelection();\n        // Bail early if there is no current selection.\n        if (!cs) {\n            return;\n        }\n        // Fetch local X and Y coordinates of the mouse.\n        var lx = data.localX;\n        var ly = data.localY;\n        // Set up the selection variables.\n        var r1 = cs.r1;\n        var c1 = cs.c1;\n        var r2 = cs.r2;\n        var c2 = cs.c2;\n        var cursorRow = model.cursorRow;\n        var cursorColumn = model.cursorColumn;\n        var clear = 'current';\n        // Fetch the grid geometry.\n        var hw = grid.headerWidth;\n        var hh = grid.headerHeight;\n        var vpw = grid.viewportWidth;\n        var vph = grid.viewportHeight;\n        // Fetch the selection mode.\n        var mode = model.selectionMode;\n        // Update the selection based on the hit region.\n        if (data.region === 'row-header' || mode === 'row') {\n            r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n        }\n        else if (data.region === 'column-header' || mode === 'column') {\n            c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n        }\n        else {\n            r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n            c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n        }\n        // Update the current selection.\n        model.select({ r1: r1, c1: c1, r2: r2, c2: c2, cursorRow: cursorRow, cursorColumn: cursorColumn, clear: clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid based on the hit region.\n        if (data.region === 'row-header' || mode === 'row') {\n            grid.scrollToRow(cs.r2);\n        }\n        else if (data.region === 'column-header' || mode == 'column') {\n            grid.scrollToColumn(cs.c2);\n        }\n        else if (mode === 'cell') {\n            grid.scrollToCell(cs.r2, cs.c2);\n        }\n        // Schedule the next call with the current timeout.\n        setTimeout(function () { autoselect(grid, data); }, data.timeout);\n    }\n    Private.autoselect = autoselect;\n    /**\n     * Compute the scroll timeout for the given delta distance.\n     *\n     * @param delta - The delta pixels from the origin.\n     *\n     * @returns The scaled timeout in milliseconds.\n     */\n    function computeTimeout(delta) {\n        return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);\n    }\n    Private.computeTimeout = computeTimeout;\n    /**\n     * A mapping of resize handle to cursor.\n     */\n    Private.cursorMap = {\n        top: 'ns-resize',\n        left: 'ew-resize',\n        right: 'ew-resize',\n        bottom: 'ns-resize',\n        none: 'default'\n    };\n})(Private || (Private = {}));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A base class for creating data grid selection models.\n *\n * #### Notes\n * If the predefined selection models are insufficient for a particular\n * use case, a custom model can be defined which derives from this class.\n */\nvar SelectionModel = /** @class */ (function () {\n    /**\n     * Construct a new selection model.\n     *\n     * @param options - The options for initializing the model.\n     */\n    function SelectionModel(options) {\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n        this._selectionMode = 'cell';\n        this.dataModel = options.dataModel;\n        this._selectionMode = options.selectionMode || 'cell';\n        this.dataModel.changed.connect(this.onDataModelChanged, this);\n    }\n    Object.defineProperty(SelectionModel.prototype, \"changed\", {\n        /**\n         * A signal emitted when the selection model has changed.\n         */\n        get: function () {\n            return this._changed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SelectionModel.prototype, \"selectionMode\", {\n        /**\n         * Get the selection mode for the model.\n         */\n        get: function () {\n            return this._selectionMode;\n        },\n        /**\n         * Set the selection mode for the model.\n         *\n         * #### Notes\n         * This will clear the selection model.\n         */\n        set: function (value) {\n            // Bail early if the mode does not change.\n            if (this._selectionMode === value) {\n                return;\n            }\n            // Update the internal mode.\n            this._selectionMode = value;\n            // Clear the current selections.\n            this.clear();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Test whether any selection intersects a row.\n     *\n     * @param index - The row index of interest.\n     *\n     * @returns Whether any selection intersects the row.\n     *\n     * #### Notes\n     * This method may be reimplemented in a subclass.\n     */\n    SelectionModel.prototype.isRowSelected = function (index) {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.some)(this.selections(), function (s) { return Private$1.containsRow(s, index); });\n    };\n    /**\n     * Test whether any selection intersects a column.\n     *\n     * @param index - The column index of interest.\n     *\n     * @returns Whether any selection intersects the column.\n     *\n     * #### Notes\n     * This method may be reimplemented in a subclass.\n     */\n    SelectionModel.prototype.isColumnSelected = function (index) {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.some)(this.selections(), function (s) { return Private$1.containsColumn(s, index); });\n    };\n    /**\n     * Test whether any selection intersects a cell.\n     *\n     * @param row - The row index of interest.\n     *\n     * @param column - The column index of interest.\n     *\n     * @returns Whether any selection intersects the cell.\n     *\n     * #### Notes\n     * This method may be reimplemented in a subclass.\n     */\n    SelectionModel.prototype.isCellSelected = function (row, column) {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.some)(this.selections(), function (s) { return Private$1.containsCell(s, row, column); });\n    };\n    /**\n     * A signal handler for the data model `changed` signal.\n     *\n     * @param args - The arguments for the signal.\n     *\n     * #### Notes\n     * Selection model implementations should update their selections\n     * in a manner that is relevant for the changes to the data model.\n     *\n     * The default implementation of this method is a no-op.\n     */\n    SelectionModel.prototype.onDataModelChanged = function (sender, args) { };\n    /**\n     * Emit the `changed` signal for the selection model.\n     *\n     * #### Notes\n     * Subclasses should call this method whenever the selection model\n     * has changed so that attached data grids can update themselves.\n     */\n    SelectionModel.prototype.emitChanged = function () {\n        this._changed.emit(undefined);\n    };\n    return SelectionModel;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private$1;\n(function (Private) {\n    /**\n     * Test whether a selection contains a given row.\n     */\n    function containsRow(selection, row) {\n        var r1 = selection.r1, r2 = selection.r2;\n        return (row >= r1 && row <= r2) || (row >= r2 && row <= r1);\n    }\n    Private.containsRow = containsRow;\n    /**\n     * Test whether a selection contains a given column.\n     */\n    function containsColumn(selection, column) {\n        var c1 = selection.c1, c2 = selection.c2;\n        return (column >= c1 && column <= c2) || (column >= c2 && column <= c1);\n    }\n    Private.containsColumn = containsColumn;\n    /**\n     * Test whether a selection contains a given cell.\n     */\n    function containsCell(selection, row, column) {\n        return containsRow(selection, row) && containsColumn(selection, column);\n    }\n    Private.containsCell = containsCell;\n})(Private$1 || (Private$1 = {}));\n\n/**\n * A basic selection model implementation.\n *\n * #### Notes\n * This selection model is sufficient for most use cases where\n * structural knowledge of the data source is *not* required.\n */\nvar BasicSelectionModel = /** @class */ (function (_super) {\n    __extends(BasicSelectionModel, _super);\n    function BasicSelectionModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._cursorRow = -1;\n        _this._cursorColumn = -1;\n        _this._cursorRectIndex = -1;\n        _this._selections = [];\n        return _this;\n    }\n    Object.defineProperty(BasicSelectionModel.prototype, \"isEmpty\", {\n        /**\n         * Wether the selection model is empty.\n         */\n        get: function () {\n            return this._selections.length === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BasicSelectionModel.prototype, \"cursorRow\", {\n        /**\n         * The row index of the cursor.\n         */\n        get: function () {\n            return this._cursorRow;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BasicSelectionModel.prototype, \"cursorColumn\", {\n        /**\n         * The column index of the cursor.\n         */\n        get: function () {\n            return this._cursorColumn;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Move cursor down/up/left/right while making sure it remains\n     * within the bounds of selected rectangles\n     *\n     * @param direction - The direction of the movement.\n     */\n    BasicSelectionModel.prototype.moveCursorWithinSelections = function (direction) {\n        var _this = this;\n        // Bail early if there are no selections or no existing cursor\n        if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {\n            return;\n        }\n        // Bail early if only single cell is selected\n        var firstSelection = this._selections[0];\n        if (this._selections.length === 1 &&\n            firstSelection.r1 === firstSelection.r2 &&\n            firstSelection.c1 === firstSelection.c2) {\n            return;\n        }\n        // start from last selection rectangle\n        if (this._cursorRectIndex === -1) {\n            this._cursorRectIndex = this._selections.length - 1;\n        }\n        var cursorRect = this._selections[this._cursorRectIndex];\n        var dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n        var dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n        var newRow = this._cursorRow + dr;\n        var newColumn = this._cursorColumn + dc;\n        var r1 = Math.min(cursorRect.r1, cursorRect.r2);\n        var r2 = Math.max(cursorRect.r1, cursorRect.r2);\n        var c1 = Math.min(cursorRect.c1, cursorRect.c2);\n        var c2 = Math.max(cursorRect.c1, cursorRect.c2);\n        var moveToNextRect = function () {\n            _this._cursorRectIndex = (_this._cursorRectIndex + 1) % _this._selections.length;\n            cursorRect = _this._selections[_this._cursorRectIndex];\n            newRow = Math.min(cursorRect.r1, cursorRect.r2);\n            newColumn = Math.min(cursorRect.c1, cursorRect.c2);\n        };\n        var moveToPreviousRect = function () {\n            _this._cursorRectIndex = _this._cursorRectIndex === 0 ? _this._selections.length - 1 : _this._cursorRectIndex - 1;\n            cursorRect = _this._selections[_this._cursorRectIndex];\n            newRow = Math.max(cursorRect.r1, cursorRect.r2);\n            newColumn = Math.max(cursorRect.c1, cursorRect.c2);\n        };\n        if (newRow > r2) {\n            newRow = r1;\n            newColumn += 1;\n            if (newColumn > c2) {\n                moveToNextRect();\n            }\n        }\n        else if (newRow < r1) {\n            newRow = r2;\n            newColumn -= 1;\n            if (newColumn < c1) {\n                moveToPreviousRect();\n            }\n        }\n        else if (newColumn > c2) {\n            newColumn = c1;\n            newRow += 1;\n            if (newRow > r2) {\n                moveToNextRect();\n            }\n        }\n        else if (newColumn < c1) {\n            newColumn = c2;\n            newRow -= 1;\n            if (newRow < r1) {\n                moveToPreviousRect();\n            }\n        }\n        this._cursorRow = newRow;\n        this._cursorColumn = newColumn;\n        // Emit the changed signal.\n        this.emitChanged();\n    };\n    /**\n     * Get the current selection in the selection model.\n     *\n     * @returns The current selection or `null`.\n     *\n     * #### Notes\n     * This is the selection which holds the cursor.\n     */\n    BasicSelectionModel.prototype.currentSelection = function () {\n        return this._selections[this._selections.length - 1] || null;\n    };\n    /**\n     * Get an iterator of the selections in the model.\n     *\n     * @returns A new iterator of the current selections.\n     *\n     * #### Notes\n     * The data grid will render the selections in order.\n     */\n    BasicSelectionModel.prototype.selections = function () {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.iter)(this._selections);\n    };\n    /**\n     * Select the specified cells.\n     *\n     * @param args - The arguments for the selection.\n     */\n    BasicSelectionModel.prototype.select = function (args) {\n        // Fetch the current row and column counts;\n        var rowCount = this.dataModel.rowCount('body');\n        var columnCount = this.dataModel.columnCount('body');\n        // Bail early if there is no content.\n        if (rowCount <= 0 || columnCount <= 0) {\n            return;\n        }\n        // Unpack the arguments.\n        var r1 = args.r1, c1 = args.c1, r2 = args.r2, c2 = args.c2, cursorRow = args.cursorRow, cursorColumn = args.cursorColumn, clear = args.clear;\n        // Clear the necessary selections.\n        if (clear === 'all') {\n            this._selections.length = 0;\n        }\n        else if (clear === 'current') {\n            this._selections.pop();\n        }\n        // Clamp to the data model bounds.\n        r1 = Math.max(0, Math.min(r1, rowCount - 1));\n        r2 = Math.max(0, Math.min(r2, rowCount - 1));\n        c1 = Math.max(0, Math.min(c1, columnCount - 1));\n        c2 = Math.max(0, Math.min(c2, columnCount - 1));\n        // Handle the selection mode.\n        if (this.selectionMode === 'row') {\n            c1 = 0;\n            c2 = columnCount - 1;\n        }\n        else if (this.selectionMode === 'column') {\n            r1 = 0;\n            r2 = rowCount - 1;\n        }\n        // Alias the cursor row and column.\n        var cr = cursorRow;\n        var cc = cursorColumn;\n        // Compute the new cursor location.\n        if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {\n            cr = r1;\n        }\n        if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {\n            cc = c1;\n        }\n        // Update the cursor.\n        this._cursorRow = cr;\n        this._cursorColumn = cc;\n        this._cursorRectIndex = this._selections.length;\n        // Add the new selection.\n        this._selections.push({ r1: r1, c1: c1, r2: r2, c2: c2 });\n        // Emit the changed signal.\n        this.emitChanged();\n    };\n    /**\n     * Clear all selections in the selection model.\n     */\n    BasicSelectionModel.prototype.clear = function () {\n        // Bail early if there are no selections.\n        if (this._selections.length === 0) {\n            return;\n        }\n        // Reset the internal state.\n        this._cursorRow = -1;\n        this._cursorColumn = -1;\n        this._cursorRectIndex = -1;\n        this._selections.length = 0;\n        // Emit the changed signal.\n        this.emitChanged();\n    };\n    /**\n     * A signal handler for the data model `changed` signal.\n     *\n     * @param args - The arguments for the signal.\n     */\n    BasicSelectionModel.prototype.onDataModelChanged = function (sender, args) {\n        // Bail early if the model has no current selections.\n        if (this._selections.length === 0) {\n            return;\n        }\n        // Bail early if the cells have changed in place.\n        if (args.type === 'cells-changed') {\n            return;\n        }\n        // Bail early if there is no change to the row or column count.\n        if (args.type === 'rows-moved' || args.type === 'columns-moved') {\n            return;\n        }\n        // Fetch the last row and column index.\n        var lr = sender.rowCount('body') - 1;\n        var lc = sender.columnCount('body') - 1;\n        // Bail early if the data model is empty.\n        if (lr < 0 || lc < 0) {\n            this._selections.length = 0;\n            this.emitChanged();\n            return;\n        }\n        // Fetch the selection mode.\n        var mode = this.selectionMode;\n        // Set up the assignment index variable.\n        var j = 0;\n        // Iterate over the current selections.\n        for (var i = 0, n = this._selections.length; i < n; ++i) {\n            // Unpack the selection.\n            var _a = this._selections[i], r1 = _a.r1, c1 = _a.c1, r2 = _a.r2, c2 = _a.c2;\n            // Skip the selection if it will disappear.\n            if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {\n                continue;\n            }\n            // Modify the bounds based on the selection mode.\n            if (mode === 'row') {\n                r1 = Math.max(0, Math.min(r1, lr));\n                r2 = Math.max(0, Math.min(r2, lr));\n                c1 = 0;\n                c2 = lc;\n            }\n            else if (mode === 'column') {\n                r1 = 0;\n                r2 = lr;\n                c1 = Math.max(0, Math.min(c1, lc));\n                c2 = Math.max(0, Math.min(c2, lc));\n            }\n            else {\n                r1 = Math.max(0, Math.min(r1, lr));\n                r2 = Math.max(0, Math.min(r2, lr));\n                c1 = Math.max(0, Math.min(c1, lc));\n                c2 = Math.max(0, Math.min(c2, lc));\n            }\n            // Assign the modified selection to the array.\n            this._selections[j++] = { r1: r1, c1: c1, r2: r2, c2: c2 };\n        }\n        // Remove the stale selections.\n        this._selections.length = j;\n        // Emit the changed signal.\n        this.emitChanged();\n    };\n    return BasicSelectionModel;\n}(SelectionModel));\n\n/**\n * An object which renders the cells of a data grid.\n *\n * #### Notes\n * If the predefined cell renderers are insufficient for a particular\n * use case, a custom cell renderer can be defined which derives from\n * this class.\n *\n * The data grid renders cells in column-major order, by region. The\n * region order is: body, row header, column header, corner header.\n */\nvar CellRenderer = /** @class */ (function () {\n    function CellRenderer() {\n    }\n    return CellRenderer;\n}());\n/**\n * The namespace for the `CellRenderer` class statics.\n */\n(function (CellRenderer) {\n    /**\n     * Resolve a config option for a cell renderer.\n     *\n     * @param option - The config option to resolve.\n     *\n     * @param config - The cell config object.\n     *\n     * @returns The resolved value for the option.\n     */\n    function resolveOption(option, config) {\n        return typeof option === 'function' ? option(config) : option;\n    }\n    CellRenderer.resolveOption = resolveOption;\n})(CellRenderer || (CellRenderer = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A widget which implements a notification popup.\n */\nvar Notification = /** @class */ (function (_super) {\n    __extends(Notification, _super);\n    /**\n     * Construct a new notification.\n     *\n     * @param options - The options for initializing the notification.\n     */\n    function Notification(options) {\n        var _this = _super.call(this, { node: Private$2.createNode() }) || this;\n        _this._message = '';\n        _this.addClass('lm-DataGrid-notification');\n        _this.setFlag(_lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget.Flag.DisallowLayout);\n        _this._target = options.target;\n        _this._message = options.message || '';\n        _this._placement = options.placement || 'bottom';\n        _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget.attach(_this, document.body);\n        if (options.timeout && options.timeout > 0) {\n            setTimeout(function () {\n                _this.close();\n            }, options.timeout);\n        }\n        return _this;\n    }\n    /**\n     * Handle the DOM events for the notification.\n     *\n     * @param event - The DOM event sent to the notification.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notification's DOM node.\n     *\n     * This should not be called directly by user code.\n     */\n    Notification.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    Object.defineProperty(Notification.prototype, \"placement\", {\n        /**\n         * Get the placement of the notification.\n         */\n        get: function () {\n            return this._placement;\n        },\n        /**\n         * Set the placement of the notification.\n         */\n        set: function (value) {\n            // Do nothing if the placement does not change.\n            if (this._placement === value) {\n                return;\n            }\n            // Update the internal placement.\n            this._placement = value;\n            // Schedule an update for notification.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Notification.prototype, \"message\", {\n        /**\n         * Get the current value of the message.\n         */\n        get: function () {\n            return this._message;\n        },\n        /**\n         * Set the current value of the message.\n         *\n         */\n        set: function (value) {\n            // Do nothing if the value does not change.\n            if (this._message === value) {\n                return;\n            }\n            // Update the internal value.\n            this._message = value;\n            // Schedule an update for notification.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Notification.prototype, \"messageNode\", {\n        /**\n         * Get the node presenting the message.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-DataGrid-notificationMessage')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * A method invoked on a 'before-attach' message.\n     */\n    Notification.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('mousedown', this);\n        this.update();\n    };\n    /**\n     * A method invoked on an 'after-detach' message.\n     */\n    Notification.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('mousedown', this);\n    };\n    /**\n     * A method invoked on an 'update-request' message.\n     */\n    Notification.prototype.onUpdateRequest = function (msg) {\n        var targetRect = this._target.getBoundingClientRect();\n        var style = this.node.style;\n        switch (this._placement) {\n            case 'bottom':\n                style.left = targetRect.left + 'px';\n                style.top = targetRect.bottom + 'px';\n                break;\n            case 'top':\n                style.left = targetRect.left + 'px';\n                style.height = targetRect.top + 'px';\n                style.top = '0';\n                style.alignItems = 'flex-end';\n                style.justifyContent = 'flex-end';\n                break;\n            case 'left':\n                style.left = '0';\n                style.width = targetRect.left + 'px';\n                style.top = targetRect.top + 'px';\n                style.alignItems = 'flex-end';\n                style.justifyContent = 'flex-end';\n                break;\n            case 'right':\n                style.left = targetRect.right + 'px';\n                style.top = targetRect.top + 'px';\n                break;\n        }\n        this.messageNode.innerHTML = this._message;\n    };\n    /**\n     * Handle the `'mousedown'` event for the notification.\n     */\n    Notification.prototype._evtMouseDown = function (event) {\n        // Do nothing if it's not a left mouse press.\n        if (event.button !== 0) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        this.close();\n    };\n    return Notification;\n}(_lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$2;\n(function (Private) {\n    /**\n     * Create the DOM node for notification.\n     */\n    function createNode() {\n        var node = document.createElement('div');\n        var container = document.createElement('div');\n        container.className = 'lm-DataGrid-notificationContainer';\n        var message = document.createElement('span');\n        message.className = 'lm-DataGrid-notificationMessage';\n        container.appendChild(message);\n        node.appendChild(container);\n        return node;\n    }\n    Private.createNode = createNode;\n})(Private$2 || (Private$2 = {}));\n\n// default validation error message\nvar DEFAULT_INVALID_INPUT_MESSAGE = \"Invalid input!\";\n/**\n * A cell input validator object which always returns valid.\n */\nvar PassInputValidator = /** @class */ (function () {\n    function PassInputValidator() {\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    PassInputValidator.prototype.validate = function (cell, value) {\n        return { valid: true };\n    };\n    return PassInputValidator;\n}());\n/**\n * Text cell input validator.\n */\nvar TextInputValidator = /** @class */ (function () {\n    function TextInputValidator() {\n        /**\n         * Minimum text length\n         *\n         * The default is Number.NaN, meaning no minimum constraint\n         */\n        this.minLength = Number.NaN;\n        /**\n         * Maximum text length\n         *\n         * The default is Number.NaN, meaning no maximum constraint\n         */\n        this.maxLength = Number.NaN;\n        /**\n         * Required text pattern as regular expression\n         *\n         * The default is null, meaning no pattern constraint\n         */\n        this.pattern = null;\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    TextInputValidator.prototype.validate = function (cell, value) {\n        if (value === null) {\n            return { valid: true };\n        }\n        if (typeof value !== 'string') {\n            return {\n                valid: false,\n                message: 'Input must be valid text'\n            };\n        }\n        if (!isNaN(this.minLength) && value.length < this.minLength) {\n            return {\n                valid: false,\n                message: \"Text length must be greater than \" + this.minLength\n            };\n        }\n        if (!isNaN(this.maxLength) && value.length > this.maxLength) {\n            return {\n                valid: false,\n                message: \"Text length must be less than \" + this.maxLength\n            };\n        }\n        if (this.pattern && !this.pattern.test(value)) {\n            return {\n                valid: false,\n                message: \"Text doesn't match the required pattern\"\n            };\n        }\n        return { valid: true };\n    };\n    return TextInputValidator;\n}());\n/**\n * Integer cell input validator.\n */\nvar IntegerInputValidator = /** @class */ (function () {\n    function IntegerInputValidator() {\n        /**\n         * Minimum value\n         *\n         * The default is Number.NaN, meaning no minimum constraint\n         */\n        this.min = Number.NaN;\n        /**\n         * Maximum value\n         *\n         * The default is Number.NaN, meaning no maximum constraint\n         */\n        this.max = Number.NaN;\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    IntegerInputValidator.prototype.validate = function (cell, value) {\n        if (value === null) {\n            return { valid: true };\n        }\n        if (isNaN(value) || (value % 1 !== 0)) {\n            return {\n                valid: false,\n                message: 'Input must be valid integer'\n            };\n        }\n        if (!isNaN(this.min) && value < this.min) {\n            return {\n                valid: false,\n                message: \"Input must be greater than \" + this.min\n            };\n        }\n        if (!isNaN(this.max) && value > this.max) {\n            return {\n                valid: false,\n                message: \"Input must be less than \" + this.max\n            };\n        }\n        return { valid: true };\n    };\n    return IntegerInputValidator;\n}());\n/**\n * Real number cell input validator.\n */\nvar NumberInputValidator = /** @class */ (function () {\n    function NumberInputValidator() {\n        /**\n         * Minimum value\n         *\n         * The default is Number.NaN, meaning no minimum constraint\n         */\n        this.min = Number.NaN;\n        /**\n         * Maximum value\n         *\n         * The default is Number.NaN, meaning no maximum constraint\n         */\n        this.max = Number.NaN;\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    NumberInputValidator.prototype.validate = function (cell, value) {\n        if (value === null) {\n            return { valid: true };\n        }\n        if (isNaN(value)) {\n            return {\n                valid: false,\n                message: 'Input must be valid number'\n            };\n        }\n        if (!isNaN(this.min) && value < this.min) {\n            return {\n                valid: false,\n                message: \"Input must be greater than \" + this.min\n            };\n        }\n        if (!isNaN(this.max) && value > this.max) {\n            return {\n                valid: false,\n                message: \"Input must be less than \" + this.max\n            };\n        }\n        return { valid: true };\n    };\n    return NumberInputValidator;\n}());\n/**\n * An abstract base class that provides the most of the functionality\n * needed by a cell editor. All of the built-in cell editors\n * for various cell types are derived from this base class. Custom cell editors\n * can be easily implemented by extending this class.\n */\nvar CellEditor = /** @class */ (function () {\n    /**\n     * Construct a new cell editor.\n     */\n    function CellEditor() {\n        var _this = this;\n        /**\n         * A signal emitted when input changes.\n         */\n        this.inputChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n        /**\n         * Notification popup used to show validation error messages.\n         */\n        this.validityNotification = null;\n        /**\n         * Whether the cell editor is disposed.\n         */\n        this._disposed = false;\n        /**\n         * Whether the value input is valid.\n         */\n        this._validInput = true;\n        /**\n         * Grid wheel event handler.\n         */\n        this._gridWheelEventHandler = null;\n        this.inputChanged.connect(function () {\n            _this.validate();\n        });\n    }\n    Object.defineProperty(CellEditor.prototype, \"isDisposed\", {\n        /**\n         * Whether the cell editor is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    CellEditor.prototype.dispose = function () {\n        if (this._disposed) {\n            return;\n        }\n        if (this._gridWheelEventHandler) {\n            this.cell.grid.node.removeEventListener('wheel', this._gridWheelEventHandler);\n            this._gridWheelEventHandler = null;\n        }\n        this._closeValidityNotification();\n        this._disposed = true;\n        this.cell.grid.node.removeChild(this.viewportOccluder);\n    };\n    /**\n     * Start editing the cell.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param options - The cell editing options.\n     */\n    CellEditor.prototype.edit = function (cell, options) {\n        var _this = this;\n        this.cell = cell;\n        this.onCommit = options && options.onCommit;\n        this.onCancel = options && options.onCancel;\n        this.validator = (options && options.validator) ? options.validator : this.createValidatorBasedOnType();\n        this._gridWheelEventHandler = function () {\n            _this._closeValidityNotification();\n            _this.updatePosition();\n        };\n        cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);\n        this._addContainer();\n        this.updatePosition();\n        this.startEditing();\n    };\n    /**\n     * Cancel editing the cell.\n     */\n    CellEditor.prototype.cancel = function () {\n        if (this._disposed) {\n            return;\n        }\n        this.dispose();\n        if (this.onCancel) {\n            this.onCancel();\n        }\n    };\n    Object.defineProperty(CellEditor.prototype, \"validInput\", {\n        /**\n         * Whether the value input is valid.\n         */\n        get: function () {\n            return this._validInput;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Validate the cell input. Shows validation error notification when input is invalid.\n     */\n    CellEditor.prototype.validate = function () {\n        var value;\n        try {\n            value = this.getInput();\n        }\n        catch (error) {\n            console.log(\"Input error: \" + error.message);\n            this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);\n            return;\n        }\n        if (this.validator) {\n            var result = this.validator.validate(this.cell, value);\n            if (result.valid) {\n                this.setValidity(true);\n            }\n            else {\n                this.setValidity(false, result.message || DEFAULT_INVALID_INPUT_MESSAGE);\n            }\n        }\n        else {\n            this.setValidity(true);\n        }\n    };\n    /**\n     * Set validity flag.\n     *\n     * @param valid - Whether the input is valid.\n     *\n     * @param message - Notification message to show.\n     *\n     * If message is set to empty string (which is the default)\n     * existing notification popup is removed if any.\n     */\n    CellEditor.prototype.setValidity = function (valid, message) {\n        if (message === void 0) { message = \"\"; }\n        this._validInput = valid;\n        this._closeValidityNotification();\n        if (valid) {\n            this.editorContainer.classList.remove('lm-mod-invalid');\n        }\n        else {\n            this.editorContainer.classList.add('lm-mod-invalid');\n            // show a notification popup\n            if (message !== \"\") {\n                this.validityNotification = new Notification({\n                    target: this.editorContainer,\n                    message: message,\n                    placement: 'bottom',\n                    timeout: 5000\n                });\n                this.validityNotification.show();\n            }\n        }\n    };\n    /**\n     * Create and return a cell input validator based on configuration of the\n     * cell being edited. If no suitable validator can be found, it returns undefined.\n     */\n    CellEditor.prototype.createValidatorBasedOnType = function () {\n        var cell = this.cell;\n        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        switch (metadata && metadata.type) {\n            case 'string':\n                {\n                    var validator = new TextInputValidator();\n                    if (typeof (metadata.format) === 'string') {\n                        var format = metadata.format;\n                        switch (format) {\n                            case 'email':\n                                validator.pattern = new RegExp(\"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$\");\n                                break;\n                            case 'uuid':\n                                validator.pattern = new RegExp(\"[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}\");\n                                break;\n                        }\n                    }\n                    if (metadata.constraint) {\n                        if (metadata.constraint.minLength !== undefined) {\n                            validator.minLength = metadata.constraint.minLength;\n                        }\n                        if (metadata.constraint.maxLength !== undefined) {\n                            validator.maxLength = metadata.constraint.maxLength;\n                        }\n                        if (typeof (metadata.constraint.pattern) === 'string') {\n                            validator.pattern = new RegExp(metadata.constraint.pattern);\n                        }\n                    }\n                    return validator;\n                }\n            case 'number':\n                {\n                    var validator = new NumberInputValidator();\n                    if (metadata.constraint) {\n                        if (metadata.constraint.minimum !== undefined) {\n                            validator.min = metadata.constraint.minimum;\n                        }\n                        if (metadata.constraint.maximum !== undefined) {\n                            validator.max = metadata.constraint.maximum;\n                        }\n                    }\n                    return validator;\n                }\n            case 'integer':\n                {\n                    var validator = new IntegerInputValidator();\n                    if (metadata.constraint) {\n                        if (metadata.constraint.minimum !== undefined) {\n                            validator.min = metadata.constraint.minimum;\n                        }\n                        if (metadata.constraint.maximum !== undefined) {\n                            validator.max = metadata.constraint.maximum;\n                        }\n                    }\n                    return validator;\n                }\n        }\n        return undefined;\n    };\n    /**\n     * Compute cell rectangle and return with other cell properties.\n     */\n    CellEditor.prototype.getCellInfo = function (cell) {\n        var grid = cell.grid, row = cell.row, column = cell.column;\n        var data = grid.dataModel.data('body', row, column);\n        var columnX = grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);\n        var rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);\n        var width = grid.columnSize('body', column);\n        var height = grid.rowSize('body', row);\n        return {\n            grid: grid,\n            row: row,\n            column: column,\n            data: data,\n            x: columnX,\n            y: rowY,\n            width: width,\n            height: height\n        };\n    };\n    /**\n     * Reposition cell editor by moving viewport occluder and cell editor container.\n     */\n    CellEditor.prototype.updatePosition = function () {\n        var grid = this.cell.grid;\n        var cellInfo = this.getCellInfo(this.cell);\n        var headerHeight = grid.headerHeight;\n        var headerWidth = grid.headerWidth;\n        this.viewportOccluder.style.top = headerHeight + 'px';\n        this.viewportOccluder.style.left = headerWidth + 'px';\n        this.viewportOccluder.style.width = (grid.viewportWidth - headerWidth) + 'px';\n        this.viewportOccluder.style.height = (grid.viewportHeight - headerHeight) + 'px';\n        this.viewportOccluder.style.position = 'absolute';\n        this.editorContainer.style.left = (cellInfo.x - 1 - headerWidth) + 'px';\n        this.editorContainer.style.top = (cellInfo.y - 1 - headerHeight) + 'px';\n        this.editorContainer.style.width = (cellInfo.width + 1) + 'px';\n        this.editorContainer.style.height = (cellInfo.height + 1) + 'px';\n        this.editorContainer.style.visibility = 'visible';\n        this.editorContainer.style.position = 'absolute';\n    };\n    /**\n     * Commit the edited value.\n     *\n     * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.\n     *\n     * @returns true on valid input, false otherwise.\n     */\n    CellEditor.prototype.commit = function (cursorMovement) {\n        if (cursorMovement === void 0) { cursorMovement = 'none'; }\n        this.validate();\n        if (!this._validInput) {\n            return false;\n        }\n        var value;\n        try {\n            value = this.getInput();\n        }\n        catch (error) {\n            console.log(\"Input error: \" + error.message);\n            return false;\n        }\n        this.dispose();\n        if (this.onCommit) {\n            this.onCommit({\n                cell: this.cell,\n                value: value,\n                cursorMovement: cursorMovement\n            });\n        }\n        return true;\n    };\n    /**\n     * Create container elements needed to prevent editor widget overflow\n     * beyond viewport and to position cell editor widget.\n     */\n    CellEditor.prototype._addContainer = function () {\n        var _this = this;\n        this.viewportOccluder = document.createElement('div');\n        this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';\n        this.cell.grid.node.appendChild(this.viewportOccluder);\n        this.editorContainer = document.createElement('div');\n        this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';\n        this.viewportOccluder.appendChild(this.editorContainer);\n        // update mouse event pass-through state based on input validity\n        this.editorContainer.addEventListener('mouseleave', function (event) {\n            _this.viewportOccluder.style.pointerEvents = _this._validInput ? 'none' : 'auto';\n        });\n        this.editorContainer.addEventListener('mouseenter', function (event) {\n            _this.viewportOccluder.style.pointerEvents = 'none';\n        });\n    };\n    /**\n     * Remove validity notification popup.\n     */\n    CellEditor.prototype._closeValidityNotification = function () {\n        if (this.validityNotification) {\n            this.validityNotification.close();\n            this.validityNotification = null;\n        }\n    };\n    return CellEditor;\n}());\n/**\n * Abstract base class with shared functionality\n * for cell editors which use HTML Input widget as editor.\n */\nvar InputCellEditor = /** @class */ (function (_super) {\n    __extends(InputCellEditor, _super);\n    function InputCellEditor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    InputCellEditor.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n            case 'input':\n                this._onInput(event);\n                break;\n        }\n    };\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    InputCellEditor.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Start editing the cell.\n     */\n    InputCellEditor.prototype.startEditing = function () {\n        this.createWidget();\n        var cell = this.cell;\n        var cellInfo = this.getCellInfo(cell);\n        this.input.value = this.deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this.input);\n        this.input.focus();\n        this.input.select();\n        this.bindEvents();\n    };\n    InputCellEditor.prototype.deserialize = function (value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return value.toString();\n    };\n    InputCellEditor.prototype.createWidget = function () {\n        var input = document.createElement('input');\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorInput');\n        input.spellcheck = false;\n        input.type = this.inputType;\n        this.input = input;\n    };\n    InputCellEditor.prototype.bindEvents = function () {\n        this.input.addEventListener('keydown', this);\n        this.input.addEventListener('blur', this);\n        this.input.addEventListener('input', this);\n    };\n    InputCellEditor.prototype._unbindEvents = function () {\n        this.input.removeEventListener('keydown', this);\n        this.input.removeEventListener('blur', this);\n        this.input.removeEventListener('input', this);\n    };\n    InputCellEditor.prototype._onKeyDown = function (event) {\n        switch ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    };\n    InputCellEditor.prototype._onBlur = function (event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.input.focus();\n        }\n    };\n    InputCellEditor.prototype._onInput = function (event) {\n        this.inputChanged.emit(void 0);\n    };\n    return InputCellEditor;\n}(CellEditor));\n/**\n * Cell editor for text cells.\n */\nvar TextCellEditor = /** @class */ (function (_super) {\n    __extends(TextCellEditor, _super);\n    function TextCellEditor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.inputType = 'text';\n        return _this;\n    }\n    /**\n     * Return the current text input entered.\n     */\n    TextCellEditor.prototype.getInput = function () {\n        return this.input.value;\n    };\n    return TextCellEditor;\n}(InputCellEditor));\n/**\n * Cell editor for real number cells.\n */\nvar NumberCellEditor = /** @class */ (function (_super) {\n    __extends(NumberCellEditor, _super);\n    function NumberCellEditor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.inputType = 'number';\n        return _this;\n    }\n    /**\n     * Start editing the cell.\n     */\n    NumberCellEditor.prototype.startEditing = function () {\n        _super.prototype.startEditing.call(this);\n        this.input.step = 'any';\n        var cell = this.cell;\n        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        var constraint = metadata.constraint;\n        if (constraint) {\n            if (constraint.minimum) {\n                this.input.min = constraint.minimum;\n            }\n            if (constraint.maximum) {\n                this.input.max = constraint.maximum;\n            }\n        }\n    };\n    /**\n     * Return the current number input entered. This method throws exception\n     * if input is invalid.\n     */\n    NumberCellEditor.prototype.getInput = function () {\n        var value = this.input.value;\n        if (value.trim() === '') {\n            return null;\n        }\n        var floatValue = parseFloat(value);\n        if (isNaN(floatValue)) {\n            throw new Error('Invalid input');\n        }\n        return floatValue;\n    };\n    return NumberCellEditor;\n}(InputCellEditor));\n/**\n * Cell editor for integer cells.\n */\nvar IntegerCellEditor = /** @class */ (function (_super) {\n    __extends(IntegerCellEditor, _super);\n    function IntegerCellEditor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.inputType = 'number';\n        return _this;\n    }\n    /**\n     * Start editing the cell.\n     */\n    IntegerCellEditor.prototype.startEditing = function () {\n        _super.prototype.startEditing.call(this);\n        this.input.step = '1';\n        var cell = this.cell;\n        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        var constraint = metadata.constraint;\n        if (constraint) {\n            if (constraint.minimum) {\n                this.input.min = constraint.minimum;\n            }\n            if (constraint.maximum) {\n                this.input.max = constraint.maximum;\n            }\n        }\n    };\n    /**\n     * Return the current integer input entered. This method throws exception\n     * if input is invalid.\n     */\n    IntegerCellEditor.prototype.getInput = function () {\n        var value = this.input.value;\n        if (value.trim() === '') {\n            return null;\n        }\n        var intValue = parseInt(value);\n        if (isNaN(intValue)) {\n            throw new Error('Invalid input');\n        }\n        return intValue;\n    };\n    return IntegerCellEditor;\n}(InputCellEditor));\n/**\n * Cell editor for date cells.\n */\nvar DateCellEditor = /** @class */ (function (_super) {\n    __extends(DateCellEditor, _super);\n    function DateCellEditor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    DateCellEditor.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n        }\n    };\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    DateCellEditor.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Start editing the cell.\n     */\n    DateCellEditor.prototype.startEditing = function () {\n        this._createWidget();\n        var cell = this.cell;\n        var cellInfo = this.getCellInfo(cell);\n        this._input.value = this._deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this._input);\n        this._input.focus();\n        this._bindEvents();\n    };\n    /**\n     * Return the current date input entered.\n     */\n    DateCellEditor.prototype.getInput = function () {\n        return this._input.value;\n    };\n    DateCellEditor.prototype._deserialize = function (value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return value.toString();\n    };\n    DateCellEditor.prototype._createWidget = function () {\n        var input = document.createElement('input');\n        input.type = 'date';\n        input.pattern = \"\\d{4}-\\d{2}-\\d{2}\";\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorInput');\n        this._input = input;\n    };\n    DateCellEditor.prototype._bindEvents = function () {\n        this._input.addEventListener('keydown', this);\n        this._input.addEventListener('blur', this);\n    };\n    DateCellEditor.prototype._unbindEvents = function () {\n        this._input.removeEventListener('keydown', this);\n        this._input.removeEventListener('blur', this);\n    };\n    DateCellEditor.prototype._onKeyDown = function (event) {\n        switch ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    };\n    DateCellEditor.prototype._onBlur = function (event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._input.focus();\n        }\n    };\n    return DateCellEditor;\n}(CellEditor));\n/**\n * Cell editor for boolean cells.\n */\nvar BooleanCellEditor = /** @class */ (function (_super) {\n    __extends(BooleanCellEditor, _super);\n    function BooleanCellEditor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    BooleanCellEditor.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'mousedown':\n                // fix focus loss problem in Safari and Firefox\n                this._input.focus();\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n        }\n    };\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    BooleanCellEditor.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Start editing the cell.\n     */\n    BooleanCellEditor.prototype.startEditing = function () {\n        this._createWidget();\n        var cell = this.cell;\n        var cellInfo = this.getCellInfo(cell);\n        this._input.checked = this._deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this._input);\n        this._input.focus();\n        this._bindEvents();\n    };\n    /**\n     * Return the current boolean input entered.\n     */\n    BooleanCellEditor.prototype.getInput = function () {\n        return this._input.checked;\n    };\n    BooleanCellEditor.prototype._deserialize = function (value) {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        return value == true;\n    };\n    BooleanCellEditor.prototype._createWidget = function () {\n        var input = document.createElement('input');\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorCheckbox');\n        input.type = 'checkbox';\n        input.spellcheck = false;\n        this._input = input;\n    };\n    BooleanCellEditor.prototype._bindEvents = function () {\n        this._input.addEventListener('keydown', this);\n        this._input.addEventListener('mousedown', this);\n        this._input.addEventListener('blur', this);\n    };\n    BooleanCellEditor.prototype._unbindEvents = function () {\n        this._input.removeEventListener('keydown', this);\n        this._input.removeEventListener('mousedown', this);\n        this._input.removeEventListener('blur', this);\n    };\n    BooleanCellEditor.prototype._onKeyDown = function (event) {\n        switch ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    };\n    BooleanCellEditor.prototype._onBlur = function (event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._input.focus();\n        }\n    };\n    return BooleanCellEditor;\n}(CellEditor));\n/**\n * Cell editor for option cells.\n *\n * It supports multiple option selection. If cell metadata contains\n * type attribute 'array', then it behaves as a multi select.\n * In that case cell data is expected to be list of string values.\n */\nvar OptionCellEditor = /** @class */ (function (_super) {\n    __extends(OptionCellEditor, _super);\n    function OptionCellEditor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._isMultiSelect = false;\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    OptionCellEditor.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        _super.prototype.dispose.call(this);\n        if (this._isMultiSelect) {\n            document.body.removeChild(this._select);\n        }\n    };\n    /**\n     * Start editing the cell.\n     */\n    OptionCellEditor.prototype.startEditing = function () {\n        var cell = this.cell;\n        var cellInfo = this.getCellInfo(cell);\n        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        this._isMultiSelect = metadata.type === 'array';\n        this._createWidget();\n        if (this._isMultiSelect) {\n            this._select.multiple = true;\n            var values = this._deserialize(cellInfo.data);\n            for (var i = 0; i < this._select.options.length; ++i) {\n                var option = this._select.options.item(i);\n                option.selected = values.indexOf(option.value) !== -1;\n            }\n            document.body.appendChild(this._select);\n        }\n        else {\n            this._select.value = this._deserialize(cellInfo.data);\n            this.editorContainer.appendChild(this._select);\n        }\n        this._select.focus();\n        this._bindEvents();\n        this.updatePosition();\n    };\n    /**\n     * Return the current option input.\n     */\n    OptionCellEditor.prototype.getInput = function () {\n        if (this._isMultiSelect) {\n            var input = [];\n            for (var i = 0; i < this._select.selectedOptions.length; ++i) {\n                input.push(this._select.selectedOptions.item(i).value);\n            }\n            return input;\n        }\n        else {\n            return this._select.value;\n        }\n    };\n    /**\n     * Reposition cell editor.\n     */\n    OptionCellEditor.prototype.updatePosition = function () {\n        _super.prototype.updatePosition.call(this);\n        if (!this._isMultiSelect) {\n            return;\n        }\n        var cellInfo = this.getCellInfo(this.cell);\n        this._select.style.position = 'absolute';\n        var editorContainerRect = this.editorContainer.getBoundingClientRect();\n        this._select.style.left = editorContainerRect.left + 'px';\n        this._select.style.top = (editorContainerRect.top + cellInfo.height) + 'px';\n        this._select.style.width = editorContainerRect.width + 'px';\n        this._select.style.maxHeight = '60px';\n        this.editorContainer.style.visibility = 'hidden';\n    };\n    OptionCellEditor.prototype._deserialize = function (value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        if (this._isMultiSelect) {\n            var values = [];\n            if (Array.isArray(value)) {\n                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                    var item = value_1[_i];\n                    values.push(item.toString());\n                }\n            }\n            return values;\n        }\n        else {\n            return value.toString();\n        }\n    };\n    OptionCellEditor.prototype._createWidget = function () {\n        var cell = this.cell;\n        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        var items = metadata.constraint.enum;\n        var select = document.createElement('select');\n        select.classList.add('lm-DataGrid-cellEditorWidget');\n        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n            var item = items_1[_i];\n            var option = document.createElement(\"option\");\n            option.value = item;\n            option.text = item;\n            select.appendChild(option);\n        }\n        this._select = select;\n    };\n    OptionCellEditor.prototype._bindEvents = function () {\n        this._select.addEventListener('keydown', this._onKeyDown.bind(this));\n        this._select.addEventListener('blur', this._onBlur.bind(this));\n    };\n    OptionCellEditor.prototype._onKeyDown = function (event) {\n        switch ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    };\n    OptionCellEditor.prototype._onBlur = function (event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._select.focus();\n        }\n    };\n    return OptionCellEditor;\n}(CellEditor));\n/**\n * Cell editor for option cells whose value can be any value\n * from set of pre-defined options or values that can be input by user.\n */\nvar DynamicOptionCellEditor = /** @class */ (function (_super) {\n    __extends(DynamicOptionCellEditor, _super);\n    function DynamicOptionCellEditor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    DynamicOptionCellEditor.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n        }\n    };\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    DynamicOptionCellEditor.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Start editing the cell.\n     */\n    DynamicOptionCellEditor.prototype.startEditing = function () {\n        this._createWidget();\n        var cell = this.cell;\n        var cellInfo = this.getCellInfo(cell);\n        this._input.value = this._deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this._input);\n        this._input.focus();\n        this._input.select();\n        this._bindEvents();\n    };\n    /**\n     * Return the current option input.\n     */\n    DynamicOptionCellEditor.prototype.getInput = function () {\n        return this._input.value;\n    };\n    DynamicOptionCellEditor.prototype._deserialize = function (value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return value.toString();\n    };\n    DynamicOptionCellEditor.prototype._createWidget = function () {\n        var cell = this.cell;\n        var grid = cell.grid;\n        var dataModel = grid.dataModel;\n        var rowCount = dataModel.rowCount('body');\n        var listId = 'cell-editor-list';\n        var list = document.createElement('datalist');\n        list.id = listId;\n        var input = document.createElement('input');\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorInput');\n        var valueSet = new Set();\n        for (var r = 0; r < rowCount; ++r) {\n            var data = dataModel.data('body', r, cell.column);\n            if (data) {\n                valueSet.add(data);\n            }\n        }\n        valueSet.forEach(function (value) {\n            var option = document.createElement(\"option\");\n            option.value = value;\n            option.text = value;\n            list.appendChild(option);\n        });\n        this.editorContainer.appendChild(list);\n        input.setAttribute('list', listId);\n        this._input = input;\n    };\n    DynamicOptionCellEditor.prototype._bindEvents = function () {\n        this._input.addEventListener('keydown', this);\n        this._input.addEventListener('blur', this);\n    };\n    DynamicOptionCellEditor.prototype._unbindEvents = function () {\n        this._input.removeEventListener('keydown', this);\n        this._input.removeEventListener('blur', this);\n    };\n    DynamicOptionCellEditor.prototype._onKeyDown = function (event) {\n        switch ((0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_1__.getKeyboardLayout)().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    };\n    DynamicOptionCellEditor.prototype._onBlur = function (event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._input.focus();\n        }\n    };\n    return DynamicOptionCellEditor;\n}(CellEditor));\n\n/**\n * An object which provides the data for a data grid.\n *\n * #### Notes\n * If the predefined data models are insufficient for a particular use\n * case, a custom model can be defined which derives from this class.\n */\nvar DataModel = /** @class */ (function () {\n    function DataModel() {\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n    }\n    Object.defineProperty(DataModel.prototype, \"changed\", {\n        /**\n         * A signal emitted when the data model has changed.\n         */\n        get: function () {\n            return this._changed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the metadata for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @returns The metadata for the specified cell.\n     *\n     * #### Notes\n     * The returned metadata should be treated as immutable.\n     *\n     * This method is called often, and so should be efficient.\n     *\n     * The default implementation returns `{}`.\n     */\n    DataModel.prototype.metadata = function (region, row, column) {\n        return DataModel.emptyMetadata;\n    };\n    /**\n     * Emit the `changed` signal for the data model.\n     *\n     * #### Notes\n     * Subclasses should call this method whenever the data model has\n     * changed so that attached data grids can update themselves.\n     */\n    DataModel.prototype.emitChanged = function (args) {\n        this._changed.emit(args);\n    };\n    return DataModel;\n}());\n/**\n * An object which provides the mutable data for a data grid.\n *\n * #### Notes\n * This object is an extension to `DataModel` and it only adds ability to\n * change data for cells.\n */\nvar MutableDataModel = /** @class */ (function (_super) {\n    __extends(MutableDataModel, _super);\n    function MutableDataModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MutableDataModel;\n}(DataModel));\n/**\n * The namespace for the `DataModel` class statics.\n */\n(function (DataModel) {\n    /**\n     * A singleton empty metadata object.\n     */\n    DataModel.emptyMetadata = Object.freeze({});\n})(DataModel || (DataModel = {}));\n\n/**\n * A thin caching wrapper around a 2D canvas rendering context.\n *\n * #### Notes\n * This class is mostly a transparent wrapper around a canvas rendering\n * context which improves performance when writing context state.\n *\n * For best performance, avoid reading state from the `gc`. Writes are\n * cached based on the previously written value.\n *\n * Unless otherwise specified, the API and semantics of this class are\n * identical to the builtin 2D canvas rendering context:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n *\n * The wrapped canvas context should not be manipulated externally\n * until the wrapping `GraphicsContext` object is disposed.\n */\nvar GraphicsContext = /** @class */ (function () {\n    /**\n     * Create a new graphics context object.\n     *\n     * @param context - The 2D canvas rendering context to wrap.\n     */\n    function GraphicsContext(context) {\n        this._disposed = false;\n        this._context = context;\n        this._state = Private$3.State.create(context);\n    }\n    GraphicsContext.prototype.dispose = function () {\n        // Bail if the gc is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        // Mark the gc as disposed.\n        this._disposed = true;\n        // Pop any unrestored saves.\n        while (this._state.next) {\n            this._state = this._state.next;\n            this._context.restore();\n        }\n    };\n    Object.defineProperty(GraphicsContext.prototype, \"isDisposed\", {\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"fillStyle\", {\n        get: function () {\n            return this._context.fillStyle;\n        },\n        set: function (value) {\n            if (this._state.fillStyle !== value) {\n                this._state.fillStyle = value;\n                this._context.fillStyle = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"strokeStyle\", {\n        get: function () {\n            return this._context.strokeStyle;\n        },\n        set: function (value) {\n            if (this._state.strokeStyle !== value) {\n                this._state.strokeStyle = value;\n                this._context.strokeStyle = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"font\", {\n        get: function () {\n            return this._context.font;\n        },\n        set: function (value) {\n            if (this._state.font !== value) {\n                this._state.font = value;\n                this._context.font = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"textAlign\", {\n        get: function () {\n            return this._context.textAlign;\n        },\n        set: function (value) {\n            if (this._state.textAlign !== value) {\n                this._state.textAlign = value;\n                this._context.textAlign = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"textBaseline\", {\n        get: function () {\n            return this._context.textBaseline;\n        },\n        set: function (value) {\n            if (this._state.textBaseline !== value) {\n                this._state.textBaseline = value;\n                this._context.textBaseline = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"lineCap\", {\n        get: function () {\n            return this._context.lineCap;\n        },\n        set: function (value) {\n            if (this._state.lineCap !== value) {\n                this._state.lineCap = value;\n                this._context.lineCap = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"lineDashOffset\", {\n        get: function () {\n            return this._context.lineDashOffset;\n        },\n        set: function (value) {\n            if (this._state.lineDashOffset !== value) {\n                this._state.lineDashOffset = value;\n                this._context.lineDashOffset = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"lineJoin\", {\n        get: function () {\n            return this._context.lineJoin;\n        },\n        set: function (value) {\n            if (this._state.lineJoin !== value) {\n                this._state.lineJoin = value;\n                this._context.lineJoin = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"lineWidth\", {\n        get: function () {\n            return this._context.lineWidth;\n        },\n        set: function (value) {\n            if (this._state.lineWidth !== value) {\n                this._state.lineWidth = value;\n                this._context.lineWidth = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"miterLimit\", {\n        get: function () {\n            return this._context.miterLimit;\n        },\n        set: function (value) {\n            if (this._state.miterLimit !== value) {\n                this._state.miterLimit = value;\n                this._context.miterLimit = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"shadowBlur\", {\n        get: function () {\n            return this._context.shadowBlur;\n        },\n        set: function (value) {\n            if (this._state.shadowBlur !== value) {\n                this._state.shadowBlur = value;\n                this._context.shadowBlur = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"shadowColor\", {\n        get: function () {\n            return this._context.shadowColor;\n        },\n        set: function (value) {\n            if (this._state.shadowColor !== value) {\n                this._state.shadowColor = value;\n                this._context.shadowColor = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"shadowOffsetX\", {\n        get: function () {\n            return this._context.shadowOffsetX;\n        },\n        set: function (value) {\n            if (this._state.shadowOffsetX !== value) {\n                this._state.shadowOffsetX = value;\n                this._context.shadowOffsetX = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"shadowOffsetY\", {\n        get: function () {\n            return this._context.shadowOffsetY;\n        },\n        set: function (value) {\n            if (this._state.shadowOffsetY !== value) {\n                this._state.shadowOffsetY = value;\n                this._context.shadowOffsetY = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"imageSmoothingEnabled\", {\n        get: function () {\n            return this._context.imageSmoothingEnabled;\n        },\n        set: function (value) {\n            if (this._state.imageSmoothingEnabled !== value) {\n                this._state.imageSmoothingEnabled = value;\n                this._context.imageSmoothingEnabled = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"globalAlpha\", {\n        get: function () {\n            return this._context.globalAlpha;\n        },\n        set: function (value) {\n            if (this._state.globalAlpha !== value) {\n                this._state.globalAlpha = value;\n                this._context.globalAlpha = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphicsContext.prototype, \"globalCompositeOperation\", {\n        get: function () {\n            return this._context.globalCompositeOperation;\n        },\n        set: function (value) {\n            if (this._state.globalCompositeOperation !== value) {\n                this._state.globalCompositeOperation = value;\n                this._context.globalCompositeOperation = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GraphicsContext.prototype.getLineDash = function () {\n        return this._context.getLineDash();\n    };\n    GraphicsContext.prototype.setLineDash = function (segments) {\n        this._context.setLineDash(segments);\n    };\n    GraphicsContext.prototype.rotate = function (angle) {\n        this._context.rotate(angle);\n    };\n    GraphicsContext.prototype.scale = function (x, y) {\n        this._context.scale(x, y);\n    };\n    GraphicsContext.prototype.transform = function (m11, m12, m21, m22, dx, dy) {\n        this._context.transform(m11, m12, m21, m22, dx, dy);\n    };\n    GraphicsContext.prototype.translate = function (x, y) {\n        this._context.translate(x, y);\n    };\n    GraphicsContext.prototype.setTransform = function (m11, m12, m21, m22, dx, dy) {\n        this._context.setTransform(m11, m12, m21, m22, dx, dy);\n    };\n    GraphicsContext.prototype.save = function () {\n        // Clone an push the current state to the stack.\n        this._state = Private$3.State.push(this._state);\n        // Save the wrapped context state.\n        this._context.save();\n    };\n    GraphicsContext.prototype.restore = function () {\n        // Bail if there is no state to restore.\n        if (!this._state.next) {\n            return;\n        }\n        // Pop the saved state from the stack.\n        this._state = Private$3.State.pop(this._state);\n        // Restore the wrapped context state.\n        this._context.restore();\n    };\n    GraphicsContext.prototype.beginPath = function () {\n        return this._context.beginPath();\n    };\n    GraphicsContext.prototype.closePath = function () {\n        this._context.closePath();\n    };\n    GraphicsContext.prototype.isPointInPath = function (x, y, fillRule) {\n        var result;\n        if (arguments.length === 2) {\n            result = this._context.isPointInPath(x, y);\n        }\n        else {\n            result = this._context.isPointInPath(x, y, fillRule);\n        }\n        return result;\n    };\n    GraphicsContext.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {\n        if (arguments.length === 5) {\n            this._context.arc(x, y, radius, startAngle, endAngle);\n        }\n        else {\n            this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n        }\n    };\n    GraphicsContext.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n        this._context.arcTo(x1, y1, x2, y2, radius);\n    };\n    GraphicsContext.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n        this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    GraphicsContext.prototype.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n        if (arguments.length === 7) {\n            this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);\n        }\n        else {\n            this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\n        }\n    };\n    GraphicsContext.prototype.lineTo = function (x, y) {\n        this._context.lineTo(x, y);\n    };\n    GraphicsContext.prototype.moveTo = function (x, y) {\n        this._context.moveTo(x, y);\n    };\n    GraphicsContext.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n        this._context.quadraticCurveTo(cpx, cpy, x, y);\n    };\n    GraphicsContext.prototype.rect = function (x, y, w, h) {\n        this._context.rect(x, y, w, h);\n    };\n    GraphicsContext.prototype.clip = function (fillRule) {\n        if (arguments.length === 0) {\n            this._context.clip();\n        }\n        else {\n            this._context.clip(fillRule);\n        }\n    };\n    GraphicsContext.prototype.fill = function (fillRule) {\n        if (arguments.length === 0) {\n            this._context.fill();\n        }\n        else {\n            this._context.fill(fillRule);\n        }\n    };\n    GraphicsContext.prototype.stroke = function () {\n        this._context.stroke();\n    };\n    GraphicsContext.prototype.clearRect = function (x, y, w, h) {\n        return this._context.clearRect(x, y, w, h);\n    };\n    GraphicsContext.prototype.fillRect = function (x, y, w, h) {\n        this._context.fillRect(x, y, w, h);\n    };\n    GraphicsContext.prototype.fillText = function (text, x, y, maxWidth) {\n        if (arguments.length === 3) {\n            this._context.fillText(text, x, y);\n        }\n        else {\n            this._context.fillText(text, x, y, maxWidth);\n        }\n    };\n    GraphicsContext.prototype.strokeRect = function (x, y, w, h) {\n        this._context.strokeRect(x, y, w, h);\n    };\n    GraphicsContext.prototype.strokeText = function (text, x, y, maxWidth) {\n        if (arguments.length === 3) {\n            this._context.strokeText(text, x, y);\n        }\n        else {\n            this._context.strokeText(text, x, y, maxWidth);\n        }\n    };\n    GraphicsContext.prototype.measureText = function (text) {\n        return this._context.measureText(text);\n    };\n    GraphicsContext.prototype.createLinearGradient = function (x0, y0, x1, y1) {\n        return this._context.createLinearGradient(x0, y0, x1, y1);\n    };\n    GraphicsContext.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {\n        return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n    };\n    GraphicsContext.prototype.createPattern = function (image, repetition) {\n        return this._context.createPattern(image, repetition);\n    };\n    GraphicsContext.prototype.createImageData = function () {\n        return this._context.createImageData.apply(this._context, arguments);\n    };\n    GraphicsContext.prototype.getImageData = function (sx, sy, sw, sh) {\n        return this._context.getImageData(sx, sy, sw, sh);\n    };\n    GraphicsContext.prototype.putImageData = function () {\n        this._context.putImageData.apply(this._context, arguments);\n    };\n    GraphicsContext.prototype.drawImage = function () {\n        this._context.drawImage.apply(this._context, arguments);\n    };\n    GraphicsContext.prototype.drawFocusIfNeeded = function (element) {\n        this._context.drawFocusIfNeeded(element);\n    };\n    return GraphicsContext;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private$3;\n(function (Private) {\n    /**\n     * The index of next valid pool object.\n     */\n    var pi = -1;\n    /**\n     * A state object allocation pool.\n     */\n    var pool = [];\n    /**\n     * An object which holds the state for a gc.\n     */\n    var State = /** @class */ (function () {\n        function State() {\n        }\n        /**\n         * Create a gc state object from a 2D canvas context.\n         */\n        State.create = function (context) {\n            var state = pi < 0 ? new State() : pool[pi--];\n            state.next = null;\n            state.fillStyle = context.fillStyle;\n            state.font = context.font;\n            state.globalAlpha = context.globalAlpha;\n            state.globalCompositeOperation = context.globalCompositeOperation;\n            state.imageSmoothingEnabled = context.imageSmoothingEnabled;\n            state.lineCap = context.lineCap;\n            state.lineDashOffset = context.lineDashOffset;\n            state.lineJoin = context.lineJoin;\n            state.lineWidth = context.lineWidth;\n            state.miterLimit = context.miterLimit;\n            state.shadowBlur = context.shadowBlur;\n            state.shadowColor = context.shadowColor;\n            state.shadowOffsetX = context.shadowOffsetX;\n            state.shadowOffsetY = context.shadowOffsetY;\n            state.strokeStyle = context.strokeStyle;\n            state.textAlign = context.textAlign;\n            state.textBaseline = context.textBaseline;\n            return state;\n        };\n        /**\n         * Clone an existing gc state object and add it to the state stack.\n         */\n        State.push = function (other) {\n            var state = pi < 0 ? new State() : pool[pi--];\n            state.next = other;\n            state.fillStyle = other.fillStyle;\n            state.font = other.font;\n            state.globalAlpha = other.globalAlpha;\n            state.globalCompositeOperation = other.globalCompositeOperation;\n            state.imageSmoothingEnabled = other.imageSmoothingEnabled;\n            state.lineCap = other.lineCap;\n            state.lineDashOffset = other.lineDashOffset;\n            state.lineJoin = other.lineJoin;\n            state.lineWidth = other.lineWidth;\n            state.miterLimit = other.miterLimit;\n            state.shadowBlur = other.shadowBlur;\n            state.shadowColor = other.shadowColor;\n            state.shadowOffsetX = other.shadowOffsetX;\n            state.shadowOffsetY = other.shadowOffsetY;\n            state.strokeStyle = other.strokeStyle;\n            state.textAlign = other.textAlign;\n            state.textBaseline = other.textBaseline;\n            return state;\n        };\n        /**\n         * Pop the next state object and return the current to the pool\n         */\n        State.pop = function (state) {\n            state.fillStyle = '';\n            state.strokeStyle = '';\n            pool[++pi] = state;\n            return state.next;\n        };\n        return State;\n    }());\n    Private.State = State;\n})(Private$3 || (Private$3 = {}));\n\n/**\n * A cell renderer which renders data values as text.\n */\nvar TextRenderer = /** @class */ (function (_super) {\n    __extends(TextRenderer, _super);\n    /**\n     * Construct a new text renderer.\n     *\n     * @param options - The options for initializing the renderer.\n     */\n    function TextRenderer(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.font = options.font || '12px sans-serif';\n        _this.textColor = options.textColor || '#000000';\n        _this.backgroundColor = options.backgroundColor || '';\n        _this.verticalAlignment = options.verticalAlignment || 'center';\n        _this.horizontalAlignment = options.horizontalAlignment || 'left';\n        _this.format = options.format || TextRenderer.formatGeneric();\n        _this.elideDirection = options.elideDirection || 'right';\n        _this.wrapText = options.wrapText || false;\n        return _this;\n    }\n    /**\n     * Paint the content for a cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    TextRenderer.prototype.paint = function (gc, config) {\n        this.drawBackground(gc, config);\n        this.drawText(gc, config);\n    };\n    /**\n     * Draw the background for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    TextRenderer.prototype.drawBackground = function (gc, config) {\n        // Resolve the background color for the cell.\n        var color = CellRenderer.resolveOption(this.backgroundColor, config);\n        // Bail if there is no background color to draw.\n        if (!color) {\n            return;\n        }\n        // Fill the cell with the background color.\n        gc.fillStyle = color;\n        gc.fillRect(config.x, config.y, config.width, config.height);\n    };\n    /**\n     * Draw the text for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    TextRenderer.prototype.drawText = function (gc, config) {\n        // Resolve the font for the cell.\n        var font = CellRenderer.resolveOption(this.font, config);\n        // Bail if there is no font to draw.\n        if (!font) {\n            return;\n        }\n        // Resolve the text color for the cell.\n        var color = CellRenderer.resolveOption(this.textColor, config);\n        // Bail if there is no text color to draw.\n        if (!color) {\n            return;\n        }\n        // Format the cell value to text.\n        var format = this.format;\n        var text = format(config);\n        // Bail if there is no text to draw.\n        if (!text) {\n            return;\n        }\n        // Resolve the vertical and horizontal alignment.\n        var vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n        var hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n        // Resolve the elision direction\n        var elideDirection = CellRenderer.resolveOption(this.elideDirection, config);\n        // Resolve the text wrapping flag\n        var wrapText = CellRenderer.resolveOption(this.wrapText, config);\n        // Compute the padded text box height for the specified alignment.\n        var boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n        // Bail if the text box has no effective size.\n        if (boxHeight <= 0) {\n            return;\n        }\n        // Compute the text height for the gc font.\n        var textHeight = TextRenderer.measureFontHeight(font);\n        // Set up the text position variables.\n        var textX;\n        var textY;\n        var boxWidth;\n        // Compute the Y position for the text.\n        switch (vAlign) {\n            case 'top':\n                textY = config.y + 2 + textHeight;\n                break;\n            case 'center':\n                textY = config.y + config.height / 2 + textHeight / 2;\n                break;\n            case 'bottom':\n                textY = config.y + config.height - 2;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Compute the X position for the text.\n        switch (hAlign) {\n            case 'left':\n                textX = config.x + 8;\n                boxWidth = config.width - 14;\n                break;\n            case 'center':\n                textX = config.x + config.width / 2;\n                boxWidth = config.width;\n                break;\n            case 'right':\n                textX = config.x + config.width - 8;\n                boxWidth = config.width - 14;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Clip the cell if the text is taller than the text box height.\n        if (textHeight > boxHeight) {\n            gc.beginPath();\n            gc.rect(config.x, config.y, config.width, config.height - 1);\n            gc.clip();\n        }\n        // Set the gc state.\n        gc.font = font;\n        gc.fillStyle = color;\n        gc.textAlign = hAlign;\n        gc.textBaseline = 'bottom';\n        // The current text width in pixels.\n        var textWidth = gc.measureText(text).width;\n        // Apply text wrapping if enabled.\n        if (wrapText && textWidth > boxWidth) {\n            // Make sure box clipping happens.\n            gc.beginPath();\n            gc.rect(config.x, config.y, config.width, config.height - 1);\n            gc.clip();\n            // Split column name to words based on\n            // whitespace preceding a word boundary.\n            // \"Hello  world\" --\x3e [\"Hello  \", \"world\"]\n            var wordsInColumn = text.split(/\\s(?=\\b)/);\n            // Y-coordinate offset for any additional lines\n            var curY = textY;\n            var textInCurrentLine = wordsInColumn.shift();\n            // Single word. Applying text wrap on word by splitting\n            // it into characters and fitting the maximum number of\n            // characters possible per line (box width).\n            if (wordsInColumn.length === 0) {\n                var curLineTextWidth = gc.measureText(textInCurrentLine).width;\n                while (curLineTextWidth > boxWidth && textInCurrentLine !== \"\") {\n                    // Iterating from the end of the string until we find a\n                    // substring (0,i) which has a width less than the box width.\n                    for (var i = textInCurrentLine.length; i > 0; i--) {\n                        var curSubString = textInCurrentLine.substring(0, i);\n                        var curSubStringWidth = gc.measureText(curSubString).width;\n                        if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n                            // Found a substring which has a width less than the current\n                            // box width. Rendering that substring on the current line\n                            // and setting the remainder of the parent string as the next\n                            // string to iterate on for the next line.\n                            var nextLineText = textInCurrentLine.substring(i, textInCurrentLine.length);\n                            textInCurrentLine = nextLineText;\n                            curLineTextWidth = gc.measureText(textInCurrentLine).width;\n                            gc.fillText(curSubString, textX, curY);\n                            curY += textHeight;\n                            // No need to continue iterating after we identified\n                            // an index to break the string on.\n                            break;\n                        }\n                    }\n                }\n            }\n            // Multiple words in column header. Fitting maximum \n            // number of words possible per line (box width).\n            else {\n                while (wordsInColumn.length !== 0) {\n                    // Processing the next word in the queue.\n                    var curWord = wordsInColumn.shift();\n                    // Joining that word with the existing text for\n                    // the current line.\n                    var incrementedText = [textInCurrentLine, curWord].join(\" \");\n                    var incrementedTextWidth = gc.measureText(incrementedText).width;\n                    if (incrementedTextWidth > boxWidth) {\n                        // If the newly combined text has a width larger than\n                        // the box width, we render the line before the current\n                        // word was added. We set the current word as the next\n                        // line.\n                        gc.fillText(textInCurrentLine, textX, curY);\n                        curY += textHeight;\n                        textInCurrentLine = curWord;\n                    }\n                    else {\n                        // The combined text hasd a width less than the box width. We\n                        // set the the current line text to be the new combined text.\n                        textInCurrentLine = incrementedText;\n                    }\n                }\n            }\n            gc.fillText(textInCurrentLine, textX, curY);\n            // Terminating the call here as we don't want\n            // to apply text eliding when wrapping is active.\n            return;\n        }\n        // Elide text that is too long\n        var elide = '\\u2026';\n        // Compute elided text\n        if (elideDirection === 'right') {\n            while ((textWidth > boxWidth) && (text.length > 1)) {\n                if (text.length > 4 && textWidth >= 2 * boxWidth) {\n                    // If text width is substantially bigger, take half the string\n                    text = text.substring(0, (text.length / 2) + 1) + elide;\n                }\n                else {\n                    // Otherwise incrementally remove the last character\n                    text = text.substring(0, text.length - 2) + elide;\n                }\n                textWidth = gc.measureText(text).width;\n            }\n        }\n        else {\n            while ((textWidth > boxWidth) && (text.length > 1)) {\n                if (text.length > 4 && textWidth >= 2 * boxWidth) {\n                    // If text width is substantially bigger, take half the string\n                    text = elide + text.substring((text.length / 2));\n                }\n                else {\n                    // Otherwise incrementally remove the last character\n                    text = elide + text.substring(2);\n                }\n                textWidth = gc.measureText(text).width;\n            }\n        }\n        // Draw the text for the cell.\n        gc.fillText(text, textX, textY);\n    };\n    return TextRenderer;\n}(CellRenderer));\n/**\n * The namespace for the `TextRenderer` class statics.\n */\n(function (TextRenderer) {\n    /**\n     * Create a generic text format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new generic text format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `String()` to coerce any value\n     * to a string.\n     */\n    function formatGeneric(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return String(value);\n        };\n    }\n    TextRenderer.formatGeneric = formatGeneric;\n    /**\n     * Create a fixed decimal format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new fixed decimal format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Number()` and `toFixed()` to\n     * coerce values.\n     *\n     * The `formatIntlNumber()` formatter is more flexible, but slower.\n     */\n    function formatFixed(options) {\n        if (options === void 0) { options = {}; }\n        var digits = options.digits;\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return Number(value).toFixed(digits);\n        };\n    }\n    TextRenderer.formatFixed = formatFixed;\n    /**\n     * Create a significant figure format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new significant figure format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Number()` and `toPrecision()`\n     * to coerce values.\n     *\n     * The `formatIntlNumber()` formatter is more flexible, but slower.\n     */\n    function formatPrecision(options) {\n        if (options === void 0) { options = {}; }\n        var digits = options.digits;\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return Number(value).toPrecision(digits);\n        };\n    }\n    TextRenderer.formatPrecision = formatPrecision;\n    /**\n     * Create a scientific notation format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new scientific notation format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Number()` and `toExponential()`\n     * to coerce values.\n     *\n     * The `formatIntlNumber()` formatter is more flexible, but slower.\n     */\n    function formatExponential(options) {\n        if (options === void 0) { options = {}; }\n        var digits = options.digits;\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return Number(value).toExponential(digits);\n        };\n    }\n    TextRenderer.formatExponential = formatExponential;\n    /**\n     * Create an international number format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new international number format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Intl.NumberFormat` object to\n     * coerce values.\n     *\n     * This is the most flexible (but slowest) number formatter.\n     */\n    function formatIntlNumber(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        var nft = new Intl.NumberFormat(options.locales, options.options);\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return nft.format(value);\n        };\n    }\n    TextRenderer.formatIntlNumber = formatIntlNumber;\n    /**\n     * Create a date format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new date format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toDateString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatDate(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toDateString();\n            }\n            return (new Date(value)).toDateString();\n        };\n    }\n    TextRenderer.formatDate = formatDate;\n    /**\n     * Create a time format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new time format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toTimeString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatTime(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toTimeString();\n            }\n            return (new Date(value)).toTimeString();\n        };\n    }\n    TextRenderer.formatTime = formatTime;\n    /**\n     * Create an ISO datetime format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new ISO datetime format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toISOString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatISODateTime(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toISOString();\n            }\n            return (new Date(value)).toISOString();\n        };\n    }\n    TextRenderer.formatISODateTime = formatISODateTime;\n    /**\n     * Create a UTC datetime format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new UTC datetime format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toUTCString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatUTCDateTime(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toUTCString();\n            }\n            return (new Date(value)).toUTCString();\n        };\n    }\n    TextRenderer.formatUTCDateTime = formatUTCDateTime;\n    /**\n     * Create an international datetime format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new international datetime format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Intl.DateTimeFormat` object to\n     * coerce values.\n     *\n     * This is the most flexible (but slowest) datetime formatter.\n     */\n    function formatIntlDateTime(options) {\n        if (options === void 0) { options = {}; }\n        var missing = options.missing || '';\n        var dtf = new Intl.DateTimeFormat(options.locales, options.options);\n        return function (_a) {\n            var value = _a.value;\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return dtf.format(value);\n        };\n    }\n    TextRenderer.formatIntlDateTime = formatIntlDateTime;\n    /**\n     * Measure the height of a font.\n     *\n     * @param font - The CSS font string of interest.\n     *\n     * @returns The height of the font bounding box.\n     *\n     * #### Notes\n     * This function uses a temporary DOM node to measure the text box\n     * height for the specified font. The first call for a given font\n     * will incur a DOM reflow, but the return value is cached, so any\n     * subsequent call for the same font will return the cached value.\n     */\n    function measureFontHeight(font) {\n        // Look up the cached font height.\n        var height = Private$4.fontHeightCache[font];\n        // Return the cached font height if it exists.\n        if (height !== undefined) {\n            return height;\n        }\n        // Normalize the font.\n        Private$4.fontMeasurementGC.font = font;\n        var normFont = Private$4.fontMeasurementGC.font;\n        // Set the font on the measurement node.\n        Private$4.fontMeasurementNode.style.font = normFont;\n        // Add the measurement node to the document.\n        document.body.appendChild(Private$4.fontMeasurementNode);\n        // Measure the node height.\n        height = Private$4.fontMeasurementNode.offsetHeight;\n        // Remove the measurement node from the document.\n        document.body.removeChild(Private$4.fontMeasurementNode);\n        // Cache the measured height for the font and norm font.\n        Private$4.fontHeightCache[font] = height;\n        Private$4.fontHeightCache[normFont] = height;\n        // Return the measured height.\n        return height;\n    }\n    TextRenderer.measureFontHeight = measureFontHeight;\n})(TextRenderer || (TextRenderer = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$4;\n(function (Private) {\n    /**\n     * A cache of measured font heights.\n     */\n    Private.fontHeightCache = Object.create(null);\n    /**\n     * The DOM node used for font height measurement.\n     */\n    Private.fontMeasurementNode = (function () {\n        var node = document.createElement('div');\n        node.style.position = 'absolute';\n        node.style.top = '-99999px';\n        node.style.left = '-99999px';\n        node.style.visibility = 'hidden';\n        node.textContent = 'M';\n        return node;\n    })();\n    /**\n     * The GC used for font measurement.\n     */\n    Private.fontMeasurementGC = (function () {\n        var canvas = document.createElement('canvas');\n        canvas.width = 0;\n        canvas.height = 0;\n        return canvas.getContext('2d');\n    })();\n})(Private$4 || (Private$4 = {}));\n\n/**\n * A class which manages the mapping of cell renderers.\n */\nvar RendererMap = /** @class */ (function () {\n    /**\n     * Construct a new renderer map.\n     *\n     * @param values - The initial values for the map.\n     *\n     * @param fallback - The renderer of last resort.\n     */\n    function RendererMap(values, fallback) {\n        if (values === void 0) { values = {}; }\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n        this._values = __assign({}, values);\n        this._fallback = fallback || new TextRenderer();\n    }\n    Object.defineProperty(RendererMap.prototype, \"changed\", {\n        /**\n         * A signal emitted when the renderer map has changed.\n         */\n        get: function () {\n            return this._changed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the cell renderer to use for the given cell config.\n     *\n     * @param config - The cell config of interest.\n     *\n     * @returns The renderer to use for the cell.\n     */\n    RendererMap.prototype.get = function (config) {\n        // Fetch the renderer from the values map.\n        var renderer = this._values[config.region];\n        // Execute a resolver function if necessary.\n        if (typeof renderer === 'function') {\n            try {\n                renderer = renderer(config);\n            }\n            catch (err) {\n                renderer = undefined;\n                console.error(err);\n            }\n        }\n        // Return the renderer or the fallback.\n        return renderer || this._fallback;\n    };\n    /**\n     * Update the renderer map with new values\n     *\n     * @param values - The updated values for the map.\n     *\n     * @param fallback - The renderer of last resort.\n     *\n     * #### Notes\n     * This method always emits the `changed` signal.\n     */\n    RendererMap.prototype.update = function (values, fallback) {\n        if (values === void 0) { values = {}; }\n        this._values = __assign(__assign({}, this._values), values);\n        this._fallback = fallback || this._fallback;\n        this._changed.emit(undefined);\n    };\n    return RendererMap;\n}());\n\n// Copyright (c) Jupyter Development Team.\n/**\n * An object which manages a collection of variable sized sections.\n *\n * #### Notes\n * This class is an implementation detail. It is designed to manage\n * the variable row and column sizes for a data grid. User code will\n * not interact with this class directly.\n */\nvar SectionList = /** @class */ (function () {\n    /**\n     * Construct a new section list.\n     *\n     * @param options - The options for initializing the list.\n     */\n    function SectionList(options) {\n        this._count = 0;\n        this._length = 0;\n        this._sections = [];\n        this._minimumSize = options.minimumSize || 2;\n        this._defaultSize = Math.max(this._minimumSize, Math.floor(options.defaultSize));\n    }\n    Object.defineProperty(SectionList.prototype, \"length\", {\n        /**\n         * The total size of all sections in the list.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SectionList.prototype, \"count\", {\n        /**\n         * The total number of sections in the list.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._count;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SectionList.prototype, \"minimumSize\", {\n        /**\n         * Get the minimum size of sections in the list.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._minimumSize;\n        },\n        /**\n         * Set the minimum size of sections in the list.\n         *\n         * #### Complexity\n         * Linear on the number of resized sections.\n         */\n        set: function (value) {\n            // Normalize the value.\n            value = Math.max(2, Math.floor(value));\n            // Bail early if the value does not change.\n            if (this._minimumSize === value) {\n                return;\n            }\n            // Update the internal minimum size.\n            this._minimumSize = value;\n            // Update default size if larger than minimum size\n            if (value > this._defaultSize) {\n                this.defaultSize = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SectionList.prototype, \"defaultSize\", {\n        /**\n         * Get the default size of sections in the list.\n         *\n         * #### Complexity\n         * Constant.\n         */\n        get: function () {\n            return this._defaultSize;\n        },\n        /**\n         * Set the default size of sections in the list.\n         *\n         * #### Complexity\n         * Linear on the number of resized sections.\n         */\n        set: function (value) {\n            // Normalize the value.\n            value = Math.max(this._minimumSize, Math.floor(value));\n            // Bail early if the value does not change.\n            if (this._defaultSize === value) {\n                return;\n            }\n            // Compute the delta default size.\n            var delta = value - this._defaultSize;\n            // Update the internal default size.\n            this._defaultSize = value;\n            // Update the length.\n            this._length += delta * (this._count - this._sections.length);\n            // Bail early if there are no modified sections.\n            if (this._sections.length === 0) {\n                return;\n            }\n            // Recompute the offsets of the modified sections.\n            for (var i = 0, n = this._sections.length; i < n; ++i) {\n                // Look up the previous and current modified sections.\n                var prev = this._sections[i - 1];\n                var curr = this._sections[i];\n                // Adjust the offset for the current section.\n                if (prev) {\n                    var count = curr.index - prev.index - 1;\n                    curr.offset = prev.offset + prev.size + count * value;\n                }\n                else {\n                    curr.offset = curr.index * value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Clamp a size to the minimum section size\n     *\n     * @param size - The size to clamp.\n     *\n     * @returns The size or the section minimum size, whichever is larger\n     */\n    SectionList.prototype.clampSize = function (size) {\n        return Math.max(this._minimumSize, Math.floor(size));\n    };\n    /**\n     * Find the index of the section which covers the given offset.\n     *\n     * @param offset - The offset of the section of interest.\n     *\n     * @returns The index of the section which covers the given offset,\n     *   or `-1` if the offset is out of range.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    SectionList.prototype.indexOf = function (offset) {\n        // Bail early if the offset is out of range.\n        if (offset < 0 || offset >= this._length || this._count === 0) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return Math.floor(offset / this._defaultSize);\n        }\n        // Find the modified section for the given offset.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, offset, Private$5.offsetCmp);\n        // Return the index of an exact match.\n        if (i < this._sections.length && this._sections[i].offset <= offset) {\n            return this._sections[i].index;\n        }\n        // Handle the case of no modified sections before the offset.\n        if (i === 0) {\n            return Math.floor(offset / this._defaultSize);\n        }\n        // Compute the index from the previous modified section.\n        var section = this._sections[i - 1];\n        var span = offset - (section.offset + section.size);\n        return section.index + Math.floor(span / this._defaultSize) + 1;\n    };\n    /**\n     * Find the offset of the section at the given index.\n     *\n     * @param index - The index of the section of interest.\n     *\n     * @returns The offset of the section at the given index, or `-1`\n     *   if the index is out of range.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    SectionList.prototype.offsetOf = function (index) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return index * this._defaultSize;\n        }\n        // Find the modified section for the given index.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index, Private$5.indexCmp);\n        // Return the offset of an exact match.\n        if (i < this._sections.length && this._sections[i].index === index) {\n            return this._sections[i].offset;\n        }\n        // Handle the case of no modified sections before the index.\n        if (i === 0) {\n            return index * this._defaultSize;\n        }\n        // Compute the offset from the previous modified section.\n        var section = this._sections[i - 1];\n        var span = index - section.index - 1;\n        return section.offset + section.size + span * this._defaultSize;\n    };\n    /**\n     * Find the extent of the section at the given index.\n     *\n     * @param index - The index of the section of interest.\n     *\n     * @returns The extent of the section at the given index, or `-1`\n     *   if the index is out of range.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    SectionList.prototype.extentOf = function (index) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return (index + 1) * this._defaultSize - 1;\n        }\n        // Find the modified section for the given index.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index, Private$5.indexCmp);\n        // Return the offset of an exact match.\n        if (i < this._sections.length && this._sections[i].index === index) {\n            return this._sections[i].offset + this._sections[i].size - 1;\n        }\n        // Handle the case of no modified sections before the index.\n        if (i === 0) {\n            return (index + 1) * this._defaultSize - 1;\n        }\n        // Compute the offset from the previous modified section.\n        var section = this._sections[i - 1];\n        var span = index - section.index;\n        return section.offset + section.size + span * this._defaultSize - 1;\n    };\n    /**\n     * Find the size of the section at the given index.\n     *\n     * @param index - The index of the section of interest.\n     *\n     * @returns The size of the section at the given index, or `-1`\n     *   if the index is out of range.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    SectionList.prototype.sizeOf = function (index) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return this._defaultSize;\n        }\n        // Find the modified section for the given index.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index, Private$5.indexCmp);\n        // Return the size of an exact match.\n        if (i < this._sections.length && this._sections[i].index === index) {\n            return this._sections[i].size;\n        }\n        // Return the default size for all other cases.\n        return this._defaultSize;\n    };\n    /**\n     * Resize a section in the list.\n     *\n     * @param index - The index of the section to resize. This method\n     *   is a no-op if this value is out of range.\n     *\n     * @param size - The new size of the section. This value will be\n     *   clamped to an integer `>= 0`.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    SectionList.prototype.resize = function (index, size) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return;\n        }\n        // Clamp the size to an integer >= minimum size.\n        size = Math.max(this._minimumSize, Math.floor(size));\n        // Find the modified section for the given index.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index, Private$5.indexCmp);\n        // Update or create the modified section as needed.\n        var delta;\n        if (i < this._sections.length && this._sections[i].index === index) {\n            var section = this._sections[i];\n            delta = size - section.size;\n            section.size = size;\n        }\n        else if (i === 0) {\n            var offset = index * this._defaultSize;\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.insert(this._sections, i, { index: index, offset: offset, size: size });\n            delta = size - this._defaultSize;\n        }\n        else {\n            var section = this._sections[i - 1];\n            var span = index - section.index - 1;\n            var offset = section.offset + section.size + span * this._defaultSize;\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.insert(this._sections, i, { index: index, offset: offset, size: size });\n            delta = size - this._defaultSize;\n        }\n        // Adjust the length.\n        this._length += delta;\n        // Update all modified sections after the resized section.\n        for (var j = i + 1, n = this._sections.length; j < n; ++j) {\n            this._sections[j].offset += delta;\n        }\n    };\n    /**\n     * Insert sections into the list.\n     *\n     * @param index - The index at which to insert the sections. This\n     *   value will be clamped to the bounds of the list.\n     *\n     * @param count - The number of sections to insert. This method\n     *   is a no-op if this value is `<= 0`.\n     *\n     * #### Undefined Behavior\n     * An `index` or `count` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    SectionList.prototype.insert = function (index, count) {\n        // Bail early if there are no sections to insert.\n        if (count <= 0) {\n            return;\n        }\n        // Clamp the index to the bounds of the list.\n        index = Math.max(0, Math.min(index, this._count));\n        // Add the new sections to the totals.\n        var span = count * this._defaultSize;\n        this._count += count;\n        this._length += span;\n        // Bail early if there are no modified sections to update.\n        if (this._sections.length === 0) {\n            return;\n        }\n        // Find the modified section for the given index.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index, Private$5.indexCmp);\n        // Update all modified sections after the insert location.\n        for (var n = this._sections.length; i < n; ++i) {\n            var section = this._sections[i];\n            section.index += count;\n            section.offset += span;\n        }\n    };\n    /**\n     * Remove sections from the list.\n     *\n     * @param index - The index of the first section to remove. This\n     *   method is a no-op if this value is out of range.\n     *\n     * @param count - The number of sections to remove. This method\n     *   is a no-op if this value is `<= 0`.\n     *\n     * #### Undefined Behavior\n     * An `index` or `count` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    SectionList.prototype.remove = function (index, count) {\n        // Bail early if there is nothing to remove.\n        if (index < 0 || index >= this._count || count <= 0) {\n            return;\n        }\n        // Clamp the count to the bounds of the list.\n        count = Math.min(this._count - index, count);\n        // Handle the simple case of no modified sections to update.\n        if (this._sections.length === 0) {\n            this._count -= count;\n            this._length -= count * this._defaultSize;\n            return;\n        }\n        // Handle the simple case of removing all sections.\n        if (count === this._count) {\n            this._length = 0;\n            this._count = 0;\n            this._sections.length = 0;\n            return;\n        }\n        // Find the modified section for the start index.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index, Private$5.indexCmp);\n        // Find the modified section for the end index.\n        var j = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, index + count, Private$5.indexCmp);\n        // Remove the relevant modified sections.\n        var removed = this._sections.splice(i, j - i);\n        // Compute the total removed span.\n        var span = (count - removed.length) * this._defaultSize;\n        for (var k = 0, n = removed.length; k < n; ++k) {\n            span += removed[k].size;\n        }\n        // Adjust the totals.\n        this._count -= count;\n        this._length -= span;\n        // Update all modified sections after the removed span.\n        for (var k = i, n = this._sections.length; k < n; ++k) {\n            var section = this._sections[k];\n            section.index -= count;\n            section.offset -= span;\n        }\n    };\n    /**\n     * Move sections within the list.\n     *\n     * @param index - The index of the first section to move. This method\n     *   is a no-op if this value is out of range.\n     *\n     * @param count - The number of sections to move. This method is a\n     *   no-op if this value is `<= 0`.\n     *\n     * @param destination - The destination index for the first section.\n     *   This value will be clamped to the allowable range.\n     *\n     * #### Undefined Behavior\n     * An `index`, `count`, or `destination` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of moved resized sections.\n     */\n    SectionList.prototype.move = function (index, count, destination) {\n        // Bail early if there is nothing to move.\n        if (index < 0 || index >= this._count || count <= 0) {\n            return;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return;\n        }\n        // Clamp the move count to the limit.\n        count = Math.min(count, this._count - index);\n        // Clamp the destination index to the limit.\n        destination = Math.min(Math.max(0, destination), this._count - count);\n        // Bail early if there is no effective move.\n        if (index === destination) {\n            return;\n        }\n        // Compute the first affected index.\n        var i1 = Math.min(index, destination);\n        // Look up the first affected modified section.\n        var k1 = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, i1, Private$5.indexCmp);\n        // Bail early if there are no affected modified sections.\n        if (k1 === this._sections.length) {\n            return;\n        }\n        // Compute the last affected index.\n        var i2 = Math.max(index + count - 1, destination + count - 1);\n        // Look up the last affected modified section.\n        var k2 = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.upperBound(this._sections, i2, Private$5.indexCmp) - 1;\n        // Bail early if there are no affected modified sections.\n        if (k2 < k1) {\n            return;\n        }\n        // Compute the pivot index.\n        var pivot = destination < index ? index : index + count;\n        // Compute the count for each side of the pivot.\n        var count1 = pivot - i1;\n        var count2 = i2 - pivot + 1;\n        // Compute the span for each side of the pivot.\n        var span1 = count1 * this._defaultSize;\n        var span2 = count2 * this._defaultSize;\n        // Adjust the spans for the modified sections.\n        for (var j = k1; j <= k2; ++j) {\n            var section = this._sections[j];\n            if (section.index < pivot) {\n                span1 += section.size - this._defaultSize;\n            }\n            else {\n                span2 += section.size - this._defaultSize;\n            }\n        }\n        // Look up the pivot section.\n        var k3 = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.lowerBound(this._sections, pivot, Private$5.indexCmp);\n        // Rotate the modified sections if needed.\n        if (k1 <= k3 && k3 <= k2) {\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.rotate(this._sections, k3 - k1, k1, k2);\n        }\n        // Adjust the modified section indices and offsets.\n        for (var j = k1; j <= k2; ++j) {\n            var section = this._sections[j];\n            if (section.index < pivot) {\n                section.index += count2;\n                section.offset += span2;\n            }\n            else {\n                section.index -= count1;\n                section.offset -= span1;\n            }\n        }\n    };\n    /**\n     * Reset all modified sections to the default size.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    SectionList.prototype.reset = function () {\n        this._sections.length = 0;\n        this._length = this._count * this._defaultSize;\n    };\n    /**\n     * Remove all sections from the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    SectionList.prototype.clear = function () {\n        this._count = 0;\n        this._length = 0;\n        this._sections.length = 0;\n    };\n    return SectionList;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private$5;\n(function (Private) {\n    /**\n     * A comparison function for searching by offset.\n     */\n    function offsetCmp(section, offset) {\n        if (offset < section.offset) {\n            return 1;\n        }\n        if (section.offset + section.size <= offset) {\n            return -1;\n        }\n        return 0;\n    }\n    Private.offsetCmp = offsetCmp;\n    /**\n     * A comparison function for searching by index.\n     */\n    function indexCmp(section, index) {\n        return section.index - index;\n    }\n    Private.indexCmp = indexCmp;\n})(Private$5 || (Private$5 = {}));\n\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Resolve a config option for a cell editor.\n *\n * @param option - The config option to resolve.\n *\n * @param config - The cell config object.\n *\n * @returns The resolved value for the option.\n */\nfunction resolveOption(option, config) {\n    return typeof option === 'function' ? option(config) : option;\n}\n/**\n * An object which manages cell editing. It stores editor overrides,\n * decides which editor to use for a cell, makes sure there is only one editor active.\n */\nvar CellEditorController = /** @class */ (function () {\n    function CellEditorController() {\n        // active cell editor\n        this._editor = null;\n        // active cell being edited\n        this._cell = null;\n        // cell editor overrides based on cell data type identifier\n        this._typeBasedOverrides = new Map();\n        // cell editor overrides based on partial metadata match\n        this._metadataBasedOverrides = new Map();\n    }\n    /**\n     * Override cell editor for the cells matching the identifier.\n     *\n     * @param identifier - Cell identifier to use when matching cells.\n     * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n     * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n     * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n     *\n     * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n     */\n    CellEditorController.prototype.setEditor = function (identifier, editor) {\n        if (typeof identifier === 'string') {\n            this._typeBasedOverrides.set(identifier, editor);\n        }\n        else {\n            var key = this._metadataIdentifierToKey(identifier);\n            this._metadataBasedOverrides.set(key, [identifier, editor]);\n        }\n    };\n    /**\n     * Start editing a cell.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param options - The cell editing options.\n     */\n    CellEditorController.prototype.edit = function (cell, options) {\n        var grid = cell.grid;\n        if (!grid.editable) {\n            console.error('Grid cannot be edited!');\n            return false;\n        }\n        this.cancel();\n        this._cell = cell;\n        options = options || {};\n        options.onCommit = options.onCommit || this._onCommit.bind(this);\n        options.onCancel = options.onCancel || this._onCancel.bind(this);\n        // if an editor is passed in with options, then use it for editing\n        if (options.editor) {\n            this._editor = options.editor;\n            options.editor.edit(cell, options);\n            return true;\n        }\n        // choose an editor based on overrides / cell data type\n        var editor = this._getEditor(cell);\n        if (editor) {\n            this._editor = editor;\n            editor.edit(cell, options);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Cancel editing.\n     */\n    CellEditorController.prototype.cancel = function () {\n        if (this._editor) {\n            this._editor.cancel();\n            this._editor = null;\n        }\n        this._cell = null;\n    };\n    CellEditorController.prototype._onCommit = function (response) {\n        var cell = this._cell;\n        if (!cell) {\n            return;\n        }\n        var grid = cell.grid;\n        var dataModel = grid.dataModel;\n        dataModel.setData('body', cell.row, cell.column, response.value);\n        grid.viewport.node.focus();\n        if (response.cursorMovement !== 'none') {\n            grid.moveCursor(response.cursorMovement);\n            grid.scrollToCursor();\n        }\n    };\n    CellEditorController.prototype._onCancel = function () {\n        if (!this._cell) {\n            return;\n        }\n        this._cell.grid.viewport.node.focus();\n    };\n    CellEditorController.prototype._getDataTypeKey = function (cell) {\n        var metadata = cell.grid.dataModel ? cell.grid.dataModel.metadata('body', cell.row, cell.column) : null;\n        if (!metadata) {\n            return 'default';\n        }\n        var key = '';\n        if (metadata) {\n            key = metadata.type;\n        }\n        if (metadata.constraint && metadata.constraint.enum) {\n            if (metadata.constraint.enum === 'dynamic') {\n                key += ':dynamic-option';\n            }\n            else {\n                key += ':option';\n            }\n        }\n        return key;\n    };\n    CellEditorController.prototype._objectToKey = function (object) {\n        var str = '';\n        for (var key in object) {\n            var value = object[key];\n            if (typeof value === 'object') {\n                str += key + \":\" + this._objectToKey(value);\n            }\n            else {\n                str += \"[\" + key + \":\" + value + \"]\";\n            }\n        }\n        return str;\n    };\n    CellEditorController.prototype._metadataIdentifierToKey = function (metadata) {\n        return this._objectToKey(metadata);\n    };\n    CellEditorController.prototype._metadataMatchesIdentifier = function (metadata, identifier) {\n        for (var key in identifier) {\n            if (!metadata.hasOwnProperty(key)) {\n                return false;\n            }\n            var identifierValue = identifier[key];\n            var metadataValue = metadata[key];\n            if (typeof identifierValue === 'object') {\n                if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {\n                    return false;\n                }\n            }\n            else if (metadataValue !== identifierValue) {\n                return false;\n            }\n        }\n        return true;\n    };\n    CellEditorController.prototype._getMetadataBasedEditor = function (cell) {\n        var _this = this;\n        var editorMatched;\n        var metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        if (metadata) {\n            this._metadataBasedOverrides.forEach(function (value) {\n                if (!editorMatched) {\n                    var identifier = value[0], editor = value[1];\n                    if (_this._metadataMatchesIdentifier(metadata, identifier)) {\n                        editorMatched = resolveOption(editor, cell);\n                    }\n                }\n            });\n        }\n        return editorMatched;\n    };\n    /**\n     * Choose the most appropriate cell editor to use based on overrides / cell data type.\n     *\n     * If no match is found in overrides or based on cell data type, and if cell has a primitive\n     * data type then TextCellEditor is used as default cell editor. If 'default' cell editor\n     * is overridden, then it is used instead of TextCellEditor for default.\n     */\n    CellEditorController.prototype._getEditor = function (cell) {\n        var dtKey = this._getDataTypeKey(cell);\n        // find an editor based on data type based override\n        if (this._typeBasedOverrides.has(dtKey)) {\n            var editor = this._typeBasedOverrides.get(dtKey);\n            return resolveOption(editor, cell);\n        } // find an editor based on metadata match based override\n        else if (this._metadataBasedOverrides.size > 0) {\n            var editor = this._getMetadataBasedEditor(cell);\n            if (editor) {\n                return editor;\n            }\n        }\n        // choose an editor based on data type\n        switch (dtKey) {\n            case 'string':\n                return new TextCellEditor();\n            case 'number':\n                return new NumberCellEditor();\n            case 'integer':\n                return new IntegerCellEditor();\n            case 'boolean':\n                return new BooleanCellEditor();\n            case 'date':\n                return new DateCellEditor();\n            case 'string:option':\n            case 'number:option':\n            case 'integer:option':\n            case 'date:option':\n            case 'array:option':\n                return new OptionCellEditor();\n            case 'string:dynamic-option':\n            case 'number:dynamic-option':\n            case 'integer:dynamic-option':\n            case 'date:dynamic-option':\n                return new DynamicOptionCellEditor();\n        }\n        // if an override exists for 'default', then use it\n        if (this._typeBasedOverrides.has('default')) {\n            var editor = this._typeBasedOverrides.get('default');\n            return resolveOption(editor, cell);\n        }\n        // if cell has a primitive data type then use TextCellEditor\n        var data = cell.grid.dataModel.data('body', cell.row, cell.column);\n        if (!data || typeof data !== 'object') {\n            return new TextCellEditor();\n        }\n        // no suitable editor found for the cell\n        return undefined;\n    };\n    return CellEditorController;\n}());\n\n/**\n * A widget which implements a high-performance tabular data grid.\n *\n * #### Notes\n * A data grid is implemented as a composition of child widgets. These\n * child widgets are considered an implementation detail. Manipulating\n * the child widgets of a data grid directly is undefined behavior.\n *\n * This class is not designed to be subclassed.\n */\nvar DataGrid = /** @class */ (function (_super) {\n    __extends(DataGrid, _super);\n    /**\n     * Construct a new data grid.\n     *\n     * @param options - The options for initializing the data grid.\n     */\n    function DataGrid(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this._scrollX = 0;\n        _this._scrollY = 0;\n        _this._viewportWidth = 0;\n        _this._viewportHeight = 0;\n        _this._mousedown = false;\n        _this._keyHandler = null;\n        _this._mouseHandler = null;\n        _this._vScrollBarMinWidth = 0;\n        _this._hScrollBarMinHeight = 0;\n        _this._dpiRatio = Math.ceil(window.devicePixelRatio);\n        _this._dataModel = null;\n        _this._selectionModel = null;\n        _this._editingEnabled = false;\n        _this.addClass('lm-DataGrid');\n        /* <DEPRECATED> */\n        _this.addClass('p-DataGrid');\n        /* </DEPRECATED> */\n        // Parse the simple options.\n        _this._style = options.style || DataGrid.defaultStyle;\n        _this._stretchLastRow = options.stretchLastRow || false;\n        _this._stretchLastColumn = options.stretchLastColumn || false;\n        _this._headerVisibility = options.headerVisibility || 'all';\n        _this._cellRenderers = options.cellRenderers || new RendererMap();\n        _this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;\n        // Connect to the renderer map changed signal.\n        _this._cellRenderers.changed.connect(_this._onRenderersChanged, _this);\n        // Parse the default sizes.\n        var defaultSizes = options.defaultSizes || DataGrid.defaultSizes;\n        var minimumSizes = options.minimumSizes || DataGrid.minimumSizes;\n        // Set up the sections lists.\n        _this._rowSections = new SectionList({ defaultSize: defaultSizes.rowHeight,\n            minimumSize: minimumSizes.rowHeight });\n        _this._columnSections = new SectionList({ defaultSize: defaultSizes.columnWidth,\n            minimumSize: minimumSizes.columnWidth });\n        _this._rowHeaderSections = new SectionList({ defaultSize: defaultSizes.rowHeaderWidth,\n            minimumSize: minimumSizes.rowHeaderWidth });\n        _this._columnHeaderSections = new SectionList({ defaultSize: defaultSizes.columnHeaderHeight,\n            minimumSize: minimumSizes.columnHeaderHeight });\n        // Create the canvas, buffer, and overlay objects.\n        _this._canvas = Private$6.createCanvas();\n        _this._buffer = Private$6.createCanvas();\n        _this._overlay = Private$6.createCanvas();\n        // Get the graphics contexts for the canvases.\n        _this._canvasGC = _this._canvas.getContext('2d');\n        _this._bufferGC = _this._buffer.getContext('2d');\n        _this._overlayGC = _this._overlay.getContext('2d');\n        // Set up the on-screen canvas.\n        _this._canvas.style.position = 'absolute';\n        _this._canvas.style.top = '0px';\n        _this._canvas.style.left = '0px';\n        _this._canvas.style.width = '0px';\n        _this._canvas.style.height = '0px';\n        // Set up the on-screen overlay.\n        _this._overlay.style.position = 'absolute';\n        _this._overlay.style.top = '0px';\n        _this._overlay.style.left = '0px';\n        _this._overlay.style.width = '0px';\n        _this._overlay.style.height = '0px';\n        // Create the internal widgets for the data grid.\n        _this._viewport = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget();\n        _this._viewport.node.tabIndex = -1;\n        _this._viewport.node.style.outline = 'none';\n        _this._vScrollBar = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.ScrollBar({ orientation: 'vertical' });\n        _this._hScrollBar = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.ScrollBar({ orientation: 'horizontal' });\n        _this._scrollCorner = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget();\n        _this._editorController = new CellEditorController();\n        // Add the extra class names to the child widgets.\n        _this._viewport.addClass('lm-DataGrid-viewport');\n        _this._vScrollBar.addClass('lm-DataGrid-scrollBar');\n        _this._hScrollBar.addClass('lm-DataGrid-scrollBar');\n        _this._scrollCorner.addClass('lm-DataGrid-scrollCorner');\n        /* <DEPRECATED> */\n        _this._viewport.addClass('p-DataGrid-viewport');\n        _this._vScrollBar.addClass('p-DataGrid-scrollBar');\n        _this._hScrollBar.addClass('p-DataGrid-scrollBar');\n        _this._scrollCorner.addClass('p-DataGrid-scrollCorner');\n        /* </DEPRECATED> */\n        // Add the on-screen canvas to the viewport node.\n        _this._viewport.node.appendChild(_this._canvas);\n        // Add the on-screen overlay to the viewport node.\n        _this._viewport.node.appendChild(_this._overlay);\n        // Install the message hooks.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.installMessageHook(_this._viewport, _this);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.installMessageHook(_this._hScrollBar, _this);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.installMessageHook(_this._vScrollBar, _this);\n        // Hide the scroll bars and corner from the outset.\n        _this._vScrollBar.hide();\n        _this._hScrollBar.hide();\n        _this._scrollCorner.hide();\n        // Connect to the scroll bar signals.\n        _this._vScrollBar.thumbMoved.connect(_this._onThumbMoved, _this);\n        _this._hScrollBar.thumbMoved.connect(_this._onThumbMoved, _this);\n        _this._vScrollBar.pageRequested.connect(_this._onPageRequested, _this);\n        _this._hScrollBar.pageRequested.connect(_this._onPageRequested, _this);\n        _this._vScrollBar.stepRequested.connect(_this._onStepRequested, _this);\n        _this._hScrollBar.stepRequested.connect(_this._onStepRequested, _this);\n        // Set the layout cell config for the child widgets.\n        _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.GridLayout.setCellConfig(_this._viewport, { row: 0, column: 0 });\n        _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.GridLayout.setCellConfig(_this._vScrollBar, { row: 0, column: 1 });\n        _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.GridLayout.setCellConfig(_this._hScrollBar, { row: 1, column: 0 });\n        _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.GridLayout.setCellConfig(_this._scrollCorner, { row: 1, column: 1 });\n        // Create the layout for the data grid.\n        var layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.GridLayout({\n            rowCount: 2,\n            columnCount: 2,\n            rowSpacing: 0,\n            columnSpacing: 0,\n            fitPolicy: 'set-no-constraint'\n        });\n        // Set the stretch factors for the grid.\n        layout.setRowStretch(0, 1);\n        layout.setRowStretch(1, 0);\n        layout.setColumnStretch(0, 1);\n        layout.setColumnStretch(1, 0);\n        // Add the child widgets to the layout.\n        layout.addWidget(_this._viewport);\n        layout.addWidget(_this._vScrollBar);\n        layout.addWidget(_this._hScrollBar);\n        layout.addWidget(_this._scrollCorner);\n        // Install the layout on the data grid.\n        _this.layout = layout;\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the widgets.\n     */\n    DataGrid.prototype.dispose = function () {\n        // Release the mouse.\n        this._releaseMouse();\n        // Dispose of the handlers.\n        if (this._keyHandler) {\n            this._keyHandler.dispose();\n        }\n        if (this._mouseHandler) {\n            this._mouseHandler.dispose();\n        }\n        this._keyHandler = null;\n        this._mouseHandler = null;\n        // Clear the models.\n        this._dataModel = null;\n        this._selectionModel = null;\n        // Clear the section lists.\n        this._rowSections.clear();\n        this._columnSections.clear();\n        this._rowHeaderSections.clear();\n        this._columnHeaderSections.clear();\n        // Dispose of the base class.\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(DataGrid.prototype, \"dataModel\", {\n        /**\n         * Get the data model for the data grid.\n         */\n        get: function () {\n            return this._dataModel;\n        },\n        /**\n         * Set the data model for the data grid.\n         *\n         * #### Notes\n         * This will automatically remove the current selection model.\n         */\n        set: function (value) {\n            // Do nothing if the model does not change.\n            if (this._dataModel === value) {\n                return;\n            }\n            // Release the mouse.\n            this._releaseMouse();\n            // Clear the selection model.\n            this.selectionModel = null;\n            // Disconnect the change handler from the old model.\n            if (this._dataModel) {\n                this._dataModel.changed.disconnect(this._onDataModelChanged, this);\n            }\n            // Connect the change handler for the new model.\n            if (value) {\n                value.changed.connect(this._onDataModelChanged, this);\n            }\n            // Update the internal model reference.\n            this._dataModel = value;\n            // Clear the section lists.\n            this._rowSections.clear();\n            this._columnSections.clear();\n            this._rowHeaderSections.clear();\n            this._columnHeaderSections.clear();\n            // Populate the section lists.\n            if (value) {\n                this._rowSections.insert(0, value.rowCount('body'));\n                this._columnSections.insert(0, value.columnCount('body'));\n                this._rowHeaderSections.insert(0, value.columnCount('row-header'));\n                this._columnHeaderSections.insert(0, value.rowCount('column-header'));\n            }\n            // Reset the scroll position.\n            this._scrollX = 0;\n            this._scrollY = 0;\n            // Sync the viewport.\n            this._syncViewport();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"selectionModel\", {\n        /**\n         * Get the selection model for the data grid.\n         */\n        get: function () {\n            return this._selectionModel;\n        },\n        /**\n         * Set the selection model for the data grid.\n         */\n        set: function (value) {\n            // Do nothing if the selection model does not change.\n            if (this._selectionModel === value) {\n                return;\n            }\n            // Release the mouse.\n            this._releaseMouse();\n            // Ensure the data models are a match.\n            if (value && value.dataModel !== this._dataModel) {\n                throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');\n            }\n            // Disconnect the change handler from the old model.\n            if (this._selectionModel) {\n                this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);\n            }\n            // Connect the change handler for the new model.\n            if (value) {\n                value.changed.connect(this._onSelectionsChanged, this);\n            }\n            // Update the internal selection model reference.\n            this._selectionModel = value;\n            // Schedule a repaint of the overlay.\n            this.repaintOverlay();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"keyHandler\", {\n        /**\n         * Get the key handler for the data grid.\n         */\n        get: function () {\n            return this._keyHandler;\n        },\n        /**\n         * Set the key handler for the data grid.\n         */\n        set: function (value) {\n            this._keyHandler = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"mouseHandler\", {\n        /**\n         * Get the mouse handler for the data grid.\n         */\n        get: function () {\n            return this._mouseHandler;\n        },\n        /**\n         * Set the mouse handler for the data grid.\n         */\n        set: function (value) {\n            // Bail early if the mouse handler does not change.\n            if (this._mouseHandler === value) {\n                return;\n            }\n            // Release the mouse.\n            this._releaseMouse();\n            // Update the internal mouse handler.\n            this._mouseHandler = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"style\", {\n        /**\n         * Get the style for the data grid.\n         */\n        get: function () {\n            return this._style;\n        },\n        /**\n         * Set the style for the data grid.\n         */\n        set: function (value) {\n            // Bail if the style does not change.\n            if (this._style === value) {\n                return;\n            }\n            // Update the internal style.\n            this._style = __assign({}, value);\n            // Schedule a repaint of the content.\n            this.repaintContent();\n            // Schedule a repaint of the overlay.\n            this.repaintOverlay();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"cellRenderers\", {\n        /**\n         * Get the cell renderer map for the data grid.\n         */\n        get: function () {\n            return this._cellRenderers;\n        },\n        /**\n         * Set the cell renderer map for the data grid.\n         */\n        set: function (value) {\n            // Bail if the renderer map does not change.\n            if (this._cellRenderers === value) {\n                return;\n            }\n            // Disconnect the old map.\n            this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);\n            // Connect the new map.\n            value.changed.connect(this._onRenderersChanged, this);\n            // Update the internal renderer map.\n            this._cellRenderers = value;\n            // Schedule a repaint of the grid content.\n            this.repaintContent();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"headerVisibility\", {\n        /**\n         * Get the header visibility for the data grid.\n         */\n        get: function () {\n            return this._headerVisibility;\n        },\n        /**\n         * Set the header visibility for the data grid.\n         */\n        set: function (value) {\n            // Bail if the visibility does not change.\n            if (this._headerVisibility === value) {\n                return;\n            }\n            // Update the internal visibility.\n            this._headerVisibility = value;\n            // Sync the viewport.\n            this._syncViewport();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"defaultSizes\", {\n        /**\n         * Get the default sizes for the various sections of the data grid.\n         */\n        get: function () {\n            var rowHeight = this._rowSections.defaultSize;\n            var columnWidth = this._columnSections.defaultSize;\n            var rowHeaderWidth = this._rowHeaderSections.defaultSize;\n            var columnHeaderHeight = this._columnHeaderSections.defaultSize;\n            return { rowHeight: rowHeight, columnWidth: columnWidth, rowHeaderWidth: rowHeaderWidth, columnHeaderHeight: columnHeaderHeight };\n        },\n        /**\n         * Set the default sizes for the various sections of the data grid.\n         */\n        set: function (value) {\n            // Update the section default sizes.\n            this._rowSections.defaultSize = value.rowHeight;\n            this._columnSections.defaultSize = value.columnWidth;\n            this._rowHeaderSections.defaultSize = value.rowHeaderWidth;\n            this._columnHeaderSections.defaultSize = value.columnHeaderHeight;\n            // Sync the viewport.\n            this._syncViewport();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"minimumSizes\", {\n        /**\n         * Get the minimum sizes for the various sections of the data grid.\n         */\n        get: function () {\n            var rowHeight = this._rowSections.minimumSize;\n            var columnWidth = this._columnSections.minimumSize;\n            var rowHeaderWidth = this._rowHeaderSections.minimumSize;\n            var columnHeaderHeight = this._columnHeaderSections.minimumSize;\n            return { rowHeight: rowHeight, columnWidth: columnWidth, rowHeaderWidth: rowHeaderWidth, columnHeaderHeight: columnHeaderHeight };\n        },\n        /**\n         * Set the minimum sizes for the various sections of the data grid.\n         */\n        set: function (value) {\n            // Update the section default sizes.\n            this._rowSections.minimumSize = value.rowHeight;\n            this._columnSections.minimumSize = value.columnWidth;\n            this._rowHeaderSections.minimumSize = value.rowHeaderWidth;\n            this._columnHeaderSections.minimumSize = value.columnHeaderHeight;\n            // Sync the viewport.\n            this._syncViewport();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"copyConfig\", {\n        /**\n         * Get the copy configuration for the data grid.\n         */\n        get: function () {\n            return this._copyConfig;\n        },\n        /**\n         * Set the copy configuration for the data grid.\n         */\n        set: function (value) {\n            this._copyConfig = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"stretchLastRow\", {\n        /**\n         * Get whether the last row is stretched.\n         */\n        get: function () {\n            return this._stretchLastRow;\n        },\n        /**\n         * Set whether the last row is stretched.\n         */\n        set: function (value) {\n            // Bail early if the value does not change.\n            if (value === this._stretchLastRow) {\n                return;\n            }\n            // Update the internal value.\n            this._stretchLastRow = value;\n            // Sync the viewport\n            this._syncViewport();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"stretchLastColumn\", {\n        /**\n         * Get whether the last column is stretched.\n         */\n        get: function () {\n            return this._stretchLastColumn;\n        },\n        /**\n         * Set whether the last column is stretched.\n         */\n        set: function (value) {\n            // Bail early if the value does not change.\n            if (value === this._stretchLastColumn) {\n                return;\n            }\n            // Update the internal value.\n            this._stretchLastColumn = value;\n            // Sync the viewport\n            this._syncViewport();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"headerWidth\", {\n        /**\n         * The virtual width of the row headers.\n         */\n        get: function () {\n            if (this._headerVisibility === 'none') {\n                return 0;\n            }\n            if (this._headerVisibility === 'column') {\n                return 0;\n            }\n            return this._rowHeaderSections.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"headerHeight\", {\n        /**\n         * The virtual height of the column headers.\n         */\n        get: function () {\n            if (this._headerVisibility === 'none') {\n                return 0;\n            }\n            if (this._headerVisibility === 'row') {\n                return 0;\n            }\n            return this._columnHeaderSections.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"bodyWidth\", {\n        /**\n         * The virtual width of the grid body.\n         *\n         * #### Notes\n         * This does *not* account for a stretched last column.\n         */\n        get: function () {\n            return this._columnSections.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"bodyHeight\", {\n        /**\n         * The virtual height of the grid body.\n         *\n         * #### Notes\n         * This does *not* account for a stretched last row.\n         */\n        get: function () {\n            return this._rowSections.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"totalWidth\", {\n        /**\n         * The virtual width of the entire grid.\n         *\n         * #### Notes\n         * This does *not* account for a stretched last column.\n         */\n        get: function () {\n            return this.headerWidth + this.bodyWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"totalHeight\", {\n        /**\n         * The virtual height of the entire grid.\n         *\n         * #### Notes\n         * This does *not* account for a stretched last row.\n         */\n        get: function () {\n            return this.headerHeight + this.bodyHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"viewportWidth\", {\n        /**\n         * The actual width of the viewport.\n         */\n        get: function () {\n            return this._viewportWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"viewportHeight\", {\n        /**\n         * The actual height of the viewport.\n         */\n        get: function () {\n            return this._viewportHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"pageWidth\", {\n        /**\n         * The width of the visible portion of the grid body.\n         */\n        get: function () {\n            return Math.max(0, this.viewportWidth - this.headerWidth);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"pageHeight\", {\n        /**\n         * The height of the visible portion of the grid body.\n         */\n        get: function () {\n            return Math.max(0, this.viewportHeight - this.headerHeight);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"scrollX\", {\n        /**\n         * The current scroll X position of the viewport.\n         */\n        get: function () {\n            return this._hScrollBar.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"scrollY\", {\n        /**\n         * The current scroll Y position of the viewport.\n         */\n        get: function () {\n            return this._vScrollBar.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"maxScrollX\", {\n        /**\n         * The maximum scroll X position for the grid.\n         */\n        get: function () {\n            return Math.max(0, this.bodyWidth - this.pageWidth - 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"maxScrollY\", {\n        /**\n         * The maximum scroll Y position for the grid.\n         */\n        get: function () {\n            return Math.max(0, this.bodyHeight - this.pageHeight - 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"viewport\", {\n        /**\n         * The viewport widget for the data grid.\n         */\n        get: function () {\n            return this._viewport;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"editorController\", {\n        /**\n         * The cell editor controller object for the data grid.\n         */\n        get: function () {\n            return this._editorController;\n        },\n        set: function (controller) {\n            this._editorController = controller;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"editingEnabled\", {\n        /**\n         * Whether the cell editing is enabled for the data grid.\n         */\n        get: function () {\n            return this._editingEnabled;\n        },\n        set: function (enabled) {\n            this._editingEnabled = enabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"editable\", {\n        /**\n         * Whether the grid cells are editable.\n         *\n         * `editingEnabled` flag must be on and grid must have required\n         * selection model, editor controller and data model properties.\n         */\n        get: function () {\n            return this._editingEnabled &&\n                this._selectionModel !== null &&\n                this._editorController !== null &&\n                this.dataModel instanceof MutableDataModel;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"canvasGC\", {\n        /**\n         * The rendering context for painting the data grid.\n         */\n        get: function () {\n            return this._canvasGC;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"rowSections\", {\n        /**\n         * The row sections of the data grid.\n         */\n        get: function () {\n            return this._rowSections;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"columnSections\", {\n        /**\n         * The column sections of the data grid.\n         */\n        get: function () {\n            return this._columnSections;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"rowHeaderSections\", {\n        /**\n         * The row header sections of the data grid.\n         */\n        get: function () {\n            return this._rowHeaderSections;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataGrid.prototype, \"columnHeaderSections\", {\n        /**\n         * The column header sections of the data grid.\n         */\n        get: function () {\n            return this._columnHeaderSections;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Scroll the grid to the specified row.\n     *\n     * @param row - The row index of the cell.\n     *\n     * #### Notes\n     * This is a no-op if the row is already visible.\n     */\n    DataGrid.prototype.scrollToRow = function (row) {\n        // Fetch the row count.\n        var nr = this._rowSections.count;\n        // Bail early if there is no content.\n        if (nr === 0) {\n            return;\n        }\n        // Floor the row index.\n        row = Math.floor(row);\n        // Clamp the row index.\n        row = Math.max(0, Math.min(row, nr - 1));\n        // Get the virtual bounds of the row.\n        var y1 = this._rowSections.offsetOf(row);\n        var y2 = this._rowSections.extentOf(row);\n        // Get the virtual bounds of the viewport.\n        var vy1 = this._scrollY;\n        var vy2 = this._scrollY + this.pageHeight - 1;\n        // Set up the delta variables.\n        var dy = 0;\n        // Compute the delta Y scroll.\n        if (y1 < vy1) {\n            dy = y1 - vy1 - 10;\n        }\n        else if (y2 > vy2) {\n            dy = y2 - vy2 + 10;\n        }\n        // Bail early if no scroll is needed.\n        if (dy === 0) {\n            return;\n        }\n        // Scroll by the computed delta.\n        this.scrollBy(0, dy);\n    };\n    /**\n     * Scroll the grid to the specified column.\n     *\n     * @param column - The column index of the cell.\n     *\n     * #### Notes\n     * This is a no-op if the column is already visible.\n     */\n    DataGrid.prototype.scrollToColumn = function (column) {\n        // Fetch the column count.\n        var nc = this._columnSections.count;\n        // Bail early if there is no content.\n        if (nc === 0) {\n            return;\n        }\n        // Floor the column index.\n        column = Math.floor(column);\n        // Clamp the column index.\n        column = Math.max(0, Math.min(column, nc - 1));\n        // Get the virtual bounds of the column.\n        var x1 = this._columnSections.offsetOf(column);\n        var x2 = this._columnSections.extentOf(column);\n        // Get the virtual bounds of the viewport.\n        var vx1 = this._scrollX;\n        var vx2 = this._scrollX + this.pageWidth - 1;\n        // Set up the delta variables.\n        var dx = 0;\n        // Compute the delta X scroll.\n        if (x1 < vx1) {\n            dx = x1 - vx1 - 10;\n        }\n        else if (x2 > vx2) {\n            dx = x2 - vx2 + 10;\n        }\n        // Bail early if no scroll is needed.\n        if (dx === 0) {\n            return;\n        }\n        // Scroll by the computed delta.\n        this.scrollBy(dx, 0);\n    };\n    /**\n     * Scroll the grid to the specified cell.\n     *\n     * @param row - The row index of the cell.\n     *\n     * @param column - The column index of the cell.\n     *\n     * #### Notes\n     * This is a no-op if the cell is already visible.\n     */\n    DataGrid.prototype.scrollToCell = function (row, column) {\n        // Fetch the row and column count.\n        var nr = this._rowSections.count;\n        var nc = this._columnSections.count;\n        // Bail early if there is no content.\n        if (nr === 0 || nc === 0) {\n            return;\n        }\n        // Floor the cell index.\n        row = Math.floor(row);\n        column = Math.floor(column);\n        // Clamp the cell index.\n        row = Math.max(0, Math.min(row, nr - 1));\n        column = Math.max(0, Math.min(column, nc - 1));\n        // Get the virtual bounds of the cell.\n        var x1 = this._columnSections.offsetOf(column);\n        var x2 = this._columnSections.extentOf(column);\n        var y1 = this._rowSections.offsetOf(row);\n        var y2 = this._rowSections.extentOf(row);\n        // Get the virtual bounds of the viewport.\n        var vx1 = this._scrollX;\n        var vx2 = this._scrollX + this.pageWidth - 1;\n        var vy1 = this._scrollY;\n        var vy2 = this._scrollY + this.pageHeight - 1;\n        // Set up the delta variables.\n        var dx = 0;\n        var dy = 0;\n        // Compute the delta X scroll.\n        if (x1 < vx1) {\n            dx = x1 - vx1 - 10;\n        }\n        else if (x2 > vx2) {\n            dx = x2 - vx2 + 10;\n        }\n        // Compute the delta Y scroll.\n        if (y1 < vy1) {\n            dy = y1 - vy1 - 10;\n        }\n        else if (y2 > vy2) {\n            dy = y2 - vy2 + 10;\n        }\n        // Bail early if no scroll is needed.\n        if (dx === 0 && dy === 0) {\n            return;\n        }\n        // Scroll by the computed delta.\n        this.scrollBy(dx, dy);\n    };\n    /**\n     * Move cursor down/up/left/right while making sure it remains\n     * within the bounds of selected rectangles\n     *\n     * @param direction - The direction of the movement.\n     */\n    DataGrid.prototype.moveCursor = function (direction) {\n        // Bail early if there is no selection\n        if (!this.dataModel ||\n            !this._selectionModel ||\n            this._selectionModel.isEmpty) {\n            return;\n        }\n        var iter = this._selectionModel.selections();\n        var onlyOne = iter.next() && !iter.next();\n        // if there is a single selection that is a single cell selection\n        // then move the selection and cursor within grid bounds\n        if (onlyOne) {\n            var currentSel = this._selectionModel.currentSelection();\n            if (currentSel.r1 === currentSel.r2 &&\n                currentSel.c1 === currentSel.c2) {\n                var dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n                var dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n                var newRow = currentSel.r1 + dr;\n                var newColumn = currentSel.c1 + dc;\n                var rowCount = this.dataModel.rowCount('body');\n                var columnCount = this.dataModel.columnCount('body');\n                if (newRow >= rowCount) {\n                    newRow = 0;\n                    newColumn += 1;\n                }\n                else if (newRow === -1) {\n                    newRow = rowCount - 1;\n                    newColumn -= 1;\n                }\n                if (newColumn >= columnCount) {\n                    newColumn = 0;\n                    newRow += 1;\n                    if (newRow >= rowCount) {\n                        newRow = 0;\n                    }\n                }\n                else if (newColumn === -1) {\n                    newColumn = columnCount - 1;\n                    newRow -= 1;\n                    if (newRow === -1) {\n                        newRow = rowCount - 1;\n                    }\n                }\n                this._selectionModel.select({\n                    r1: newRow, c1: newColumn,\n                    r2: newRow, c2: newColumn,\n                    cursorRow: newRow, cursorColumn: newColumn,\n                    clear: 'all'\n                });\n                return;\n            }\n        }\n        // if there are multiple selections, move cursor\n        // within selection rectangles\n        this._selectionModel.moveCursorWithinSelections(direction);\n    };\n    /**\n     * Scroll the grid to the current cursor position.\n     *\n     * #### Notes\n     * This is a no-op if the cursor is already visible or\n     * if there is no selection model installed on the grid.\n     */\n    DataGrid.prototype.scrollToCursor = function () {\n        // Bail early if there is no selection model.\n        if (!this._selectionModel) {\n            return;\n        }\n        // Fetch the cursor row and column.\n        var row = this._selectionModel.cursorRow;\n        var column = this._selectionModel.cursorColumn;\n        // Scroll to the cursor cell.\n        this.scrollToCell(row, column);\n    };\n    /**\n     * Scroll the viewport by the specified amount.\n     *\n     * @param dx - The X scroll amount.\n     *\n     * @param dy - The Y scroll amount.\n     */\n    DataGrid.prototype.scrollBy = function (dx, dy) {\n        this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n    };\n    /**\n     * Scroll the viewport by one page.\n     *\n     * @param dir - The desired direction of the scroll.\n     */\n    DataGrid.prototype.scrollByPage = function (dir) {\n        var dx = 0;\n        var dy = 0;\n        switch (dir) {\n            case 'up':\n                dy = -this.pageHeight;\n                break;\n            case 'down':\n                dy = this.pageHeight;\n                break;\n            case 'left':\n                dx = -this.pageWidth;\n                break;\n            case 'right':\n                dx = this.pageWidth;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n    };\n    /**\n     * Scroll the viewport by one cell-aligned step.\n     *\n     * @param dir - The desired direction of the scroll.\n     */\n    DataGrid.prototype.scrollByStep = function (dir) {\n        var r;\n        var c;\n        var x = this.scrollX;\n        var y = this.scrollY;\n        var rows = this._rowSections;\n        var columns = this._columnSections;\n        switch (dir) {\n            case 'up':\n                r = rows.indexOf(y - 1);\n                y = r < 0 ? y : rows.offsetOf(r);\n                break;\n            case 'down':\n                r = rows.indexOf(y);\n                y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);\n                break;\n            case 'left':\n                c = columns.indexOf(x - 1);\n                x = c < 0 ? x : columns.offsetOf(c);\n                break;\n            case 'right':\n                c = columns.indexOf(x);\n                x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.scrollTo(x, y);\n    };\n    /**\n     * Scroll to the specified offset position.\n     *\n     * @param x - The desired X position.\n     *\n     * @param y - The desired Y position.\n     */\n    DataGrid.prototype.scrollTo = function (x, y) {\n        // Floor and clamp the position to the allowable range.\n        x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n        y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n        // Update the scroll bar values with the desired position.\n        this._hScrollBar.value = x;\n        this._vScrollBar.value = y;\n        // Post a scroll request message to the viewport.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, Private$6.ScrollRequest);\n    };\n    /**\n     * Get the row count for a particular region in the data grid.\n     *\n     * @param region - The row region of interest.\n     *\n     * @returns The row count for the specified region.\n     */\n    DataGrid.prototype.rowCount = function (region) {\n        var count;\n        if (region === 'body') {\n            count = this._rowSections.count;\n        }\n        else {\n            count = this._columnHeaderSections.count;\n        }\n        return count;\n    };\n    /**\n     * Get the column count for a particular region in the data grid.\n     *\n     * @param region - The column region of interest.\n     *\n     * @returns The column count for the specified region.\n     */\n    DataGrid.prototype.columnCount = function (region) {\n        var count;\n        if (region === 'body') {\n            count = this._columnSections.count;\n        }\n        else {\n            count = this._rowHeaderSections.count;\n        }\n        return count;\n    };\n    /**\n     * Get the row at a virtual offset in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param offset - The virtual offset of the row of interest.\n     *\n     * @returns The index of the row, or `-1` if the offset is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last row.\n     */\n    DataGrid.prototype.rowAt = function (region, offset) {\n        // Bail early if the offset is negative.\n        if (offset < 0) {\n            return -1;\n        }\n        // Return early for the column header region.\n        if (region === 'column-header') {\n            return this._columnHeaderSections.indexOf(offset);\n        }\n        // Fetch the index.\n        var index = this._rowSections.indexOf(offset);\n        // Return early if the section is found.\n        if (index >= 0) {\n            return index;\n        }\n        // Bail early if the last row is not stretched.\n        if (!this._stretchLastRow) {\n            return -1;\n        }\n        // Fetch the geometry.\n        var bh = this.bodyHeight;\n        var ph = this.pageHeight;\n        // Bail early if no row stretching is required.\n        if (ph <= bh) {\n            return -1;\n        }\n        // Bail early if the offset is out of bounds.\n        if (offset >= ph) {\n            return -1;\n        }\n        // Otherwise, return the last row.\n        return this._rowSections.count - 1;\n    };\n    /**\n     * Get the column at a virtual offset in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param offset - The virtual offset of the column of interest.\n     *\n     * @returns The index of the column, or `-1` if the offset is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last column.\n     */\n    DataGrid.prototype.columnAt = function (region, offset) {\n        if (offset < 0) {\n            return -1;\n        }\n        // Return early for the row header region.\n        if (region === 'row-header') {\n            return this._rowHeaderSections.indexOf(offset);\n        }\n        // Fetch the index.\n        var index = this._columnSections.indexOf(offset);\n        // Return early if the section is found.\n        if (index >= 0) {\n            return index;\n        }\n        // Bail early if the last column is not stretched.\n        if (!this._stretchLastColumn) {\n            return -1;\n        }\n        // Fetch the geometry.\n        var bw = this.bodyWidth;\n        var pw = this.pageWidth;\n        // Bail early if no column stretching is required.\n        if (pw <= bw) {\n            return -1;\n        }\n        // Bail early if the offset is out of bounds.\n        if (offset >= pw) {\n            return -1;\n        }\n        // Otherwise, return the last column.\n        return this._columnSections.count - 1;\n    };\n    /**\n     * Get the offset of a row in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param index - The index of the row of interest.\n     *\n     * @returns The offset of the row, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * A stretched last row has no effect on the return value.\n     */\n    DataGrid.prototype.rowOffset = function (region, index) {\n        var offset;\n        if (region === 'body') {\n            offset = this._rowSections.offsetOf(index);\n        }\n        else {\n            offset = this._columnHeaderSections.offsetOf(index);\n        }\n        return offset;\n    };\n    /**\n     * Get the offset of a column in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param index - The index of the column of interest.\n     *\n     * @returns The offset of the column, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * A stretched last column has no effect on the return value.\n     */\n    DataGrid.prototype.columnOffset = function (region, index) {\n        var offset;\n        if (region === 'body') {\n            offset = this._columnSections.offsetOf(index);\n        }\n        else {\n            offset = this._rowHeaderSections.offsetOf(index);\n        }\n        return offset;\n    };\n    /**\n     * Get the size of a row in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param index - The index of the row of interest.\n     *\n     * @returns The size of the row, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last row.\n     */\n    DataGrid.prototype.rowSize = function (region, index) {\n        // Return early for the column header region.\n        if (region === 'column-header') {\n            return this._columnHeaderSections.sizeOf(index);\n        }\n        // Fetch the row size.\n        var size = this._rowSections.sizeOf(index);\n        // Bail early if the index is out of bounds.\n        if (size < 0) {\n            return size;\n        }\n        // Return early if the last row is not stretched.\n        if (!this._stretchLastRow) {\n            return size;\n        }\n        // Return early if its not the last row.\n        if (index < this._rowSections.count - 1) {\n            return size;\n        }\n        // Fetch the geometry.\n        var bh = this.bodyHeight;\n        var ph = this.pageHeight;\n        // Return early if no stretching is needed.\n        if (ph <= bh) {\n            return size;\n        }\n        // Return the adjusted size.\n        return size + (ph - bh);\n    };\n    /**\n     * Get the size of a column in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param index - The index of the column of interest.\n     *\n     * @returns The size of the column, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last column.\n     */\n    DataGrid.prototype.columnSize = function (region, index) {\n        // Return early for the row header region.\n        if (region === 'row-header') {\n            return this._rowHeaderSections.sizeOf(index);\n        }\n        // Fetch the column size.\n        var size = this._columnSections.sizeOf(index);\n        // Bail early if the index is out of bounds.\n        if (size < 0) {\n            return size;\n        }\n        // Return early if the last column is not stretched.\n        if (!this._stretchLastColumn) {\n            return size;\n        }\n        // Return early if its not the last column.\n        if (index < this._columnSections.count - 1) {\n            return size;\n        }\n        // Fetch the geometry.\n        var bw = this.bodyWidth;\n        var pw = this.pageWidth;\n        // Return early if no stretching is needed.\n        if (pw <= bw) {\n            return size;\n        }\n        // Return the adjusted size.\n        return size + (pw - bw);\n    };\n    /**\n     * Resize a row in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param index - The index of the row of interest.\n     *\n     * @param size - The desired size of the row.\n     */\n    DataGrid.prototype.resizeRow = function (region, index, size) {\n        var msg = new Private$6.RowResizeRequest(region, index, size);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, msg);\n    };\n    /**\n     * Resize a column in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param index - The index of the column of interest.\n     *\n     * @param size - The desired size of the column.\n     */\n    DataGrid.prototype.resizeColumn = function (region, index, size) {\n        var msg = new Private$6.ColumnResizeRequest(region, index, size);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, msg);\n    };\n    /**\n     * Reset modified rows to their default size.\n     *\n     * @param region - The row region of interest.\n     */\n    DataGrid.prototype.resetRows = function (region) {\n        switch (region) {\n            case 'all':\n                this._rowSections.reset();\n                this._columnHeaderSections.reset();\n                break;\n            case 'body':\n                this._rowSections.reset();\n                break;\n            case 'column-header':\n                this._columnHeaderSections.reset();\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.repaintContent();\n        this.repaintOverlay();\n    };\n    /**\n     * Reset modified columns to their default size.\n     *\n     * @param region - The column region of interest.\n     */\n    DataGrid.prototype.resetColumns = function (region) {\n        switch (region) {\n            case 'all':\n                this._columnSections.reset();\n                this._rowHeaderSections.reset();\n                break;\n            case 'body':\n                this._columnSections.reset();\n                break;\n            case 'row-header':\n                this._rowHeaderSections.reset();\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.repaintContent();\n        this.repaintOverlay();\n    };\n    /**\n     * Map a client position to local viewport coordinates.\n     *\n     * @param clientX - The client X position of the mouse.\n     *\n     * @param clientY - The client Y position of the mouse.\n     *\n     * @returns The local viewport coordinates for the position.\n     */\n    DataGrid.prototype.mapToLocal = function (clientX, clientY) {\n        // Fetch the viewport rect.\n        var rect = this._viewport.node.getBoundingClientRect();\n        // Extract the rect coordinates.\n        var left = rect.left, top = rect.top;\n        // Round the rect coordinates for sub-pixel positioning.\n        left = Math.floor(left);\n        top = Math.floor(top);\n        // Convert to local coordinates.\n        var lx = clientX - left;\n        var ly = clientY - top;\n        // Return the local coordinates.\n        return { lx: lx, ly: ly };\n    };\n    /**\n     * Map a client position to virtual grid coordinates.\n     *\n     * @param clientX - The client X position of the mouse.\n     *\n     * @param clientY - The client Y position of the mouse.\n     *\n     * @returns The virtual grid coordinates for the position.\n     */\n    DataGrid.prototype.mapToVirtual = function (clientX, clientY) {\n        // Convert to local coordiates.\n        var _a = this.mapToLocal(clientX, clientY), lx = _a.lx, ly = _a.ly;\n        // Convert to virtual coordinates.\n        var vx = lx + this.scrollX - this.headerWidth;\n        var vy = ly + this.scrollY - this.headerHeight;\n        // Return the local coordinates.\n        return { vx: vx, vy: vy };\n    };\n    /**\n     * Hit test the viewport for the given client position.\n     *\n     * @param clientX - The client X position of the mouse.\n     *\n     * @param clientY - The client Y position of the mouse.\n     *\n     * @returns The hit test result, or `null` if the client\n     *   position is out of bounds.\n     *\n     * #### Notes\n     * This method accounts for a stretched last row and/or column.\n     */\n    DataGrid.prototype.hitTest = function (clientX, clientY) {\n        // Convert the mouse position into local coordinates.\n        var _a = this.mapToLocal(clientX, clientY), lx = _a.lx, ly = _a.ly;\n        // Fetch the header and body dimensions.\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        var bw = this.bodyWidth;\n        var bh = this.bodyHeight;\n        var ph = this.pageHeight;\n        var pw = this.pageWidth;\n        // Adjust the body width for a stretched last column.\n        if (this._stretchLastColumn && pw > bw) {\n            bw = pw;\n        }\n        // Adjust the body height for a stretched last row.\n        if (this._stretchLastRow && ph > bh) {\n            bh = ph;\n        }\n        // Check for a corner header hit.\n        if (lx >= 0 && lx < hw && ly >= 0 && ly < hh) {\n            // Convert to unscrolled virtual coordinates.\n            var vx = lx;\n            var vy = ly;\n            // Fetch the row and column index.\n            var row_1 = this.rowAt('column-header', vy);\n            var column_1 = this.columnAt('row-header', vx);\n            // Fetch the cell offset position.\n            var ox = this.columnOffset('row-header', column_1);\n            var oy = this.rowOffset('column-header', row_1);\n            // Fetch cell width and height.\n            var width_1 = this.columnSize('row-header', column_1);\n            var height_1 = this.rowSize('column-header', row_1);\n            // Compute the leading and trailing positions.\n            var x_1 = vx - ox;\n            var y_1 = vy - oy;\n            // Return the hit test result.\n            return { region: 'corner-header', row: row_1, column: column_1, x: x_1, y: y_1, width: width_1, height: height_1 };\n        }\n        // Check for a column header hit.\n        if (ly >= 0 && ly < hh && lx >= 0 && lx < (hw + bw)) {\n            // Convert to unscrolled virtual coordinates.\n            var vx = lx + this._scrollX - hw;\n            var vy = ly;\n            // Fetch the row and column index.\n            var row_2 = this.rowAt('column-header', vy);\n            var column_2 = this.columnAt('body', vx);\n            // Fetch the cell offset position.\n            var ox = this.columnOffset('body', column_2);\n            var oy = this.rowOffset('column-header', row_2);\n            // Fetch the cell width and height.\n            var width_2 = this.columnSize('body', column_2);\n            var height_2 = this.rowSize('column-header', row_2);\n            // Compute the leading and trailing positions.\n            var x_2 = vx - ox;\n            var y_2 = vy - oy;\n            // Return the hit test result.\n            return { region: 'column-header', row: row_2, column: column_2, x: x_2, y: y_2, width: width_2, height: height_2 };\n        }\n        // Check for a row header hit.\n        if (lx >= 0 && lx < hw && ly >= 0 && ly < (hh + bh)) {\n            // Convert to unscrolled virtual coordinates.\n            var vx = lx;\n            var vy = ly + this._scrollY - hh;\n            // Fetch the row and column index.\n            var row_3 = this.rowAt('body', vy);\n            var column_3 = this.columnAt('row-header', vx);\n            // Fetch the cell offset position.\n            var ox = this.columnOffset('row-header', column_3);\n            var oy = this.rowOffset('body', row_3);\n            // Fetch the cell width and height.\n            var width_3 = this.columnSize('row-header', column_3);\n            var height_3 = this.rowSize('body', row_3);\n            // Compute the leading and trailing positions.\n            var x_3 = vx - ox;\n            var y_3 = vy - oy;\n            // Return the hit test result.\n            return { region: 'row-header', row: row_3, column: column_3, x: x_3, y: y_3, width: width_3, height: height_3 };\n        }\n        // Check for a body hit.\n        if (lx >= hw && lx < (hw + bw) && ly >= hh && ly < (hh + bh)) {\n            // Convert to unscrolled virtual coordinates.\n            var vx = lx + this._scrollX - hw;\n            var vy = ly + this._scrollY - hh;\n            // Fetch the row and column index.\n            var row_4 = this.rowAt('body', vy);\n            var column_4 = this.columnAt('body', vx);\n            // Fetch the cell offset position.\n            var ox = this.columnOffset('body', column_4);\n            var oy = this.rowOffset('body', row_4);\n            // Fetch the cell width and height.\n            var width_4 = this.columnSize('body', column_4);\n            var height_4 = this.rowSize('body', row_4);\n            // Compute the part coordinates.\n            var x_4 = vx - ox;\n            var y_4 = vy - oy;\n            // Return the result.\n            return { region: 'body', row: row_4, column: column_4, x: x_4, y: y_4, width: width_4, height: height_4 };\n        }\n        // Otherwise, it's a void space hit.\n        var row = -1;\n        var column = -1;\n        var x = -1;\n        var y = -1;\n        var width = -1;\n        var height = -1;\n        // Return the hit test result.\n        return { region: 'void', row: row, column: column, x: x, y: y, width: width, height: height };\n    };\n    /**\n     * Copy the current selection to the system clipboard.\n     *\n     * #### Notes\n     * The grid must have a data model and a selection model.\n     *\n     * The behavior can be configured via `DataGrid.copyConfig`.\n     */\n    DataGrid.prototype.copyToClipboard = function () {\n        var _a, _b;\n        // Fetch the data model.\n        var dataModel = this._dataModel;\n        // Bail early if there is no data model.\n        if (!dataModel) {\n            return;\n        }\n        // Fetch the selection model.\n        var selectionModel = this._selectionModel;\n        // Bail early if there is no selection model.\n        if (!selectionModel) {\n            return;\n        }\n        // Coerce the selections to an array.\n        var selections = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.toArray)(selectionModel.selections());\n        // Bail early if there are no selections.\n        if (selections.length === 0) {\n            return;\n        }\n        // Alert that multiple selections cannot be copied.\n        if (selections.length > 1) {\n            alert('Cannot copy multiple grid selections.');\n            return;\n        }\n        // Fetch the model counts.\n        var br = dataModel.rowCount('body');\n        var bc = dataModel.columnCount('body');\n        // Bail early if there is nothing to copy.\n        if (br === 0 || bc === 0) {\n            return;\n        }\n        // Unpack the selection.\n        var _c = selections[0], r1 = _c.r1, c1 = _c.c1, r2 = _c.r2, c2 = _c.c2;\n        // Clamp the selection to the model bounds.\n        r1 = Math.max(0, Math.min(r1, br - 1));\n        c1 = Math.max(0, Math.min(c1, bc - 1));\n        r2 = Math.max(0, Math.min(r2, br - 1));\n        c2 = Math.max(0, Math.min(c2, bc - 1));\n        // Ensure the limits are well-orderd.\n        if (r2 < r1)\n            _a = [r2, r1], r1 = _a[0], r2 = _a[1];\n        if (c2 < c1)\n            _b = [c2, c1], c1 = _b[0], c2 = _b[1];\n        // Fetch the header counts.\n        var rhc = dataModel.columnCount('row-header');\n        var chr = dataModel.rowCount('column-header');\n        // Unpack the copy config.\n        var separator = this._copyConfig.separator;\n        var format = this._copyConfig.format;\n        var headers = this._copyConfig.headers;\n        var warningThreshold = this._copyConfig.warningThreshold;\n        // Compute the number of cells to be copied.\n        var rowCount = r2 - r1 + 1;\n        var colCount = c2 - c1 + 1;\n        switch (headers) {\n            case 'none':\n                rhc = 0;\n                chr = 0;\n                break;\n            case 'row':\n                chr = 0;\n                colCount += rhc;\n                break;\n            case 'column':\n                rhc = 0;\n                rowCount += chr;\n                break;\n            case 'all':\n                rowCount += chr;\n                colCount += rhc;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Compute the total cell count.\n        var cellCount = rowCount * colCount;\n        // Allow the user to cancel a large copy request.\n        if (cellCount > warningThreshold) {\n            var msg = \"Copying \" + cellCount + \" cells may take a while. Continue?\";\n            if (!window.confirm(msg)) {\n                return;\n            }\n        }\n        // Set up the format args.\n        var args = {\n            region: 'body',\n            row: 0,\n            column: 0,\n            value: null,\n            metadata: {}\n        };\n        // Allocate the array of rows.\n        var rows = new Array(rowCount);\n        // Iterate over the rows.\n        for (var j = 0; j < rowCount; ++j) {\n            // Allocate the array of cells.\n            var cells = new Array(colCount);\n            // Iterate over the columns.\n            for (var i = 0; i < colCount; ++i) {\n                // Set up the format variables.\n                var region = void 0;\n                var row = void 0;\n                var column = void 0;\n                // Populate the format variables.\n                if (j < chr && i < rhc) {\n                    region = 'corner-header';\n                    row = j;\n                    column = i;\n                }\n                else if (j < chr) {\n                    region = 'column-header';\n                    row = j;\n                    column = i - rhc + c1;\n                }\n                else if (i < rhc) {\n                    region = 'row-header';\n                    row = j - chr + r1;\n                    column = i;\n                }\n                else {\n                    region = 'body';\n                    row = j - chr + r1;\n                    column = i - rhc + c1;\n                }\n                // Populate the format args.\n                args.region = region;\n                args.row = row;\n                args.column = column;\n                args.value = dataModel.data(region, row, column);\n                args.metadata = dataModel.metadata(region, row, column);\n                // Format the cell.\n                cells[i] = format(args);\n            }\n            // Save the row of cells.\n            rows[j] = cells;\n        }\n        // Convert the cells into lines.\n        var lines = rows.map(function (cells) { return cells.join(separator); });\n        // Convert the lines into text.\n        var text = lines.join('\\n');\n        // Copy the text to the clipboard.\n        _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.ClipboardExt.copyText(text);\n    };\n    /**\n     * Process a message sent to the widget.\n     *\n     * @param msg - The message sent to the widget.\n     */\n    DataGrid.prototype.processMessage = function (msg) {\n        // Ignore child show/hide messages. The data grid controls the\n        // visibility of its children, and will manually dispatch the\n        // fit-request messages as a result of visibility change.\n        if (msg.type === 'child-shown' || msg.type === 'child-hidden') {\n            return;\n        }\n        // Recompute the scroll bar minimums before the layout refits.\n        if (msg.type === 'fit-request') {\n            var vsbLimits = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.ElementExt.sizeLimits(this._vScrollBar.node);\n            var hsbLimits = _lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.ElementExt.sizeLimits(this._hScrollBar.node);\n            this._vScrollBarMinWidth = vsbLimits.minWidth;\n            this._hScrollBarMinHeight = hsbLimits.minHeight;\n        }\n        // Process all other messages as normal.\n        _super.prototype.processMessage.call(this, msg);\n    };\n    /**\n     * Intercept a message sent to a message handler.\n     *\n     * @param handler - The target handler of the message.\n     *\n     * @param msg - The message to be sent to the handler.\n     *\n     * @returns `true` if the message should continue to be processed\n     *   as normal, or `false` if processing should cease immediately.\n     */\n    DataGrid.prototype.messageHook = function (handler, msg) {\n        // Process viewport messages.\n        if (handler === this._viewport) {\n            this._processViewportMessage(msg);\n            return true;\n        }\n        // Process horizontal scroll bar messages.\n        if (handler === this._hScrollBar && msg.type === 'activate-request') {\n            this.activate();\n            return false;\n        }\n        // Process vertical scroll bar messages.\n        if (handler === this._vScrollBar && msg.type === 'activate-request') {\n            this.activate();\n            return false;\n        }\n        // Ignore all other messages.\n        return true;\n    };\n    /**\n     * Handle the DOM events for the data grid.\n     *\n     * @param event - The DOM event sent to the data grid.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the data grid's DOM node. It\n     * should not be called directly by user code.\n     */\n    DataGrid.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'dblclick':\n                this._evtMouseDoubleClick(event);\n                break;\n            case 'mouseleave':\n                this._evtMouseLeave(event);\n                break;\n            case 'contextmenu':\n                this._evtContextMenu(event);\n                break;\n            case 'wheel':\n                this._evtWheel(event);\n                break;\n            case 'resize':\n                this._refreshDPI();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    DataGrid.prototype.onActivateRequest = function (msg) {\n        this.viewport.node.focus();\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    DataGrid.prototype.onBeforeAttach = function (msg) {\n        window.addEventListener('resize', this);\n        this.node.addEventListener('wheel', this);\n        this._viewport.node.addEventListener('keydown', this);\n        this._viewport.node.addEventListener('mousedown', this);\n        this._viewport.node.addEventListener('mousemove', this);\n        this._viewport.node.addEventListener('dblclick', this);\n        this._viewport.node.addEventListener('mouseleave', this);\n        this._viewport.node.addEventListener('contextmenu', this);\n        this.repaintContent();\n        this.repaintOverlay();\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    DataGrid.prototype.onAfterDetach = function (msg) {\n        window.removeEventListener('resize', this);\n        this.node.removeEventListener('wheel', this);\n        this._viewport.node.removeEventListener('keydown', this);\n        this._viewport.node.removeEventListener('mousedown', this);\n        this._viewport.node.removeEventListener('mousemove', this);\n        this._viewport.node.removeEventListener('mouseleave', this);\n        this._viewport.node.removeEventListener('dblclick', this);\n        this._viewport.node.removeEventListener('contextmenu', this);\n        this._releaseMouse();\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    DataGrid.prototype.onBeforeShow = function (msg) {\n        this.repaintContent();\n        this.repaintOverlay();\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    DataGrid.prototype.onResize = function (msg) {\n        if (this._editorController) {\n            this._editorController.cancel();\n        }\n        this._syncScrollState();\n    };\n    /**\n     * Schedule a repaint of all of the grid content.\n     */\n    DataGrid.prototype.repaintContent = function () {\n        var msg = new Private$6.PaintRequest('all', 0, 0, 0, 0);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, msg);\n    };\n    /**\n     * Schedule a repaint of specific grid content.\n     */\n    DataGrid.prototype.repaintRegion = function (region, r1, c1, r2, c2) {\n        var msg = new Private$6.PaintRequest(region, r1, c1, r2, c2);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, msg);\n    };\n    /**\n     * Schedule a repaint of the overlay.\n     */\n    DataGrid.prototype.repaintOverlay = function () {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, Private$6.OverlayPaintRequest);\n    };\n    /**\n     * Ensure the canvas is at least the specified size.\n     *\n     * This method will retain the valid canvas content.\n     */\n    DataGrid.prototype._resizeCanvasIfNeeded = function (width, height) {\n        // Scale the size by the dpi ratio.\n        width = width * this._dpiRatio;\n        height = height * this._dpiRatio;\n        // Compute the maximum canvas size for the given width and height.\n        var maxW = (Math.ceil((width + 1) / 512) + 1) * 512;\n        var maxH = (Math.ceil((height + 1) / 512) + 1) * 512;\n        // Get the current size of the canvas.\n        var curW = this._canvas.width;\n        var curH = this._canvas.height;\n        // Bail early if the canvas size is within bounds.\n        if (curW >= width && curH >= height && curW <= maxW && curH <= maxH) {\n            return;\n        }\n        // Compute the expanded canvas size.\n        var expW = maxW - 512;\n        var expH = maxH - 512;\n        // Set the transforms to the identity matrix.\n        this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n        this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);\n        this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);\n        // Resize the buffer if needed.\n        if (curW < width) {\n            this._buffer.width = expW;\n        }\n        else if (curW > maxW) {\n            this._buffer.width = maxW;\n        }\n        // Resize the buffer height if needed.\n        if (curH < height) {\n            this._buffer.height = expH;\n        }\n        else if (curH > maxH) {\n            this._buffer.height = maxH;\n        }\n        // Test whether there is content to blit.\n        var needBlit = curH > 0 && curH > 0 && width > 0 && height > 0;\n        // Copy the valid canvas content into the buffer if needed.\n        if (needBlit) {\n            this._bufferGC.drawImage(this._canvas, 0, 0);\n        }\n        // Resize the canvas width if needed.\n        if (curW < width) {\n            this._canvas.width = expW;\n            this._canvas.style.width = expW / this._dpiRatio + \"px\";\n        }\n        else if (curW > maxW) {\n            this._canvas.width = maxW;\n            this._canvas.style.width = maxW / this._dpiRatio + \"px\";\n        }\n        // Resize the canvas height if needed.\n        if (curH < height) {\n            this._canvas.height = expH;\n            this._canvas.style.height = expH / this._dpiRatio + \"px\";\n        }\n        else if (curH > maxH) {\n            this._canvas.height = maxH;\n            this._canvas.style.height = maxH / this._dpiRatio + \"px\";\n        }\n        // Copy the valid canvas content from the buffer if needed.\n        if (needBlit) {\n            this._canvasGC.drawImage(this._buffer, 0, 0);\n        }\n        // Copy the valid overlay content into the buffer if needed.\n        if (needBlit) {\n            this._bufferGC.drawImage(this._overlay, 0, 0);\n        }\n        // Resize the overlay width if needed.\n        if (curW < width) {\n            this._overlay.width = expW;\n            this._overlay.style.width = expW / this._dpiRatio + \"px\";\n        }\n        else if (curW > maxW) {\n            this._overlay.width = maxW;\n            this._overlay.style.width = maxW / this._dpiRatio + \"px\";\n        }\n        // Resize the overlay height if needed.\n        if (curH < height) {\n            this._overlay.height = expH;\n            this._overlay.style.height = expH / this._dpiRatio + \"px\";\n        }\n        else if (curH > maxH) {\n            this._overlay.height = maxH;\n            this._overlay.style.height = maxH / this._dpiRatio + \"px\";\n        }\n        // Copy the valid overlay content from the buffer if needed.\n        if (needBlit) {\n            this._overlayGC.drawImage(this._buffer, 0, 0);\n        }\n    };\n    /**\n     * Sync the scroll bars and scroll state with the viewport.\n     *\n     * #### Notes\n     * If the visibility of either scroll bar changes, a synchronous\n     * fit-request will be dispatched to the data grid to immediately\n     * resize the viewport.\n     */\n    DataGrid.prototype._syncScrollState = function () {\n        // Fetch the viewport dimensions.\n        var bw = this.bodyWidth;\n        var bh = this.bodyHeight;\n        var pw = this.pageWidth;\n        var ph = this.pageHeight;\n        // Get the current scroll bar visibility.\n        var hasVScroll = !this._vScrollBar.isHidden;\n        var hasHScroll = !this._hScrollBar.isHidden;\n        // Get the minimum sizes of the scroll bars.\n        var vsw = this._vScrollBarMinWidth;\n        var hsh = this._hScrollBarMinHeight;\n        // Get the page size as if no scroll bars are visible.\n        var apw = pw + (hasVScroll ? vsw : 0);\n        var aph = ph + (hasHScroll ? hsh : 0);\n        // Test whether scroll bars are needed for the adjusted size.\n        var needVScroll = aph < bh - 1;\n        var needHScroll = apw < bw - 1;\n        // Re-test the horizontal scroll if a vertical scroll is needed.\n        if (needVScroll && !needHScroll) {\n            needHScroll = (apw - vsw) < bw - 1;\n        }\n        // Re-test the vertical scroll if a horizontal scroll is needed.\n        if (needHScroll && !needVScroll) {\n            needVScroll = (aph - hsh) < bh - 1;\n        }\n        // If the visibility changes, immediately refit the grid.\n        if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {\n            this._vScrollBar.setHidden(!needVScroll);\n            this._hScrollBar.setHidden(!needHScroll);\n            this._scrollCorner.setHidden(!needVScroll || !needHScroll);\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.sendMessage(this, _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget.Msg.FitRequest);\n        }\n        // Update the scroll bar limits.\n        this._vScrollBar.maximum = this.maxScrollY;\n        this._vScrollBar.page = this.pageHeight;\n        this._hScrollBar.maximum = this.maxScrollX;\n        this._hScrollBar.page = this.pageWidth;\n        // Re-clamp the scroll position.\n        this._scrollTo(this._scrollX, this._scrollY);\n    };\n    /**\n     * Sync the viewport to the given scroll position.\n     *\n     * #### Notes\n     * This schedules a full repaint and syncs the scroll state.\n     */\n    DataGrid.prototype._syncViewport = function () {\n        this.repaintContent();\n        this.repaintOverlay();\n        this._syncScrollState();\n    };\n    /**\n     * Process a message sent to the viewport\n     */\n    DataGrid.prototype._processViewportMessage = function (msg) {\n        switch (msg.type) {\n            case 'resize':\n                this._onViewportResize(msg);\n                break;\n            case 'scroll-request':\n                this._onViewportScrollRequest(msg);\n                break;\n            case 'paint-request':\n                this._onViewportPaintRequest(msg);\n                break;\n            case 'overlay-paint-request':\n                this._onViewportOverlayPaintRequest(msg);\n                break;\n            case 'row-resize-request':\n                this._onViewportRowResizeRequest(msg);\n                break;\n            case 'column-resize-request':\n                this._onViewportColumnResizeRequest(msg);\n                break;\n        }\n    };\n    /**\n     * A message hook invoked on a viewport `'resize'` message.\n     */\n    DataGrid.prototype._onViewportResize = function (msg) {\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            return;\n        }\n        // Unpack the message data.\n        var width = msg.width, height = msg.height;\n        // Measure the viewport node if the dimensions are unknown.\n        if (width === -1) {\n            width = this._viewport.node.offsetWidth;\n        }\n        if (height === -1) {\n            height = this._viewport.node.offsetHeight;\n        }\n        // Round the dimensions to the nearest pixel.\n        width = Math.round(width);\n        height = Math.round(height);\n        // Get the current size of the viewport.\n        var oldWidth = this._viewportWidth;\n        var oldHeight = this._viewportHeight;\n        // Updated internal viewport size.\n        this._viewportWidth = width;\n        this._viewportHeight = height;\n        // Resize the canvas if needed.\n        this._resizeCanvasIfNeeded(width, height);\n        // Bail early if there is nothing to paint.\n        if (width === 0 || height === 0) {\n            return;\n        }\n        // Paint the whole grid if the old size was zero.\n        if (oldWidth === 0 || oldHeight === 0) {\n            this.paintContent(0, 0, width, height);\n            this._paintOverlay();\n            return;\n        }\n        // Paint the right edge as needed.\n        if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n            var bx = this._columnSections.offsetOf(this._columnSections.count - 1);\n            var x = Math.min(this.headerWidth + bx, oldWidth);\n            this.paintContent(x, 0, width - x, height);\n        }\n        else if (width > oldWidth) {\n            this.paintContent(oldWidth, 0, width - oldWidth, height);\n        }\n        // Paint the bottom edge as needed.\n        if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n            var by = this._rowSections.offsetOf(this._rowSections.count - 1);\n            var y = Math.min(this.headerHeight + by, oldHeight);\n            this.paintContent(0, y, width, height - y);\n        }\n        else if (height > oldHeight) {\n            this.paintContent(0, oldHeight, width, height - oldHeight);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n    };\n    /**\n     * A message hook invoked on a viewport `'scroll-request'` message.\n     */\n    DataGrid.prototype._onViewportScrollRequest = function (msg) {\n        this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);\n    };\n    /**\n     * A message hook invoked on a viewport `'paint-request'` message.\n     */\n    DataGrid.prototype._onViewportPaintRequest = function (msg) {\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            return;\n        }\n        // Bail early if the viewport has zero area.\n        if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n            return;\n        }\n        // Set up the paint limits.\n        var xMin = 0;\n        var yMin = 0;\n        var xMax = this._viewportWidth - 1;\n        var yMax = this._viewportHeight - 1;\n        // Fetch the scroll position.\n        var sx = this._scrollX;\n        var sy = this._scrollY;\n        // Fetch the header dimensions.\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        // Fetch the section lists.\n        var rs = this._rowSections;\n        var cs = this._columnSections;\n        var rhs = this._rowHeaderSections;\n        var chs = this._columnHeaderSections;\n        // Unpack the message data.\n        var region = msg.region, r1 = msg.r1, c1 = msg.c1, r2 = msg.r2, c2 = msg.c2;\n        // Set up the paint variables.\n        var x1;\n        var y1;\n        var x2;\n        var y2;\n        // Fill the paint variables based on the paint region.\n        switch (region) {\n            case 'all':\n                x1 = xMin;\n                y1 = yMin;\n                x2 = xMax;\n                y2 = yMax;\n                break;\n            case 'body':\n                r1 = Math.max(0, Math.min(r1, rs.count));\n                c1 = Math.max(0, Math.min(c1, cs.count));\n                r2 = Math.max(0, Math.min(r2, rs.count));\n                c2 = Math.max(0, Math.min(c2, cs.count));\n                x1 = cs.offsetOf(c1) - sx + hw;\n                y1 = rs.offsetOf(r1) - sy + hh;\n                x2 = cs.extentOf(c2) - sx + hw;\n                y2 = rs.extentOf(r2) - sy + hh;\n                break;\n            case 'row-header':\n                r1 = Math.max(0, Math.min(r1, rs.count));\n                c1 = Math.max(0, Math.min(c1, rhs.count));\n                r2 = Math.max(0, Math.min(r2, rs.count));\n                c2 = Math.max(0, Math.min(c2, rhs.count));\n                x1 = rhs.offsetOf(c1);\n                y1 = rs.offsetOf(r1) - sy + hh;\n                x2 = rhs.extentOf(c2);\n                y2 = rs.extentOf(r2) - sy + hh;\n                break;\n            case 'column-header':\n                r1 = Math.max(0, Math.min(r1, chs.count));\n                c1 = Math.max(0, Math.min(c1, cs.count));\n                r2 = Math.max(0, Math.min(r2, chs.count));\n                c2 = Math.max(0, Math.min(c2, cs.count));\n                x1 = cs.offsetOf(c1) - sx + hw;\n                y1 = chs.offsetOf(r1);\n                x2 = cs.extentOf(c2) - sx + hw;\n                y2 = chs.extentOf(r2);\n                break;\n            case 'corner-header':\n                r1 = Math.max(0, Math.min(r1, chs.count));\n                c1 = Math.max(0, Math.min(c1, rhs.count));\n                r2 = Math.max(0, Math.min(r2, chs.count));\n                c2 = Math.max(0, Math.min(c2, rhs.count));\n                x1 = rhs.offsetOf(c1);\n                y1 = chs.offsetOf(r1);\n                x2 = rhs.extentOf(c2);\n                y2 = chs.extentOf(r2);\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Bail early if the dirty rect is outside the bounds.\n        if (x2 < xMin || y2 < yMin || x1 > xMax || y1 > yMax) {\n            return;\n        }\n        // Clamp the dirty rect to the paint bounds.\n        x1 = Math.max(xMin, Math.min(x1, xMax));\n        y1 = Math.max(yMin, Math.min(y1, yMax));\n        x2 = Math.max(xMin, Math.min(x2, xMax));\n        y2 = Math.max(yMin, Math.min(y2, yMax));\n        // Paint the content of the dirty rect.\n        this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    };\n    /**\n     * A message hook invoked on a viewport `'overlay-paint-request'` message.\n     */\n    DataGrid.prototype._onViewportOverlayPaintRequest = function (msg) {\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            return;\n        }\n        // Bail early if the viewport has zero area.\n        if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n            return;\n        }\n        // Paint the content of the overlay.\n        this._paintOverlay();\n    };\n    /**\n     * A message hook invoked on a viewport `'row-resize-request'` message.\n     */\n    DataGrid.prototype._onViewportRowResizeRequest = function (msg) {\n        if (msg.region === 'body') {\n            this._resizeRow(msg.index, msg.size);\n        }\n        else {\n            this._resizeColumnHeader(msg.index, msg.size);\n        }\n    };\n    /**\n     * A message hook invoked on a viewport `'column-resize-request'` message.\n     */\n    DataGrid.prototype._onViewportColumnResizeRequest = function (msg) {\n        if (msg.region === 'body') {\n            this._resizeColumn(msg.index, msg.size);\n        }\n        else {\n            this._resizeRowHeader(msg.index, msg.size);\n        }\n    };\n    /**\n     * Handle the `thumbMoved` signal from a scroll bar.\n     */\n    DataGrid.prototype._onThumbMoved = function (sender) {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.MessageLoop.postMessage(this._viewport, Private$6.ScrollRequest);\n    };\n    /**\n     * Handle the `pageRequested` signal from a scroll bar.\n     */\n    DataGrid.prototype._onPageRequested = function (sender, dir) {\n        if (sender === this._vScrollBar) {\n            this.scrollByPage(dir === 'decrement' ? 'up' : 'down');\n        }\n        else {\n            this.scrollByPage(dir === 'decrement' ? 'left' : 'right');\n        }\n    };\n    /**\n     * Handle the `stepRequested` signal from a scroll bar.\n     */\n    DataGrid.prototype._onStepRequested = function (sender, dir) {\n        if (sender === this._vScrollBar) {\n            this.scrollByStep(dir === 'decrement' ? 'up' : 'down');\n        }\n        else {\n            this.scrollByStep(dir === 'decrement' ? 'left' : 'right');\n        }\n    };\n    /**\n     * A signal handler for the data model `changed` signal.\n     */\n    DataGrid.prototype._onDataModelChanged = function (sender, args) {\n        switch (args.type) {\n            case 'rows-inserted':\n                this._onRowsInserted(args);\n                break;\n            case 'columns-inserted':\n                this._onColumnsInserted(args);\n                break;\n            case 'rows-removed':\n                this._onRowsRemoved(args);\n                break;\n            case 'columns-removed':\n                this._onColumnsRemoved(args);\n                break;\n            case 'rows-moved':\n                this._onRowsMoved(args);\n                break;\n            case 'columns-moved':\n                this._onColumnsMoved(args);\n                break;\n            case 'cells-changed':\n                this._onCellsChanged(args);\n                break;\n            case 'model-reset':\n                this._onModelReset(args);\n                break;\n            default:\n                throw 'unreachable';\n        }\n    };\n    /**\n     * A signal handler for the selection model `changed` signal.\n     */\n    DataGrid.prototype._onSelectionsChanged = function (sender) {\n        this.repaintOverlay();\n    };\n    /**\n     * Handle rows being inserted in the data model.\n     */\n    DataGrid.prototype._onRowsInserted = function (args) {\n        // Unpack the arg data.\n        var region = args.region, index = args.index, span = args.span;\n        // Bail early if there are no sections to insert.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        var list;\n        if (region === 'body') {\n            list = this._rowSections;\n        }\n        else {\n            list = this._columnHeaderSections;\n        }\n        // Insert the span, maintaining the scroll position as needed.\n        if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n            list.insert(index, span);\n            this._scrollY = this.maxScrollY;\n        }\n        else {\n            list.insert(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * Handle columns being inserted into the data model.\n     */\n    DataGrid.prototype._onColumnsInserted = function (args) {\n        // Unpack the arg data.\n        var region = args.region, index = args.index, span = args.span;\n        // Bail early if there are no sections to insert.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        var list;\n        if (region === 'body') {\n            list = this._columnSections;\n        }\n        else {\n            list = this._rowHeaderSections;\n        }\n        // Insert the span, maintaining the scroll position as needed.\n        if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n            list.insert(index, span);\n            this._scrollX = this.maxScrollX;\n        }\n        else {\n            list.insert(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * Handle rows being removed from the data model.\n     */\n    DataGrid.prototype._onRowsRemoved = function (args) {\n        // Unpack the arg data.\n        var region = args.region, index = args.index, span = args.span;\n        // Bail early if there are no sections to remove.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        var list;\n        if (region === 'body') {\n            list = this._rowSections;\n        }\n        else {\n            list = this._columnHeaderSections;\n        }\n        // Bail if the index or is invalid\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Remove the span, maintaining the scroll position as needed.\n        if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n            list.remove(index, span);\n            this._scrollY = this.maxScrollY;\n        }\n        else {\n            list.remove(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * Handle columns being removed from the data model.\n     */\n    DataGrid.prototype._onColumnsRemoved = function (args) {\n        // Unpack the arg data.\n        var region = args.region, index = args.index, span = args.span;\n        // Bail early if there are no sections to remove.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        var list;\n        if (region === 'body') {\n            list = this._columnSections;\n        }\n        else {\n            list = this._rowHeaderSections;\n        }\n        // Bail if the index or is invalid\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Remove the span, maintaining the scroll position as needed.\n        if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n            list.remove(index, span);\n            this._scrollX = this.maxScrollX;\n        }\n        else {\n            list.remove(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * Handle rows moving in the data model.\n     */\n    DataGrid.prototype._onRowsMoved = function (args) {\n        // Unpack the arg data.\n        var region = args.region, index = args.index, span = args.span, destination = args.destination;\n        // Bail early if there are no sections to move.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        var list;\n        if (region === 'body') {\n            list = this._rowSections;\n        }\n        else {\n            list = this._columnHeaderSections;\n        }\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Clamp the move span to the limit.\n        span = Math.min(span, list.count - index);\n        // Clamp the destination index to the limit.\n        destination = Math.min(Math.max(0, destination), list.count - span);\n        // Bail early if there is no effective move.\n        if (index === destination) {\n            return;\n        }\n        // Compute the first affected index.\n        var r1 = Math.min(index, destination);\n        // Compute the last affected index.\n        var r2 = Math.max(index + span - 1, destination + span - 1);\n        // Move the sections in the list.\n        list.move(index, span, destination);\n        // Schedule a repaint of the dirty cells.\n        if (region === 'body') {\n            this.repaintRegion('body', r1, 0, r2, Infinity);\n            this.repaintRegion('row-header', r1, 0, r2, Infinity);\n        }\n        else {\n            this.repaintRegion('column-header', r1, 0, r2, Infinity);\n            this.repaintRegion('corner-header', r1, 0, r2, Infinity);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * Handle columns moving in the data model.\n     */\n    DataGrid.prototype._onColumnsMoved = function (args) {\n        // Unpack the arg data.\n        var region = args.region, index = args.index, span = args.span, destination = args.destination;\n        // Bail early if there are no sections to move.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        var list;\n        if (region === 'body') {\n            list = this._columnSections;\n        }\n        else {\n            list = this._rowHeaderSections;\n        }\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Clamp the move span to the limit.\n        span = Math.min(span, list.count - index);\n        // Clamp the destination index to the limit.\n        destination = Math.min(Math.max(0, destination), list.count - span);\n        // Bail early if there is no effective move.\n        if (index === destination) {\n            return;\n        }\n        // Move the sections in the list.\n        list.move(index, span, destination);\n        // Compute the first affected index.\n        var c1 = Math.min(index, destination);\n        // Compute the last affected index.\n        var c2 = Math.max(index + span - 1, destination + span - 1);\n        // Schedule a repaint of the dirty cells.\n        if (region === 'body') {\n            this.repaintRegion('body', 0, c1, Infinity, c2);\n            this.repaintRegion('column-header', 0, c1, Infinity, c2);\n        }\n        else {\n            this.repaintRegion('row-header', 0, c1, Infinity, c2);\n            this.repaintRegion('corner-header', 0, c1, Infinity, c2);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * Handle cells changing in the data model.\n     */\n    DataGrid.prototype._onCellsChanged = function (args) {\n        // Unpack the arg data.\n        var region = args.region, row = args.row, column = args.column, rowSpan = args.rowSpan, columnSpan = args.columnSpan;\n        // Bail early if there are no cells to modify.\n        if (rowSpan <= 0 && columnSpan <= 0) {\n            return;\n        }\n        // Compute the changed cell bounds.\n        var r1 = row;\n        var c1 = column;\n        var r2 = r1 + rowSpan - 1;\n        var c2 = c1 + columnSpan - 1;\n        // Schedule a repaint of the cell content.\n        this.repaintRegion(region, r1, c1, r2, c2);\n    };\n    /**\n     * Handle a full data model reset.\n     */\n    DataGrid.prototype._onModelReset = function (args) {\n        // Look up the various current section counts.\n        var nr = this._rowSections.count;\n        var nc = this._columnSections.count;\n        var nrh = this._rowHeaderSections.count;\n        var nch = this._columnHeaderSections.count;\n        // Compute the delta count for each region.\n        var dr = this._dataModel.rowCount('body') - nr;\n        var dc = this._dataModel.columnCount('body') - nc;\n        var drh = this._dataModel.columnCount('row-header') - nrh;\n        var dch = this._dataModel.rowCount('column-header') - nch;\n        // Update the row sections, if needed.\n        if (dr > 0) {\n            this._rowSections.insert(nr, dr);\n        }\n        else if (dr < 0) {\n            this._rowSections.remove(nr + dr, -dr);\n        }\n        // Update the column sections, if needed.\n        if (dc > 0) {\n            this._columnSections.insert(nc, dc);\n        }\n        else if (dc < 0) {\n            this._columnSections.remove(nc + dc, -dc);\n        }\n        // Update the row header sections, if needed.\n        if (drh > 0) {\n            this._rowHeaderSections.insert(nrh, drh);\n        }\n        else if (drh < 0) {\n            this._rowHeaderSections.remove(nrh + drh, -drh);\n        }\n        // Update the column header sections, if needed.\n        if (dch > 0) {\n            this._columnHeaderSections.insert(nch, dch);\n        }\n        else if (dch < 0) {\n            this._columnHeaderSections.remove(nch + dch, -dch);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    };\n    /**\n     * A signal handler for the renderer map `changed` signal.\n     */\n    DataGrid.prototype._onRenderersChanged = function () {\n        this.repaintContent();\n    };\n    /**\n     * Handle the `'keydown'` event for the data grid.\n     */\n    DataGrid.prototype._evtKeyDown = function (event) {\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else if (this._keyHandler) {\n            this._keyHandler.onKeyDown(this, event);\n        }\n    };\n    /**\n     * Handle the `'mousedown'` event for the data grid.\n     */\n    DataGrid.prototype._evtMouseDown = function (event) {\n        // Ignore everything except the left mouse button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Activate the grid.\n        this.activate();\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Add the extra document listeners.\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('mousedown', this, true);\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Flip the mousedown flag.\n        this._mousedown = true;\n        // Dispatch to the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.onMouseDown(this, event);\n        }\n    };\n    /**\n     * Handle the `'mousemove'` event for the data grid.\n     */\n    DataGrid.prototype._evtMouseMove = function (event) {\n        // Stop the event propagation if the mouse is down.\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        // Bail if there is no mouse handler.\n        if (!this._mouseHandler) {\n            return;\n        }\n        // Dispatch to the mouse handler.\n        if (this._mousedown) {\n            this._mouseHandler.onMouseMove(this, event);\n        }\n        else {\n            this._mouseHandler.onMouseHover(this, event);\n        }\n    };\n    /**\n     * Handle the `'mouseup'` event for the data grid.\n     */\n    DataGrid.prototype._evtMouseUp = function (event) {\n        // Ignore everything except the left mouse button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Dispatch to the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.onMouseUp(this, event);\n        }\n        // Release the mouse.\n        this._releaseMouse();\n    };\n    /**\n     * Handle the `'dblclick'` event for the data grid.\n     */\n    DataGrid.prototype._evtMouseDoubleClick = function (event) {\n        // Ignore everything except the left mouse button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Dispatch to the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.onMouseDoubleClick(this, event);\n        }\n        // Release the mouse.\n        this._releaseMouse();\n    };\n    /**\n     * Handle the `'mouseleave'` event for the data grid.\n     */\n    DataGrid.prototype._evtMouseLeave = function (event) {\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else if (this._mouseHandler) {\n            this._mouseHandler.onMouseLeave(this, event);\n        }\n    };\n    /**\n     * Handle the `'contextmenu'` event for the data grid.\n     */\n    DataGrid.prototype._evtContextMenu = function (event) {\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else if (this._mouseHandler) {\n            this._mouseHandler.onContextMenu(this, event);\n        }\n    };\n    /**\n     * Handle the `'wheel'` event for the data grid.\n     */\n    DataGrid.prototype._evtWheel = function (event) {\n        // Ignore the event if `accel` is held.\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_0__.Platform.accelKey(event)) {\n            return;\n        }\n        // Bail early if there is no mouse handler.\n        if (!this._mouseHandler) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Dispatch to the mouse handler.\n        this._mouseHandler.onWheel(this, event);\n    };\n    /**\n     * Release the mouse grab.\n     */\n    DataGrid.prototype._releaseMouse = function () {\n        // Clear the mousedown flag.\n        this._mousedown = false;\n        // Relase the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.release();\n        }\n        // Remove the document listeners.\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('mousedown', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    };\n    /**\n     * Refresh the dpi ratio.\n     */\n    DataGrid.prototype._refreshDPI = function () {\n        // Get the best integral value for the dpi ratio.\n        var dpiRatio = Math.ceil(window.devicePixelRatio);\n        // Bail early if the computed dpi ratio has not changed.\n        if (this._dpiRatio === dpiRatio) {\n            return;\n        }\n        // Update the internal dpi ratio.\n        this._dpiRatio = dpiRatio;\n        // Schedule a repaint of the content.\n        this.repaintContent();\n        // Schedule a repaint of the overlay.\n        this.repaintOverlay();\n        // Update the canvas size for the new dpi ratio.\n        this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);\n        // Ensure the canvas style is scaled for the new ratio.\n        this._canvas.style.width = this._canvas.width / this._dpiRatio + \"px\";\n        this._canvas.style.height = this._canvas.height / this._dpiRatio + \"px\";\n        // Ensure the overlay style is scaled for the new ratio.\n        this._overlay.style.width = this._overlay.width / this._dpiRatio + \"px\";\n        this._overlay.style.height = this._overlay.height / this._dpiRatio + \"px\";\n    };\n    /**\n     * Resize a row section immediately.\n     */\n    DataGrid.prototype._resizeRow = function (index, size) {\n        // Look up the target section list.\n        var list = this._rowSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Look up the old size of the section.\n        var oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        var newSize = list.clampSize(size);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        var vw = this._viewportWidth;\n        var vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Compute the size delta.\n        var delta = newSize - oldSize;\n        // Look up the column header height.\n        var hh = this.headerHeight;\n        // Compute the viewport offset of the section.\n        var offset = list.offsetOf(index) + hh - this._scrollY;\n        // Bail early if there is nothing to paint.\n        if (hh >= vh || offset >= vh) {\n            this._syncScrollState();\n            return;\n        }\n        // Update the scroll position if the section is not visible.\n        if (offset + oldSize <= hh) {\n            this._scrollY += delta;\n            this._syncScrollState();\n            return;\n        }\n        // Compute the paint origin of the section.\n        var pos = Math.max(hh, offset);\n        // Paint from the section onward if it spans the viewport.\n        if (offset + oldSize >= vh || offset + newSize >= vh) {\n            this.paintContent(0, pos, vw, vh - pos);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the X blit dimensions.\n        var sx = 0;\n        var sw = vw;\n        var dx = 0;\n        // Compute the Y blit dimensions.\n        var sy;\n        var sh;\n        var dy;\n        if (offset + newSize <= hh) {\n            sy = hh - delta;\n            sh = vh - sy;\n            dy = hh;\n        }\n        else {\n            sy = offset + oldSize;\n            sh = vh - sy;\n            dy = sy + delta;\n        }\n        // Blit the valid content to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the section if needed.\n        if (newSize > 0 && offset + newSize > hh) {\n            this.paintContent(0, pos, vw, offset + newSize - pos);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n            var r = this._rowSections.count - 1;\n            var y = hh + this._rowSections.offsetOf(r);\n            this.paintContent(0, y, vw, vh - y);\n        }\n        else if (delta < 0) {\n            this.paintContent(0, vh + delta, vw, -delta);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state.\n        this._syncScrollState();\n    };\n    /**\n     * Resize a column section immediately.\n     */\n    DataGrid.prototype._resizeColumn = function (index, size) {\n        // Look up the target section list.\n        var list = this._columnSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Look up the old size of the section.\n        var oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        var newSize = list.clampSize(size);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        var vw = this._viewportWidth;\n        var vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Compute the size delta.\n        var delta = newSize - oldSize;\n        // Look up the row header width.\n        var hw = this.headerWidth;\n        // Compute the viewport offset of the section.\n        var offset = list.offsetOf(index) + hw - this._scrollX;\n        // Bail early if there is nothing to paint.\n        if (hw >= vw || offset >= vw) {\n            this._syncScrollState();\n            return;\n        }\n        // Update the scroll position if the section is not visible.\n        if (offset + oldSize <= hw) {\n            this._scrollX += delta;\n            this._syncScrollState();\n            return;\n        }\n        // Compute the paint origin of the section.\n        var pos = Math.max(hw, offset);\n        // Paint from the section onward if it spans the viewport.\n        if (offset + oldSize >= vw || offset + newSize >= vw) {\n            this.paintContent(pos, 0, vw - pos, vh);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the Y blit dimensions.\n        var sy = 0;\n        var sh = vh;\n        var dy = 0;\n        // Compute the X blit dimensions.\n        var sx;\n        var sw;\n        var dx;\n        if (offset + newSize <= hw) {\n            sx = hw - delta;\n            sw = vw - sx;\n            dx = hw;\n        }\n        else {\n            sx = offset + oldSize;\n            sw = vw - sx;\n            dx = sx + delta;\n        }\n        // Blit the valid content to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the section if needed.\n        if (newSize > 0 && offset + newSize > hw) {\n            this.paintContent(pos, 0, offset + newSize - pos, vh);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n            var c = this._columnSections.count - 1;\n            var x = hw + this._columnSections.offsetOf(c);\n            this.paintContent(x, 0, vw - x, vh);\n        }\n        else if (delta < 0) {\n            this.paintContent(vw + delta, 0, -delta, vh);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state after painting.\n        this._syncScrollState();\n    };\n    /**\n     * Resize a row header section immediately.\n     */\n    DataGrid.prototype._resizeRowHeader = function (index, size) {\n        // Look up the target section list.\n        var list = this._rowHeaderSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Look up the old size of the section.\n        var oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        var newSize = list.clampSize(size);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        var vw = this._viewportWidth;\n        var vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Compute the size delta.\n        var delta = newSize - oldSize;\n        // Look up the offset of the section.\n        var offset = list.offsetOf(index);\n        // Bail early if the section is fully outside the viewport.\n        if (offset >= vw) {\n            this._syncScrollState();\n            return;\n        }\n        // Paint the entire tail if the section spans the viewport.\n        if (offset + oldSize >= vw || offset + newSize >= vw) {\n            this.paintContent(offset, 0, vw - offset, vh);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the blit content dimensions.\n        var sx = offset + oldSize;\n        var sy = 0;\n        var sw = vw - sx;\n        var sh = vh;\n        var dx = sx + delta;\n        var dy = 0;\n        // Blit the valid contents to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the header section if needed.\n        if (newSize > 0) {\n            this.paintContent(offset, 0, newSize, vh);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n            var c = this._columnSections.count - 1;\n            var x = this.headerWidth + this._columnSections.offsetOf(c);\n            this.paintContent(x, 0, vw - x, vh);\n        }\n        else if (delta < 0) {\n            this.paintContent(vw + delta, 0, -delta, vh);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state after painting.\n        this._syncScrollState();\n    };\n    /**\n     * Resize a column header section immediately.\n     */\n    DataGrid.prototype._resizeColumnHeader = function (index, size) {\n        // Look up the target section list.\n        var list = this._columnHeaderSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Look up the old size of the section.\n        var oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        var newSize = list.clampSize(size);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        var vw = this._viewportWidth;\n        var vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Compute the size delta.\n        var delta = newSize - oldSize;\n        // Look up the offset of the section.\n        var offset = list.offsetOf(index);\n        // Bail early if the section is fully outside the viewport.\n        if (offset >= vh) {\n            this._syncScrollState();\n            return;\n        }\n        // Paint the entire tail if the section spans the viewport.\n        if (offset + oldSize >= vh || offset + newSize >= vh) {\n            this.paintContent(0, offset, vw, vh - offset);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the blit content dimensions.\n        var sx = 0;\n        var sy = offset + oldSize;\n        var sw = vw;\n        var sh = vh - sy;\n        var dx = 0;\n        var dy = sy + delta;\n        // Blit the valid contents to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the header section if needed.\n        if (newSize > 0) {\n            this.paintContent(0, offset, vw, newSize);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n            var r = this._rowSections.count - 1;\n            var y = this.headerHeight + this._rowSections.offsetOf(r);\n            this.paintContent(0, y, vw, vh - y);\n        }\n        else if (delta < 0) {\n            this.paintContent(0, vh + delta, vw, -delta);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state after painting.\n        this._syncScrollState();\n    };\n    /**\n     * Scroll immediately to the specified offset position.\n     */\n    DataGrid.prototype._scrollTo = function (x, y) {\n        // Floor and clamp the position to the allowable range.\n        x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n        y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n        // Synchronize the scroll bar values.\n        this._hScrollBar.value = x;\n        this._vScrollBar.value = y;\n        // Compute the delta scroll amount.\n        var dx = x - this._scrollX;\n        var dy = y - this._scrollY;\n        // Bail early if there is no effective scroll.\n        if (dx === 0 && dy === 0) {\n            return;\n        }\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            this._scrollX = x;\n            this._scrollY = y;\n            return;\n        }\n        // Get the current size of the viewport.\n        var width = this._viewportWidth;\n        var height = this._viewportHeight;\n        // Bail early if the viewport is empty.\n        if (width === 0 || height === 0) {\n            this._scrollX = x;\n            this._scrollY = y;\n            return;\n        }\n        // Get the visible content origin.\n        var contentX = this.headerWidth;\n        var contentY = this.headerHeight;\n        // Get the visible content dimensions.\n        var contentWidth = width - contentX;\n        var contentHeight = height - contentY;\n        // Bail early if there is no content to draw.\n        if (contentWidth <= 0 && contentHeight <= 0) {\n            this._scrollX = x;\n            this._scrollY = y;\n            return;\n        }\n        // Compute the area which needs painting for the `dx` scroll.\n        var dxArea = 0;\n        if (dx !== 0 && contentWidth > 0) {\n            if (Math.abs(dx) >= contentWidth) {\n                dxArea = contentWidth * height;\n            }\n            else {\n                dxArea = Math.abs(dx) * height;\n            }\n        }\n        // Compute the area which needs painting for the `dy` scroll.\n        var dyArea = 0;\n        if (dy !== 0 && contentHeight > 0) {\n            if (Math.abs(dy) >= contentHeight) {\n                dyArea = width * contentHeight;\n            }\n            else {\n                dyArea = width * Math.abs(dy);\n            }\n        }\n        // If the area sum is larger than the total, paint everything.\n        if ((dxArea + dyArea) >= (width * height)) {\n            this._scrollX = x;\n            this._scrollY = y;\n            this.paintContent(0, 0, width, height);\n            this._paintOverlay();\n            return;\n        }\n        // Update the internal Y scroll position.\n        this._scrollY = y;\n        // Scroll the Y axis if needed. If the scroll distance exceeds\n        // the visible height, paint everything. Otherwise, blit the\n        // valid content and paint the dirty region.\n        if (dy !== 0 && contentHeight > 0) {\n            if (Math.abs(dy) >= contentHeight) {\n                this.paintContent(0, contentY, width, contentHeight);\n            }\n            else {\n                var x_5 = 0;\n                var y_5 = dy < 0 ? contentY : contentY + dy;\n                var w = width;\n                var h = contentHeight - Math.abs(dy);\n                this._blitContent(this._canvas, x_5, y_5, w, h, x_5, y_5 - dy);\n                this.paintContent(0, dy < 0 ? contentY : height - dy, width, Math.abs(dy));\n            }\n        }\n        // Update the internal X scroll position.\n        this._scrollX = x;\n        // Scroll the X axis if needed. If the scroll distance exceeds\n        // the visible width, paint everything. Otherwise, blit the\n        // valid content and paint the dirty region.\n        if (dx !== 0 && contentWidth > 0) {\n            if (Math.abs(dx) >= contentWidth) {\n                this.paintContent(contentX, 0, contentWidth, height);\n            }\n            else {\n                var x_6 = dx < 0 ? contentX : contentX + dx;\n                var y_6 = 0;\n                var w = contentWidth - Math.abs(dx);\n                var h = height;\n                this._blitContent(this._canvas, x_6, y_6, w, h, x_6 - dx, y_6);\n                this.paintContent(dx < 0 ? contentX : width - dx, 0, Math.abs(dx), height);\n            }\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n    };\n    /**\n     * Blit content into the on-screen grid canvas.\n     *\n     * The rect should be expressed in viewport coordinates.\n     *\n     * This automatically accounts for the dpi ratio.\n     */\n    DataGrid.prototype._blitContent = function (source, x, y, w, h, dx, dy) {\n        // Scale the blit coordinates by the dpi ratio.\n        x *= this._dpiRatio;\n        y *= this._dpiRatio;\n        w *= this._dpiRatio;\n        h *= this._dpiRatio;\n        dx *= this._dpiRatio;\n        dy *= this._dpiRatio;\n        // Save the current gc state.\n        this._canvasGC.save();\n        // Set the transform to the identity matrix.\n        this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n        // Draw the specified content.\n        this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);\n        // Restore the gc state.\n        this._canvasGC.restore();\n    };\n    /**\n     * Paint the grid content for the given dirty rect.\n     *\n     * The rect should be expressed in valid viewport coordinates.\n     *\n     * This is the primary paint entry point. The individual `_draw*`\n     * methods should not be invoked directly. This method dispatches\n     * to the drawing methods in the correct order.\n     */\n    DataGrid.prototype.paintContent = function (rx, ry, rw, rh) {\n        // Scale the canvas and buffer GC for the dpi ratio.\n        this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n        this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n        // Clear the dirty rect of all content.\n        this._canvasGC.clearRect(rx, ry, rw, rh);\n        // Draw the void region.\n        this._drawVoidRegion(rx, ry, rw, rh);\n        // Draw the body region.\n        this._drawBodyRegion(rx, ry, rw, rh);\n        // Draw the row header region.\n        this._drawRowHeaderRegion(rx, ry, rw, rh);\n        // Draw the column header region.\n        this._drawColumnHeaderRegion(rx, ry, rw, rh);\n        // Draw the corner header region.\n        this.drawCornerHeaderRegion(rx, ry, rw, rh);\n    };\n    /**\n     * Paint the overlay content for the entire grid.\n     *\n     * This is the primary overlay paint entry point. The individual\n     * `_draw*` methods should not be invoked directly. This method\n     * dispatches to the drawing methods in the correct order.\n     */\n    DataGrid.prototype._paintOverlay = function () {\n        // Scale the overlay GC for the dpi ratio.\n        this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n        // Clear the overlay of all content.\n        this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);\n        // Draw the body selections.\n        this._drawBodySelections();\n        // Draw the row header selections.\n        this._drawRowHeaderSelections();\n        // Draw the column header selections.\n        this._drawColumnHeaderSelections();\n        // Draw the cursor.\n        this._drawCursor();\n        // Draw the shadows.\n        this._drawShadows();\n    };\n    /**\n     * Draw the void region for the dirty rect.\n     */\n    DataGrid.prototype._drawVoidRegion = function (rx, ry, rw, rh) {\n        // Look up the void color.\n        var color = this._style.voidColor;\n        // Bail if there is no void color.\n        if (!color) {\n            return;\n        }\n        // Fill the dirty rect with the void color.\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(rx, ry, rw, rh);\n    };\n    /**\n     * Draw the body region which intersects the dirty rect.\n     */\n    DataGrid.prototype._drawBodyRegion = function (rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        var contentW = this._columnSections.length - this._scrollX;\n        var contentH = this._rowSections.length - this._scrollY;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        var contentX = this.headerWidth;\n        var contentY = this.headerHeight;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Fetch the geometry.\n        var bh = this.bodyHeight;\n        var bw = this.bodyWidth;\n        var ph = this.pageHeight;\n        var pw = this.pageWidth;\n        // Get the upper and lower bounds of the dirty content area.\n        var x1 = Math.max(rx, contentX);\n        var y1 = Math.max(ry, contentY);\n        var x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        var y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        var r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n        var c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n        var r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n        var c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n        // Fetch the max row and column.\n        var maxRow = this._rowSections.count - 1;\n        var maxColumn = this._columnSections.count - 1;\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = maxRow;\n        }\n        if (c2 < 0) {\n            c2 = maxColumn;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        var x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n        var y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n        // Set up the paint region size variables.\n        var width = 0;\n        var height = 0;\n        // Allocate the section sizes arrays.\n        var rowSizes = new Array(r2 - r1 + 1);\n        var columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (var j = r1; j <= r2; ++j) {\n            var size = this._rowSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (var i = c1; i <= c2; ++i) {\n            var size = this._columnSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Adjust the geometry if the last row is streched.\n        if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n            var dh = this.pageHeight - this.bodyHeight;\n            rowSizes[rowSizes.length - 1] += dh;\n            height += dh;\n            y2 += dh;\n        }\n        // Adjust the geometry if the last column is streched.\n        if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n            var dw = this.pageWidth - this.bodyWidth;\n            columnSizes[columnSizes.length - 1] += dw;\n            width += dw;\n            x2 += dw;\n        }\n        // Create the paint region object.\n        var rgn = {\n            region: 'body',\n            xMin: x1, yMin: y1,\n            xMax: x2, yMax: y2,\n            x: x, y: y, width: width, height: height,\n            row: r1, column: c1,\n            rowSizes: rowSizes, columnSizes: columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.backgroundColor);\n        // Draw the row background.\n        this._drawRowBackground(rgn, this._style.rowBackgroundColor);\n        // Draw the column background.\n        this._drawColumnBackground(rgn, this._style.columnBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.horizontalGridLineColor ||\n            this._style.gridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.verticalGridLineColor ||\n            this._style.gridLineColor);\n    };\n    /**\n     * Draw the row header region which intersects the dirty rect.\n     */\n    DataGrid.prototype._drawRowHeaderRegion = function (rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        var contentW = this.headerWidth;\n        var contentH = this.bodyHeight - this._scrollY;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        var contentX = 0;\n        var contentY = this.headerHeight;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Fetch the geometry.\n        var bh = this.bodyHeight;\n        var ph = this.pageHeight;\n        // Get the upper and lower bounds of the dirty content area.\n        var x1 = rx;\n        var y1 = Math.max(ry, contentY);\n        var x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        var y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        var r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n        var c1 = this._rowHeaderSections.indexOf(x1);\n        var r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n        var c2 = this._rowHeaderSections.indexOf(x2);\n        // Fetch max row and column.\n        var maxRow = this._rowSections.count - 1;\n        var maxColumn = this._rowHeaderSections.count - 1;\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = maxRow;\n        }\n        if (c2 < 0) {\n            c2 = maxColumn;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        var x = this._rowHeaderSections.offsetOf(c1);\n        var y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n        // Set up the paint region size variables.\n        var width = 0;\n        var height = 0;\n        // Allocate the section sizes arrays.\n        var rowSizes = new Array(r2 - r1 + 1);\n        var columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (var j = r1; j <= r2; ++j) {\n            var size = this._rowSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (var i = c1; i <= c2; ++i) {\n            var size = this._rowHeaderSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Adjust the geometry if the last row is stretched.\n        if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n            var dh = this.pageHeight - this.bodyHeight;\n            rowSizes[rowSizes.length - 1] += dh;\n            height += dh;\n            y2 += dh;\n        }\n        // Create the paint region object.\n        var rgn = {\n            region: 'row-header',\n            xMin: x1, yMin: y1,\n            xMax: x2, yMax: y2,\n            x: x, y: y, width: width, height: height,\n            row: r1, column: c1,\n            rowSizes: rowSizes, columnSizes: columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.headerBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||\n            this._style.headerGridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor ||\n            this._style.headerGridLineColor);\n    };\n    /**\n     * Draw the column header region which intersects the dirty rect.\n     */\n    DataGrid.prototype._drawColumnHeaderRegion = function (rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        var contentW = this.bodyWidth - this._scrollX;\n        var contentH = this.headerHeight;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        var contentX = this.headerWidth;\n        var contentY = 0;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Fetch the geometry.\n        var bw = this.bodyWidth;\n        var pw = this.pageWidth;\n        // Get the upper and lower bounds of the dirty content area.\n        var x1 = Math.max(rx, contentX);\n        var y1 = ry;\n        var x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        var y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        var r1 = this._columnHeaderSections.indexOf(y1);\n        var c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n        var r2 = this._columnHeaderSections.indexOf(y2);\n        var c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n        // Fetch the max row and column.\n        var maxRow = this._columnHeaderSections.count - 1;\n        var maxColumn = this._columnSections.count - 1;\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = maxRow;\n        }\n        if (c2 < 0) {\n            c2 = maxColumn;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        var x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n        var y = this._columnHeaderSections.offsetOf(r1);\n        // Set up the paint region size variables.\n        var width = 0;\n        var height = 0;\n        // Allocate the section sizes arrays.\n        var rowSizes = new Array(r2 - r1 + 1);\n        var columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (var j = r1; j <= r2; ++j) {\n            var size = this._columnHeaderSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (var i = c1; i <= c2; ++i) {\n            var size = this._columnSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Adjust the geometry if the last column is stretched.\n        if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n            var dw = this.pageWidth - this.bodyWidth;\n            columnSizes[columnSizes.length - 1] += dw;\n            width += dw;\n            x2 += dw;\n        }\n        // Create the paint region object.\n        var rgn = {\n            region: 'column-header',\n            xMin: x1, yMin: y1,\n            xMax: x2, yMax: y2,\n            x: x, y: y, width: width, height: height,\n            row: r1, column: c1,\n            rowSizes: rowSizes, columnSizes: columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.headerBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||\n            this._style.headerGridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor ||\n            this._style.headerGridLineColor);\n    };\n    /**\n     * Draw the corner header region which intersects the dirty rect.\n     */\n    DataGrid.prototype.drawCornerHeaderRegion = function (rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        var contentW = this.headerWidth;\n        var contentH = this.headerHeight;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        var contentX = 0;\n        var contentY = 0;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Get the upper and lower bounds of the dirty content area.\n        var x1 = rx;\n        var y1 = ry;\n        var x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        var y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        var r1 = this._columnHeaderSections.indexOf(y1);\n        var c1 = this._rowHeaderSections.indexOf(x1);\n        var r2 = this._columnHeaderSections.indexOf(y2);\n        var c2 = this._rowHeaderSections.indexOf(x2);\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = this._columnHeaderSections.count - 1;\n        }\n        if (c2 < 0) {\n            c2 = this._rowHeaderSections.count - 1;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        var x = this._rowHeaderSections.offsetOf(c1);\n        var y = this._columnHeaderSections.offsetOf(r1);\n        // Set up the paint region size variables.\n        var width = 0;\n        var height = 0;\n        // Allocate the section sizes arrays.\n        var rowSizes = new Array(r2 - r1 + 1);\n        var columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (var j = r1; j <= r2; ++j) {\n            var size = this._columnHeaderSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (var i = c1; i <= c2; ++i) {\n            var size = this._rowHeaderSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Create the paint region object.\n        var rgn = {\n            region: 'corner-header',\n            xMin: x1, yMin: y1,\n            xMax: x2, yMax: y2,\n            x: x, y: y, width: width, height: height,\n            row: r1, column: c1,\n            rowSizes: rowSizes, columnSizes: columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.headerBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||\n            this._style.headerGridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor ||\n            this._style.headerGridLineColor);\n    };\n    /**\n     * Draw the background for the given paint region.\n     */\n    DataGrid.prototype._drawBackground = function (rgn, color) {\n        // Bail if there is no color to draw.\n        if (!color) {\n            return;\n        }\n        // Unpack the region.\n        var xMin = rgn.xMin, yMin = rgn.yMin, xMax = rgn.xMax, yMax = rgn.yMax;\n        // Fill the region with the specified color.\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);\n    };\n    /**\n     * Draw the row background for the given paint region.\n     */\n    DataGrid.prototype._drawRowBackground = function (rgn, colorFn) {\n        // Bail if there is no color function.\n        if (!colorFn) {\n            return;\n        }\n        // Compute the X bounds for the row.\n        var x1 = Math.max(rgn.xMin, rgn.x);\n        var x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);\n        // Draw the background for the rows in the region.\n        for (var y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n            // Fetch the size of the row.\n            var size = rgn.rowSizes[j];\n            // Skip zero sized rows.\n            if (size === 0) {\n                continue;\n            }\n            // Get the background color for the row.\n            var color = colorFn(rgn.row + j);\n            // Fill the row with the background color if needed.\n            if (color) {\n                var y1 = Math.max(rgn.yMin, y);\n                var y2 = Math.min(y + size - 1, rgn.yMax);\n                this._canvasGC.fillStyle = color;\n                this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Increment the running Y coordinate.\n            y += size;\n        }\n    };\n    /**\n     * Draw the column background for the given paint region.\n     */\n    DataGrid.prototype._drawColumnBackground = function (rgn, colorFn) {\n        // Bail if there is no color function.\n        if (!colorFn) {\n            return;\n        }\n        // Compute the Y bounds for the column.\n        var y1 = Math.max(rgn.yMin, rgn.y);\n        var y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n        // Draw the background for the columns in the region.\n        for (var x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n            // Fetch the size of the column.\n            var size = rgn.columnSizes[i];\n            // Skip zero sized columns.\n            if (size === 0) {\n                continue;\n            }\n            // Get the background color for the column.\n            var color = colorFn(rgn.column + i);\n            // Fill the column with the background color if needed.\n            if (color) {\n                var x1 = Math.max(rgn.xMin, x);\n                var x2 = Math.min(x + size - 1, rgn.xMax);\n                this._canvasGC.fillStyle = color;\n                this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Increment the running X coordinate.\n            x += size;\n        }\n    };\n    /**\n     * Draw the cells for the given paint region.\n     */\n    DataGrid.prototype._drawCells = function (rgn) {\n        // Bail if there is no data model.\n        if (!this._dataModel) {\n            return;\n        }\n        // Set up the cell config object for rendering.\n        var config = {\n            x: 0, y: 0, width: 0, height: 0,\n            region: rgn.region, row: 0, column: 0,\n            value: null, metadata: DataModel.emptyMetadata\n        };\n        // Save the buffer gc before wrapping.\n        this._bufferGC.save();\n        // Wrap the buffer gc for painting the cells.\n        var gc = new GraphicsContext(this._bufferGC);\n        // Compute the actual Y bounds for the cell range.\n        var y1 = Math.max(rgn.yMin, rgn.y);\n        var y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n        // Loop over the columns in the region.\n        for (var x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n            // Fetch the size of the column.\n            var width = rgn.columnSizes[i];\n            // Skip zero sized columns.\n            if (width === 0) {\n                continue;\n            }\n            // Compute the column index.\n            var column = rgn.column + i;\n            // Update the config for the current column.\n            config.x = x;\n            config.width = width;\n            config.column = column;\n            // Clear the buffer rect for the column.\n            gc.clearRect(x, rgn.y, width, rgn.height);\n            // Save the GC state.\n            gc.save();\n            // Loop over the rows in the column.\n            for (var y = rgn.y, j = 0, n_1 = rgn.rowSizes.length; j < n_1; ++j) {\n                // Fetch the size of the row.\n                var height = rgn.rowSizes[j];\n                // Skip zero sized rows.\n                if (height === 0) {\n                    continue;\n                }\n                // Compute the row index.\n                var row = rgn.row + j;\n                // Get the value for the cell.\n                var value = void 0;\n                try {\n                    value = this._dataModel.data(rgn.region, row, column);\n                }\n                catch (err) {\n                    value = undefined;\n                    console.error(err);\n                }\n                // Get the metadata for the cell.\n                var metadata = void 0;\n                try {\n                    metadata = this._dataModel.metadata(rgn.region, row, column);\n                }\n                catch (err) {\n                    metadata = DataModel.emptyMetadata;\n                    console.error(err);\n                }\n                // Update the config for the current cell.\n                config.y = y;\n                config.height = height;\n                config.row = row;\n                config.value = value;\n                config.metadata = metadata;\n                // Get the renderer for the cell.\n                var renderer = this._cellRenderers.get(config);\n                // Save the GC state.\n                gc.save();\n                // Paint the cell into the off-screen buffer.\n                try {\n                    renderer.paint(gc, config);\n                }\n                catch (err) {\n                    console.error(err);\n                }\n                // Restore the GC state.\n                gc.restore();\n                // Increment the running Y coordinate.\n                y += height;\n            }\n            // Restore the GC state.\n            gc.restore();\n            // Compute the actual X bounds for the column.\n            var x1 = Math.max(rgn.xMin, x);\n            var x2 = Math.min(x + width - 1, rgn.xMax);\n            // Blit the off-screen buffer column into the on-screen canvas.\n            //\n            // This is *much* faster than drawing directly into the on-screen\n            // canvas with a clip rect on the column. Managed column clipping\n            // is required to prevent cell renderers from needing to set up a\n            // clip rect for handling horizontal overflow text (slow!).\n            this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);\n            // Increment the running X coordinate.\n            x += width;\n        }\n        // Dispose of the wrapped gc.\n        gc.dispose();\n        // Restore the final buffer gc state.\n        this._bufferGC.restore();\n    };\n    /**\n     * Draw the horizontal grid lines for the given paint region.\n     */\n    DataGrid.prototype._drawHorizontalGridLines = function (rgn, color) {\n        // Bail if there is no color to draw.\n        if (!color) {\n            return;\n        }\n        // Compute the X bounds for the horizontal lines.\n        var x1 = Math.max(rgn.xMin, rgn.x);\n        var x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);\n        // Begin the path for the grid lines.\n        this._canvasGC.beginPath();\n        // Set the line width for the grid lines.\n        this._canvasGC.lineWidth = 1;\n        // Fetch the geometry.\n        var bh = this.bodyHeight;\n        var ph = this.pageHeight;\n        // Fetch the number of grid lines to be drawn.\n        var n = rgn.rowSizes.length;\n        // Adjust the count down if the last line shouldn't be drawn.\n        if (this._stretchLastRow && ph > bh) {\n            if (rgn.row + n === this._rowSections.count) {\n                n -= 1;\n            }\n        }\n        // Draw the horizontal grid lines.\n        for (var y = rgn.y, j = 0; j < n; ++j) {\n            // Fetch the size of the row.\n            var size = rgn.rowSizes[j];\n            // Skip zero sized rows.\n            if (size === 0) {\n                continue;\n            }\n            // Compute the Y position of the line.\n            var pos = y + size - 1;\n            // Draw the line if it's in range of the dirty rect.\n            if (pos >= rgn.yMin && pos <= rgn.yMax) {\n                this._canvasGC.moveTo(x1, pos + 0.5);\n                this._canvasGC.lineTo(x2, pos + 0.5);\n            }\n            // Increment the running Y coordinate.\n            y += size;\n        }\n        // Stroke the lines with the specified color.\n        this._canvasGC.strokeStyle = color;\n        this._canvasGC.stroke();\n    };\n    /**\n     * Draw the vertical grid lines for the given paint region.\n     */\n    DataGrid.prototype._drawVerticalGridLines = function (rgn, color) {\n        // Bail if there is no color to draw.\n        if (!color) {\n            return;\n        }\n        // Compute the Y bounds for the vertical lines.\n        var y1 = Math.max(rgn.yMin, rgn.y);\n        var y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);\n        // Begin the path for the grid lines\n        this._canvasGC.beginPath();\n        // Set the line width for the grid lines.\n        this._canvasGC.lineWidth = 1;\n        // Fetch the geometry.\n        var bw = this.bodyWidth;\n        var pw = this.pageWidth;\n        // Fetch the number of grid lines to be drawn.\n        var n = rgn.columnSizes.length;\n        // Adjust the count down if the last line shouldn't be drawn.\n        if (this._stretchLastColumn && pw > bw) {\n            if (rgn.column + n === this._columnSections.count) {\n                n -= 1;\n            }\n        }\n        // Draw the vertical grid lines.\n        for (var x = rgn.x, i = 0; i < n; ++i) {\n            // Fetch the size of the column.\n            var size = rgn.columnSizes[i];\n            // Skip zero sized columns.\n            if (size === 0) {\n                continue;\n            }\n            // Compute the X position of the line.\n            var pos = x + size - 1;\n            // Draw the line if it's in range of the dirty rect.\n            if (pos >= rgn.xMin && pos <= rgn.xMax) {\n                this._canvasGC.moveTo(pos + 0.5, y1);\n                this._canvasGC.lineTo(pos + 0.5, y2);\n            }\n            // Increment the running X coordinate.\n            x += size;\n        }\n        // Stroke the lines with the specified color.\n        this._canvasGC.strokeStyle = color;\n        this._canvasGC.stroke();\n    };\n    /**\n     * Draw the body selections for the data grid.\n     */\n    DataGrid.prototype._drawBodySelections = function () {\n        // Fetch the selection model.\n        var model = this._selectionModel;\n        // Bail early if there are no selections.\n        if (!model || model.isEmpty) {\n            return;\n        }\n        // Fetch the selection colors.\n        var fill = this._style.selectionFillColor;\n        var stroke = this._style.selectionBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch the scroll geometry.\n        var sx = this._scrollX;\n        var sy = this._scrollY;\n        // Get the first visible cell of the grid.\n        var r1 = this._rowSections.indexOf(sy);\n        var c1 = this._columnSections.indexOf(sx);\n        // Bail early if there are no visible cells.\n        if (r1 < 0 || c1 < 0) {\n            return;\n        }\n        // Fetch the extra geometry.\n        var bw = this.bodyWidth;\n        var bh = this.bodyHeight;\n        var pw = this.pageWidth;\n        var ph = this.pageHeight;\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        // Get the last visible cell of the grid.\n        var r2 = this._rowSections.indexOf(sy + ph);\n        var c2 = this._columnSections.indexOf(sx + pw);\n        // Fetch the max row and column.\n        var maxRow = this._rowSections.count - 1;\n        var maxColumn = this._columnSections.count - 1;\n        // Clamp the last cell if the void space is visible.\n        r2 = r2 < 0 ? maxRow : r2;\n        c2 = c2 < 0 ? maxColumn : c2;\n        // Fetch the overlay gc.\n        var gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the body clipping rect.\n        gc.beginPath();\n        gc.rect(hw, hh, pw, ph);\n        gc.clip();\n        // Set up the gc style.\n        if (fill) {\n            gc.fillStyle = fill;\n        }\n        if (stroke) {\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 1;\n        }\n        // Iterate over the selections.\n        var it = model.selections();\n        var s;\n        while ((s = it.next()) !== undefined) {\n            // Skip the section if it's not visible.\n            if (s.r1 < r1 && s.r2 < r1) {\n                continue;\n            }\n            if (s.r1 > r2 && s.r2 > r2) {\n                continue;\n            }\n            if (s.c1 < c1 && s.c2 < c1) {\n                continue;\n            }\n            if (s.c1 > c2 && s.c2 > c2) {\n                continue;\n            }\n            // Clamp the cell to the model bounds.\n            var sr1 = Math.max(0, Math.min(s.r1, maxRow));\n            var sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n            var sr2 = Math.max(0, Math.min(s.r2, maxRow));\n            var sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n            // Swap index order if needed.\n            var tmp = void 0;\n            if (sr1 > sr2) {\n                tmp = sr1;\n                sr1 = sr2;\n                sr2 = tmp;\n            }\n            if (sc1 > sc2) {\n                tmp = sc1;\n                sc1 = sc2;\n                sc2 = tmp;\n            }\n            // Convert to pixel coordinates.\n            var x1 = this._columnSections.offsetOf(sc1) - sx + hw;\n            var y1 = this._rowSections.offsetOf(sr1) - sy + hh;\n            var x2 = this._columnSections.extentOf(sc2) - sx + hw;\n            var y2 = this._rowSections.extentOf(sr2) - sy + hh;\n            // Adjust the trailing X coordinate for column stretch.\n            if (this._stretchLastColumn && pw > bw && sc2 === maxColumn) {\n                x2 = hw + pw - 1;\n            }\n            // Adjust the trailing Y coordinate for row stretch.\n            if (this._stretchLastRow && ph > bh && sr2 === maxRow) {\n                y2 = hh + ph - 1;\n            }\n            // Clamp the bounds to just outside of the clipping rect.\n            x1 = Math.max(hw - 1, x1);\n            y1 = Math.max(hh - 1, y1);\n            x2 = Math.min(hw + pw + 1, x2);\n            y2 = Math.min(hh + ph + 1, y2);\n            // Skip zero sized ranges.\n            if (x2 < x1 || y2 < y1) {\n                continue;\n            }\n            // Fill the rect if needed.\n            if (fill) {\n                gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Stroke the rect if needed.\n            if (stroke) {\n                gc.strokeRect(x1 - .5, y1 - .5, x2 - x1 + 1, y2 - y1 + 1);\n            }\n        }\n        // Restore the gc state.\n        gc.restore();\n    };\n    /**\n     * Draw the row header selections for the data grid.\n     */\n    DataGrid.prototype._drawRowHeaderSelections = function () {\n        // Fetch the selection model.\n        var model = this._selectionModel;\n        // Bail early if there are no selections or if the selectionMode is the entire column.\n        if (!model || model.isEmpty || model.selectionMode == 'column') {\n            return;\n        }\n        // Bail early if the row headers are not visible.\n        if (this.headerWidth === 0 || this.pageHeight === 0) {\n            return;\n        }\n        // Fetch the selection colors.\n        var fill = this._style.headerSelectionFillColor;\n        var stroke = this._style.headerSelectionBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch common geometry.\n        var sy = this._scrollY;\n        var bh = this.bodyHeight;\n        var ph = this.pageHeight;\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        var rs = this._rowSections;\n        // Fetch the overlay gc.\n        var gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the header clipping rect.\n        gc.beginPath();\n        gc.rect(0, hh, hw, ph);\n        gc.clip();\n        // Set up the gc style.\n        if (fill) {\n            gc.fillStyle = fill;\n        }\n        if (stroke) {\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 1;\n        }\n        // Fetch the max row.\n        var maxRow = rs.count - 1;\n        // Fetch the visible rows.\n        var r1 = rs.indexOf(sy);\n        var r2 = rs.indexOf(sy + ph - 1);\n        r2 = r2 < 0 ? maxRow : r2;\n        // Iterate over the visible rows.\n        for (var j = r1; j <= r2; ++j) {\n            // Skip rows which aren't selected.\n            if (!model.isRowSelected(j)) {\n                continue;\n            }\n            // Get the dimensions of the row.\n            var y = rs.offsetOf(j) - sy + hh;\n            var h = rs.sizeOf(j);\n            // Adjust the height for row stretch.\n            if (this._stretchLastRow && ph > bh && j === maxRow) {\n                h = hh + ph - y;\n            }\n            // Skip zero sized rows.\n            if (h === 0) {\n                continue;\n            }\n            // Fill the rect if needed.\n            if (fill) {\n                gc.fillRect(0, y, hw, h);\n            }\n            // Draw the border if needed.\n            if (stroke) {\n                gc.beginPath();\n                gc.moveTo(hw - .5, y - 1);\n                gc.lineTo(hw - .5, y + h);\n                gc.stroke();\n            }\n        }\n        // Restore the gc state.\n        gc.restore();\n    };\n    /**\n     * Draw the column header selections for the data grid.\n     */\n    DataGrid.prototype._drawColumnHeaderSelections = function () {\n        // Fetch the selection model.\n        var model = this._selectionModel;\n        // Bail early if there are no selections or if the selectionMode is the entire row\n        if (!model || model.isEmpty || model.selectionMode == 'row') {\n            return;\n        }\n        // Bail early if the column headers are not visible.\n        if (this.headerHeight === 0 || this.pageWidth === 0) {\n            return;\n        }\n        // Fetch the selection colors.\n        var fill = this._style.headerSelectionFillColor;\n        var stroke = this._style.headerSelectionBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch common geometry.\n        var sx = this._scrollX;\n        var bw = this.bodyWidth;\n        var pw = this.pageWidth;\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        var cs = this._columnSections;\n        // Fetch the overlay gc.\n        var gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the header clipping rect.\n        gc.beginPath();\n        gc.rect(hw, 0, pw, hh);\n        gc.clip();\n        // Set up the gc style.\n        if (fill) {\n            gc.fillStyle = fill;\n        }\n        if (stroke) {\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 1;\n        }\n        // Fetch the max column.\n        var maxCol = cs.count - 1;\n        // Fetch the visible columns.\n        var c1 = cs.indexOf(sx);\n        var c2 = cs.indexOf(sx + pw - 1);\n        c2 = c2 < 0 ? maxCol : c2;\n        // Iterate over the visible columns.\n        for (var i = c1; i <= c2; ++i) {\n            // Skip columns which aren't selected.\n            if (!model.isColumnSelected(i)) {\n                continue;\n            }\n            // Get the dimensions of the column.\n            var x = cs.offsetOf(i) - sx + hw;\n            var w = cs.sizeOf(i);\n            // Adjust the width for column stretch.\n            if (this._stretchLastColumn && pw > bw && i === maxCol) {\n                w = hw + pw - x;\n            }\n            // Skip zero sized columns.\n            if (w === 0) {\n                continue;\n            }\n            // Fill the rect if needed.\n            if (fill) {\n                gc.fillRect(x, 0, w, hh);\n            }\n            // Draw the border if needed.\n            if (stroke) {\n                gc.beginPath();\n                gc.moveTo(x - 1, hh - .5);\n                gc.lineTo(x + w, hh - .5);\n                gc.stroke();\n            }\n        }\n        // Restore the gc state.\n        gc.restore();\n    };\n    /**\n     * Draw the overlay cursor for the data grid.\n     */\n    DataGrid.prototype._drawCursor = function () {\n        // Fetch the selection model.\n        var model = this._selectionModel;\n        // Bail early if there is no cursor.\n        if (!model || model.isEmpty || model.selectionMode !== 'cell') {\n            return;\n        }\n        // Extract the style information.\n        var fill = this._style.cursorFillColor;\n        var stroke = this._style.cursorBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch the cursor location.\n        var row = model.cursorRow;\n        var column = model.cursorColumn;\n        // Fetch the max row and column.\n        var maxRow = this._rowSections.count - 1;\n        var maxColumn = this._columnSections.count - 1;\n        // Bail early if the cursor is out of bounds.\n        if (row < 0 || row > maxRow) {\n            return;\n        }\n        if (column < 0 || column > maxColumn) {\n            return;\n        }\n        // Fetch geometry.\n        var sx = this._scrollX;\n        var sy = this._scrollY;\n        var bw = this.bodyWidth;\n        var bh = this.bodyHeight;\n        var pw = this.pageWidth;\n        var ph = this.pageHeight;\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        var vw = this._viewportWidth;\n        var vh = this._viewportHeight;\n        // Get the cursor bounds in viewport coordinates.\n        var x1 = this._columnSections.offsetOf(column) - sx + hw;\n        var x2 = this._columnSections.extentOf(column) - sx + hw;\n        var y1 = this._rowSections.offsetOf(row) - sy + hh;\n        var y2 = this._rowSections.extentOf(row) - sy + hh;\n        // Adjust the trailing X coordinate for column stretch.\n        if (this._stretchLastColumn && pw > bw && column === maxColumn) {\n            x2 = vw - 1;\n        }\n        // Adjust the trailing Y coordinate for row stretch.\n        if (this._stretchLastRow && ph > bh && row === maxRow) {\n            y2 = vh - 1;\n        }\n        // Skip zero sized cursors.\n        if (x2 < x1 || y2 < y1) {\n            return;\n        }\n        // Bail early if the cursor is off the screen.\n        if ((x1 - 1) >= vw || (y1 - 1) >= vh || (x2 + 1) < hw || (y2 + 1) < hh) {\n            return;\n        }\n        // Fetch the overlay gc.\n        var gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the body clipping rect.\n        gc.beginPath();\n        gc.rect(hw, hh, pw, ph);\n        gc.clip();\n        // Clear any existing overlay content.\n        gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n        // Fill the cursor rect if needed.\n        if (fill) {\n            // Set up the fill style.\n            gc.fillStyle = fill;\n            // Fill the cursor rect.\n            gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n        }\n        // Stroke the cursor border if needed.\n        if (stroke) {\n            // Set up the stroke style.\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 2;\n            // Stroke the cursor rect.\n            gc.strokeRect(x1, y1, x2 - x1, y2 - y1);\n        }\n        // Restore the gc state.\n        gc.restore();\n    };\n    /**\n     * Draw the overlay shadows for the data grid.\n     */\n    DataGrid.prototype._drawShadows = function () {\n        // Fetch the scroll shadow from the style.\n        var shadow = this._style.scrollShadow;\n        // Bail early if there is no shadow to draw.\n        if (!shadow) {\n            return;\n        }\n        // Fetch the scroll position.\n        var sx = this._scrollX;\n        var sy = this._scrollY;\n        // Fetch maximum scroll position.\n        var sxMax = this.maxScrollX;\n        var syMax = this.maxScrollY;\n        // Fetch the header width and height.\n        var hw = this.headerWidth;\n        var hh = this.headerHeight;\n        // Fetch the page width and height.\n        var pw = this.pageWidth;\n        var ph = this.pageHeight;\n        // Fetch the viewport width and height.\n        var vw = this._viewportWidth;\n        var vh = this._viewportHeight;\n        // Fetch the body width and height.\n        var bw = this.bodyWidth;\n        var bh = this.bodyHeight;\n        // Adjust the body size for row and column stretch.\n        if (this._stretchLastRow && ph > bh) {\n            bh = ph;\n        }\n        if (this._stretchLastColumn && pw > bw) {\n            bw = pw;\n        }\n        // Fetch the gc object.\n        var gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Draw the column header shadow if needed.\n        if (sy > 0) {\n            // Set up the gradient coordinates.\n            var x0 = 0;\n            var y0 = hh;\n            var x1 = 0;\n            var y1 = y0 + shadow.size;\n            // Create the gradient object.\n            var grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            var x = 0;\n            var y = hh;\n            var w = hw + Math.min(pw, bw - sx);\n            var h = shadow.size;\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Draw the row header shadow if needed.\n        if (sx > 0) {\n            // Set up the gradient coordinates.\n            var x0 = hw;\n            var y0 = 0;\n            var x1 = x0 + shadow.size;\n            var y1 = 0;\n            // Create the gradient object.\n            var grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            var x = hw;\n            var y = 0;\n            var w = shadow.size;\n            var h = hh + Math.min(ph, bh - sy);\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Draw the column footer shadow if needed.\n        if (sy < syMax) {\n            // Set up the gradient coordinates.\n            var x0 = 0;\n            var y0 = vh;\n            var x1 = 0;\n            var y1 = vh - shadow.size;\n            // Create the gradient object.\n            var grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            var x = 0;\n            var y = vh - shadow.size;\n            var w = hw + Math.min(pw, bw - sx);\n            var h = shadow.size;\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Draw the row footer shadow if needed.\n        if (sx < sxMax) {\n            // Set up the gradient coordinates.\n            var x0 = vw;\n            var y0 = 0;\n            var x1 = vw - shadow.size;\n            var y1 = 0;\n            // Create the gradient object.\n            var grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            var x = vw - shadow.size;\n            var y = 0;\n            var w = shadow.size;\n            var h = hh + Math.min(ph, bh - sy);\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Restore the gc state.\n        gc.restore();\n    };\n    return DataGrid;\n}(_lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget));\n/**\n * The namespace for the `DataGrid` class statics.\n */\n(function (DataGrid) {\n    /**\n     * A generic format function for the copy handler.\n     *\n     * @param args - The format args for the function.\n     *\n     * @returns The string representation of the value.\n     *\n     * #### Notes\n     * This function uses `String()` to coerce a value to a string.\n     */\n    function copyFormatGeneric(args) {\n        if (args.value === null || args.value === undefined) {\n            return '';\n        }\n        return String(args.value);\n    }\n    DataGrid.copyFormatGeneric = copyFormatGeneric;\n    /**\n     * The default theme for a data grid.\n     */\n    DataGrid.defaultStyle = {\n        voidColor: '#F3F3F3',\n        backgroundColor: '#FFFFFF',\n        gridLineColor: 'rgba(20, 20, 20, 0.15)',\n        headerBackgroundColor: '#F3F3F3',\n        headerGridLineColor: 'rgba(20, 20, 20, 0.25)',\n        selectionFillColor: 'rgba(49, 119, 229, 0.2)',\n        selectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n        cursorBorderColor: 'rgba(0, 107, 247, 1.0)',\n        headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',\n        headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n        scrollShadow: {\n            size: 10,\n            color1: 'rgba(0, 0, 0, 0.20)',\n            color2: 'rgba(0, 0, 0, 0.05)',\n            color3: 'rgba(0, 0, 0, 0.00)'\n        }\n    };\n    /**\n     * The default sizes for a data grid.\n     */\n    DataGrid.defaultSizes = {\n        rowHeight: 20,\n        columnWidth: 64,\n        rowHeaderWidth: 64,\n        columnHeaderHeight: 20\n    };\n    /**\n     * The default minimum sizes for a data grid.\n     */\n    DataGrid.minimumSizes = {\n        rowHeight: 20,\n        columnWidth: 10,\n        rowHeaderWidth: 10,\n        columnHeaderHeight: 20\n    };\n    /**\n     * The default copy config for a data grid.\n     */\n    DataGrid.defaultCopyConfig = {\n        separator: '\\t',\n        format: copyFormatGeneric,\n        headers: 'none',\n        warningThreshold: 1e6\n    };\n})(DataGrid || (DataGrid = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$6;\n(function (Private) {\n    /**\n     * A singleton `scroll-request` conflatable message.\n     */\n    Private.ScrollRequest = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.ConflatableMessage('scroll-request');\n    /**\n     * A singleton `overlay-paint-request` conflatable message.\n     */\n    Private.OverlayPaintRequest = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.ConflatableMessage('overlay-paint-request');\n    /**\n     * Create a new zero-sized canvas element.\n     */\n    function createCanvas() {\n        var canvas = document.createElement('canvas');\n        canvas.width = 0;\n        canvas.height = 0;\n        return canvas;\n    }\n    Private.createCanvas = createCanvas;\n    /**\n     * A conflatable message which merges dirty paint regions.\n     */\n    var PaintRequest = /** @class */ (function (_super) {\n        __extends(PaintRequest, _super);\n        /**\n         * Construct a new paint request messages.\n         *\n         * @param region - The cell region for the paint.\n         *\n         * @param r1 - The top-left row of the dirty region.\n         *\n         * @param c1 - The top-left column of the dirty region.\n         *\n         * @param r2 - The bottom-right row of the dirty region.\n         *\n         * @param c2 - The bottom-right column of the dirty region.\n         */\n        function PaintRequest(region, r1, c1, r2, c2) {\n            var _this = _super.call(this, 'paint-request') || this;\n            _this._region = region;\n            _this._r1 = r1;\n            _this._c1 = c1;\n            _this._r2 = r2;\n            _this._c2 = c2;\n            return _this;\n        }\n        Object.defineProperty(PaintRequest.prototype, \"region\", {\n            /**\n             * The cell region for the paint.\n             */\n            get: function () {\n                return this._region;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PaintRequest.prototype, \"r1\", {\n            /**\n             * The top-left row of the dirty region.\n             */\n            get: function () {\n                return this._r1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PaintRequest.prototype, \"c1\", {\n            /**\n             * The top-left column of the dirty region.\n             */\n            get: function () {\n                return this._c1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PaintRequest.prototype, \"r2\", {\n            /**\n             * The bottom-right row of the dirty region.\n             */\n            get: function () {\n                return this._r2;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PaintRequest.prototype, \"c2\", {\n            /**\n             * The bottom-right column of the dirty region.\n             */\n            get: function () {\n                return this._c2;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Conflate this message with another paint request.\n         */\n        PaintRequest.prototype.conflate = function (other) {\n            // Bail early if the request is already painting everything.\n            if (this._region === 'all') {\n                return true;\n            }\n            // Any region can conflate with the `'all'` region.\n            if (other._region === 'all') {\n                this._region = 'all';\n                return true;\n            }\n            // Otherwise, do not conflate with a different region.\n            if (this._region !== other._region) {\n                return false;\n            }\n            // Conflate the region to the total boundary.\n            this._r1 = Math.min(this._r1, other._r1);\n            this._c1 = Math.min(this._c1, other._c1);\n            this._r2 = Math.max(this._r2, other._r2);\n            this._c2 = Math.max(this._c2, other._c2);\n            return true;\n        };\n        return PaintRequest;\n    }(_lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.ConflatableMessage));\n    Private.PaintRequest = PaintRequest;\n    /**\n     * A conflatable message for resizing rows.\n     */\n    var RowResizeRequest = /** @class */ (function (_super) {\n        __extends(RowResizeRequest, _super);\n        /**\n         * Construct a new row resize request.\n         *\n         * @param region - The row region which holds the section.\n         *\n         * @param index - The index of row in the region.\n         *\n         * @param size - The target size of the section.\n         */\n        function RowResizeRequest(region, index, size) {\n            var _this = _super.call(this, 'row-resize-request') || this;\n            _this._region = region;\n            _this._index = index;\n            _this._size = size;\n            return _this;\n        }\n        Object.defineProperty(RowResizeRequest.prototype, \"region\", {\n            /**\n             * The row region which holds the section.\n             */\n            get: function () {\n                return this._region;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RowResizeRequest.prototype, \"index\", {\n            /**\n             * The index of the row in the region.\n             */\n            get: function () {\n                return this._index;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RowResizeRequest.prototype, \"size\", {\n            /**\n             * The target size of the section.\n             */\n            get: function () {\n                return this._size;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Conflate this message with another row resize request.\n         */\n        RowResizeRequest.prototype.conflate = function (other) {\n            if (this._region !== other._region || this._index !== other._index) {\n                return false;\n            }\n            this._size = other._size;\n            return true;\n        };\n        return RowResizeRequest;\n    }(_lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.ConflatableMessage));\n    Private.RowResizeRequest = RowResizeRequest;\n    /**\n     * A conflatable message for resizing columns.\n     */\n    var ColumnResizeRequest = /** @class */ (function (_super) {\n        __extends(ColumnResizeRequest, _super);\n        /**\n         * Construct a new column resize request.\n         *\n         * @param region - The column region which holds the section.\n         *\n         * @param index - The index of column in the region.\n         *\n         * @param size - The target size of the section.\n         */\n        function ColumnResizeRequest(region, index, size) {\n            var _this = _super.call(this, 'column-resize-request') || this;\n            _this._region = region;\n            _this._index = index;\n            _this._size = size;\n            return _this;\n        }\n        Object.defineProperty(ColumnResizeRequest.prototype, \"region\", {\n            /**\n             * The column region which holds the section.\n             */\n            get: function () {\n                return this._region;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColumnResizeRequest.prototype, \"index\", {\n            /**\n             * The index of the column in the region.\n             */\n            get: function () {\n                return this._index;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColumnResizeRequest.prototype, \"size\", {\n            /**\n             * The target size of the section.\n             */\n            get: function () {\n                return this._size;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Conflate this message with another column resize request.\n         */\n        ColumnResizeRequest.prototype.conflate = function (other) {\n            if (this._region !== other._region || this._index !== other._index) {\n                return false;\n            }\n            this._size = other._size;\n            return true;\n        };\n        return ColumnResizeRequest;\n    }(_lumino_messaging__WEBPACK_IMPORTED_MODULE_6__.ConflatableMessage));\n    Private.ColumnResizeRequest = ColumnResizeRequest;\n})(Private$6 || (Private$6 = {}));\n\n/**\n * A data model implementation for in-memory JSON data.\n */\nvar JSONModel = /** @class */ (function (_super) {\n    __extends(JSONModel, _super);\n    /**\n     * Create a data model with static JSON data.\n     *\n     * @param options - The options for initializing the data model.\n     */\n    function JSONModel(options) {\n        var _this = _super.call(this) || this;\n        var split = Private$7.splitFields(options.schema);\n        _this._data = options.data;\n        _this._bodyFields = split.bodyFields;\n        _this._headerFields = split.headerFields;\n        _this._missingValues = Private$7.createMissingMap(options.schema);\n        return _this;\n    }\n    /**\n     * Get the row count for a region in the data model.\n     *\n     * @param region - The row region of interest.\n     *\n     * @returns - The row count for the region.\n     */\n    JSONModel.prototype.rowCount = function (region) {\n        if (region === 'body') {\n            return this._data.length;\n        }\n        return 1; // TODO multiple column-header rows?\n    };\n    /**\n     * Get the column count for a region in the data model.\n     *\n     * @param region - The column region of interest.\n     *\n     * @returns - The column count for the region.\n     */\n    JSONModel.prototype.columnCount = function (region) {\n        if (region === 'body') {\n            return this._bodyFields.length;\n        }\n        return this._headerFields.length;\n    };\n    /**\n     * Get the data value for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @returns - The data value for the specified cell.\n     *\n     * #### Notes\n     * A `missingValue` as defined by the schema is converted to `null`.\n     */\n    JSONModel.prototype.data = function (region, row, column) {\n        // Set up the field and value variables.\n        var field;\n        var value;\n        // Look up the field and value for the region.\n        switch (region) {\n            case 'body':\n                field = this._bodyFields[column];\n                value = this._data[row][field.name];\n                break;\n            case 'column-header':\n                field = this._bodyFields[column];\n                value = field.title || field.name;\n                break;\n            case 'row-header':\n                field = this._headerFields[column];\n                value = this._data[row][field.name];\n                break;\n            case 'corner-header':\n                field = this._headerFields[column];\n                value = field.title || field.name;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Test whether the value is a missing value.\n        var missing = (this._missingValues !== null &&\n            typeof value === 'string' &&\n            this._missingValues[value] === true);\n        // Return the final value.\n        return missing ? null : value;\n    };\n    /**\n     * Get the metadata for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @returns The metadata for the cell.\n     */\n    JSONModel.prototype.metadata = function (region, row, column) {\n        if (region === 'body' || region === 'column-header') {\n            return this._bodyFields[column];\n        }\n        return this._headerFields[column];\n    };\n    return JSONModel;\n}(DataModel));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$7;\n(function (Private) {\n    /**\n     * Split the schema fields into header and body fields.\n     */\n    function splitFields(schema) {\n        // Normalize the primary keys.\n        var primaryKeys;\n        if (schema.primaryKey === undefined) {\n            primaryKeys = [];\n        }\n        else if (typeof schema.primaryKey === 'string') {\n            primaryKeys = [schema.primaryKey];\n        }\n        else {\n            primaryKeys = schema.primaryKey;\n        }\n        // Separate the fields for the body and header.\n        var bodyFields = [];\n        var headerFields = [];\n        for (var _i = 0, _a = schema.fields; _i < _a.length; _i++) {\n            var field = _a[_i];\n            if (primaryKeys.indexOf(field.name) === -1) {\n                bodyFields.push(field);\n            }\n            else {\n                headerFields.push(field);\n            }\n        }\n        // Return the separated fields.\n        return { bodyFields: bodyFields, headerFields: headerFields };\n    }\n    Private.splitFields = splitFields;\n    /**\n     * Create a missing values map for a schema.\n     *\n     * This returns `null` if there are no missing values.\n     */\n    function createMissingMap(schema) {\n        // Bail early if there are no missing values.\n        if (!schema.missingValues || schema.missingValues.length === 0) {\n            return null;\n        }\n        // Collect the missing values into a map.\n        var result = Object.create(null);\n        for (var _i = 0, _a = schema.missingValues; _i < _a.length; _i++) {\n            var value = _a[_i];\n            result[value] = true;\n        }\n        // Return the populated map.\n        return result;\n    }\n    Private.createMissingMap = createMissingMap;\n})(Private$7 || (Private$7 = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9kYXRhZ3JpZC9kaXN0L2luZGV4LmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0U7QUFDakI7QUFDYjtBQUMwQjtBQUN2QjtBQUNxQjtBQUNJOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrREFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtFQUErRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0VBQStFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrRUFBK0U7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrREFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtFQUErRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0VBQStFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtFQUErRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4R0FBOEc7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQW1CO0FBQ2hEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQW1CO0FBQ2hEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnR0FBZ0c7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0dBQWdHO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnR0FBZ0c7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUzQjtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFJLG1DQUFtQyx5Q0FBeUM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBSSxtQ0FBbUMsNENBQTRDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFJLG1DQUFtQyxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4QkFBOEI7QUFDdEU7QUFDQTtBQUNBLHNCQUFzQix1RUFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsbURBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBLDRFQUE0RSxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsR0FBRztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBeUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw0QkFBNEIscURBQU07QUFDbEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWUsc0JBQXNCLDBDQUEwQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFlLHNCQUFzQiwwQ0FBMEM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQW1CO0FBQ25DO0FBQ0EsZ0JBQWdCLGtFQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrRUFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0VBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxZQUFZLDhEQUFlO0FBQzNCO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGlEQUFpRDtBQUNqRCxrREFBa0Q7QUFDbEQsbURBQW1EO0FBQ25ELHFEQUFxRDtBQUNyRCxzREFBc0Q7QUFDdEQsd0RBQXdEO0FBQ3hELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQU07QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxzREFBUyxHQUFHLHlCQUF5QjtBQUNyRSxnQ0FBZ0Msc0RBQVMsR0FBRywyQkFBMkI7QUFDdkUsa0NBQWtDLG1EQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZFQUE4QjtBQUN0QyxRQUFRLDZFQUE4QjtBQUN0QyxRQUFRLDZFQUE4QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFFQUF3QixvQkFBb0IsbUJBQW1CO0FBQ3ZFLFFBQVEscUVBQXdCLHNCQUFzQixtQkFBbUI7QUFDekUsUUFBUSxxRUFBd0Isc0JBQXNCLG1CQUFtQjtBQUN6RSxRQUFRLHFFQUF3Qix3QkFBd0IsbUJBQW1CO0FBQzNFO0FBQ0EseUJBQXlCLHVEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQStCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBcUI7QUFDakQsNEJBQTRCLG1FQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUIsT0FBTyxrRUFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLG1EQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpRUFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlFQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxDQUFDLGlFQUFrQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLENBQUMsaUVBQWtCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssQ0FBQyxpRUFBa0I7QUFDeEI7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFOFo7QUFDN2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWZzaGluL2xpZmUvLi9ub2RlX21vZHVsZXMvQGx1bWluby9kYXRhZ3JpZC9kaXN0L2luZGV4LmVzNi5qcz9lODRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsYXRmb3JtLCBDbGlwYm9hcmRFeHQsIEVsZW1lbnRFeHQgfSBmcm9tICdAbHVtaW5vL2RvbXV0aWxzJztcbmltcG9ydCB7IGdldEtleWJvYXJkTGF5b3V0IH0gZnJvbSAnQGx1bWluby9rZXlib2FyZCc7XG5pbXBvcnQgeyBEcmFnIH0gZnJvbSAnQGx1bWluby9kcmFnZHJvcCc7XG5pbXBvcnQgeyBzb21lLCBpdGVyLCBBcnJheUV4dCwgdG9BcnJheSB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbmltcG9ydCB7IFdpZGdldCwgU2Nyb2xsQmFyLCBHcmlkTGF5b3V0IH0gZnJvbSAnQGx1bWluby93aWRnZXRzJztcbmltcG9ydCB7IE1lc3NhZ2VMb29wLCBDb25mbGF0YWJsZU1lc3NhZ2UgfSBmcm9tICdAbHVtaW5vL21lc3NhZ2luZyc7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBBIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIGEgZGF0YSBncmlkIGtleSBoYW5kbGVyLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgbWF5IGJlIHN1YmNsYXNzZWQgYW5kIGN1c3RvbWl6ZWQgYXMgbmVlZGVkLlxuICovXG52YXIgQmFzaWNLZXlIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2ljS2V5SGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljS2V5SGFuZGxlci5wcm90b3R5cGUsIFwiaXNEaXNwb3NlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBrZXkgaGFuZGxlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUga2V5IGhhbmRsZXIuXG4gICAgICovXG4gICAgQmFzaWNLZXlIYW5kbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGtleSBkb3duIGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWRvd24gZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLlxuICAgICAqL1xuICAgIEJhc2ljS2V5SGFuZGxlci5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24gKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIGlmIGdyaWQgaXMgZWRpdGFibGUgYW5kIGNlbGwgc2VsZWN0aW9uIGF2YWlsYWJsZSwgc3RhcnQgY2VsbCBlZGl0aW5nXG4gICAgICAgIC8vIG9uIGtleSBwcmVzcyAobGV0dGVycywgbnVtYmVycyBhbmQgc3BhY2Ugb25seSlcbiAgICAgICAgaWYgKGdyaWQuZWRpdGFibGUgJiZcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0aW9uTW9kZWwuY3Vyc29yUm93ICE9PSAtMSAmJlxuICAgICAgICAgICAgZ3JpZC5zZWxlY3Rpb25Nb2RlbC5jdXJzb3JDb2x1bW4gIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgaWYgKC9bYS16QS1aMC05LV8gXS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5jdXJzb3JSb3c7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGdyaWQuc2VsZWN0aW9uTW9kZWwuY3Vyc29yQ29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdyaWQuZWRpdG9yQ29udHJvbGxlci5lZGl0KGNlbGwpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRLZXlib2FyZExheW91dCgpLmtleUZvcktleWRvd25FdmVudChldmVudCkgPT09ICdTcGFjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGdldEtleWJvYXJkTGF5b3V0KCkua2V5Rm9yS2V5ZG93bkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQXJyb3dMZWZ0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgICAgIHRoaXMub25BcnJvd1JpZ2h0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIHRoaXMub25BcnJvd1VwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFycm93RG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICAgICAgICAgIHRoaXMub25QYWdlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUGFnZURvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMub25QYWdlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25Fc2NhcGUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRGVsZXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGVsZXRlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlDKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5zZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBncmlkLm1vdmVDdXJzb3IoZXZlbnQuc2hpZnRLZXkgPyAndXAnIDogJ2Rvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5zY3JvbGxUb0N1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuc2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5tb3ZlQ3Vyc29yKGV2ZW50LnNoaWZ0S2V5ID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG9DdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnQXJyb3dMZWZ0J2Aga2V5IHByZXNzIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIEJhc2ljS2V5SGFuZGxlci5wcm90b3R5cGUub25BcnJvd0xlZnQgPSBmdW5jdGlvbiAoZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICB2YXIgbW9kZWwgPSBncmlkLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICAvLyBGZXRjaCB0aGUgbW9kaWZpZXIgZmxhZ3MuXG4gICAgICAgIHZhciBzaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB2YXIgYWNjZWwgPSBQbGF0Zm9ybS5hY2NlbEtleShldmVudCk7XG4gICAgICAgIC8vIEhhbmRsZSBubyBtb2RlbCB3aXRoIHRoZSBhY2NlbCBtb2RpZmllci5cbiAgICAgICAgaWYgKCFtb2RlbCAmJiBhY2NlbCkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxUbygwLCBncmlkLnNjcm9sbFkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBubyBtb2RlbCBhbmQgbm8gbW9kaWZpZXIuIChpZ25vcmUgc2hpZnQpXG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnlTdGVwKCdsZWZ0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlLlxuICAgICAgICB2YXIgbW9kZSA9IG1vZGVsLnNlbGVjdGlvbk1vZGU7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcm93IHNlbGVjdGlvbiBtb2RlIHdpdGggYWNjZWwga2V5LlxuICAgICAgICBpZiAobW9kZSA9PT0gJ3JvdycgJiYgYWNjZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG8oMCwgZ3JpZC5zY3JvbGxZKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIHJvdyBzZWxlY3Rpb24gbW9kZSB3aXRoIG5vIG1vZGlmaWVyLiAoaWdub3JlIHNoaWZ0KVxuICAgICAgICBpZiAobW9kZSA9PT0gJ3JvdycpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnlTdGVwKCdsZWZ0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnNvciBhbmQgc2VsZWN0aW9uLlxuICAgICAgICB2YXIgciA9IG1vZGVsLmN1cnNvclJvdztcbiAgICAgICAgdmFyIGMgPSBtb2RlbC5jdXJzb3JDb2x1bW47XG4gICAgICAgIHZhciBjcyA9IG1vZGVsLmN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICB2YXIgcjE7XG4gICAgICAgIHZhciByMjtcbiAgICAgICAgdmFyIGMxO1xuICAgICAgICB2YXIgYzI7XG4gICAgICAgIHZhciBjcjtcbiAgICAgICAgdmFyIGNjO1xuICAgICAgICB2YXIgY2xlYXI7XG4gICAgICAgIC8vIERpc3BhdGNoIGJhc2VkIG9uIHRoZSBtb2RpZmllciBrZXlzLlxuICAgICAgICBpZiAoYWNjZWwgJiYgc2hpZnQpIHtcbiAgICAgICAgICAgIHIxID0gY3MgPyBjcy5yMSA6IDA7XG4gICAgICAgICAgICByMiA9IGNzID8gY3MucjIgOiAwO1xuICAgICAgICAgICAgYzEgPSBjcyA/IGNzLmMxIDogMDtcbiAgICAgICAgICAgIGMyID0gMDtcbiAgICAgICAgICAgIGNyID0gcjtcbiAgICAgICAgICAgIGNjID0gYztcbiAgICAgICAgICAgIGNsZWFyID0gJ2N1cnJlbnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoaWZ0KSB7XG4gICAgICAgICAgICByMSA9IGNzID8gY3MucjEgOiAwO1xuICAgICAgICAgICAgcjIgPSBjcyA/IGNzLnIyIDogMDtcbiAgICAgICAgICAgIGMxID0gY3MgPyBjcy5jMSA6IDA7XG4gICAgICAgICAgICBjMiA9IGNzID8gY3MuYzIgLSAxIDogMDtcbiAgICAgICAgICAgIGNyID0gcjtcbiAgICAgICAgICAgIGNjID0gYztcbiAgICAgICAgICAgIGNsZWFyID0gJ2N1cnJlbnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VsKSB7XG4gICAgICAgICAgICByMSA9IHI7XG4gICAgICAgICAgICByMiA9IHI7XG4gICAgICAgICAgICBjMSA9IDA7XG4gICAgICAgICAgICBjMiA9IDA7XG4gICAgICAgICAgICBjciA9IHIxO1xuICAgICAgICAgICAgY2MgPSBjMTtcbiAgICAgICAgICAgIGNsZWFyID0gJ2FsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IHI7XG4gICAgICAgICAgICByMiA9IHI7XG4gICAgICAgICAgICBjMSA9IGMgLSAxO1xuICAgICAgICAgICAgYzIgPSBjIC0gMTtcbiAgICAgICAgICAgIGNyID0gcjE7XG4gICAgICAgICAgICBjYyA9IGMxO1xuICAgICAgICAgICAgY2xlYXIgPSAnYWxsJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBzZWxlY3Rpb24uXG4gICAgICAgIG1vZGVsLnNlbGVjdCh7IHIxOiByMSwgYzE6IGMxLCByMjogcjIsIGMyOiBjMiwgY3Vyc29yUm93OiBjciwgY3Vyc29yQ29sdW1uOiBjYywgY2xlYXI6IGNsZWFyIH0pO1xuICAgICAgICAvLyBSZS1mZXRjaCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgIGNzID0gbW9kZWwuY3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi5cbiAgICAgICAgaWYgKCFjcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCB0aGUgZ3JpZCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICBpZiAoc2hpZnQgfHwgbW9kZSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG9Db2x1bW4oY3MuYzIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxUb0N1cnNvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnQXJyb3dSaWdodCdgIGtleSBwcmVzcyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBCYXNpY0tleUhhbmRsZXIucHJvdG90eXBlLm9uQXJyb3dSaWdodCA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICAvLyBTdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIHZhciBtb2RlbCA9IGdyaWQuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIC8vIEZldGNoIHRoZSBtb2RpZmllciBmbGFncy5cbiAgICAgICAgdmFyIHNoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHZhciBhY2NlbCA9IFBsYXRmb3JtLmFjY2VsS2V5KGV2ZW50KTtcbiAgICAgICAgLy8gSGFuZGxlIG5vIG1vZGVsIHdpdGggdGhlIGFjY2VsIG1vZGlmaWVyLlxuICAgICAgICBpZiAoIW1vZGVsICYmIGFjY2VsKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbFRvKGdyaWQubWF4U2Nyb2xsWCwgZ3JpZC5zY3JvbGxZKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbm8gbW9kZWwgYW5kIG5vIG1vZGlmaWVyLiAoaWdub3JlIHNoaWZ0KVxuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5U3RlcCgncmlnaHQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgIHZhciBtb2RlID0gbW9kZWwuc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSByb3cgc2VsZWN0aW9uIG1vZGVsIHdpdGggYWNjZWwga2V5LlxuICAgICAgICBpZiAobW9kZSA9PT0gJ3JvdycgJiYgYWNjZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG8oZ3JpZC5tYXhTY3JvbGxYLCBncmlkLnNjcm9sbFkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcm93IHNlbGVjdGlvbiBtb2RlIHdpdGggbm8gbW9kaWZpZXIuIChpZ25vcmUgc2hpZnQpXG4gICAgICAgIGlmIChtb2RlID09PSAncm93Jykge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeVN0ZXAoJ3JpZ2h0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnNvciBhbmQgc2VsZWN0aW9uLlxuICAgICAgICB2YXIgciA9IG1vZGVsLmN1cnNvclJvdztcbiAgICAgICAgdmFyIGMgPSBtb2RlbC5jdXJzb3JDb2x1bW47XG4gICAgICAgIHZhciBjcyA9IG1vZGVsLmN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICB2YXIgcjE7XG4gICAgICAgIHZhciByMjtcbiAgICAgICAgdmFyIGMxO1xuICAgICAgICB2YXIgYzI7XG4gICAgICAgIHZhciBjcjtcbiAgICAgICAgdmFyIGNjO1xuICAgICAgICB2YXIgY2xlYXI7XG4gICAgICAgIC8vIERpc3BhdGNoIGJhc2VkIG9uIHRoZSBtb2RpZmllciBrZXlzLlxuICAgICAgICBpZiAoYWNjZWwgJiYgc2hpZnQpIHtcbiAgICAgICAgICAgIHIxID0gY3MgPyBjcy5yMSA6IDA7XG4gICAgICAgICAgICByMiA9IGNzID8gY3MucjIgOiAwO1xuICAgICAgICAgICAgYzEgPSBjcyA/IGNzLmMxIDogMDtcbiAgICAgICAgICAgIGMyID0gSW5maW5pdHk7XG4gICAgICAgICAgICBjciA9IHI7XG4gICAgICAgICAgICBjYyA9IGM7XG4gICAgICAgICAgICBjbGVhciA9ICdjdXJyZW50JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGlmdCkge1xuICAgICAgICAgICAgcjEgPSBjcyA/IGNzLnIxIDogMDtcbiAgICAgICAgICAgIHIyID0gY3MgPyBjcy5yMiA6IDA7XG4gICAgICAgICAgICBjMSA9IGNzID8gY3MuYzEgOiAwO1xuICAgICAgICAgICAgYzIgPSBjcyA/IGNzLmMyICsgMSA6IDA7XG4gICAgICAgICAgICBjciA9IHI7XG4gICAgICAgICAgICBjYyA9IGM7XG4gICAgICAgICAgICBjbGVhciA9ICdjdXJyZW50JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlbCkge1xuICAgICAgICAgICAgcjEgPSByO1xuICAgICAgICAgICAgcjIgPSByO1xuICAgICAgICAgICAgYzEgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGMyID0gSW5maW5pdHk7XG4gICAgICAgICAgICBjciA9IHIxO1xuICAgICAgICAgICAgY2MgPSBjMTtcbiAgICAgICAgICAgIGNsZWFyID0gJ2FsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IHI7XG4gICAgICAgICAgICByMiA9IHI7XG4gICAgICAgICAgICBjMSA9IGMgKyAxO1xuICAgICAgICAgICAgYzIgPSBjICsgMTtcbiAgICAgICAgICAgIGNyID0gcjE7XG4gICAgICAgICAgICBjYyA9IGMxO1xuICAgICAgICAgICAgY2xlYXIgPSAnYWxsJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBzZWxlY3Rpb24uXG4gICAgICAgIG1vZGVsLnNlbGVjdCh7IHIxOiByMSwgYzE6IGMxLCByMjogcjIsIGMyOiBjMiwgY3Vyc29yUm93OiBjciwgY3Vyc29yQ29sdW1uOiBjYywgY2xlYXI6IGNsZWFyIH0pO1xuICAgICAgICAvLyBSZS1mZXRjaCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgIGNzID0gbW9kZWwuY3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi5cbiAgICAgICAgaWYgKCFjcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCB0aGUgZ3JpZCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICBpZiAoc2hpZnQgfHwgbW9kZSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG9Db2x1bW4oY3MuYzIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxUb0N1cnNvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnQXJyb3dVcCdgIGtleSBwcmVzcyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBCYXNpY0tleUhhbmRsZXIucHJvdG90eXBlLm9uQXJyb3dVcCA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICAvLyBTdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIHZhciBtb2RlbCA9IGdyaWQuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIC8vIEZldGNoIHRoZSBtb2RpZmllciBmbGFncy5cbiAgICAgICAgdmFyIHNoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHZhciBhY2NlbCA9IFBsYXRmb3JtLmFjY2VsS2V5KGV2ZW50KTtcbiAgICAgICAgLy8gSGFuZGxlIG5vIG1vZGVsIHdpdGggdGhlIGFjY2VsIG1vZGlmaWVyLlxuICAgICAgICBpZiAoIW1vZGVsICYmIGFjY2VsKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbFRvKGdyaWQuc2Nyb2xsWCwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG5vIG1vZGVsIGFuZCBubyBtb2RpZmllci4gKGlnbm9yZSBzaGlmdClcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeVN0ZXAoJ3VwJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlLlxuICAgICAgICB2YXIgbW9kZSA9IG1vZGVsLnNlbGVjdGlvbk1vZGU7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY29sdW1uIHNlbGVjdGlvbiBtb2RlIHdpdGggYWNjZWwga2V5LlxuICAgICAgICBpZiAobW9kZSA9PT0gJ2NvbHVtbicgJiYgYWNjZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG8oZ3JpZC5zY3JvbGxYLCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGNvbHVtbiBzZWxlY3Rpb24gbW9kZSB3aXRoIG5vIG1vZGlmaWVyLiAoaWdub3JlIHNoaWZ0KVxuICAgICAgICBpZiAobW9kZSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnlTdGVwKCd1cCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBjdXJzb3IgYW5kIHNlbGVjdGlvbi5cbiAgICAgICAgdmFyIHIgPSBtb2RlbC5jdXJzb3JSb3c7XG4gICAgICAgIHZhciBjID0gbW9kZWwuY3Vyc29yQ29sdW1uO1xuICAgICAgICB2YXIgY3MgPSBtb2RlbC5jdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgc2VsZWN0aW9uIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIHIxO1xuICAgICAgICB2YXIgcjI7XG4gICAgICAgIHZhciBjMTtcbiAgICAgICAgdmFyIGMyO1xuICAgICAgICB2YXIgY3I7XG4gICAgICAgIHZhciBjYztcbiAgICAgICAgdmFyIGNsZWFyO1xuICAgICAgICAvLyBEaXNwYXRjaCBiYXNlZCBvbiB0aGUgbW9kaWZpZXIga2V5cy5cbiAgICAgICAgaWYgKGFjY2VsICYmIHNoaWZ0KSB7XG4gICAgICAgICAgICByMSA9IGNzID8gY3MucjEgOiAwO1xuICAgICAgICAgICAgcjIgPSAwO1xuICAgICAgICAgICAgYzEgPSBjcyA/IGNzLmMxIDogMDtcbiAgICAgICAgICAgIGMyID0gY3MgPyBjcy5jMiA6IDA7XG4gICAgICAgICAgICBjciA9IHI7XG4gICAgICAgICAgICBjYyA9IGM7XG4gICAgICAgICAgICBjbGVhciA9ICdjdXJyZW50JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGlmdCkge1xuICAgICAgICAgICAgcjEgPSBjcyA/IGNzLnIxIDogMDtcbiAgICAgICAgICAgIHIyID0gY3MgPyBjcy5yMiAtIDEgOiAwO1xuICAgICAgICAgICAgYzEgPSBjcyA/IGNzLmMxIDogMDtcbiAgICAgICAgICAgIGMyID0gY3MgPyBjcy5jMiA6IDA7XG4gICAgICAgICAgICBjciA9IHI7XG4gICAgICAgICAgICBjYyA9IGM7XG4gICAgICAgICAgICBjbGVhciA9ICdjdXJyZW50JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlbCkge1xuICAgICAgICAgICAgcjEgPSAwO1xuICAgICAgICAgICAgcjIgPSAwO1xuICAgICAgICAgICAgYzEgPSBjO1xuICAgICAgICAgICAgYzIgPSBjO1xuICAgICAgICAgICAgY3IgPSByMTtcbiAgICAgICAgICAgIGNjID0gYzE7XG4gICAgICAgICAgICBjbGVhciA9ICdhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcjEgPSByIC0gMTtcbiAgICAgICAgICAgIHIyID0gciAtIDE7XG4gICAgICAgICAgICBjMSA9IGM7XG4gICAgICAgICAgICBjMiA9IGM7XG4gICAgICAgICAgICBjciA9IHIxO1xuICAgICAgICAgICAgY2MgPSBjMTtcbiAgICAgICAgICAgIGNsZWFyID0gJ2FsbCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgc2VsZWN0aW9uLlxuICAgICAgICBtb2RlbC5zZWxlY3QoeyByMTogcjEsIGMxOiBjMSwgcjI6IHIyLCBjMjogYzIsIGN1cnNvclJvdzogY3IsIGN1cnNvckNvbHVtbjogY2MsIGNsZWFyOiBjbGVhciB9KTtcbiAgICAgICAgLy8gUmUtZmV0Y2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICBjcyA9IG1vZGVsLmN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAgICAgIGlmICghY3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTY3JvbGwgdGhlIGdyaWQgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgaWYgKHNoaWZ0IHx8IG1vZGUgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbFRvUm93KGNzLnIyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG9DdXJzb3IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ0Fycm93RG93bidgIGtleSBwcmVzcyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBCYXNpY0tleUhhbmRsZXIucHJvdG90eXBlLm9uQXJyb3dEb3duID0gZnVuY3Rpb24gKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgdmFyIG1vZGVsID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG1vZGlmaWVyIGZsYWdzLlxuICAgICAgICB2YXIgc2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgICAgdmFyIGFjY2VsID0gUGxhdGZvcm0uYWNjZWxLZXkoZXZlbnQpO1xuICAgICAgICAvLyBIYW5kbGUgbm8gbW9kZWwgd2l0aCB0aGUgYWNjZWwgbW9kaWZpZXIuXG4gICAgICAgIGlmICghbW9kZWwgJiYgYWNjZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG8oZ3JpZC5zY3JvbGxYLCBncmlkLm1heFNjcm9sbFkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBubyBtb2RlbCBhbmQgbm8gbW9kaWZpZXIuIChpZ25vcmUgc2hpZnQpXG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnlTdGVwKCdkb3duJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlLlxuICAgICAgICB2YXIgbW9kZSA9IG1vZGVsLnNlbGVjdGlvbk1vZGU7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY29sdW1uIHNlbGVjdGlvbiBtb2RlIHdpdGggYWNjZWwga2V5LlxuICAgICAgICBpZiAobW9kZSA9PT0gJ2NvbHVtbicgJiYgYWNjZWwpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG8oZ3JpZC5zY3JvbGxYLCBncmlkLm1heFNjcm9sbFkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY29sdW1uIHNlbGVjdGlvbiBtb2RlIHdpdGggbm8gbW9kaWZpZXIuIChpZ25vcmUgc2hpZnQpXG4gICAgICAgIGlmIChtb2RlID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeVN0ZXAoJ2Rvd24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgY3Vyc29yIGFuZCBzZWxlY3Rpb24uXG4gICAgICAgIHZhciByID0gbW9kZWwuY3Vyc29yUm93O1xuICAgICAgICB2YXIgYyA9IG1vZGVsLmN1cnNvckNvbHVtbjtcbiAgICAgICAgdmFyIGNzID0gbW9kZWwuY3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHNlbGVjdGlvbiB2YXJpYWJsZXMuXG4gICAgICAgIHZhciByMTtcbiAgICAgICAgdmFyIHIyO1xuICAgICAgICB2YXIgYzE7XG4gICAgICAgIHZhciBjMjtcbiAgICAgICAgdmFyIGNyO1xuICAgICAgICB2YXIgY2M7XG4gICAgICAgIHZhciBjbGVhcjtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYmFzZWQgb24gdGhlIG1vZGlmaWVyIGtleXMuXG4gICAgICAgIGlmIChhY2NlbCAmJiBzaGlmdCkge1xuICAgICAgICAgICAgcjEgPSBjcyA/IGNzLnIxIDogMDtcbiAgICAgICAgICAgIHIyID0gSW5maW5pdHk7XG4gICAgICAgICAgICBjMSA9IGNzID8gY3MuYzEgOiAwO1xuICAgICAgICAgICAgYzIgPSBjcyA/IGNzLmMyIDogMDtcbiAgICAgICAgICAgIGNyID0gcjtcbiAgICAgICAgICAgIGNjID0gYztcbiAgICAgICAgICAgIGNsZWFyID0gJ2N1cnJlbnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoaWZ0KSB7XG4gICAgICAgICAgICByMSA9IGNzID8gY3MucjEgOiAwO1xuICAgICAgICAgICAgcjIgPSBjcyA/IGNzLnIyICsgMSA6IDA7XG4gICAgICAgICAgICBjMSA9IGNzID8gY3MuYzEgOiAwO1xuICAgICAgICAgICAgYzIgPSBjcyA/IGNzLmMyIDogMDtcbiAgICAgICAgICAgIGNyID0gcjtcbiAgICAgICAgICAgIGNjID0gYztcbiAgICAgICAgICAgIGNsZWFyID0gJ2N1cnJlbnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VsKSB7XG4gICAgICAgICAgICByMSA9IEluZmluaXR5O1xuICAgICAgICAgICAgcjIgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGMxID0gYztcbiAgICAgICAgICAgIGMyID0gYztcbiAgICAgICAgICAgIGNyID0gcjE7XG4gICAgICAgICAgICBjYyA9IGMxO1xuICAgICAgICAgICAgY2xlYXIgPSAnYWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIxID0gciArIDE7XG4gICAgICAgICAgICByMiA9IHIgKyAxO1xuICAgICAgICAgICAgYzEgPSBjO1xuICAgICAgICAgICAgYzIgPSBjO1xuICAgICAgICAgICAgY3IgPSByMTtcbiAgICAgICAgICAgIGNjID0gYzE7XG4gICAgICAgICAgICBjbGVhciA9ICdhbGwnO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IHNlbGVjdGlvbi5cbiAgICAgICAgbW9kZWwuc2VsZWN0KHsgcjE6IHIxLCBjMTogYzEsIHIyOiByMiwgYzI6IGMyLCBjdXJzb3JSb3c6IGNyLCBjdXJzb3JDb2x1bW46IGNjLCBjbGVhcjogY2xlYXIgfSk7XG4gICAgICAgIC8vIFJlLWZldGNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgY3MgPSBtb2RlbC5jdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICBpZiAoIWNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Nyb2xsIHRoZSBncmlkIGFwcHJvcHJpYXRlbHkuXG4gICAgICAgIGlmIChzaGlmdCB8fCBtb2RlID09PSAncm93Jykge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxUb1Jvdyhjcy5yMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbFRvQ3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdQYWdlVXAnYCBrZXkgcHJlc3MgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZCAtIFRoZSBkYXRhIGdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUga2V5Ym9hcmQgZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgQmFzaWNLZXlIYW5kbGVyLnByb3RvdHlwZS5vblBhZ2VVcCA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoZSBhY2NlbCBrZXkgaXMgcHJlc3NlZC5cbiAgICAgICAgaWYgKFBsYXRmb3JtLmFjY2VsS2V5KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgdmFyIG1vZGVsID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgLy8gU2Nyb2xsIGJ5IHBhZ2UgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICBpZiAoIW1vZGVsIHx8IG1vZGVsLnNlbGVjdGlvbk1vZGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5UGFnZSgndXAnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbCBudW1iZXIgb2YgY2VsbHMgaW4gdGhlIHBhZ2UgaGVpZ2h0LlxuICAgICAgICB2YXIgbiA9IE1hdGguZmxvb3IoZ3JpZC5wYWdlSGVpZ2h0IC8gZ3JpZC5kZWZhdWx0U2l6ZXMucm93SGVpZ2h0KTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnNvciBhbmQgc2VsZWN0aW9uLlxuICAgICAgICB2YXIgciA9IG1vZGVsLmN1cnNvclJvdztcbiAgICAgICAgdmFyIGMgPSBtb2RlbC5jdXJzb3JDb2x1bW47XG4gICAgICAgIHZhciBjcyA9IG1vZGVsLmN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICB2YXIgcjE7XG4gICAgICAgIHZhciByMjtcbiAgICAgICAgdmFyIGMxO1xuICAgICAgICB2YXIgYzI7XG4gICAgICAgIHZhciBjcjtcbiAgICAgICAgdmFyIGNjO1xuICAgICAgICB2YXIgY2xlYXI7XG4gICAgICAgIC8vIFNlbGVjdCBvciByZXNpemUgYXMgbmVlZGVkLlxuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHIxID0gY3MgPyBjcy5yMSA6IDA7XG4gICAgICAgICAgICByMiA9IGNzID8gY3MucjIgLSBuIDogMDtcbiAgICAgICAgICAgIGMxID0gY3MgPyBjcy5jMSA6IDA7XG4gICAgICAgICAgICBjMiA9IGNzID8gY3MuYzIgOiAwO1xuICAgICAgICAgICAgY3IgPSByO1xuICAgICAgICAgICAgY2MgPSBjO1xuICAgICAgICAgICAgY2xlYXIgPSAnY3VycmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IGNzID8gY3MucjEgLSBuIDogMDtcbiAgICAgICAgICAgIHIyID0gcjE7XG4gICAgICAgICAgICBjMSA9IGM7XG4gICAgICAgICAgICBjMiA9IGM7XG4gICAgICAgICAgICBjciA9IHIxO1xuICAgICAgICAgICAgY2MgPSBjO1xuICAgICAgICAgICAgY2xlYXIgPSAnYWxsJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBzZWxlY3Rpb24uXG4gICAgICAgIG1vZGVsLnNlbGVjdCh7IHIxOiByMSwgYzE6IGMxLCByMjogcjIsIGMyOiBjMiwgY3Vyc29yUm93OiBjciwgY3Vyc29yQ29sdW1uOiBjYywgY2xlYXI6IGNsZWFyIH0pO1xuICAgICAgICAvLyBSZS1mZXRjaCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgIGNzID0gbW9kZWwuY3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi5cbiAgICAgICAgaWYgKCFjcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCB0aGUgZ3JpZCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICBncmlkLnNjcm9sbFRvUm93KGNzLnIyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdQYWdlRG93bidgIGtleSBwcmVzcyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBCYXNpY0tleUhhbmRsZXIucHJvdG90eXBlLm9uUGFnZURvd24gPSBmdW5jdGlvbiAoZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGUgYWNjZWwga2V5IGlzIHByZXNzZWQuXG4gICAgICAgIGlmIChQbGF0Zm9ybS5hY2NlbEtleShldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIHZhciBtb2RlbCA9IGdyaWQuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIC8vIFNjcm9sbCBieSBwYWdlIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgaWYgKCFtb2RlbCB8fCBtb2RlbC5zZWxlY3Rpb25Nb2RlID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeVBhZ2UoJ2Rvd24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbCBudW1iZXIgb2YgY2VsbHMgaW4gdGhlIHBhZ2UgaGVpZ2h0LlxuICAgICAgICB2YXIgbiA9IE1hdGguZmxvb3IoZ3JpZC5wYWdlSGVpZ2h0IC8gZ3JpZC5kZWZhdWx0U2l6ZXMucm93SGVpZ2h0KTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnNvciBhbmQgc2VsZWN0aW9uLlxuICAgICAgICB2YXIgciA9IG1vZGVsLmN1cnNvclJvdztcbiAgICAgICAgdmFyIGMgPSBtb2RlbC5jdXJzb3JDb2x1bW47XG4gICAgICAgIHZhciBjcyA9IG1vZGVsLmN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICB2YXIgcjE7XG4gICAgICAgIHZhciByMjtcbiAgICAgICAgdmFyIGMxO1xuICAgICAgICB2YXIgYzI7XG4gICAgICAgIHZhciBjcjtcbiAgICAgICAgdmFyIGNjO1xuICAgICAgICB2YXIgY2xlYXI7XG4gICAgICAgIC8vIFNlbGVjdCBvciByZXNpemUgYXMgbmVlZGVkLlxuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHIxID0gY3MgPyBjcy5yMSA6IDA7XG4gICAgICAgICAgICByMiA9IGNzID8gY3MucjIgKyBuIDogMDtcbiAgICAgICAgICAgIGMxID0gY3MgPyBjcy5jMSA6IDA7XG4gICAgICAgICAgICBjMiA9IGNzID8gY3MuYzIgOiAwO1xuICAgICAgICAgICAgY3IgPSByO1xuICAgICAgICAgICAgY2MgPSBjO1xuICAgICAgICAgICAgY2xlYXIgPSAnY3VycmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IGNzID8gY3MucjEgKyBuIDogMDtcbiAgICAgICAgICAgIHIyID0gcjE7XG4gICAgICAgICAgICBjMSA9IGM7XG4gICAgICAgICAgICBjMiA9IGM7XG4gICAgICAgICAgICBjciA9IHIxO1xuICAgICAgICAgICAgY2MgPSBjO1xuICAgICAgICAgICAgY2xlYXIgPSAnYWxsJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBzZWxlY3Rpb24uXG4gICAgICAgIG1vZGVsLnNlbGVjdCh7IHIxOiByMSwgYzE6IGMxLCByMjogcjIsIGMyOiBjMiwgY3Vyc29yUm93OiBjciwgY3Vyc29yQ29sdW1uOiBjYywgY2xlYXI6IGNsZWFyIH0pO1xuICAgICAgICAvLyBSZS1mZXRjaCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgIGNzID0gbW9kZWwuY3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbi5cbiAgICAgICAgaWYgKCFjcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCB0aGUgZ3JpZCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICBncmlkLnNjcm9sbFRvUm93KGNzLnIyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdFc2NhcGUnYCBrZXkgcHJlc3MgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZCAtIFRoZSBkYXRhIGdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUga2V5Ym9hcmQgZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgQmFzaWNLZXlIYW5kbGVyLnByb3RvdHlwZS5vbkVzY2FwZSA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZ3JpZC5zZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnRGVsZXRlJ2Aga2V5IHByZXNzIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIEJhc2ljS2V5SGFuZGxlci5wcm90b3R5cGUub25EZWxldGUgPSBmdW5jdGlvbiAoZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuZWRpdGFibGUgJiZcbiAgICAgICAgICAgICFncmlkLnNlbGVjdGlvbk1vZGVsLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHZhciBkYXRhTW9kZWwgPSBncmlkLmRhdGFNb2RlbDtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBtYXggcm93IGFuZCBjb2x1bW4uXG4gICAgICAgICAgICB2YXIgbWF4Um93ID0gZGF0YU1vZGVsLnJvd0NvdW50KCdib2R5JykgLSAxO1xuICAgICAgICAgICAgdmFyIG1heENvbHVtbiA9IGRhdGFNb2RlbC5jb2x1bW5Db3VudCgnYm9keScpIC0gMTtcbiAgICAgICAgICAgIHZhciBpdCA9IGdyaWQuc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdmFyIHMgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoKHMgPSBpdC5uZXh0KCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDbGFtcCB0aGUgY2VsbCB0byB0aGUgbW9kZWwgYm91bmRzLlxuICAgICAgICAgICAgICAgIHZhciBzcjEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzLnIxLCBtYXhSb3cpKTtcbiAgICAgICAgICAgICAgICB2YXIgc2MxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocy5jMSwgbWF4Q29sdW1uKSk7XG4gICAgICAgICAgICAgICAgdmFyIHNyMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKHMucjIsIG1heFJvdykpO1xuICAgICAgICAgICAgICAgIHZhciBzYzIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzLmMyLCBtYXhDb2x1bW4pKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gc3IxOyByIDw9IHNyMjsgKytyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSBzYzE7IGMgPD0gc2MyOyArK2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFNb2RlbC5zZXREYXRhKCdib2R5JywgciwgYywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdDJ2Aga2V5IHByZXNzIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIEJhc2ljS2V5SGFuZGxlci5wcm90b3R5cGUub25LZXlDID0gZnVuY3Rpb24gKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG1vZGlmaWVycyBhcmVuJ3QgY29ycmVjdCBmb3IgY29weS5cbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8ICFQbGF0Zm9ybS5hY2NlbEtleShldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIENvcHkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBjbGlwYm9hcmQuXG4gICAgICAgIGdyaWQuY29weVRvQ2xpcGJvYXJkKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzaWNLZXlIYW5kbGVyO1xufSgpKTtcblxuLyoqXG4gKiBBIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIGEgZGF0YSBncmlkIG1vdXNlIGhhbmRsZXIuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhpcyBjbGFzcyBtYXkgYmUgc3ViY2xhc3NlZCBhbmQgY3VzdG9taXplZCBhcyBuZWVkZWQuXG4gKi9cbnZhciBCYXNpY01vdXNlSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNpY01vdXNlSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIG1vdXNlIGhhbmRsZXIuXG4gICAgICovXG4gICAgQmFzaWNNb3VzZUhhbmRsZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGhhbmRsZXIgaXMgYWxyZWFkeSBkaXNwb3NlZC5cbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsZWFzZSBhbnkgaGVsZCByZXNvdXJjZXMuXG4gICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgICAgICAvLyBNYXJrIHRoZSBoYW5kbGVyIGFzIGRpc3Bvc2VkLlxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNNb3VzZUhhbmRsZXIucHJvdG90eXBlLCBcImlzRGlzcG9zZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbW91c2UgaGFuZGxlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBCYXNpY01vdXNlSGFuZGxlci5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgaXMgbm8gcHJlc3MgZGF0YS5cbiAgICAgICAgaWYgKCF0aGlzLl9wcmVzc0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0aGUgYXV0b3NlbGVjdCB0aW1lb3V0LlxuICAgICAgICBpZiAodGhpcy5fcHJlc3NEYXRhLnR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVzc0RhdGEudGltZW91dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSBwcmVzcyBkYXRhLlxuICAgICAgICB0aGlzLl9wcmVzc0RhdGEub3ZlcnJpZGUuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9wcmVzc0RhdGEgPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBtb3VzZSBob3ZlciBldmVudCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBob3ZlciBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBCYXNpY01vdXNlSGFuZGxlci5wcm90b3R5cGUub25Nb3VzZUhvdmVyID0gZnVuY3Rpb24gKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIEhpdCB0ZXN0IHRoZSBncmlkLlxuICAgICAgICB2YXIgaGl0ID0gZ3JpZC5oaXRUZXN0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICAvLyBHZXQgdGhlIHJlc2l6ZSBoYW5kbGUgZm9yIHRoZSBoaXQgdGVzdC5cbiAgICAgICAgdmFyIGhhbmRsZSA9IFByaXZhdGUucmVzaXplSGFuZGxlRm9ySGl0VGVzdChoaXQpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgY3Vyc29yIGZvciB0aGUgaGFuZGxlLlxuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5jdXJzb3JGb3JIYW5kbGUoaGFuZGxlKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2aWV3cG9ydCBjdXJzb3IgYmFzZWQgb24gdGhlIHBhcnQuXG4gICAgICAgIGdyaWQudmlld3BvcnQubm9kZS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIC8vIFRPRE8gc3VwcG9ydCB1c2VyLWRlZmluZWQgaG92ZXIgaXRlbXNcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgbW91c2UgbGVhdmUgZXZlbnQgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZCAtIFRoZSBkYXRhIGdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbW91c2UgaG92ZXIgZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgQmFzaWNNb3VzZUhhbmRsZXIucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgdXNlci1kZWZpbmVkIGhvdmVyIHBvcHVwcy5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHZpZXdwb3J0IGN1cnNvci5cbiAgICAgICAgZ3JpZC52aWV3cG9ydC5ub2RlLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBtb3VzZSBkb3duIGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIGRvd24gZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgQmFzaWNNb3VzZUhhbmRsZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8vIFVucGFjayB0aGUgZXZlbnQuXG4gICAgICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCwgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIC8vIEhpdCB0ZXN0IHRoZSBncmlkLlxuICAgICAgICB2YXIgaGl0ID0gZ3JpZC5oaXRUZXN0KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICAvLyBVbnBhY2sgdGhlIGhpdCB0ZXN0LlxuICAgICAgICB2YXIgcmVnaW9uID0gaGl0LnJlZ2lvbiwgcm93ID0gaGl0LnJvdywgY29sdW1uID0gaGl0LmNvbHVtbjtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgaGl0IHRlc3QgaXMgb24gYW4gdW5pbnRlcmVzdGluZyByZWdpb24uXG4gICAgICAgIGlmIChyZWdpb24gPT09ICd2b2lkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBtb2RpZmllciBmbGFncy5cbiAgICAgICAgdmFyIHNoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHZhciBhY2NlbCA9IFBsYXRmb3JtLmFjY2VsS2V5KGV2ZW50KTtcbiAgICAgICAgLy8gSWYgdGhlIGhpdCB0ZXN0IGlzIHRoZSBib2R5IHJlZ2lvbiwgdGhlIG9ubHkgb3B0aW9uIGlzIHNlbGVjdC5cbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICAgICAgdmFyIG1vZGVsXzEgPSBncmlkLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgICAgICBpZiAoIW1vZGVsXzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgZG9jdW1lbnQgY3Vyc29yLlxuICAgICAgICAgICAgdmFyIG92ZXJyaWRlXzEgPSBEcmFnLm92ZXJyaWRlQ3Vyc29yKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIHByZXNzIGRhdGEuXG4gICAgICAgICAgICB0aGlzLl9wcmVzc0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NlbGVjdCcsIHJlZ2lvbjogcmVnaW9uLCByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4sIG92ZXJyaWRlOiBvdmVycmlkZV8xLFxuICAgICAgICAgICAgICAgIGxvY2FsWDogLTEsIGxvY2FsWTogLTEsIHRpbWVvdXQ6IC0xXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICAgICAgdmFyIHIxXzE7XG4gICAgICAgICAgICB2YXIgYzFfMTtcbiAgICAgICAgICAgIHZhciByMl8xO1xuICAgICAgICAgICAgdmFyIGMyXzE7XG4gICAgICAgICAgICB2YXIgY3Vyc29yUm93XzE7XG4gICAgICAgICAgICB2YXIgY3Vyc29yQ29sdW1uXzE7XG4gICAgICAgICAgICB2YXIgY2xlYXJfMTtcbiAgICAgICAgICAgIC8vIEFjY2VsID09IG5ldyBzZWxlY3Rpb24sIGtlZXAgb2xkIHNlbGVjdGlvbnMuXG4gICAgICAgICAgICBpZiAoYWNjZWwpIHtcbiAgICAgICAgICAgICAgICByMV8xID0gcm93O1xuICAgICAgICAgICAgICAgIHIyXzEgPSByb3c7XG4gICAgICAgICAgICAgICAgYzFfMSA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBjMl8xID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIGN1cnNvclJvd18xID0gcm93O1xuICAgICAgICAgICAgICAgIGN1cnNvckNvbHVtbl8xID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIGNsZWFyXzEgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaGlmdCkge1xuICAgICAgICAgICAgICAgIHIxXzEgPSBtb2RlbF8xLmN1cnNvclJvdztcbiAgICAgICAgICAgICAgICByMl8xID0gcm93O1xuICAgICAgICAgICAgICAgIGMxXzEgPSBtb2RlbF8xLmN1cnNvckNvbHVtbjtcbiAgICAgICAgICAgICAgICBjMl8xID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIGN1cnNvclJvd18xID0gbW9kZWxfMS5jdXJzb3JSb3c7XG4gICAgICAgICAgICAgICAgY3Vyc29yQ29sdW1uXzEgPSBtb2RlbF8xLmN1cnNvckNvbHVtbjtcbiAgICAgICAgICAgICAgICBjbGVhcl8xID0gJ2N1cnJlbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcjFfMSA9IHJvdztcbiAgICAgICAgICAgICAgICByMl8xID0gcm93O1xuICAgICAgICAgICAgICAgIGMxXzEgPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgYzJfMSA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBjdXJzb3JSb3dfMSA9IHJvdztcbiAgICAgICAgICAgICAgICBjdXJzb3JDb2x1bW5fMSA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBjbGVhcl8xID0gJ2FsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2Ugc2VsZWN0aW9uIG1vZGUgJ2NlbGwnXG4gICAgICAgICAgICBtb2RlbF8xLnNlbGVjdGlvbk1vZGUgPSAnY2VsbCc7XG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICBtb2RlbF8xLnNlbGVjdCh7IHIxOiByMV8xLCBjMTogYzFfMSwgcjI6IHIyXzEsIGMyOiBjMl8xLCBjdXJzb3JSb3c6IGN1cnNvclJvd18xLCBjdXJzb3JDb2x1bW46IGN1cnNvckNvbHVtbl8xLCBjbGVhcjogY2xlYXJfMSB9KTtcbiAgICAgICAgICAgIC8vIERvbmUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgaGl0IHRlc3QgaXMgb24gYSBoZWFkZXIgcmVnaW9uLlxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBoaXQgdGVzdCBpbnRvIGEgcGFydC5cbiAgICAgICAgdmFyIGhhbmRsZSA9IFByaXZhdGUucmVzaXplSGFuZGxlRm9ySGl0VGVzdChoaXQpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgY3Vyc29yIGZvciB0aGUgaGFuZGxlLlxuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5jdXJzb3JGb3JIYW5kbGUoaGFuZGxlKTtcbiAgICAgICAgLy8gSGFuZGxlIGhvcml6b250YWwgcmVzaXplLlxuICAgICAgICBpZiAoaGFuZGxlID09PSAnbGVmdCcgfHwgaGFuZGxlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIHJlc2l6ZSBkYXRhIHR5cGUuXG4gICAgICAgICAgICB2YXIgdHlwZSA9ICdjb2x1bW4tcmVzaXplJztcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29sdW1uIHJlZ2lvbi5cbiAgICAgICAgICAgIHZhciByZ24gPSAocmVnaW9uID09PSAnY29sdW1uLWhlYWRlcicgPyAnYm9keScgOiAncm93LWhlYWRlcicpO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzZWN0aW9uIGluZGV4LlxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlID09PSAnbGVmdCcgPyBjb2x1bW4gLSAxIDogY29sdW1uO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHNlY3Rpb24gc2l6ZS5cbiAgICAgICAgICAgIHZhciBzaXplID0gZ3JpZC5jb2x1bW5TaXplKHJnbiwgaW5kZXgpO1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGRvY3VtZW50IGN1cnNvci5cbiAgICAgICAgICAgIHZhciBvdmVycmlkZV8yID0gRHJhZy5vdmVycmlkZUN1cnNvcihjdXJzb3IpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZW1wb3JhcnkgcHJlc3MgZGF0YS5cbiAgICAgICAgICAgIHRoaXMuX3ByZXNzRGF0YSA9IHsgdHlwZTogdHlwZSwgcmVnaW9uOiByZ24sIGluZGV4OiBpbmRleCwgc2l6ZTogc2l6ZSwgY2xpZW50WDogY2xpZW50WCwgb3ZlcnJpZGU6IG92ZXJyaWRlXzIgfTtcbiAgICAgICAgICAgIC8vIERvbmUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHZlcnRpY2FsIHJlc2l6ZVxuICAgICAgICBpZiAoaGFuZGxlID09PSAndG9wJyB8fCBoYW5kbGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIHJlc2l6ZSBkYXRhIHR5cGUuXG4gICAgICAgICAgICB2YXIgdHlwZSA9ICdyb3ctcmVzaXplJztcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgcm93IHJlZ2lvbi5cbiAgICAgICAgICAgIHZhciByZ24gPSAocmVnaW9uID09PSAncm93LWhlYWRlcicgPyAnYm9keScgOiAnY29sdW1uLWhlYWRlcicpO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzZWN0aW9uIGluZGV4LlxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlID09PSAndG9wJyA/IHJvdyAtIDEgOiByb3c7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgc2VjdGlvbiBzaXplLlxuICAgICAgICAgICAgdmFyIHNpemUgPSBncmlkLnJvd1NpemUocmduLCBpbmRleCk7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgZG9jdW1lbnQgY3Vyc29yLlxuICAgICAgICAgICAgdmFyIG92ZXJyaWRlXzMgPSBEcmFnLm92ZXJyaWRlQ3Vyc29yKGN1cnNvcik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRlbXBvcmFyeSBwcmVzcyBkYXRhLlxuICAgICAgICAgICAgdGhpcy5fcHJlc3NEYXRhID0geyB0eXBlOiB0eXBlLCByZWdpb246IHJnbiwgaW5kZXg6IGluZGV4LCBzaXplOiBzaXplLCBjbGllbnRZOiBjbGllbnRZLCBvdmVycmlkZTogb3ZlcnJpZGVfMyB9O1xuICAgICAgICAgICAgLy8gRG9uZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBvbmx5IG9wdGlvbiBpcyBzZWxlY3QuXG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIHZhciBtb2RlbCA9IGdyaWQuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGRvY3VtZW50IGN1cnNvci5cbiAgICAgICAgdmFyIG92ZXJyaWRlID0gRHJhZy5vdmVycmlkZUN1cnNvcignZGVmYXVsdCcpO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHByZXNzIGRhdGEuXG4gICAgICAgIHRoaXMuX3ByZXNzRGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QnLCByZWdpb246IHJlZ2lvbiwgcm93OiByb3csIGNvbHVtbjogY29sdW1uLCBvdmVycmlkZTogb3ZlcnJpZGUsXG4gICAgICAgICAgICBsb2NhbFg6IC0xLCBsb2NhbFk6IC0xLCB0aW1lb3V0OiAtMVxuICAgICAgICB9O1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHNlbGVjdGlvbiB2YXJpYWJsZXMuXG4gICAgICAgIHZhciByMTtcbiAgICAgICAgdmFyIGMxO1xuICAgICAgICB2YXIgcjI7XG4gICAgICAgIHZhciBjMjtcbiAgICAgICAgdmFyIGN1cnNvclJvdztcbiAgICAgICAgdmFyIGN1cnNvckNvbHVtbjtcbiAgICAgICAgdmFyIGNsZWFyO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBzZWxlY3Rpb24gYmFzZWQgb24gdGhlIHByZXNzZWQgcmVnaW9uLlxuICAgICAgICBpZiAocmVnaW9uID09PSAnY29ybmVyLWhlYWRlcicpIHtcbiAgICAgICAgICAgIHIxID0gMDtcbiAgICAgICAgICAgIHIyID0gSW5maW5pdHk7XG4gICAgICAgICAgICBjMSA9IDA7XG4gICAgICAgICAgICBjMiA9IEluZmluaXR5O1xuICAgICAgICAgICAgY3Vyc29yUm93ID0gYWNjZWwgPyAwIDogc2hpZnQgPyBtb2RlbC5jdXJzb3JSb3cgOiAwO1xuICAgICAgICAgICAgY3Vyc29yQ29sdW1uID0gYWNjZWwgPyAwIDogc2hpZnQgPyBtb2RlbC5jdXJzb3JDb2x1bW4gOiAwO1xuICAgICAgICAgICAgY2xlYXIgPSBhY2NlbCA/ICdub25lJyA6IHNoaWZ0ID8gJ2N1cnJlbnQnIDogJ2FsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVnaW9uID09PSAncm93LWhlYWRlcicpIHtcbiAgICAgICAgICAgIHIxID0gYWNjZWwgPyByb3cgOiBzaGlmdCA/IG1vZGVsLmN1cnNvclJvdyA6IHJvdztcbiAgICAgICAgICAgIHIyID0gcm93O1xuICAgICAgICAgICAgYzEgPSAwO1xuICAgICAgICAgICAgYzIgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGN1cnNvclJvdyA9IGFjY2VsID8gcm93IDogc2hpZnQgPyBtb2RlbC5jdXJzb3JSb3cgOiByb3c7XG4gICAgICAgICAgICBjdXJzb3JDb2x1bW4gPSBhY2NlbCA/IDAgOiBzaGlmdCA/IG1vZGVsLmN1cnNvckNvbHVtbiA6IDA7XG4gICAgICAgICAgICBjbGVhciA9IGFjY2VsID8gJ25vbmUnIDogc2hpZnQgPyAnY3VycmVudCcgOiAnYWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWdpb24gPT09ICdjb2x1bW4taGVhZGVyJykge1xuICAgICAgICAgICAgcjEgPSAwO1xuICAgICAgICAgICAgcjIgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGMxID0gYWNjZWwgPyBjb2x1bW4gOiBzaGlmdCA/IG1vZGVsLmN1cnNvckNvbHVtbiA6IGNvbHVtbjtcbiAgICAgICAgICAgIGMyID0gY29sdW1uO1xuICAgICAgICAgICAgY3Vyc29yUm93ID0gYWNjZWwgPyAwIDogc2hpZnQgPyBtb2RlbC5jdXJzb3JSb3cgOiAwO1xuICAgICAgICAgICAgY3Vyc29yQ29sdW1uID0gYWNjZWwgPyBjb2x1bW4gOiBzaGlmdCA/IG1vZGVsLmN1cnNvckNvbHVtbiA6IGNvbHVtbjtcbiAgICAgICAgICAgIGNsZWFyID0gYWNjZWwgPyAnbm9uZScgOiBzaGlmdCA/ICdjdXJyZW50JyA6ICdhbGwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcjEgPSBhY2NlbCA/IHJvdyA6IHNoaWZ0ID8gbW9kZWwuY3Vyc29yUm93IDogcm93O1xuICAgICAgICAgICAgcjIgPSByb3c7XG4gICAgICAgICAgICBjMSA9IGFjY2VsID8gY29sdW1uIDogc2hpZnQgPyBtb2RlbC5jdXJzb3JDb2x1bW4gOiBjb2x1bW47XG4gICAgICAgICAgICBjMiA9IGNvbHVtbjtcbiAgICAgICAgICAgIGN1cnNvclJvdyA9IGFjY2VsID8gcm93IDogc2hpZnQgPyBtb2RlbC5jdXJzb3JSb3cgOiByb3c7XG4gICAgICAgICAgICBjdXJzb3JDb2x1bW4gPSBhY2NlbCA/IGNvbHVtbiA6IHNoaWZ0ID8gbW9kZWwuY3Vyc29yQ29sdW1uIDogY29sdW1uO1xuICAgICAgICAgICAgY2xlYXIgPSBhY2NlbCA/ICdub25lJyA6IHNoaWZ0ID8gJ2N1cnJlbnQnIDogJ2FsbCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHNlbGVjdGlvbiBtb2RlIGJhc2VkIG9uIHJlZ2lvblxuICAgICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICAgICAgY2FzZSAnY29sdW1uLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0aW9uTW9kZSA9ICdjb2x1bW4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm93LWhlYWRlcic6XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0aW9uTW9kZSA9ICdyb3cnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3Rpb25Nb2RlID0gJ2NlbGwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgbW9kZWwuc2VsZWN0KHsgcjE6IHIxLCBjMTogYzEsIHIyOiByMiwgYzI6IGMyLCBjdXJzb3JSb3c6IGN1cnNvclJvdywgY3Vyc29yQ29sdW1uOiBjdXJzb3JDb2x1bW4sIGNsZWFyOiBjbGVhciB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgbW91c2UgbW92ZSBldmVudCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBtb3ZlIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIEJhc2ljTW91c2VIYW5kbGVyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICAvLyBGZXRjaCB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9wcmVzc0RhdGE7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gcHJlc3MgZGF0YS5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGEgcm93IHJlc2l6ZS5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3Jvdy1yZXNpemUnKSB7XG4gICAgICAgICAgICB2YXIgZHkgPSBldmVudC5jbGllbnRZIC0gZGF0YS5jbGllbnRZO1xuICAgICAgICAgICAgZ3JpZC5yZXNpemVSb3coZGF0YS5yZWdpb24sIGRhdGEuaW5kZXgsIGRhdGEuc2l6ZSArIGR5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYSBjb2x1bW4gcmVzaXplLlxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnY29sdW1uLXJlc2l6ZScpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSBkYXRhLmNsaWVudFg7XG4gICAgICAgICAgICBncmlkLnJlc2l6ZUNvbHVtbihkYXRhLnJlZ2lvbiwgZGF0YS5pbmRleCwgZGF0YS5zaXplICsgZHgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBhIHNlbGVjdC5cbiAgICAgICAgLy8gTW91c2UgbW92ZXMgZHVyaW5nIGEgY29ybmVyIGhlYWRlciBwcmVzcyBhcmUgYSBuby1vcC5cbiAgICAgICAgaWYgKGRhdGEucmVnaW9uID09PSAnY29ybmVyLWhlYWRlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICB2YXIgbW9kZWwgPSBncmlkLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBzZWxlY3Rpb24gbW9kZWwgd2FzIHJlbW92ZWQuXG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXAgdG8gbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgICAgIHZhciBfYSA9IGdyaWQubWFwVG9Mb2NhbChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSwgbHggPSBfYS5seCwgbHkgPSBfYS5seTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCBtb3VzZSBjb29yZGluYXRlcyBpbiB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgZGF0YS5sb2NhbFggPSBseDtcbiAgICAgICAgZGF0YS5sb2NhbFkgPSBseTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGdyaWQgZ2VvbWV0cnkuXG4gICAgICAgIHZhciBodyA9IGdyaWQuaGVhZGVyV2lkdGg7XG4gICAgICAgIHZhciBoaCA9IGdyaWQuaGVhZGVySGVpZ2h0O1xuICAgICAgICB2YXIgdnB3ID0gZ3JpZC52aWV3cG9ydFdpZHRoO1xuICAgICAgICB2YXIgdnBoID0gZ3JpZC52aWV3cG9ydEhlaWdodDtcbiAgICAgICAgdmFyIHN4ID0gZ3JpZC5zY3JvbGxYO1xuICAgICAgICB2YXIgc3kgPSBncmlkLnNjcm9sbFk7XG4gICAgICAgIHZhciBtc3ggPSBncmlkLm1heFNjcm9sbFk7XG4gICAgICAgIHZhciBtc3kgPSBncmlkLm1heFNjcm9sbFk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZS5cbiAgICAgICAgdmFyIG1vZGUgPSBtb2RlbC5zZWxlY3Rpb25Nb2RlO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHRpbWVvdXQgdmFyaWFibGUuXG4gICAgICAgIHZhciB0aW1lb3V0ID0gLTE7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHRpbWVtb3V0IGJhc2VkIG9uIGhpdCByZWdpb24gYW5kIG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICBpZiAoZGF0YS5yZWdpb24gPT09ICdyb3ctaGVhZGVyJyB8fCBtb2RlID09PSAncm93Jykge1xuICAgICAgICAgICAgaWYgKGx5IDwgaGggJiYgc3kgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IFByaXZhdGUuY29tcHV0ZVRpbWVvdXQoaGggLSBseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChseSA+PSB2cGggJiYgc3kgPCBtc3kpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gUHJpdmF0ZS5jb21wdXRlVGltZW91dChseSAtIHZwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5yZWdpb24gPT09ICdjb2x1bW4taGVhZGVyJyB8fCBtb2RlID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgaWYgKGx4IDwgaHcgJiYgc3ggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IFByaXZhdGUuY29tcHV0ZVRpbWVvdXQoaHcgLSBseCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChseCA+PSB2cHcgJiYgc3ggPCBtc3gpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gUHJpdmF0ZS5jb21wdXRlVGltZW91dChseCAtIHZwdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobHggPCBodyAmJiBzeCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gUHJpdmF0ZS5jb21wdXRlVGltZW91dChodyAtIGx4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGx4ID49IHZwdyAmJiBzeCA8IG1zeCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBQcml2YXRlLmNvbXB1dGVUaW1lb3V0KGx4IC0gdnB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGx5IDwgaGggJiYgc3kgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IFByaXZhdGUuY29tcHV0ZVRpbWVvdXQoaGggLSBseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChseSA+PSB2cGggJiYgc3kgPCBtc3kpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gUHJpdmF0ZS5jb21wdXRlVGltZW91dChseSAtIHZwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIG9yIGluaXRpYXRlIHRoZSBhdXRvc2VsZWN0IGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKHRpbWVvdXQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGRhdGEudGltZW91dCA8IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBQcml2YXRlLmF1dG9zZWxlY3QoZ3JpZCwgZGF0YSk7IH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGNsZWFyIHRoZSBhdXRvc2VsZWN0IHRpbWVvdXQuXG4gICAgICAgIGRhdGEudGltZW91dCA9IC0xO1xuICAgICAgICAvLyBNYXAgdGhlIHBvc2l0aW9uIHRvIHZpcnR1YWwgY29vcmRpbmF0ZXMuXG4gICAgICAgIHZhciBfYiA9IGdyaWQubWFwVG9WaXJ0dWFsKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpLCB2eCA9IF9iLnZ4LCB2eSA9IF9iLnZ5O1xuICAgICAgICAvLyBDbGFtcCB0aGUgY29vcmRpbmF0ZXMgdG8gdGhlIGxpbWl0cy5cbiAgICAgICAgdnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2eCwgZ3JpZC5ib2R5V2lkdGggLSAxKSk7XG4gICAgICAgIHZ5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odnksIGdyaWQuYm9keUhlaWdodCAtIDEpKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICB2YXIgcjE7XG4gICAgICAgIHZhciBjMTtcbiAgICAgICAgdmFyIHIyO1xuICAgICAgICB2YXIgYzI7XG4gICAgICAgIHZhciBjdXJzb3JSb3cgPSBtb2RlbC5jdXJzb3JSb3c7XG4gICAgICAgIHZhciBjdXJzb3JDb2x1bW4gPSBtb2RlbC5jdXJzb3JDb2x1bW47XG4gICAgICAgIHZhciBjbGVhciA9ICdjdXJyZW50JztcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgc2VsZWN0aW9uIGJhc2VkIHByZXNzZWQgcmVnaW9uLlxuICAgICAgICBpZiAoZGF0YS5yZWdpb24gPT09ICdyb3ctaGVhZGVyJyB8fCBtb2RlID09PSAncm93Jykge1xuICAgICAgICAgICAgcjEgPSBkYXRhLnJvdztcbiAgICAgICAgICAgIHIyID0gZ3JpZC5yb3dBdCgnYm9keScsIHZ5KTtcbiAgICAgICAgICAgIGMxID0gMDtcbiAgICAgICAgICAgIGMyID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5yZWdpb24gPT09ICdjb2x1bW4taGVhZGVyJyB8fCBtb2RlID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgcjEgPSAwO1xuICAgICAgICAgICAgcjIgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGMxID0gZGF0YS5jb2x1bW47XG4gICAgICAgICAgICBjMiA9IGdyaWQuY29sdW1uQXQoJ2JvZHknLCB2eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IGN1cnNvclJvdztcbiAgICAgICAgICAgIHIyID0gZ3JpZC5yb3dBdCgnYm9keScsIHZ5KTtcbiAgICAgICAgICAgIGMxID0gY3Vyc29yQ29sdW1uO1xuICAgICAgICAgICAgYzIgPSBncmlkLmNvbHVtbkF0KCdib2R5JywgdngpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgbW9kZWwuc2VsZWN0KHsgcjE6IHIxLCBjMTogYzEsIHIyOiByMiwgYzI6IGMyLCBjdXJzb3JSb3c6IGN1cnNvclJvdywgY3Vyc29yQ29sdW1uOiBjdXJzb3JDb2x1bW4sIGNsZWFyOiBjbGVhciB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgbW91c2UgdXAgZXZlbnQgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZCAtIFRoZSBkYXRhIGdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbW91c2UgdXAgZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgQmFzaWNNb3VzZUhhbmRsZXIucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLnJlbGVhc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgbW91c2UgZG91YmxlIGNsaWNrIGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIHVwIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIEJhc2ljTW91c2VIYW5kbGVyLnByb3RvdHlwZS5vbk1vdXNlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKCFncmlkLmRhdGFNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5wYWNrIHRoZSBldmVudC5cbiAgICAgICAgdmFyIGNsaWVudFggPSBldmVudC5jbGllbnRYLCBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgLy8gSGl0IHRlc3QgdGhlIGdyaWQuXG4gICAgICAgIHZhciBoaXQgPSBncmlkLmhpdFRlc3QoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIC8vIFVucGFjayB0aGUgaGl0IHRlc3QuXG4gICAgICAgIHZhciByZWdpb24gPSBoaXQucmVnaW9uLCByb3cgPSBoaXQucm93LCBjb2x1bW4gPSBoaXQuY29sdW1uO1xuICAgICAgICBpZiAocmVnaW9uID09PSAndm9pZCcpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgaWYgKGdyaWQuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBncmlkLmVkaXRvckNvbnRyb2xsZXIuZWRpdChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbGVhc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgY29udGV4dCBtZW51IGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YSBncmlkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGNvbnRleHQgbWVudSBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBCYXNpY01vdXNlSGFuZGxlci5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChncmlkLCBldmVudCkge1xuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgdXNlci1kZWZpbmVkIGNvbnRleHQgbWVudXNcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgd2hlZWwgZXZlbnQgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZCAtIFRoZSBkYXRhIGdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgd2hlZWwgZXZlbnQgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgQmFzaWNNb3VzZUhhbmRsZXIucHJvdG90eXBlLm9uV2hlZWwgPSBmdW5jdGlvbiAoZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy8gQmFpbCBpZiBhIG1vdXNlIHByZXNzIGlzIGluIHByb2dyZXNzLlxuICAgICAgICBpZiAodGhpcy5fcHJlc3NEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZGVsdGEgWCBhbmQgWSBtb3ZlbWVudC5cbiAgICAgICAgdmFyIGR4ID0gZXZlbnQuZGVsdGFYO1xuICAgICAgICB2YXIgZHkgPSBldmVudC5kZWx0YVk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGRlbHRhIHZhbHVlcyB0byBwaXhlbCB2YWx1ZXMuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IC8vIERPTV9ERUxUQV9QSVhFTFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBET01fREVMVEFfTElORVxuICAgICAgICAgICAgICAgIHZhciBkcyA9IGdyaWQuZGVmYXVsdFNpemVzO1xuICAgICAgICAgICAgICAgIGR4ICo9IGRzLmNvbHVtbldpZHRoO1xuICAgICAgICAgICAgICAgIGR5ICo9IGRzLnJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjogLy8gRE9NX0RFTFRBX1BBR0VcbiAgICAgICAgICAgICAgICBkeCAqPSBncmlkLnBhZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBkeSAqPSBncmlkLnBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Nyb2xsIGJ5IHRoZSBkZXNpcmVkIGFtb3VudC5cbiAgICAgICAgZ3JpZC5zY3JvbGxCeShkeCwgZHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJlc2l6ZSBoYW5kbGUgaW50byBhIGN1cnNvci5cbiAgICAgKi9cbiAgICBCYXNpY01vdXNlSGFuZGxlci5wcm90b3R5cGUuY3Vyc29yRm9ySGFuZGxlID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5jdXJzb3JNYXBbaGFuZGxlXTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY01vdXNlSGFuZGxlci5wcm90b3R5cGUsIFwicHJlc3NEYXRhXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBwcmVzc0RhdGFcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXNzRGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEJhc2ljTW91c2VIYW5kbGVyO1xufSgpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZTtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVzaXplIGhhbmRsZSBmb3IgYSBncmlkIGhpdCB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZUZvckhpdFRlc3QoaGl0KSB7XG4gICAgICAgIC8vIEZldGNoIHRoZSByb3cgYW5kIGNvbHVtbi5cbiAgICAgICAgdmFyIHIgPSBoaXQucm93O1xuICAgICAgICB2YXIgYyA9IGhpdC5jb2x1bW47XG4gICAgICAgIC8vIEZldGNoIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzaXplcy5cbiAgICAgICAgdmFyIGx3ID0gaGl0Lng7XG4gICAgICAgIHZhciBsaCA9IGhpdC55O1xuICAgICAgICB2YXIgdHcgPSBoaXQud2lkdGggLSBoaXQueDtcbiAgICAgICAgdmFyIHRoID0gaGl0LmhlaWdodCAtIGhpdC55O1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHJlc3VsdCB2YXJpYWJsZS5cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYmFzZWQgb24gaGl0IHRlc3QgcmVnaW9uLlxuICAgICAgICBzd2l0Y2ggKGhpdC5yZWdpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvcm5lci1oZWFkZXInOlxuICAgICAgICAgICAgICAgIGlmIChjID4gMCAmJiBsdyA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHcgPD0gNikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyID4gMCAmJiBsaCA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aCA8PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbHVtbi1oZWFkZXInOlxuICAgICAgICAgICAgICAgIGlmIChjID4gMCAmJiBsdyA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHcgPD0gNikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyID4gMCAmJiBsaCA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aCA8PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jvdy1oZWFkZXInOlxuICAgICAgICAgICAgICAgIGlmIChjID4gMCAmJiBsdyA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHcgPD0gNikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyID4gMCAmJiBsaCA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aCA8PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZvaWQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUHJpdmF0ZS5yZXNpemVIYW5kbGVGb3JIaXRUZXN0ID0gcmVzaXplSGFuZGxlRm9ySGl0VGVzdDtcbiAgICAvKipcbiAgICAgKiBBIHRpbWVyIGNhbGxiYWNrIGZvciB0aGUgYXV0b3NlbGVjdCBsb29wLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSBUaGUgZGF0YWdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBzZWxlY3QgZGF0YSBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvc2VsZWN0KGdyaWQsIGRhdGEpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgdGltZW91dCBoYXMgYmVlbiByZXNldC5cbiAgICAgICAgaWYgKGRhdGEudGltZW91dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICB2YXIgbW9kZWwgPSBncmlkLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBzZWxlY3Rpb24gbW9kZWwgaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgdmFyIGNzID0gbW9kZWwuY3VycmVudFNlbGVjdGlvbigpO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICBpZiAoIWNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggbG9jYWwgWCBhbmQgWSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UuXG4gICAgICAgIHZhciBseCA9IGRhdGEubG9jYWxYO1xuICAgICAgICB2YXIgbHkgPSBkYXRhLmxvY2FsWTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWxlY3Rpb24gdmFyaWFibGVzLlxuICAgICAgICB2YXIgcjEgPSBjcy5yMTtcbiAgICAgICAgdmFyIGMxID0gY3MuYzE7XG4gICAgICAgIHZhciByMiA9IGNzLnIyO1xuICAgICAgICB2YXIgYzIgPSBjcy5jMjtcbiAgICAgICAgdmFyIGN1cnNvclJvdyA9IG1vZGVsLmN1cnNvclJvdztcbiAgICAgICAgdmFyIGN1cnNvckNvbHVtbiA9IG1vZGVsLmN1cnNvckNvbHVtbjtcbiAgICAgICAgdmFyIGNsZWFyID0gJ2N1cnJlbnQnO1xuICAgICAgICAvLyBGZXRjaCB0aGUgZ3JpZCBnZW9tZXRyeS5cbiAgICAgICAgdmFyIGh3ID0gZ3JpZC5oZWFkZXJXaWR0aDtcbiAgICAgICAgdmFyIGhoID0gZ3JpZC5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIHZhciB2cHcgPSBncmlkLnZpZXdwb3J0V2lkdGg7XG4gICAgICAgIHZhciB2cGggPSBncmlkLnZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgIHZhciBtb2RlID0gbW9kZWwuc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gYmFzZWQgb24gdGhlIGhpdCByZWdpb24uXG4gICAgICAgIGlmIChkYXRhLnJlZ2lvbiA9PT0gJ3Jvdy1oZWFkZXInIHx8IG1vZGUgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICByMiArPSBseSA8PSBoaCA/IC0xIDogbHkgPj0gdnBoID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5yZWdpb24gPT09ICdjb2x1bW4taGVhZGVyJyB8fCBtb2RlID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgYzIgKz0gbHggPD0gaHcgPyAtMSA6IGx4ID49IHZwdyA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcjIgKz0gbHkgPD0gaGggPyAtMSA6IGx5ID49IHZwaCA/IDEgOiAwO1xuICAgICAgICAgICAgYzIgKz0gbHggPD0gaHcgPyAtMSA6IGx4ID49IHZwdyA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgIG1vZGVsLnNlbGVjdCh7IHIxOiByMSwgYzE6IGMxLCByMjogcjIsIGMyOiBjMiwgY3Vyc29yUm93OiBjdXJzb3JSb3csIGN1cnNvckNvbHVtbjogY3Vyc29yQ29sdW1uLCBjbGVhcjogY2xlYXIgfSk7XG4gICAgICAgIC8vIFJlLWZldGNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgY3MgPSBtb2RlbC5jdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICBpZiAoIWNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Nyb2xsIHRoZSBncmlkIGJhc2VkIG9uIHRoZSBoaXQgcmVnaW9uLlxuICAgICAgICBpZiAoZGF0YS5yZWdpb24gPT09ICdyb3ctaGVhZGVyJyB8fCBtb2RlID09PSAncm93Jykge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxUb1Jvdyhjcy5yMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5yZWdpb24gPT09ICdjb2x1bW4taGVhZGVyJyB8fCBtb2RlID09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbFRvQ29sdW1uKGNzLmMyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnY2VsbCcpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsVG9DZWxsKGNzLnIyLCBjcy5jMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgY2FsbCB3aXRoIHRoZSBjdXJyZW50IHRpbWVvdXQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBhdXRvc2VsZWN0KGdyaWQsIGRhdGEpOyB9LCBkYXRhLnRpbWVvdXQpO1xuICAgIH1cbiAgICBQcml2YXRlLmF1dG9zZWxlY3QgPSBhdXRvc2VsZWN0O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHNjcm9sbCB0aW1lb3V0IGZvciB0aGUgZ2l2ZW4gZGVsdGEgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgZGVsdGEgcGl4ZWxzIGZyb20gdGhlIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcHV0ZVRpbWVvdXQoZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIDUgKyAxMjAgKiAoMSAtIE1hdGgubWluKDEyOCwgTWF0aC5hYnMoZGVsdGEpKSAvIDEyOCk7XG4gICAgfVxuICAgIFByaXZhdGUuY29tcHV0ZVRpbWVvdXQgPSBjb21wdXRlVGltZW91dDtcbiAgICAvKipcbiAgICAgKiBBIG1hcHBpbmcgb2YgcmVzaXplIGhhbmRsZSB0byBjdXJzb3IuXG4gICAgICovXG4gICAgUHJpdmF0ZS5jdXJzb3JNYXAgPSB7XG4gICAgICAgIHRvcDogJ25zLXJlc2l6ZScsXG4gICAgICAgIGxlZnQ6ICdldy1yZXNpemUnLFxuICAgICAgICByaWdodDogJ2V3LXJlc2l6ZScsXG4gICAgICAgIGJvdHRvbTogJ25zLXJlc2l6ZScsXG4gICAgICAgIG5vbmU6ICdkZWZhdWx0J1xuICAgIH07XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgZGF0YSBncmlkIHNlbGVjdGlvbiBtb2RlbHMuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogSWYgdGhlIHByZWRlZmluZWQgc2VsZWN0aW9uIG1vZGVscyBhcmUgaW5zdWZmaWNpZW50IGZvciBhIHBhcnRpY3VsYXJcbiAqIHVzZSBjYXNlLCBhIGN1c3RvbSBtb2RlbCBjYW4gYmUgZGVmaW5lZCB3aGljaCBkZXJpdmVzIGZyb20gdGhpcyBjbGFzcy5cbiAqL1xudmFyIFNlbGVjdGlvbk1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbk1vZGVsKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGUgPSAnY2VsbCc7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsID0gb3B0aW9ucy5kYXRhTW9kZWw7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGUgPSBvcHRpb25zLnNlbGVjdGlvbk1vZGUgfHwgJ2NlbGwnO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5jaGFuZ2VkLmNvbm5lY3QodGhpcy5vbkRhdGFNb2RlbENoYW5nZWQsIHRoaXMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLCBcImNoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3Rpb24gbW9kZWwgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLCBcInNlbGVjdGlvbk1vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzZWxlY3Rpb24gbW9kZSBmb3IgdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgc2VsZWN0aW9uIG1vZGUgZm9yIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHdpbGwgY2xlYXIgdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBtb2RlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgbW9kZS5cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjdXJyZW50IHNlbGVjdGlvbnMuXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhbnkgc2VsZWN0aW9uIGludGVyc2VjdHMgYSByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgcm93IGluZGV4IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBhbnkgc2VsZWN0aW9uIGludGVyc2VjdHMgdGhlIHJvdy5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgcmVpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc1Jvd1NlbGVjdGVkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzb21lKHRoaXMuc2VsZWN0aW9ucygpLCBmdW5jdGlvbiAocykgeyByZXR1cm4gUHJpdmF0ZSQxLmNvbnRhaW5zUm93KHMsIGluZGV4KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYW55IHNlbGVjdGlvbiBpbnRlcnNlY3RzIGEgY29sdW1uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgYW55IHNlbGVjdGlvbiBpbnRlcnNlY3RzIHRoZSBjb2x1bW4uXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIHJlaW1wbGVtZW50ZWQgaW4gYSBzdWJjbGFzcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuaXNDb2x1bW5TZWxlY3RlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gc29tZSh0aGlzLnNlbGVjdGlvbnMoKSwgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFByaXZhdGUkMS5jb250YWluc0NvbHVtbihzLCBpbmRleCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGFueSBzZWxlY3Rpb24gaW50ZXJzZWN0cyBhIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93IC0gVGhlIHJvdyBpbmRleCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBhbnkgc2VsZWN0aW9uIGludGVyc2VjdHMgdGhlIGNlbGwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIHJlaW1wbGVtZW50ZWQgaW4gYSBzdWJjbGFzcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuaXNDZWxsU2VsZWN0ZWQgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHNvbWUodGhpcy5zZWxlY3Rpb25zKCksIGZ1bmN0aW9uIChzKSB7IHJldHVybiBQcml2YXRlJDEuY29udGFpbnNDZWxsKHMsIHJvdywgY29sdW1uKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNpZ25hbCBoYW5kbGVyIGZvciB0aGUgZGF0YSBtb2RlbCBgY2hhbmdlZGAgc2lnbmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgc2lnbmFsLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFNlbGVjdGlvbiBtb2RlbCBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHVwZGF0ZSB0aGVpciBzZWxlY3Rpb25zXG4gICAgICogaW4gYSBtYW5uZXIgdGhhdCBpcyByZWxldmFudCBmb3IgdGhlIGNoYW5nZXMgdG8gdGhlIGRhdGEgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5vbkRhdGFNb2RlbENoYW5nZWQgPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7IH07XG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgYGNoYW5nZWRgIHNpZ25hbCBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgKiBoYXMgY2hhbmdlZCBzbyB0aGF0IGF0dGFjaGVkIGRhdGEgZ3JpZHMgY2FuIHVwZGF0ZSB0aGVtc2VsdmVzLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5lbWl0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0aW9uTW9kZWw7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJDE7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBzZWxlY3Rpb24gY29udGFpbnMgYSBnaXZlbiByb3cuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnNSb3coc2VsZWN0aW9uLCByb3cpIHtcbiAgICAgICAgdmFyIHIxID0gc2VsZWN0aW9uLnIxLCByMiA9IHNlbGVjdGlvbi5yMjtcbiAgICAgICAgcmV0dXJuIChyb3cgPj0gcjEgJiYgcm93IDw9IHIyKSB8fCAocm93ID49IHIyICYmIHJvdyA8PSByMSk7XG4gICAgfVxuICAgIFByaXZhdGUuY29udGFpbnNSb3cgPSBjb250YWluc1JvdztcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBzZWxlY3Rpb24gY29udGFpbnMgYSBnaXZlbiBjb2x1bW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnNDb2x1bW4oc2VsZWN0aW9uLCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIGMxID0gc2VsZWN0aW9uLmMxLCBjMiA9IHNlbGVjdGlvbi5jMjtcbiAgICAgICAgcmV0dXJuIChjb2x1bW4gPj0gYzEgJiYgY29sdW1uIDw9IGMyKSB8fCAoY29sdW1uID49IGMyICYmIGNvbHVtbiA8PSBjMSk7XG4gICAgfVxuICAgIFByaXZhdGUuY29udGFpbnNDb2x1bW4gPSBjb250YWluc0NvbHVtbjtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBzZWxlY3Rpb24gY29udGFpbnMgYSBnaXZlbiBjZWxsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zQ2VsbChzZWxlY3Rpb24sIHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBjb250YWluc1JvdyhzZWxlY3Rpb24sIHJvdykgJiYgY29udGFpbnNDb2x1bW4oc2VsZWN0aW9uLCBjb2x1bW4pO1xuICAgIH1cbiAgICBQcml2YXRlLmNvbnRhaW5zQ2VsbCA9IGNvbnRhaW5zQ2VsbDtcbn0pKFByaXZhdGUkMSB8fCAoUHJpdmF0ZSQxID0ge30pKTtcblxuLyoqXG4gKiBBIGJhc2ljIHNlbGVjdGlvbiBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIHNlbGVjdGlvbiBtb2RlbCBpcyBzdWZmaWNpZW50IGZvciBtb3N0IHVzZSBjYXNlcyB3aGVyZVxuICogc3RydWN0dXJhbCBrbm93bGVkZ2Ugb2YgdGhlIGRhdGEgc291cmNlIGlzICpub3QqIHJlcXVpcmVkLlxuICovXG52YXIgQmFzaWNTZWxlY3Rpb25Nb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzaWNTZWxlY3Rpb25Nb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNpY1NlbGVjdGlvbk1vZGVsKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2N1cnNvclJvdyA9IC0xO1xuICAgICAgICBfdGhpcy5fY3Vyc29yQ29sdW1uID0gLTE7XG4gICAgICAgIF90aGlzLl9jdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICAgICAgX3RoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZXRoZXIgdGhlIHNlbGVjdGlvbiBtb2RlbCBpcyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUsIFwiY3Vyc29yUm93XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByb3cgaW5kZXggb2YgdGhlIGN1cnNvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvclJvdztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLCBcImN1cnNvckNvbHVtblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sdW1uIGluZGV4IG9mIHRoZSBjdXJzb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3JDb2x1bW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE1vdmUgY3Vyc29yIGRvd24vdXAvbGVmdC9yaWdodCB3aGlsZSBtYWtpbmcgc3VyZSBpdCByZW1haW5zXG4gICAgICogd2l0aGluIHRoZSBib3VuZHMgb2Ygc2VsZWN0ZWQgcmVjdGFuZ2xlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIG1vdmVtZW50LlxuICAgICAqL1xuICAgIEJhc2ljU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLm1vdmVDdXJzb3JXaXRoaW5TZWxlY3Rpb25zID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBzZWxlY3Rpb25zIG9yIG5vIGV4aXN0aW5nIGN1cnNvclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5IHx8IHRoaXMuY3Vyc29yUm93ID09PSAtMSB8fCB0aGlzLl9jdXJzb3JDb2x1bW4gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiBvbmx5IHNpbmdsZSBjZWxsIGlzIHNlbGVjdGVkXG4gICAgICAgIHZhciBmaXJzdFNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbnNbMF07XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgZmlyc3RTZWxlY3Rpb24ucjEgPT09IGZpcnN0U2VsZWN0aW9uLnIyICYmXG4gICAgICAgICAgICBmaXJzdFNlbGVjdGlvbi5jMSA9PT0gZmlyc3RTZWxlY3Rpb24uYzIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCBmcm9tIGxhc3Qgc2VsZWN0aW9uIHJlY3RhbmdsZVxuICAgICAgICBpZiAodGhpcy5fY3Vyc29yUmVjdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yUmVjdEluZGV4ID0gdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJzb3JSZWN0ID0gdGhpcy5fc2VsZWN0aW9uc1t0aGlzLl9jdXJzb3JSZWN0SW5kZXhdO1xuICAgICAgICB2YXIgZHIgPSBkaXJlY3Rpb24gPT09ICdkb3duJyA/IDEgOiBkaXJlY3Rpb24gPT09ICd1cCcgPyAtMSA6IDA7XG4gICAgICAgIHZhciBkYyA9IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDEgOiBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IC0xIDogMDtcbiAgICAgICAgdmFyIG5ld1JvdyA9IHRoaXMuX2N1cnNvclJvdyArIGRyO1xuICAgICAgICB2YXIgbmV3Q29sdW1uID0gdGhpcy5fY3Vyc29yQ29sdW1uICsgZGM7XG4gICAgICAgIHZhciByMSA9IE1hdGgubWluKGN1cnNvclJlY3QucjEsIGN1cnNvclJlY3QucjIpO1xuICAgICAgICB2YXIgcjIgPSBNYXRoLm1heChjdXJzb3JSZWN0LnIxLCBjdXJzb3JSZWN0LnIyKTtcbiAgICAgICAgdmFyIGMxID0gTWF0aC5taW4oY3Vyc29yUmVjdC5jMSwgY3Vyc29yUmVjdC5jMik7XG4gICAgICAgIHZhciBjMiA9IE1hdGgubWF4KGN1cnNvclJlY3QuYzEsIGN1cnNvclJlY3QuYzIpO1xuICAgICAgICB2YXIgbW92ZVRvTmV4dFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY3Vyc29yUmVjdEluZGV4ID0gKF90aGlzLl9jdXJzb3JSZWN0SW5kZXggKyAxKSAlIF90aGlzLl9zZWxlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnNvclJlY3QgPSBfdGhpcy5fc2VsZWN0aW9uc1tfdGhpcy5fY3Vyc29yUmVjdEluZGV4XTtcbiAgICAgICAgICAgIG5ld1JvdyA9IE1hdGgubWluKGN1cnNvclJlY3QucjEsIGN1cnNvclJlY3QucjIpO1xuICAgICAgICAgICAgbmV3Q29sdW1uID0gTWF0aC5taW4oY3Vyc29yUmVjdC5jMSwgY3Vyc29yUmVjdC5jMik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb3ZlVG9QcmV2aW91c1JlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY3Vyc29yUmVjdEluZGV4ID0gX3RoaXMuX2N1cnNvclJlY3RJbmRleCA9PT0gMCA/IF90aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCAtIDEgOiBfdGhpcy5fY3Vyc29yUmVjdEluZGV4IC0gMTtcbiAgICAgICAgICAgIGN1cnNvclJlY3QgPSBfdGhpcy5fc2VsZWN0aW9uc1tfdGhpcy5fY3Vyc29yUmVjdEluZGV4XTtcbiAgICAgICAgICAgIG5ld1JvdyA9IE1hdGgubWF4KGN1cnNvclJlY3QucjEsIGN1cnNvclJlY3QucjIpO1xuICAgICAgICAgICAgbmV3Q29sdW1uID0gTWF0aC5tYXgoY3Vyc29yUmVjdC5jMSwgY3Vyc29yUmVjdC5jMik7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChuZXdSb3cgPiByMikge1xuICAgICAgICAgICAgbmV3Um93ID0gcjE7XG4gICAgICAgICAgICBuZXdDb2x1bW4gKz0gMTtcbiAgICAgICAgICAgIGlmIChuZXdDb2x1bW4gPiBjMikge1xuICAgICAgICAgICAgICAgIG1vdmVUb05leHRSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Um93IDwgcjEpIHtcbiAgICAgICAgICAgIG5ld1JvdyA9IHIyO1xuICAgICAgICAgICAgbmV3Q29sdW1uIC09IDE7XG4gICAgICAgICAgICBpZiAobmV3Q29sdW1uIDwgYzEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlVG9QcmV2aW91c1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDb2x1bW4gPiBjMikge1xuICAgICAgICAgICAgbmV3Q29sdW1uID0gYzE7XG4gICAgICAgICAgICBuZXdSb3cgKz0gMTtcbiAgICAgICAgICAgIGlmIChuZXdSb3cgPiByMikge1xuICAgICAgICAgICAgICAgIG1vdmVUb05leHRSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q29sdW1uIDwgYzEpIHtcbiAgICAgICAgICAgIG5ld0NvbHVtbiA9IGMyO1xuICAgICAgICAgICAgbmV3Um93IC09IDE7XG4gICAgICAgICAgICBpZiAobmV3Um93IDwgcjEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlVG9QcmV2aW91c1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJzb3JSb3cgPSBuZXdSb3c7XG4gICAgICAgIHRoaXMuX2N1cnNvckNvbHVtbiA9IG5ld0NvbHVtbjtcbiAgICAgICAgLy8gRW1pdCB0aGUgY2hhbmdlZCBzaWduYWwuXG4gICAgICAgIHRoaXMuZW1pdENoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNlbGVjdGlvbiBvciBgbnVsbGAuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyB0aGUgc2VsZWN0aW9uIHdoaWNoIGhvbGRzIHRoZSBjdXJzb3IuXG4gICAgICovXG4gICAgQmFzaWNTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY3VycmVudFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnNbdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGl0ZXJhdG9yIG9mIHRoZSBzZWxlY3Rpb25zIGluIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRhdGEgZ3JpZCB3aWxsIHJlbmRlciB0aGUgc2VsZWN0aW9ucyBpbiBvcmRlci5cbiAgICAgKi9cbiAgICBCYXNpY1NlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9zZWxlY3Rpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgc3BlY2lmaWVkIGNlbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIEJhc2ljU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIC8vIEZldGNoIHRoZSBjdXJyZW50IHJvdyBhbmQgY29sdW1uIGNvdW50cztcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5kYXRhTW9kZWwucm93Q291bnQoJ2JvZHknKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5kYXRhTW9kZWwuY29sdW1uQ291bnQoJ2JvZHknKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgICAgICBpZiAocm93Q291bnQgPD0gMCB8fCBjb2x1bW5Db3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5wYWNrIHRoZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciByMSA9IGFyZ3MucjEsIGMxID0gYXJncy5jMSwgcjIgPSBhcmdzLnIyLCBjMiA9IGFyZ3MuYzIsIGN1cnNvclJvdyA9IGFyZ3MuY3Vyc29yUm93LCBjdXJzb3JDb2x1bW4gPSBhcmdzLmN1cnNvckNvbHVtbiwgY2xlYXIgPSBhcmdzLmNsZWFyO1xuICAgICAgICAvLyBDbGVhciB0aGUgbmVjZXNzYXJ5IHNlbGVjdGlvbnMuXG4gICAgICAgIGlmIChjbGVhciA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGVhciA9PT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRvIHRoZSBkYXRhIG1vZGVsIGJvdW5kcy5cbiAgICAgICAgcjEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMSwgcm93Q291bnQgLSAxKSk7XG4gICAgICAgIHIyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocjIsIHJvd0NvdW50IC0gMSkpO1xuICAgICAgICBjMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMxLCBjb2x1bW5Db3VudCAtIDEpKTtcbiAgICAgICAgYzIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjMiwgY29sdW1uQ291bnQgLSAxKSk7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICBjMSA9IDA7XG4gICAgICAgICAgICBjMiA9IGNvbHVtbkNvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICByMSA9IDA7XG4gICAgICAgICAgICByMiA9IHJvd0NvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGlhcyB0aGUgY3Vyc29yIHJvdyBhbmQgY29sdW1uLlxuICAgICAgICB2YXIgY3IgPSBjdXJzb3JSb3c7XG4gICAgICAgIHZhciBjYyA9IGN1cnNvckNvbHVtbjtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGN1cnNvciBsb2NhdGlvbi5cbiAgICAgICAgaWYgKGNyIDwgMCB8fCAoY3IgPCByMSAmJiBjciA8IHIyKSB8fCAoY3IgPiByMSAmJiBjciA+IHIyKSkge1xuICAgICAgICAgICAgY3IgPSByMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2MgPCAwIHx8IChjYyA8IGMxICYmIGNjIDwgYzIpIHx8IChjYyA+IGMxICYmIGNjID4gYzIpKSB7XG4gICAgICAgICAgICBjYyA9IGMxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3Vyc29yLlxuICAgICAgICB0aGlzLl9jdXJzb3JSb3cgPSBjcjtcbiAgICAgICAgdGhpcy5fY3Vyc29yQ29sdW1uID0gY2M7XG4gICAgICAgIHRoaXMuX2N1cnNvclJlY3RJbmRleCA9IHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBzZWxlY3Rpb24uXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbnMucHVzaCh7IHIxOiByMSwgYzE6IGMxLCByMjogcjIsIGMyOiBjMiB9KTtcbiAgICAgICAgLy8gRW1pdCB0aGUgY2hhbmdlZCBzaWduYWwuXG4gICAgICAgIHRoaXMuZW1pdENoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBzZWxlY3Rpb25zIGluIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICovXG4gICAgQmFzaWNTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIHNlbGVjdGlvbnMuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fY3Vyc29yUm93ID0gLTE7XG4gICAgICAgIHRoaXMuX2N1cnNvckNvbHVtbiA9IC0xO1xuICAgICAgICB0aGlzLl9jdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBFbWl0IHRoZSBjaGFuZ2VkIHNpZ25hbC5cbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaWduYWwgaGFuZGxlciBmb3IgdGhlIGRhdGEgbW9kZWwgYGNoYW5nZWRgIHNpZ25hbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHNpZ25hbC5cbiAgICAgKi9cbiAgICBCYXNpY1NlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5vbkRhdGFNb2RlbENoYW5nZWQgPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG1vZGVsIGhhcyBubyBjdXJyZW50IHNlbGVjdGlvbnMuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGNlbGxzIGhhdmUgY2hhbmdlZCBpbiBwbGFjZS5cbiAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2NlbGxzLWNoYW5nZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBjaGFuZ2UgdG8gdGhlIHJvdyBvciBjb2x1bW4gY291bnQuXG4gICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdyb3dzLW1vdmVkJyB8fCBhcmdzLnR5cGUgPT09ICdjb2x1bW5zLW1vdmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBsYXN0IHJvdyBhbmQgY29sdW1uIGluZGV4LlxuICAgICAgICB2YXIgbHIgPSBzZW5kZXIucm93Q291bnQoJ2JvZHknKSAtIDE7XG4gICAgICAgIHZhciBsYyA9IHNlbmRlci5jb2x1bW5Db3VudCgnYm9keScpIC0gMTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgZGF0YSBtb2RlbCBpcyBlbXB0eS5cbiAgICAgICAgaWYgKGxyIDwgMCB8fCBsYyA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuZW1pdENoYW5nZWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5zZWxlY3Rpb25Nb2RlO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGFzc2lnbm1lbnQgaW5kZXggdmFyaWFibGUuXG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbnMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5fc2VsZWN0aW9ucy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIFVucGFjayB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5fc2VsZWN0aW9uc1tpXSwgcjEgPSBfYS5yMSwgYzEgPSBfYS5jMSwgcjIgPSBfYS5yMiwgYzIgPSBfYS5jMjtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIHNlbGVjdGlvbiBpZiBpdCB3aWxsIGRpc2FwcGVhci5cbiAgICAgICAgICAgIGlmICgobHIgPCByMSAmJiBsciA8IHIyKSB8fCAobGMgPCBjMSAmJiBsYyA8IGMyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBib3VuZHMgYmFzZWQgb24gdGhlIHNlbGVjdGlvbiBtb2RlLlxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICAgICAgcjEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMSwgbHIpKTtcbiAgICAgICAgICAgICAgICByMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKHIyLCBscikpO1xuICAgICAgICAgICAgICAgIGMxID0gMDtcbiAgICAgICAgICAgICAgICBjMiA9IGxjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICByMSA9IDA7XG4gICAgICAgICAgICAgICAgcjIgPSBscjtcbiAgICAgICAgICAgICAgICBjMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMxLCBsYykpO1xuICAgICAgICAgICAgICAgIGMyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYzIsIGxjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHIxLCBscikpO1xuICAgICAgICAgICAgICAgIHIyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocjIsIGxyKSk7XG4gICAgICAgICAgICAgICAgYzEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjMSwgbGMpKTtcbiAgICAgICAgICAgICAgICBjMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMyLCBsYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSBtb2RpZmllZCBzZWxlY3Rpb24gdG8gdGhlIGFycmF5LlxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uc1tqKytdID0geyByMTogcjEsIGMxOiBjMSwgcjI6IHIyLCBjMjogYzIgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YWxlIHNlbGVjdGlvbnMuXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbnMubGVuZ3RoID0gajtcbiAgICAgICAgLy8gRW1pdCB0aGUgY2hhbmdlZCBzaWduYWwuXG4gICAgICAgIHRoaXMuZW1pdENoYW5nZWQoKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNpY1NlbGVjdGlvbk1vZGVsO1xufShTZWxlY3Rpb25Nb2RlbCkpO1xuXG4vKipcbiAqIEFuIG9iamVjdCB3aGljaCByZW5kZXJzIHRoZSBjZWxscyBvZiBhIGRhdGEgZ3JpZC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBJZiB0aGUgcHJlZGVmaW5lZCBjZWxsIHJlbmRlcmVycyBhcmUgaW5zdWZmaWNpZW50IGZvciBhIHBhcnRpY3VsYXJcbiAqIHVzZSBjYXNlLCBhIGN1c3RvbSBjZWxsIHJlbmRlcmVyIGNhbiBiZSBkZWZpbmVkIHdoaWNoIGRlcml2ZXMgZnJvbVxuICogdGhpcyBjbGFzcy5cbiAqXG4gKiBUaGUgZGF0YSBncmlkIHJlbmRlcnMgY2VsbHMgaW4gY29sdW1uLW1ham9yIG9yZGVyLCBieSByZWdpb24uIFRoZVxuICogcmVnaW9uIG9yZGVyIGlzOiBib2R5LCByb3cgaGVhZGVyLCBjb2x1bW4gaGVhZGVyLCBjb3JuZXIgaGVhZGVyLlxuICovXG52YXIgQ2VsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlbGxSZW5kZXJlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcjtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgQ2VsbFJlbmRlcmVyYCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKENlbGxSZW5kZXJlcikge1xuICAgIC8qKlxuICAgICAqIFJlc29sdmUgYSBjb25maWcgb3B0aW9uIGZvciBhIGNlbGwgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uIC0gVGhlIGNvbmZpZyBvcHRpb24gdG8gcmVzb2x2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY2VsbCBjb25maWcgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJlc29sdmVkIHZhbHVlIGZvciB0aGUgb3B0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVPcHRpb24ob3B0aW9uLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgPyBvcHRpb24oY29uZmlnKSA6IG9wdGlvbjtcbiAgICB9XG4gICAgQ2VsbFJlbmRlcmVyLnJlc29sdmVPcHRpb24gPSByZXNvbHZlT3B0aW9uO1xufSkoQ2VsbFJlbmRlcmVyIHx8IChDZWxsUmVuZGVyZXIgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8qKlxuICogQSB3aWRnZXQgd2hpY2ggaW1wbGVtZW50cyBhIG5vdGlmaWNhdGlvbiBwb3B1cC5cbiAqL1xudmFyIE5vdGlmaWNhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90aWZpY2F0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IG5vZGU6IFByaXZhdGUkMi5jcmVhdGVOb2RlKCkgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX21lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ2xtLURhdGFHcmlkLW5vdGlmaWNhdGlvbicpO1xuICAgICAgICBfdGhpcy5zZXRGbGFnKFdpZGdldC5GbGFnLkRpc2FsbG93TGF5b3V0KTtcbiAgICAgICAgX3RoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgICAgICBfdGhpcy5fbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCAnJztcbiAgICAgICAgX3RoaXMuX3BsYWNlbWVudCA9IG9wdGlvbnMucGxhY2VtZW50IHx8ICdib3R0b20nO1xuICAgICAgICBXaWRnZXQuYXR0YWNoKF90aGlzLCBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCAmJiBvcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBET00gZXZlbnQgc2VudCB0byB0aGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIERPTSBgRXZlbnRMaXN0ZW5lcmAgaW50ZXJmYWNlIGFuZCBpc1xuICAgICAqIGNhbGxlZCBpbiByZXNwb25zZSB0byBldmVudHMgb24gdGhlIG5vdGlmaWNhdGlvbidzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm90aWZpY2F0aW9uLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcGxhY2VtZW50IG9mIHRoZSBub3RpZmljYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgcGxhY2VtZW50IGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZW1lbnQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBwbGFjZW1lbnQuXG4gICAgICAgICAgICB0aGlzLl9wbGFjZW1lbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBmb3Igbm90aWZpY2F0aW9uLlxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vdGlmaWNhdGlvbi5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXNzYWdlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgZm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb3RpZmljYXRpb24ucHJvdG90eXBlLCBcIm1lc3NhZ2VOb2RlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbm9kZSBwcmVzZW50aW5nIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xtLURhdGFHcmlkLW5vdGlmaWNhdGlvbk1lc3NhZ2UnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgaW52b2tlZCBvbiBhICdiZWZvcmUtYXR0YWNoJyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUub25CZWZvcmVBdHRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIGludm9rZWQgb24gYW4gJ2FmdGVyLWRldGFjaCcgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLm9uQWZ0ZXJEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIGludm9rZWQgb24gYW4gJ3VwZGF0ZS1yZXF1ZXN0JyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IHRoaXMuX3RhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5ub2RlLnN0eWxlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3BsYWNlbWVudCkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSB0YXJnZXRSZWN0LmJvdHRvbSArICdweCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHRhcmdldFJlY3QudG9wICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSAnMCc7XG4gICAgICAgICAgICAgICAgc3R5bGUuYWxpZ25JdGVtcyA9ICdmbGV4LWVuZCc7XG4gICAgICAgICAgICAgICAgc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHRhcmdldFJlY3QubGVmdCArICdweCc7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gdGFyZ2V0UmVjdC50b3AgKyAncHgnO1xuICAgICAgICAgICAgICAgIHN0eWxlLmFsaWduSXRlbXMgPSAnZmxleC1lbmQnO1xuICAgICAgICAgICAgICAgIHN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gdGFyZ2V0UmVjdC5yaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gdGFyZ2V0UmVjdC50b3AgKyAncHgnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZU5vZGUuaW5uZXJIVE1MID0gdGhpcy5fbWVzc2FnZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdtb3VzZWRvd24nYCBldmVudCBmb3IgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLl9ldnRNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBpdCdzIG5vdCBhIGxlZnQgbW91c2UgcHJlc3MuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbn0oV2lkZ2V0KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkMjtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgRE9NIG5vZGUgZm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAnbG0tRGF0YUdyaWQtbm90aWZpY2F0aW9uQ29udGFpbmVyJztcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIG1lc3NhZ2UuY2xhc3NOYW1lID0gJ2xtLURhdGFHcmlkLW5vdGlmaWNhdGlvbk1lc3NhZ2UnO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWVzc2FnZSk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlTm9kZSA9IGNyZWF0ZU5vZGU7XG59KShQcml2YXRlJDIgfHwgKFByaXZhdGUkMiA9IHt9KSk7XG5cbi8vIGRlZmF1bHQgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlXG52YXIgREVGQVVMVF9JTlZBTElEX0lOUFVUX01FU1NBR0UgPSBcIkludmFsaWQgaW5wdXQhXCI7XG4vKipcbiAqIEEgY2VsbCBpbnB1dCB2YWxpZGF0b3Igb2JqZWN0IHdoaWNoIGFsd2F5cyByZXR1cm5zIHZhbGlkLlxuICovXG52YXIgUGFzc0lucHV0VmFsaWRhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhc3NJbnB1dFZhbGlkYXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgY2VsbCBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZWxsIC0gVGhlIG9iamVjdCBob2xkaW5nIGNlbGwgY29uZmlndXJhdGlvbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGNlbGwgdmFsdWUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICBQYXNzSW5wdXRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNlbGwsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgfTtcbiAgICByZXR1cm4gUGFzc0lucHV0VmFsaWRhdG9yO1xufSgpKTtcbi8qKlxuICogVGV4dCBjZWxsIGlucHV0IHZhbGlkYXRvci5cbiAqL1xudmFyIFRleHRJbnB1dFZhbGlkYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0SW5wdXRWYWxpZGF0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIHRleHQgbGVuZ3RoXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIE51bWJlci5OYU4sIG1lYW5pbmcgbm8gbWluaW11bSBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IE51bWJlci5OYU47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIHRleHQgbGVuZ3RoXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIE51bWJlci5OYU4sIG1lYW5pbmcgbm8gbWF4aW11bSBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IE51bWJlci5OYU47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1aXJlZCB0ZXh0IHBhdHRlcm4gYXMgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIG51bGwsIG1lYW5pbmcgbm8gcGF0dGVybiBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBjZWxsIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlbGwgLSBUaGUgb2JqZWN0IGhvbGRpbmcgY2VsbCBjb25maWd1cmF0aW9uIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgY2VsbCB2YWx1ZSBpbnB1dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHZhbGlkYXRpb24gcmVzdWx0LlxuICAgICAqL1xuICAgIFRleHRJbnB1dFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY2VsbCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW5wdXQgbXVzdCBiZSB2YWxpZCB0ZXh0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKHRoaXMubWluTGVuZ3RoKSAmJiB2YWx1ZS5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUZXh0IGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcIiArIHRoaXMubWluTGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4odGhpcy5tYXhMZW5ndGgpICYmIHZhbHVlLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRleHQgbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIFwiICsgdGhpcy5tYXhMZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0dGVybiAmJiAhdGhpcy5wYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRleHQgZG9lc24ndCBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVyblwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dElucHV0VmFsaWRhdG9yO1xufSgpKTtcbi8qKlxuICogSW50ZWdlciBjZWxsIGlucHV0IHZhbGlkYXRvci5cbiAqL1xudmFyIEludGVnZXJJbnB1dFZhbGlkYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlZ2VySW5wdXRWYWxpZGF0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIE51bWJlci5OYU4sIG1lYW5pbmcgbm8gbWluaW11bSBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbiA9IE51bWJlci5OYU47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIE51bWJlci5OYU4sIG1lYW5pbmcgbm8gbWF4aW11bSBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heCA9IE51bWJlci5OYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGNlbGwgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VsbCAtIFRoZSBvYmplY3QgaG9sZGluZyBjZWxsIGNvbmZpZ3VyYXRpb24gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBjZWxsIHZhbHVlIGlucHV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdmFsaWRhdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgSW50ZWdlcklucHV0VmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjZWxsLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgJSAxICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0lucHV0IG11c3QgYmUgdmFsaWQgaW50ZWdlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTih0aGlzLm1pbikgJiYgdmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnB1dCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcIiArIHRoaXMubWluXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4odGhpcy5tYXgpICYmIHZhbHVlID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW5wdXQgbXVzdCBiZSBsZXNzIHRoYW4gXCIgKyB0aGlzLm1heFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIEludGVnZXJJbnB1dFZhbGlkYXRvcjtcbn0oKSk7XG4vKipcbiAqIFJlYWwgbnVtYmVyIGNlbGwgaW5wdXQgdmFsaWRhdG9yLlxuICovXG52YXIgTnVtYmVySW5wdXRWYWxpZGF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVySW5wdXRWYWxpZGF0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIE51bWJlci5OYU4sIG1lYW5pbmcgbm8gbWluaW11bSBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbiA9IE51bWJlci5OYU47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIE51bWJlci5OYU4sIG1lYW5pbmcgbm8gbWF4aW11bSBjb25zdHJhaW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heCA9IE51bWJlci5OYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGNlbGwgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VsbCAtIFRoZSBvYmplY3QgaG9sZGluZyBjZWxsIGNvbmZpZ3VyYXRpb24gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBjZWxsIHZhbHVlIGlucHV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdmFsaWRhdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgTnVtYmVySW5wdXRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNlbGwsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW5wdXQgbXVzdCBiZSB2YWxpZCBudW1iZXInXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4odGhpcy5taW4pICYmIHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW5wdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCIgKyB0aGlzLm1pblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKHRoaXMubWF4KSAmJiB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIklucHV0IG11c3QgYmUgbGVzcyB0aGFuIFwiICsgdGhpcy5tYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfTtcbiAgICB9O1xuICAgIHJldHVybiBOdW1iZXJJbnB1dFZhbGlkYXRvcjtcbn0oKSk7XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0eVxuICogbmVlZGVkIGJ5IGEgY2VsbCBlZGl0b3IuIEFsbCBvZiB0aGUgYnVpbHQtaW4gY2VsbCBlZGl0b3JzXG4gKiBmb3IgdmFyaW91cyBjZWxsIHR5cGVzIGFyZSBkZXJpdmVkIGZyb20gdGhpcyBiYXNlIGNsYXNzLiBDdXN0b20gY2VsbCBlZGl0b3JzXG4gKiBjYW4gYmUgZWFzaWx5IGltcGxlbWVudGVkIGJ5IGV4dGVuZGluZyB0aGlzIGNsYXNzLlxuICovXG52YXIgQ2VsbEVkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2VsbEVkaXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTm90aWZpY2F0aW9uIHBvcHVwIHVzZWQgdG8gc2hvdyB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWxpZGl0eU5vdGlmaWNhdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjZWxsIGVkaXRvciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB2YWx1ZSBpbnB1dCBpcyB2YWxpZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbGlkSW5wdXQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogR3JpZCB3aGVlbCBldmVudCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3JpZFdoZWVsRXZlbnRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQuY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENlbGxFZGl0b3IucHJvdG90eXBlLCBcImlzRGlzcG9zZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2VsbCBlZGl0b3IgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgQ2VsbEVkaXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2dyaWRXaGVlbEV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5jZWxsLmdyaWQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2dyaWRXaGVlbEV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLl9ncmlkV2hlZWxFdmVudEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlVmFsaWRpdHlOb3RpZmljYXRpb24oKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNlbGwuZ3JpZC5ub2RlLnJlbW92ZUNoaWxkKHRoaXMudmlld3BvcnRPY2NsdWRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBlZGl0aW5nIHRoZSBjZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlbGwgLSBUaGUgb2JqZWN0IGhvbGRpbmcgY2VsbCBjb25maWd1cmF0aW9uIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjZWxsIGVkaXRpbmcgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBDZWxsRWRpdG9yLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24gKGNlbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICAgICAgdGhpcy5vbkNvbW1pdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkNvbW1pdDtcbiAgICAgICAgdGhpcy5vbkNhbmNlbCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbkNhbmNlbDtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAob3B0aW9ucyAmJiBvcHRpb25zLnZhbGlkYXRvcikgPyBvcHRpb25zLnZhbGlkYXRvciA6IHRoaXMuY3JlYXRlVmFsaWRhdG9yQmFzZWRPblR5cGUoKTtcbiAgICAgICAgdGhpcy5fZ3JpZFdoZWVsRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2Nsb3NlVmFsaWRpdHlOb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNlbGwuZ3JpZC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fZ3JpZFdoZWVsRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fYWRkQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5zdGFydEVkaXRpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCBlZGl0aW5nIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIENlbGxFZGl0b3IucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDZWxsRWRpdG9yLnByb3RvdHlwZSwgXCJ2YWxpZElucHV0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHZhbHVlIGlucHV0IGlzIHZhbGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRJbnB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGNlbGwgaW5wdXQuIFNob3dzIHZhbGlkYXRpb24gZXJyb3Igbm90aWZpY2F0aW9uIHdoZW4gaW5wdXQgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBDZWxsRWRpdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldElucHV0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklucHV0IGVycm9yOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWxpZGl0eShmYWxzZSwgZXJyb3IubWVzc2FnZSB8fCBERUZBVUxUX0lOVkFMSURfSU5QVVRfTUVTU0FHRSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWxpZGF0b3IudmFsaWRhdGUodGhpcy5jZWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWxpZGl0eSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsaWRpdHkoZmFsc2UsIHJlc3VsdC5tZXNzYWdlIHx8IERFRkFVTFRfSU5WQUxJRF9JTlBVVF9NRVNTQUdFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsaWRpdHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB2YWxpZGl0eSBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkIC0gV2hldGhlciB0aGUgaW5wdXQgaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIE5vdGlmaWNhdGlvbiBtZXNzYWdlIHRvIHNob3cuXG4gICAgICpcbiAgICAgKiBJZiBtZXNzYWdlIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgKHdoaWNoIGlzIHRoZSBkZWZhdWx0KVxuICAgICAqIGV4aXN0aW5nIG5vdGlmaWNhdGlvbiBwb3B1cCBpcyByZW1vdmVkIGlmIGFueS5cbiAgICAgKi9cbiAgICBDZWxsRWRpdG9yLnByb3RvdHlwZS5zZXRWYWxpZGl0eSA9IGZ1bmN0aW9uICh2YWxpZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBcIlwiOyB9XG4gICAgICAgIHRoaXMuX3ZhbGlkSW5wdXQgPSB2YWxpZDtcbiAgICAgICAgdGhpcy5fY2xvc2VWYWxpZGl0eU5vdGlmaWNhdGlvbigpO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2xtLW1vZC1pbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtaW52YWxpZCcpO1xuICAgICAgICAgICAgLy8gc2hvdyBhIG5vdGlmaWNhdGlvbiBwb3B1cFxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkaXR5Tm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5lZGl0b3JDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkaXR5Tm90aWZpY2F0aW9uLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBjZWxsIGlucHV0IHZhbGlkYXRvciBiYXNlZCBvbiBjb25maWd1cmF0aW9uIG9mIHRoZVxuICAgICAqIGNlbGwgYmVpbmcgZWRpdGVkLiBJZiBubyBzdWl0YWJsZSB2YWxpZGF0b3IgY2FuIGJlIGZvdW5kLCBpdCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBDZWxsRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVWYWxpZGF0b3JCYXNlZE9uVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGw7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGNlbGwuZ3JpZC5kYXRhTW9kZWwubWV0YWRhdGEoJ2JvZHknLCBjZWxsLnJvdywgY2VsbC5jb2x1bW4pO1xuICAgICAgICBzd2l0Y2ggKG1ldGFkYXRhICYmIG1ldGFkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFRleHRJbnB1dFZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtZXRhZGF0YS5mb3JtYXQpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IG1ldGFkYXRhLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IucGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKFthLXowLTlfXFwuLV0rKUAoW1xcZGEtelxcLi1dKylcXC4oW2EtelxcLl17Miw2fSkkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dWlkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLnBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiWzAtOWEtZkEtRl17OH1cXC1bMC05YS1mQS1GXXs0fVxcLVswLTlhLWZBLUZdezR9XFwtWzAtOWEtZkEtRl17NH1cXC1bMC05YS1mQS1GXXsxMn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuY29uc3RyYWludC5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5taW5MZW5ndGggPSBtZXRhZGF0YS5jb25zdHJhaW50Lm1pbkxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb25zdHJhaW50Lm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLm1heExlbmd0aCA9IG1ldGFkYXRhLmNvbnN0cmFpbnQubWF4TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobWV0YWRhdGEuY29uc3RyYWludC5wYXR0ZXJuKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IucGF0dGVybiA9IG5ldyBSZWdFeHAobWV0YWRhdGEuY29uc3RyYWludC5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IE51bWJlcklucHV0VmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuY29uc3RyYWludC5taW5pbXVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IubWluID0gbWV0YWRhdGEuY29uc3RyYWludC5taW5pbXVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmNvbnN0cmFpbnQubWF4aW11bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLm1heCA9IG1ldGFkYXRhLmNvbnN0cmFpbnQubWF4aW11bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBJbnRlZ2VySW5wdXRWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb25zdHJhaW50Lm1pbmltdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5taW4gPSBtZXRhZGF0YS5jb25zdHJhaW50Lm1pbmltdW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuY29uc3RyYWludC5tYXhpbXVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IubWF4ID0gbWV0YWRhdGEuY29uc3RyYWludC5tYXhpbXVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGNlbGwgcmVjdGFuZ2xlIGFuZCByZXR1cm4gd2l0aCBvdGhlciBjZWxsIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgQ2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0Q2VsbEluZm8gPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICB2YXIgZ3JpZCA9IGNlbGwuZ3JpZCwgcm93ID0gY2VsbC5yb3csIGNvbHVtbiA9IGNlbGwuY29sdW1uO1xuICAgICAgICB2YXIgZGF0YSA9IGdyaWQuZGF0YU1vZGVsLmRhdGEoJ2JvZHknLCByb3csIGNvbHVtbik7XG4gICAgICAgIHZhciBjb2x1bW5YID0gZ3JpZC5oZWFkZXJXaWR0aCAtIGdyaWQuc2Nyb2xsWCArIGdyaWQuY29sdW1uT2Zmc2V0KCdib2R5JywgY29sdW1uKTtcbiAgICAgICAgdmFyIHJvd1kgPSBncmlkLmhlYWRlckhlaWdodCAtIGdyaWQuc2Nyb2xsWSArIGdyaWQucm93T2Zmc2V0KCdib2R5Jywgcm93KTtcbiAgICAgICAgdmFyIHdpZHRoID0gZ3JpZC5jb2x1bW5TaXplKCdib2R5JywgY29sdW1uKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGdyaWQucm93U2l6ZSgnYm9keScsIHJvdyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB4OiBjb2x1bW5YLFxuICAgICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9uIGNlbGwgZWRpdG9yIGJ5IG1vdmluZyB2aWV3cG9ydCBvY2NsdWRlciBhbmQgY2VsbCBlZGl0b3IgY29udGFpbmVyLlxuICAgICAqL1xuICAgIENlbGxFZGl0b3IucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuY2VsbC5ncmlkO1xuICAgICAgICB2YXIgY2VsbEluZm8gPSB0aGlzLmdldENlbGxJbmZvKHRoaXMuY2VsbCk7XG4gICAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSBncmlkLmhlYWRlckhlaWdodDtcbiAgICAgICAgdmFyIGhlYWRlcldpZHRoID0gZ3JpZC5oZWFkZXJXaWR0aDtcbiAgICAgICAgdGhpcy52aWV3cG9ydE9jY2x1ZGVyLnN0eWxlLnRvcCA9IGhlYWRlckhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMudmlld3BvcnRPY2NsdWRlci5zdHlsZS5sZWZ0ID0gaGVhZGVyV2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLnZpZXdwb3J0T2NjbHVkZXIuc3R5bGUud2lkdGggPSAoZ3JpZC52aWV3cG9ydFdpZHRoIC0gaGVhZGVyV2lkdGgpICsgJ3B4JztcbiAgICAgICAgdGhpcy52aWV3cG9ydE9jY2x1ZGVyLnN0eWxlLmhlaWdodCA9IChncmlkLnZpZXdwb3J0SGVpZ2h0IC0gaGVhZGVySGVpZ2h0KSArICdweCc7XG4gICAgICAgIHRoaXMudmlld3BvcnRPY2NsdWRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLmxlZnQgPSAoY2VsbEluZm8ueCAtIDEgLSBoZWFkZXJXaWR0aCkgKyAncHgnO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZS50b3AgPSAoY2VsbEluZm8ueSAtIDEgLSBoZWFkZXJIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgdGhpcy5lZGl0b3JDb250YWluZXIuc3R5bGUud2lkdGggPSAoY2VsbEluZm8ud2lkdGggKyAxKSArICdweCc7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IChjZWxsSW5mby5oZWlnaHQgKyAxKSArICdweCc7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbW1pdCB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cnNvck1vdmVtZW50IC0gQ3Vyc29yIG1vdmUgZGlyZWN0aW9uIGJhc2VkIG9uIGtleXMgcHJlc3NlZCB0byBlbmQgdGhlIGVkaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIG9uIHZhbGlkIGlucHV0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgQ2VsbEVkaXRvci5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKGN1cnNvck1vdmVtZW50KSB7XG4gICAgICAgIGlmIChjdXJzb3JNb3ZlbWVudCA9PT0gdm9pZCAwKSB7IGN1cnNvck1vdmVtZW50ID0gJ25vbmUnOyB9XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldElucHV0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklucHV0IGVycm9yOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5vbkNvbW1pdCkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbW1pdCh7XG4gICAgICAgICAgICAgICAgY2VsbDogdGhpcy5jZWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjdXJzb3JNb3ZlbWVudDogY3Vyc29yTW92ZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvbnRhaW5lciBlbGVtZW50cyBuZWVkZWQgdG8gcHJldmVudCBlZGl0b3Igd2lkZ2V0IG92ZXJmbG93XG4gICAgICogYmV5b25kIHZpZXdwb3J0IGFuZCB0byBwb3NpdGlvbiBjZWxsIGVkaXRvciB3aWRnZXQuXG4gICAgICovXG4gICAgQ2VsbEVkaXRvci5wcm90b3R5cGUuX2FkZENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aWV3cG9ydE9jY2x1ZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudmlld3BvcnRPY2NsdWRlci5jbGFzc05hbWUgPSAnbG0tRGF0YUdyaWQtY2VsbEVkaXRvck9jY2x1ZGVyJztcbiAgICAgICAgdGhpcy5jZWxsLmdyaWQubm9kZS5hcHBlbmRDaGlsZCh0aGlzLnZpZXdwb3J0T2NjbHVkZXIpO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5jbGFzc05hbWUgPSAnbG0tRGF0YUdyaWQtY2VsbEVkaXRvckNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMudmlld3BvcnRPY2NsdWRlci5hcHBlbmRDaGlsZCh0aGlzLmVkaXRvckNvbnRhaW5lcik7XG4gICAgICAgIC8vIHVwZGF0ZSBtb3VzZSBldmVudCBwYXNzLXRocm91Z2ggc3RhdGUgYmFzZWQgb24gaW5wdXQgdmFsaWRpdHlcbiAgICAgICAgdGhpcy5lZGl0b3JDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMudmlld3BvcnRPY2NsdWRlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gX3RoaXMuX3ZhbGlkSW5wdXQgPyAnbm9uZScgOiAnYXV0byc7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy52aWV3cG9ydE9jY2x1ZGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHZhbGlkaXR5IG5vdGlmaWNhdGlvbiBwb3B1cC5cbiAgICAgKi9cbiAgICBDZWxsRWRpdG9yLnByb3RvdHlwZS5fY2xvc2VWYWxpZGl0eU5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRpdHlOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRpdHlOb3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRpdHlOb3RpZmljYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbEVkaXRvcjtcbn0oKSk7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3Mgd2l0aCBzaGFyZWQgZnVuY3Rpb25hbGl0eVxuICogZm9yIGNlbGwgZWRpdG9ycyB3aGljaCB1c2UgSFRNTCBJbnB1dCB3aWRnZXQgYXMgZWRpdG9yLlxuICovXG52YXIgSW5wdXRDZWxsRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnB1dENlbGxFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5wdXRDZWxsRWRpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBET00gZXZlbnQgc2VudCB0byB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIElucHV0Q2VsbEVkaXRvci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmx1cic6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25CbHVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vbklucHV0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgSW5wdXRDZWxsRWRpdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdW5iaW5kRXZlbnRzKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgZWRpdGluZyB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBJbnB1dENlbGxFZGl0b3IucHJvdG90eXBlLnN0YXJ0RWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVXaWRnZXQoKTtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGw7XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMuZ2V0Q2VsbEluZm8oY2VsbCk7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB0aGlzLmRlc2VyaWFsaXplKGNlbGxJbmZvLmRhdGEpO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmlucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB0aGlzLmlucHV0LnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9O1xuICAgIElucHV0Q2VsbEVkaXRvci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIElucHV0Q2VsbEVkaXRvci5wcm90b3R5cGUuY3JlYXRlV2lkZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdsbS1EYXRhR3JpZC1jZWxsRWRpdG9yV2lkZ2V0Jyk7XG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2xtLURhdGFHcmlkLWNlbGxFZGl0b3JJbnB1dCcpO1xuICAgICAgICBpbnB1dC5zcGVsbGNoZWNrID0gZmFsc2U7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0aGlzLmlucHV0VHlwZTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIH07XG4gICAgSW5wdXRDZWxsRWRpdG9yLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzKTtcbiAgICB9O1xuICAgIElucHV0Q2VsbEVkaXRvci5wcm90b3R5cGUuX3VuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcyk7XG4gICAgfTtcbiAgICBJbnB1dENlbGxFZGl0b3IucHJvdG90eXBlLl9vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChnZXRLZXlib2FyZExheW91dCgpLmtleUZvcktleWRvd25FdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdChldmVudC5zaGlmdEtleSA/ICd1cCcgOiAnZG93bicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdChldmVudC5zaGlmdEtleSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0Q2VsbEVkaXRvci5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbW1pdCgpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0Q2VsbEVkaXRvci5wcm90b3R5cGUuX29uSW5wdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQuZW1pdCh2b2lkIDApO1xuICAgIH07XG4gICAgcmV0dXJuIElucHV0Q2VsbEVkaXRvcjtcbn0oQ2VsbEVkaXRvcikpO1xuLyoqXG4gKiBDZWxsIGVkaXRvciBmb3IgdGV4dCBjZWxscy5cbiAqL1xudmFyIFRleHRDZWxsRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0Q2VsbEVkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0Q2VsbEVkaXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlucHV0VHlwZSA9ICd0ZXh0JztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgdGV4dCBpbnB1dCBlbnRlcmVkLlxuICAgICAqL1xuICAgIFRleHRDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dENlbGxFZGl0b3I7XG59KElucHV0Q2VsbEVkaXRvcikpO1xuLyoqXG4gKiBDZWxsIGVkaXRvciBmb3IgcmVhbCBudW1iZXIgY2VsbHMuXG4gKi9cbnZhciBOdW1iZXJDZWxsRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdW1iZXJDZWxsRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bWJlckNlbGxFZGl0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbnB1dFR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBlZGl0aW5nIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIE51bWJlckNlbGxFZGl0b3IucHJvdG90eXBlLnN0YXJ0RWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zdGFydEVkaXRpbmcuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zdGVwID0gJ2FueSc7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjZWxsLmdyaWQuZGF0YU1vZGVsLm1ldGFkYXRhKCdib2R5JywgY2VsbC5yb3csIGNlbGwuY29sdW1uKTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBtZXRhZGF0YS5jb25zdHJhaW50O1xuICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQubWluaW11bSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQubWluID0gY29uc3RyYWludC5taW5pbXVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQubWF4aW11bSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQubWF4ID0gY29uc3RyYWludC5tYXhpbXVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgbnVtYmVyIGlucHV0IGVudGVyZWQuIFRoaXMgbWV0aG9kIHRocm93cyBleGNlcHRpb25cbiAgICAgKiBpZiBpbnB1dCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIE51bWJlckNlbGxFZGl0b3IucHJvdG90eXBlLmdldElucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzTmFOKGZsb2F0VmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxvYXRWYWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBOdW1iZXJDZWxsRWRpdG9yO1xufShJbnB1dENlbGxFZGl0b3IpKTtcbi8qKlxuICogQ2VsbCBlZGl0b3IgZm9yIGludGVnZXIgY2VsbHMuXG4gKi9cbnZhciBJbnRlZ2VyQ2VsbEVkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW50ZWdlckNlbGxFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW50ZWdlckNlbGxFZGl0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbnB1dFR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBlZGl0aW5nIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIEludGVnZXJDZWxsRWRpdG9yLnByb3RvdHlwZS5zdGFydEVkaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc3RhcnRFZGl0aW5nLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXQuc3RlcCA9ICcxJztcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGw7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGNlbGwuZ3JpZC5kYXRhTW9kZWwubWV0YWRhdGEoJ2JvZHknLCBjZWxsLnJvdywgY2VsbC5jb2x1bW4pO1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IG1ldGFkYXRhLmNvbnN0cmFpbnQ7XG4gICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5taW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5taW4gPSBjb25zdHJhaW50Lm1pbmltdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5tYXhpbXVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5tYXggPSBjb25zdHJhaW50Lm1heGltdW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBpbnRlZ2VyIGlucHV0IGVudGVyZWQuIFRoaXMgbWV0aG9kIHRocm93cyBleGNlcHRpb25cbiAgICAgKiBpZiBpbnB1dCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIEludGVnZXJDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzTmFOKGludFZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludFZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVnZXJDZWxsRWRpdG9yO1xufShJbnB1dENlbGxFZGl0b3IpKTtcbi8qKlxuICogQ2VsbCBlZGl0b3IgZm9yIGRhdGUgY2VsbHMuXG4gKi9cbnZhciBEYXRlQ2VsbEVkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZUNlbGxFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNlbGxFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIERPTSBldmVudCBzZW50IHRvIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgRGF0ZUNlbGxFZGl0b3IucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JsdXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uQmx1cihldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIERhdGVDZWxsRWRpdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdW5iaW5kRXZlbnRzKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgZWRpdGluZyB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBEYXRlQ2VsbEVkaXRvci5wcm90b3R5cGUuc3RhcnRFZGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVXaWRnZXQoKTtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGw7XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMuZ2V0Q2VsbEluZm8oY2VsbCk7XG4gICAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdGhpcy5fZGVzZXJpYWxpemUoY2VsbEluZm8uZGF0YSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2lucHV0KTtcbiAgICAgICAgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGRhdGUgaW5wdXQgZW50ZXJlZC5cbiAgICAgKi9cbiAgICBEYXRlQ2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgICB9O1xuICAgIERhdGVDZWxsRWRpdG9yLnByb3RvdHlwZS5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIERhdGVDZWxsRWRpdG9yLnByb3RvdHlwZS5fY3JlYXRlV2lkZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC50eXBlID0gJ2RhdGUnO1xuICAgICAgICBpbnB1dC5wYXR0ZXJuID0gXCJcXGR7NH0tXFxkezJ9LVxcZHsyfVwiO1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdsbS1EYXRhR3JpZC1jZWxsRWRpdG9yV2lkZ2V0Jyk7XG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2xtLURhdGFHcmlkLWNlbGxFZGl0b3JJbnB1dCcpO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgIH07XG4gICAgRGF0ZUNlbGxFZGl0b3IucHJvdG90eXBlLl9iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzKTtcbiAgICB9O1xuICAgIERhdGVDZWxsRWRpdG9yLnByb3RvdHlwZS5fdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzKTtcbiAgICB9O1xuICAgIERhdGVDZWxsRWRpdG9yLnByb3RvdHlwZS5fb25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZ2V0S2V5Ym9hcmRMYXlvdXQoKS5rZXlGb3JLZXlkb3duRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXQoZXZlbnQuc2hpZnRLZXkgPyAndXAnIDogJ2Rvd24nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXQoZXZlbnQuc2hpZnRLZXkgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRlQ2VsbEVkaXRvci5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbW1pdCgpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZUNlbGxFZGl0b3I7XG59KENlbGxFZGl0b3IpKTtcbi8qKlxuICogQ2VsbCBlZGl0b3IgZm9yIGJvb2xlYW4gY2VsbHMuXG4gKi9cbnZhciBCb29sZWFuQ2VsbEVkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm9vbGVhbkNlbGxFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQm9vbGVhbkNlbGxFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgZWRpdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIERPTSBldmVudCBzZW50IHRvIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgQm9vbGVhbkNlbGxFZGl0b3IucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgLy8gZml4IGZvY3VzIGxvc3MgcHJvYmxlbSBpbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBCb29sZWFuQ2VsbEVkaXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuYmluZEV2ZW50cygpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGVkaXRpbmcgdGhlIGNlbGwuXG4gICAgICovXG4gICAgQm9vbGVhbkNlbGxFZGl0b3IucHJvdG90eXBlLnN0YXJ0RWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlV2lkZ2V0KCk7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsO1xuICAgICAgICB2YXIgY2VsbEluZm8gPSB0aGlzLmdldENlbGxJbmZvKGNlbGwpO1xuICAgICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdGhpcy5fZGVzZXJpYWxpemUoY2VsbEluZm8uZGF0YSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2lucHV0KTtcbiAgICAgICAgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGJvb2xlYW4gaW5wdXQgZW50ZXJlZC5cbiAgICAgKi9cbiAgICBCb29sZWFuQ2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5jaGVja2VkO1xuICAgIH07XG4gICAgQm9vbGVhbkNlbGxFZGl0b3IucHJvdG90eXBlLl9kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSB0cnVlO1xuICAgIH07XG4gICAgQm9vbGVhbkNlbGxFZGl0b3IucHJvdG90eXBlLl9jcmVhdGVXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2xtLURhdGFHcmlkLWNlbGxFZGl0b3JXaWRnZXQnKTtcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnbG0tRGF0YUdyaWQtY2VsbEVkaXRvckNoZWNrYm94Jyk7XG4gICAgICAgIGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICBpbnB1dC5zcGVsbGNoZWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgfTtcbiAgICBCb29sZWFuQ2VsbEVkaXRvci5wcm90b3R5cGUuX2JpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzKTtcbiAgICB9O1xuICAgIEJvb2xlYW5DZWxsRWRpdG9yLnByb3RvdHlwZS5fdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcyk7XG4gICAgfTtcbiAgICBCb29sZWFuQ2VsbEVkaXRvci5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGdldEtleWJvYXJkTGF5b3V0KCkua2V5Rm9yS2V5ZG93bkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0KGV2ZW50LnNoaWZ0S2V5ID8gJ3VwJyA6ICdkb3duJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0KGV2ZW50LnNoaWZ0S2V5ID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQm9vbGVhbkNlbGxFZGl0b3IucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb21taXQoKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJvb2xlYW5DZWxsRWRpdG9yO1xufShDZWxsRWRpdG9yKSk7XG4vKipcbiAqIENlbGwgZWRpdG9yIGZvciBvcHRpb24gY2VsbHMuXG4gKlxuICogSXQgc3VwcG9ydHMgbXVsdGlwbGUgb3B0aW9uIHNlbGVjdGlvbi4gSWYgY2VsbCBtZXRhZGF0YSBjb250YWluc1xuICogdHlwZSBhdHRyaWJ1dGUgJ2FycmF5JywgdGhlbiBpdCBiZWhhdmVzIGFzIGEgbXVsdGkgc2VsZWN0LlxuICogSW4gdGhhdCBjYXNlIGNlbGwgZGF0YSBpcyBleHBlY3RlZCB0byBiZSBsaXN0IG9mIHN0cmluZyB2YWx1ZXMuXG4gKi9cbnZhciBPcHRpb25DZWxsRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcHRpb25DZWxsRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9wdGlvbkNlbGxFZGl0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5faXNNdWx0aVNlbGVjdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIE9wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzTXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5fc2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgZWRpdGluZyB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBPcHRpb25DZWxsRWRpdG9yLnByb3RvdHlwZS5zdGFydEVkaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsO1xuICAgICAgICB2YXIgY2VsbEluZm8gPSB0aGlzLmdldENlbGxJbmZvKGNlbGwpO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjZWxsLmdyaWQuZGF0YU1vZGVsLm1ldGFkYXRhKCdib2R5JywgY2VsbC5yb3csIGNlbGwuY29sdW1uKTtcbiAgICAgICAgdGhpcy5faXNNdWx0aVNlbGVjdCA9IG1ldGFkYXRhLnR5cGUgPT09ICdhcnJheSc7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVdpZGdldCgpO1xuICAgICAgICBpZiAodGhpcy5faXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl9kZXNlcmlhbGl6ZShjZWxsSW5mby5kYXRhKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5fc2VsZWN0Lm9wdGlvbnMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdC52YWx1ZSA9IHRoaXMuX2Rlc2VyaWFsaXplKGNlbGxJbmZvLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWxlY3QuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgb3B0aW9uIGlucHV0LlxuICAgICAqL1xuICAgIE9wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLmdldElucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlbGVjdC5zZWxlY3RlZE9wdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHRoaXMuX3NlbGVjdC5zZWxlY3RlZE9wdGlvbnMuaXRlbShpKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9uIGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIE9wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5faXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMuZ2V0Q2VsbEluZm8odGhpcy5jZWxsKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdmFyIGVkaXRvckNvbnRhaW5lclJlY3QgPSB0aGlzLmVkaXRvckNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0LnN0eWxlLmxlZnQgPSBlZGl0b3JDb250YWluZXJSZWN0LmxlZnQgKyAncHgnO1xuICAgICAgICB0aGlzLl9zZWxlY3Quc3R5bGUudG9wID0gKGVkaXRvckNvbnRhaW5lclJlY3QudG9wICsgY2VsbEluZm8uaGVpZ2h0KSArICdweCc7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5zdHlsZS53aWR0aCA9IGVkaXRvckNvbnRhaW5lclJlY3Qud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl9zZWxlY3Quc3R5bGUubWF4SGVpZ2h0ID0gJzYwcHgnO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfTtcbiAgICBPcHRpb25DZWxsRWRpdG9yLnByb3RvdHlwZS5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB2YWx1ZV8xID0gdmFsdWU7IF9pIDwgdmFsdWVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB2YWx1ZV8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLl9jcmVhdGVXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjZWxsLmdyaWQuZGF0YU1vZGVsLm1ldGFkYXRhKCdib2R5JywgY2VsbC5yb3csIGNlbGwuY29sdW1uKTtcbiAgICAgICAgdmFyIGl0ZW1zID0gbWV0YWRhdGEuY29uc3RyYWludC5lbnVtO1xuICAgICAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHNlbGVjdC5jbGFzc0xpc3QuYWRkKCdsbS1EYXRhR3JpZC1jZWxsRWRpdG9yV2lkZ2V0Jyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaXRlbXNfMSA9IGl0ZW1zOyBfaSA8IGl0ZW1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zXzFbX2ldO1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBpdGVtO1xuICAgICAgICAgICAgb3B0aW9uLnRleHQgPSBpdGVtO1xuICAgICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VsZWN0ID0gc2VsZWN0O1xuICAgIH07XG4gICAgT3B0aW9uQ2VsbEVkaXRvci5wcm90b3R5cGUuX2JpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9zZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uQmx1ci5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIE9wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLl9vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChnZXRLZXlib2FyZExheW91dCgpLmtleUZvcktleWRvd25FdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdChldmVudC5zaGlmdEtleSA/ICd1cCcgOiAnZG93bicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdChldmVudC5zaGlmdEtleSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb21taXQoKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPcHRpb25DZWxsRWRpdG9yO1xufShDZWxsRWRpdG9yKSk7XG4vKipcbiAqIENlbGwgZWRpdG9yIGZvciBvcHRpb24gY2VsbHMgd2hvc2UgdmFsdWUgY2FuIGJlIGFueSB2YWx1ZVxuICogZnJvbSBzZXQgb2YgcHJlLWRlZmluZWQgb3B0aW9ucyBvciB2YWx1ZXMgdGhhdCBjYW4gYmUgaW5wdXQgYnkgdXNlci5cbiAqL1xudmFyIER5bmFtaWNPcHRpb25DZWxsRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEeW5hbWljT3B0aW9uQ2VsbEVkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEeW5hbWljT3B0aW9uQ2VsbEVkaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIERPTSBldmVudHMgZm9yIHRoZSBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IHNlbnQgdG8gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBEeW5hbWljT3B0aW9uQ2VsbEVkaXRvci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmx1cic6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25CbHVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgY2VsbCBlZGl0b3IuXG4gICAgICovXG4gICAgRHluYW1pY09wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91bmJpbmRFdmVudHMoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBlZGl0aW5nIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIER5bmFtaWNPcHRpb25DZWxsRWRpdG9yLnByb3RvdHlwZS5zdGFydEVkaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVdpZGdldCgpO1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbDtcbiAgICAgICAgdmFyIGNlbGxJbmZvID0gdGhpcy5nZXRDZWxsSW5mbyhjZWxsKTtcbiAgICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB0aGlzLl9kZXNlcmlhbGl6ZShjZWxsSW5mby5kYXRhKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5faW5wdXQpO1xuICAgICAgICB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICB0aGlzLl9pbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IG9wdGlvbiBpbnB1dC5cbiAgICAgKi9cbiAgICBEeW5hbWljT3B0aW9uQ2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgICB9O1xuICAgIER5bmFtaWNPcHRpb25DZWxsRWRpdG9yLnByb3RvdHlwZS5fZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIER5bmFtaWNPcHRpb25DZWxsRWRpdG9yLnByb3RvdHlwZS5fY3JlYXRlV2lkZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbDtcbiAgICAgICAgdmFyIGdyaWQgPSBjZWxsLmdyaWQ7XG4gICAgICAgIHZhciBkYXRhTW9kZWwgPSBncmlkLmRhdGFNb2RlbDtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gZGF0YU1vZGVsLnJvd0NvdW50KCdib2R5Jyk7XG4gICAgICAgIHZhciBsaXN0SWQgPSAnY2VsbC1lZGl0b3ItbGlzdCc7XG4gICAgICAgIHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgbGlzdC5pZCA9IGxpc3RJZDtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnbG0tRGF0YUdyaWQtY2VsbEVkaXRvcldpZGdldCcpO1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdsbS1EYXRhR3JpZC1jZWxsRWRpdG9ySW5wdXQnKTtcbiAgICAgICAgdmFyIHZhbHVlU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyArK3IpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YU1vZGVsLmRhdGEoJ2JvZHknLCByLCBjZWxsLmNvbHVtbik7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhbHVlU2V0LmFkZChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZVNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICBsaXN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0KTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdsaXN0JywgbGlzdElkKTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICB9O1xuICAgIER5bmFtaWNPcHRpb25DZWxsRWRpdG9yLnByb3RvdHlwZS5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcyk7XG4gICAgfTtcbiAgICBEeW5hbWljT3B0aW9uQ2VsbEVkaXRvci5wcm90b3R5cGUuX3VuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcyk7XG4gICAgfTtcbiAgICBEeW5hbWljT3B0aW9uQ2VsbEVkaXRvci5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGdldEtleWJvYXJkTGF5b3V0KCkua2V5Rm9yS2V5ZG93bkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0KGV2ZW50LnNoaWZ0S2V5ID8gJ3VwJyA6ICdkb3duJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0KGV2ZW50LnNoaWZ0S2V5ID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHluYW1pY09wdGlvbkNlbGxFZGl0b3IucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb21taXQoKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIER5bmFtaWNPcHRpb25DZWxsRWRpdG9yO1xufShDZWxsRWRpdG9yKSk7XG5cbi8qKlxuICogQW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHRoZSBkYXRhIGZvciBhIGRhdGEgZ3JpZC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBJZiB0aGUgcHJlZGVmaW5lZCBkYXRhIG1vZGVscyBhcmUgaW5zdWZmaWNpZW50IGZvciBhIHBhcnRpY3VsYXIgdXNlXG4gKiBjYXNlLCBhIGN1c3RvbSBtb2RlbCBjYW4gYmUgZGVmaW5lZCB3aGljaCBkZXJpdmVzIGZyb20gdGhpcyBjbGFzcy5cbiAqL1xudmFyIERhdGFNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhTW9kZWwoKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU1vZGVsLnByb3RvdHlwZSwgXCJjaGFuZ2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgZGF0YSBtb2RlbCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWV0YWRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgY2VsbCByZWdpb24gb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93IC0gVGhlIHJvdyBpbmRleCBvZiB0aGUgY2VsbCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIGluZGV4IG9mIHRoZSBjZWxsIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGNlbGwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIHJldHVybmVkIG1ldGFkYXRhIHNob3VsZCBiZSB0cmVhdGVkIGFzIGltbXV0YWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvZnRlbiwgYW5kIHNvIHNob3VsZCBiZSBlZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGB7fWAuXG4gICAgICovXG4gICAgRGF0YU1vZGVsLnByb3RvdHlwZS5tZXRhZGF0YSA9IGZ1bmN0aW9uIChyZWdpb24sIHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBEYXRhTW9kZWwuZW1wdHlNZXRhZGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGBjaGFuZ2VkYCBzaWduYWwgZm9yIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2Qgd2hlbmV2ZXIgdGhlIGRhdGEgbW9kZWwgaGFzXG4gICAgICogY2hhbmdlZCBzbyB0aGF0IGF0dGFjaGVkIGRhdGEgZ3JpZHMgY2FuIHVwZGF0ZSB0aGVtc2VsdmVzLlxuICAgICAqL1xuICAgIERhdGFNb2RlbC5wcm90b3R5cGUuZW1pdENoYW5nZWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQoYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YU1vZGVsO1xufSgpKTtcbi8qKlxuICogQW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHRoZSBtdXRhYmxlIGRhdGEgZm9yIGEgZGF0YSBncmlkLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgb2JqZWN0IGlzIGFuIGV4dGVuc2lvbiB0byBgRGF0YU1vZGVsYCBhbmQgaXQgb25seSBhZGRzIGFiaWxpdHkgdG9cbiAqIGNoYW5nZSBkYXRhIGZvciBjZWxscy5cbiAqL1xudmFyIE11dGFibGVEYXRhTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11dGFibGVEYXRhTW9kZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXV0YWJsZURhdGFNb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTXV0YWJsZURhdGFNb2RlbDtcbn0oRGF0YU1vZGVsKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgRGF0YU1vZGVsYCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKERhdGFNb2RlbCkge1xuICAgIC8qKlxuICAgICAqIEEgc2luZ2xldG9uIGVtcHR5IG1ldGFkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBEYXRhTW9kZWwuZW1wdHlNZXRhZGF0YSA9IE9iamVjdC5mcmVlemUoe30pO1xufSkoRGF0YU1vZGVsIHx8IChEYXRhTW9kZWwgPSB7fSkpO1xuXG4vKipcbiAqIEEgdGhpbiBjYWNoaW5nIHdyYXBwZXIgYXJvdW5kIGEgMkQgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0LlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgaXMgbW9zdGx5IGEgdHJhbnNwYXJlbnQgd3JhcHBlciBhcm91bmQgYSBjYW52YXMgcmVuZGVyaW5nXG4gKiBjb250ZXh0IHdoaWNoIGltcHJvdmVzIHBlcmZvcm1hbmNlIHdoZW4gd3JpdGluZyBjb250ZXh0IHN0YXRlLlxuICpcbiAqIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBhdm9pZCByZWFkaW5nIHN0YXRlIGZyb20gdGhlIGBnY2AuIFdyaXRlcyBhcmVcbiAqIGNhY2hlZCBiYXNlZCBvbiB0aGUgcHJldmlvdXNseSB3cml0dGVuIHZhbHVlLlxuICpcbiAqIFVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLCB0aGUgQVBJIGFuZCBzZW1hbnRpY3Mgb2YgdGhpcyBjbGFzcyBhcmVcbiAqIGlkZW50aWNhbCB0byB0aGUgYnVpbHRpbiAyRCBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHQ6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gKlxuICogVGhlIHdyYXBwZWQgY2FudmFzIGNvbnRleHQgc2hvdWxkIG5vdCBiZSBtYW5pcHVsYXRlZCBleHRlcm5hbGx5XG4gKiB1bnRpbCB0aGUgd3JhcHBpbmcgYEdyYXBoaWNzQ29udGV4dGAgb2JqZWN0IGlzIGRpc3Bvc2VkLlxuICovXG52YXIgR3JhcGhpY3NDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBncmFwaGljcyBjb250ZXh0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIDJEIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dCB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoaWNzQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFByaXZhdGUkMy5TdGF0ZS5jcmVhdGUoY29udGV4dCk7XG4gICAgfVxuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgZ2MgaXMgYWxyZWFkeSBkaXNwb3NlZC5cbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayB0aGUgZ2MgYXMgZGlzcG9zZWQuXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gUG9wIGFueSB1bnJlc3RvcmVkIHNhdmVzLlxuICAgICAgICB3aGlsZSAodGhpcy5fc3RhdGUubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZS5uZXh0O1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcImlzRGlzcG9zZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwiZmlsbFN0eWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUuZmlsbFN0eWxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmZpbGxTdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcInN0cm9rZVN0eWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zdHJva2VTdHlsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zdHJva2VTdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwiZm9udFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5mb250ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC50ZXh0QWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUudGV4dEFsaWduICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnRleHRBbGlnbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQudGV4dEFsaWduID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcInRleHRCYXNlbGluZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQudGV4dEJhc2VsaW5lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnRleHRCYXNlbGluZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS50ZXh0QmFzZWxpbmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRleHRCYXNlbGluZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZSwgXCJsaW5lQ2FwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5saW5lQ2FwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmxpbmVDYXAgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUubGluZUNhcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZUNhcCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQubGluZURhc2hPZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUubGluZURhc2hPZmZzZXQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUubGluZURhc2hPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcImxpbmVKb2luXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5saW5lSm9pbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5saW5lSm9pbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5saW5lSm9pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZUpvaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwibGluZVdpZHRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5saW5lV2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUubGluZVdpZHRoICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmxpbmVXaWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVdpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcIm1pdGVyTGltaXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Lm1pdGVyTGltaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUubWl0ZXJMaW1pdCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5taXRlckxpbWl0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5taXRlckxpbWl0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcInNoYWRvd0JsdXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2hhZG93Qmx1ciAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zaGFkb3dCbHVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcInNoYWRvd0NvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zaGFkb3dDb2xvciAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zaGFkb3dDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwic2hhZG93T2Zmc2V0WFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zaGFkb3dPZmZzZXRYICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNoYWRvd09mZnNldFggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFggPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwic2hhZG93T2Zmc2V0WVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zaGFkb3dPZmZzZXRZICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNoYWRvd09mZnNldFkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFkgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLCBcImdsb2JhbEFscGhhXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nbG9iYWxBbHBoYSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5nbG9iYWxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuZ2V0TGluZURhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldExpbmVEYXNoKCk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLnNldExpbmVEYXNoID0gZnVuY3Rpb24gKHNlZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2V0TGluZURhc2goc2VnbWVudHMpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2NhbGUoeCwgeSk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zZm9ybShtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDbG9uZSBhbiBwdXNoIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBzdGFjay5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBQcml2YXRlJDMuU3RhdGUucHVzaCh0aGlzLl9zdGF0ZSk7XG4gICAgICAgIC8vIFNhdmUgdGhlIHdyYXBwZWQgY29udGV4dCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fY29udGV4dC5zYXZlKCk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gc3RhdGUgdG8gcmVzdG9yZS5cbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wIHRoZSBzYXZlZCBzdGF0ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBQcml2YXRlJDMuU3RhdGUucG9wKHRoaXMuX3N0YXRlKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgd3JhcHBlZCBjb250ZXh0IHN0YXRlLlxuICAgICAgICB0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5pc1BvaW50SW5QYXRoID0gZnVuY3Rpb24gKHgsIHksIGZpbGxSdWxlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9jb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9jb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSwgZmlsbFJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLmFyY1RvID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXNYLCByYWRpdXNZLCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZWxsaXBzZSh4LCB5LCByYWRpdXNYLCByYWRpdXNZLCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5lbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHJvdGF0aW9uLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKGNweCwgY3B5LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAoZmlsbFJ1bGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGlwKGZpbGxSdWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKGZpbGxSdWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbChmaWxsUnVsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5jbGVhclJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLmZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuZmlsbFRleHQgPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgbWF4V2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHksIG1heFdpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5zdHJva2VSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VSZWN0KHgsIHksIHcsIGgpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5zdHJva2VUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIG1heFdpZHRoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSwgbWF4V2lkdGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUxpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgwLCB5MCwgeDEsIHkxKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVQYXR0ZXJuKGltYWdlLCByZXBldGl0aW9uKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlSW1hZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVJbWFnZURhdGEuYXBwbHkodGhpcy5fY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24gKHN4LCBzeSwgc3csIHNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEltYWdlRGF0YShzeCwgc3ksIHN3LCBzaCk7XG4gICAgfTtcbiAgICBHcmFwaGljc0NvbnRleHQucHJvdG90eXBlLnB1dEltYWdlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5wdXRJbWFnZURhdGEuYXBwbHkodGhpcy5fY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUuZHJhd0ltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbWFnZS5hcHBseSh0aGlzLl9jb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZS5kcmF3Rm9jdXNJZk5lZWRlZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0ZvY3VzSWZOZWVkZWQoZWxlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhpY3NDb250ZXh0O1xufSgpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSQzO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIG5leHQgdmFsaWQgcG9vbCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHBpID0gLTE7XG4gICAgLyoqXG4gICAgICogQSBzdGF0ZSBvYmplY3QgYWxsb2NhdGlvbiBwb29sLlxuICAgICAqL1xuICAgIHZhciBwb29sID0gW107XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHdoaWNoIGhvbGRzIHRoZSBzdGF0ZSBmb3IgYSBnYy5cbiAgICAgKi9cbiAgICB2YXIgU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0YXRlKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBnYyBzdGF0ZSBvYmplY3QgZnJvbSBhIDJEIGNhbnZhcyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHBpIDwgMCA/IG5ldyBTdGF0ZSgpIDogcG9vbFtwaS0tXTtcbiAgICAgICAgICAgIHN0YXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUuZmlsbFN0eWxlID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgICAgICBzdGF0ZS5mb250ID0gY29udGV4dC5mb250O1xuICAgICAgICAgICAgc3RhdGUuZ2xvYmFsQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgICAgICAgc3RhdGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgICAgICBzdGF0ZS5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICAgICAgICAgIHN0YXRlLmxpbmVDYXAgPSBjb250ZXh0LmxpbmVDYXA7XG4gICAgICAgICAgICBzdGF0ZS5saW5lRGFzaE9mZnNldCA9IGNvbnRleHQubGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICBzdGF0ZS5saW5lSm9pbiA9IGNvbnRleHQubGluZUpvaW47XG4gICAgICAgICAgICBzdGF0ZS5saW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgICAgIHN0YXRlLm1pdGVyTGltaXQgPSBjb250ZXh0Lm1pdGVyTGltaXQ7XG4gICAgICAgICAgICBzdGF0ZS5zaGFkb3dCbHVyID0gY29udGV4dC5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgc3RhdGUuc2hhZG93Q29sb3IgPSBjb250ZXh0LnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgc3RhdGUuc2hhZG93T2Zmc2V0WCA9IGNvbnRleHQuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIHN0YXRlLnNoYWRvd09mZnNldFkgPSBjb250ZXh0LnNoYWRvd09mZnNldFk7XG4gICAgICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBzdGF0ZS50ZXh0QWxpZ24gPSBjb250ZXh0LnRleHRBbGlnbjtcbiAgICAgICAgICAgIHN0YXRlLnRleHRCYXNlbGluZSA9IGNvbnRleHQudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmUgYW4gZXhpc3RpbmcgZ2Mgc3RhdGUgb2JqZWN0IGFuZCBhZGQgaXQgdG8gdGhlIHN0YXRlIHN0YWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdGUucHVzaCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcGkgPCAwID8gbmV3IFN0YXRlKCkgOiBwb29sW3BpLS1dO1xuICAgICAgICAgICAgc3RhdGUubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgc3RhdGUuZmlsbFN0eWxlID0gb3RoZXIuZmlsbFN0eWxlO1xuICAgICAgICAgICAgc3RhdGUuZm9udCA9IG90aGVyLmZvbnQ7XG4gICAgICAgICAgICBzdGF0ZS5nbG9iYWxBbHBoYSA9IG90aGVyLmdsb2JhbEFscGhhO1xuICAgICAgICAgICAgc3RhdGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gb3RoZXIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgICAgc3RhdGUuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gb3RoZXIuaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgICAgICAgICAgc3RhdGUubGluZUNhcCA9IG90aGVyLmxpbmVDYXA7XG4gICAgICAgICAgICBzdGF0ZS5saW5lRGFzaE9mZnNldCA9IG90aGVyLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICAgICAgc3RhdGUubGluZUpvaW4gPSBvdGhlci5saW5lSm9pbjtcbiAgICAgICAgICAgIHN0YXRlLmxpbmVXaWR0aCA9IG90aGVyLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIHN0YXRlLm1pdGVyTGltaXQgPSBvdGhlci5taXRlckxpbWl0O1xuICAgICAgICAgICAgc3RhdGUuc2hhZG93Qmx1ciA9IG90aGVyLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICBzdGF0ZS5zaGFkb3dDb2xvciA9IG90aGVyLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgc3RhdGUuc2hhZG93T2Zmc2V0WCA9IG90aGVyLnNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBzdGF0ZS5zaGFkb3dPZmZzZXRZID0gb3RoZXIuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlID0gb3RoZXIuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBzdGF0ZS50ZXh0QWxpZ24gPSBvdGhlci50ZXh0QWxpZ247XG4gICAgICAgICAgICBzdGF0ZS50ZXh0QmFzZWxpbmUgPSBvdGhlci50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3AgdGhlIG5leHQgc3RhdGUgb2JqZWN0IGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgdG8gdGhlIHBvb2xcbiAgICAgICAgICovXG4gICAgICAgIFN0YXRlLnBvcCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgc3RhdGUuZmlsbFN0eWxlID0gJyc7XG4gICAgICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSA9ICcnO1xuICAgICAgICAgICAgcG9vbFsrK3BpXSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm5leHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTdGF0ZTtcbiAgICB9KCkpO1xuICAgIFByaXZhdGUuU3RhdGUgPSBTdGF0ZTtcbn0pKFByaXZhdGUkMyB8fCAoUHJpdmF0ZSQzID0ge30pKTtcblxuLyoqXG4gKiBBIGNlbGwgcmVuZGVyZXIgd2hpY2ggcmVuZGVycyBkYXRhIHZhbHVlcyBhcyB0ZXh0LlxuICovXG52YXIgVGV4dFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0UmVuZGVyZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHRleHQgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZvbnQgPSBvcHRpb25zLmZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG4gICAgICAgIF90aGlzLnRleHRDb2xvciA9IG9wdGlvbnMudGV4dENvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgJyc7XG4gICAgICAgIF90aGlzLnZlcnRpY2FsQWxpZ25tZW50ID0gb3B0aW9ucy52ZXJ0aWNhbEFsaWdubWVudCB8fCAnY2VudGVyJztcbiAgICAgICAgX3RoaXMuaG9yaXpvbnRhbEFsaWdubWVudCA9IG9wdGlvbnMuaG9yaXpvbnRhbEFsaWdubWVudCB8fCAnbGVmdCc7XG4gICAgICAgIF90aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IFRleHRSZW5kZXJlci5mb3JtYXRHZW5lcmljKCk7XG4gICAgICAgIF90aGlzLmVsaWRlRGlyZWN0aW9uID0gb3B0aW9ucy5lbGlkZURpcmVjdGlvbiB8fCAncmlnaHQnO1xuICAgICAgICBfdGhpcy53cmFwVGV4dCA9IG9wdGlvbnMud3JhcFRleHQgfHwgZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNvbnRlbnQgZm9yIGEgY2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnYyAtIFRoZSBncmFwaGljcyBjb250ZXh0IHRvIHVzZSBmb3IgZHJhd2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBkYXRhIGZvciB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBUZXh0UmVuZGVyZXIucHJvdG90eXBlLnBhaW50ID0gZnVuY3Rpb24gKGdjLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChnYywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5kcmF3VGV4dChnYywgY29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGJhY2tncm91bmQgZm9yIHRoZSBjZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdjIC0gVGhlIGdyYXBoaWNzIGNvbnRleHQgdG8gdXNlIGZvciBkcmF3aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIGRhdGEgZm9yIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIFRleHRSZW5kZXJlci5wcm90b3R5cGUuZHJhd0JhY2tncm91bmQgPSBmdW5jdGlvbiAoZ2MsIGNvbmZpZykge1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgY2VsbC5cbiAgICAgICAgdmFyIGNvbG9yID0gQ2VsbFJlbmRlcmVyLnJlc29sdmVPcHRpb24odGhpcy5iYWNrZ3JvdW5kQ29sb3IsIGNvbmZpZyk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gYmFja2dyb3VuZCBjb2xvciB0byBkcmF3LlxuICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsbCB0aGUgY2VsbCB3aXRoIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QoY29uZmlnLngsIGNvbmZpZy55LCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgdGV4dCBmb3IgdGhlIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2MgLSBUaGUgZ3JhcGhpY3MgY29udGV4dCB0byB1c2UgZm9yIGRyYXdpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gZGF0YSBmb3IgdGhlIGNlbGwuXG4gICAgICovXG4gICAgVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uIChnYywgY29uZmlnKSB7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGZvbnQgZm9yIHRoZSBjZWxsLlxuICAgICAgICB2YXIgZm9udCA9IENlbGxSZW5kZXJlci5yZXNvbHZlT3B0aW9uKHRoaXMuZm9udCwgY29uZmlnKTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBmb250IHRvIGRyYXcuXG4gICAgICAgIGlmICghZm9udCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRleHQgY29sb3IgZm9yIHRoZSBjZWxsLlxuICAgICAgICB2YXIgY29sb3IgPSBDZWxsUmVuZGVyZXIucmVzb2x2ZU9wdGlvbih0aGlzLnRleHRDb2xvciwgY29uZmlnKTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyB0ZXh0IGNvbG9yIHRvIGRyYXcuXG4gICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3JtYXQgdGhlIGNlbGwgdmFsdWUgdG8gdGV4dC5cbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgICAgICB2YXIgdGV4dCA9IGZvcm1hdChjb25maWcpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIHRleHQgdG8gZHJhdy5cbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgYWxpZ25tZW50LlxuICAgICAgICB2YXIgdkFsaWduID0gQ2VsbFJlbmRlcmVyLnJlc29sdmVPcHRpb24odGhpcy52ZXJ0aWNhbEFsaWdubWVudCwgY29uZmlnKTtcbiAgICAgICAgdmFyIGhBbGlnbiA9IENlbGxSZW5kZXJlci5yZXNvbHZlT3B0aW9uKHRoaXMuaG9yaXpvbnRhbEFsaWdubWVudCwgY29uZmlnKTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgZWxpc2lvbiBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGVsaWRlRGlyZWN0aW9uID0gQ2VsbFJlbmRlcmVyLnJlc29sdmVPcHRpb24odGhpcy5lbGlkZURpcmVjdGlvbiwgY29uZmlnKTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGV4dCB3cmFwcGluZyBmbGFnXG4gICAgICAgIHZhciB3cmFwVGV4dCA9IENlbGxSZW5kZXJlci5yZXNvbHZlT3B0aW9uKHRoaXMud3JhcFRleHQsIGNvbmZpZyk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRlZCB0ZXh0IGJveCBoZWlnaHQgZm9yIHRoZSBzcGVjaWZpZWQgYWxpZ25tZW50LlxuICAgICAgICB2YXIgYm94SGVpZ2h0ID0gY29uZmlnLmhlaWdodCAtICh2QWxpZ24gPT09ICdjZW50ZXInID8gMSA6IDIpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSB0ZXh0IGJveCBoYXMgbm8gZWZmZWN0aXZlIHNpemUuXG4gICAgICAgIGlmIChib3hIZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHRleHQgaGVpZ2h0IGZvciB0aGUgZ2MgZm9udC5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSBUZXh0UmVuZGVyZXIubWVhc3VyZUZvbnRIZWlnaHQoZm9udCk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgdGV4dCBwb3NpdGlvbiB2YXJpYWJsZXMuXG4gICAgICAgIHZhciB0ZXh0WDtcbiAgICAgICAgdmFyIHRleHRZO1xuICAgICAgICB2YXIgYm94V2lkdGg7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIFkgcG9zaXRpb24gZm9yIHRoZSB0ZXh0LlxuICAgICAgICBzd2l0Y2ggKHZBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICB0ZXh0WSA9IGNvbmZpZy55ICsgMiArIHRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIHRleHRZID0gY29uZmlnLnkgKyBjb25maWcuaGVpZ2h0IC8gMiArIHRleHRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0ZXh0WSA9IGNvbmZpZy55ICsgY29uZmlnLmhlaWdodCAtIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgWCBwb3NpdGlvbiBmb3IgdGhlIHRleHQuXG4gICAgICAgIHN3aXRjaCAoaEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB0ZXh0WCA9IGNvbmZpZy54ICsgODtcbiAgICAgICAgICAgICAgICBib3hXaWR0aCA9IGNvbmZpZy53aWR0aCAtIDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB0ZXh0WCA9IGNvbmZpZy54ICsgY29uZmlnLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBib3hXaWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB0ZXh0WCA9IGNvbmZpZy54ICsgY29uZmlnLndpZHRoIC0gODtcbiAgICAgICAgICAgICAgICBib3hXaWR0aCA9IGNvbmZpZy53aWR0aCAtIDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsaXAgdGhlIGNlbGwgaWYgdGhlIHRleHQgaXMgdGFsbGVyIHRoYW4gdGhlIHRleHQgYm94IGhlaWdodC5cbiAgICAgICAgaWYgKHRleHRIZWlnaHQgPiBib3hIZWlnaHQpIHtcbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZ2MucmVjdChjb25maWcueCwgY29uZmlnLnksIGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCAtIDEpO1xuICAgICAgICAgICAgZ2MuY2xpcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgZ2Mgc3RhdGUuXG4gICAgICAgIGdjLmZvbnQgPSBmb250O1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZ2MudGV4dEFsaWduID0gaEFsaWduO1xuICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgdGV4dCB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSBnYy5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgLy8gQXBwbHkgdGV4dCB3cmFwcGluZyBpZiBlbmFibGVkLlxuICAgICAgICBpZiAod3JhcFRleHQgJiYgdGV4dFdpZHRoID4gYm94V2lkdGgpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib3ggY2xpcHBpbmcgaGFwcGVucy5cbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZ2MucmVjdChjb25maWcueCwgY29uZmlnLnksIGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCAtIDEpO1xuICAgICAgICAgICAgZ2MuY2xpcCgpO1xuICAgICAgICAgICAgLy8gU3BsaXQgY29sdW1uIG5hbWUgdG8gd29yZHMgYmFzZWQgb25cbiAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UgcHJlY2VkaW5nIGEgd29yZCBib3VuZGFyeS5cbiAgICAgICAgICAgIC8vIFwiSGVsbG8gIHdvcmxkXCIgLS0+IFtcIkhlbGxvICBcIiwgXCJ3b3JsZFwiXVxuICAgICAgICAgICAgdmFyIHdvcmRzSW5Db2x1bW4gPSB0ZXh0LnNwbGl0KC9cXHMoPz1cXGIpLyk7XG4gICAgICAgICAgICAvLyBZLWNvb3JkaW5hdGUgb2Zmc2V0IGZvciBhbnkgYWRkaXRpb25hbCBsaW5lc1xuICAgICAgICAgICAgdmFyIGN1clkgPSB0ZXh0WTtcbiAgICAgICAgICAgIHZhciB0ZXh0SW5DdXJyZW50TGluZSA9IHdvcmRzSW5Db2x1bW4uc2hpZnQoKTtcbiAgICAgICAgICAgIC8vIFNpbmdsZSB3b3JkLiBBcHBseWluZyB0ZXh0IHdyYXAgb24gd29yZCBieSBzcGxpdHRpbmdcbiAgICAgICAgICAgIC8vIGl0IGludG8gY2hhcmFjdGVycyBhbmQgZml0dGluZyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIGNoYXJhY3RlcnMgcG9zc2libGUgcGVyIGxpbmUgKGJveCB3aWR0aCkuXG4gICAgICAgICAgICBpZiAod29yZHNJbkNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyTGluZVRleHRXaWR0aCA9IGdjLm1lYXN1cmVUZXh0KHRleHRJbkN1cnJlbnRMaW5lKS53aWR0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyTGluZVRleHRXaWR0aCA+IGJveFdpZHRoICYmIHRleHRJbkN1cnJlbnRMaW5lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGluZyBmcm9tIHRoZSBlbmQgb2YgdGhlIHN0cmluZyB1bnRpbCB3ZSBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Vic3RyaW5nICgwLGkpIHdoaWNoIGhhcyBhIHdpZHRoIGxlc3MgdGhhbiB0aGUgYm94IHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGV4dEluQ3VycmVudExpbmUubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyU3ViU3RyaW5nID0gdGV4dEluQ3VycmVudExpbmUuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1clN1YlN0cmluZ1dpZHRoID0gZ2MubWVhc3VyZVRleHQoY3VyU3ViU3RyaW5nKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJTdWJTdHJpbmdXaWR0aCA8IGJveFdpZHRoIHx8IGN1clN1YlN0cmluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHN1YnN0cmluZyB3aGljaCBoYXMgYSB3aWR0aCBsZXNzIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3ggd2lkdGguIFJlbmRlcmluZyB0aGF0IHN1YnN0cmluZyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNldHRpbmcgdGhlIHJlbWFpbmRlciBvZiB0aGUgcGFyZW50IHN0cmluZyBhcyB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZyB0byBpdGVyYXRlIG9uIGZvciB0aGUgbmV4dCBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0TGluZVRleHQgPSB0ZXh0SW5DdXJyZW50TGluZS5zdWJzdHJpbmcoaSwgdGV4dEluQ3VycmVudExpbmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0SW5DdXJyZW50TGluZSA9IG5leHRMaW5lVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMaW5lVGV4dFdpZHRoID0gZ2MubWVhc3VyZVRleHQodGV4dEluQ3VycmVudExpbmUpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdjLmZpbGxUZXh0KGN1clN1YlN0cmluZywgdGV4dFgsIGN1clkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clkgKz0gdGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnRpbnVlIGl0ZXJhdGluZyBhZnRlciB3ZSBpZGVudGlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW5kZXggdG8gYnJlYWsgdGhlIHN0cmluZyBvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11bHRpcGxlIHdvcmRzIGluIGNvbHVtbiBoZWFkZXIuIEZpdHRpbmcgbWF4aW11bSBcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiB3b3JkcyBwb3NzaWJsZSBwZXIgbGluZSAoYm94IHdpZHRoKS5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlICh3b3Jkc0luQ29sdW1uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzaW5nIHRoZSBuZXh0IHdvcmQgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyV29yZCA9IHdvcmRzSW5Db2x1bW4uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSm9pbmluZyB0aGF0IHdvcmQgd2l0aCB0aGUgZXhpc3RpbmcgdGV4dCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluY3JlbWVudGVkVGV4dCA9IFt0ZXh0SW5DdXJyZW50TGluZSwgY3VyV29yZF0uam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmNyZW1lbnRlZFRleHRXaWR0aCA9IGdjLm1lYXN1cmVUZXh0KGluY3JlbWVudGVkVGV4dCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnRlZFRleHRXaWR0aCA+IGJveFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV3bHkgY29tYmluZWQgdGV4dCBoYXMgYSB3aWR0aCBsYXJnZXIgdGhhblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJveCB3aWR0aCwgd2UgcmVuZGVyIHRoZSBsaW5lIGJlZm9yZSB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yZCB3YXMgYWRkZWQuIFdlIHNldCB0aGUgY3VycmVudCB3b3JkIGFzIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2MuZmlsbFRleHQodGV4dEluQ3VycmVudExpbmUsIHRleHRYLCBjdXJZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clkgKz0gdGV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRJbkN1cnJlbnRMaW5lID0gY3VyV29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb21iaW5lZCB0ZXh0IGhhc2QgYSB3aWR0aCBsZXNzIHRoYW4gdGhlIGJveCB3aWR0aC4gV2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgdGhlIGN1cnJlbnQgbGluZSB0ZXh0IHRvIGJlIHRoZSBuZXcgY29tYmluZWQgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRJbkN1cnJlbnRMaW5lID0gaW5jcmVtZW50ZWRUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MuZmlsbFRleHQodGV4dEluQ3VycmVudExpbmUsIHRleHRYLCBjdXJZKTtcbiAgICAgICAgICAgIC8vIFRlcm1pbmF0aW5nIHRoZSBjYWxsIGhlcmUgYXMgd2UgZG9uJ3Qgd2FudFxuICAgICAgICAgICAgLy8gdG8gYXBwbHkgdGV4dCBlbGlkaW5nIHdoZW4gd3JhcHBpbmcgaXMgYWN0aXZlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsaWRlIHRleHQgdGhhdCBpcyB0b28gbG9uZ1xuICAgICAgICB2YXIgZWxpZGUgPSAnXFx1MjAyNic7XG4gICAgICAgIC8vIENvbXB1dGUgZWxpZGVkIHRleHRcbiAgICAgICAgaWYgKGVsaWRlRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB3aGlsZSAoKHRleHRXaWR0aCA+IGJveFdpZHRoKSAmJiAodGV4dC5sZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDQgJiYgdGV4dFdpZHRoID49IDIgKiBib3hXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0ZXh0IHdpZHRoIGlzIHN1YnN0YW50aWFsbHkgYmlnZ2VyLCB0YWtlIGhhbGYgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgKHRleHQubGVuZ3RoIC8gMikgKyAxKSArIGVsaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudGFsbHkgcmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSAyKSArIGVsaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBnYy5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgodGV4dFdpZHRoID4gYm94V2lkdGgpICYmICh0ZXh0Lmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gNCAmJiB0ZXh0V2lkdGggPj0gMiAqIGJveFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRleHQgd2lkdGggaXMgc3Vic3RhbnRpYWxseSBiaWdnZXIsIHRha2UgaGFsZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBlbGlkZSArIHRleHQuc3Vic3RyaW5nKCh0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnRhbGx5IHJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGVsaWRlICsgdGV4dC5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IGdjLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERyYXcgdGhlIHRleHQgZm9yIHRoZSBjZWxsLlxuICAgICAgICBnYy5maWxsVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHRSZW5kZXJlcjtcbn0oQ2VsbFJlbmRlcmVyKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgVGV4dFJlbmRlcmVyYCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKFRleHRSZW5kZXJlcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdlbmVyaWMgdGV4dCBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgZ2VuZXJpYyB0ZXh0IGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZvcm1hdHRlciB1c2VzIHRoZSBidWlsdGluIGBTdHJpbmcoKWAgdG8gY29lcmNlIGFueSB2YWx1ZVxuICAgICAqIHRvIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdEdlbmVyaWMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbWlzc2luZyA9IG9wdGlvbnMubWlzc2luZyB8fCAnJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRleHRSZW5kZXJlci5mb3JtYXRHZW5lcmljID0gZm9ybWF0R2VuZXJpYztcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBmaXhlZCBkZWNpbWFsIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBmaXhlZCBkZWNpbWFsIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZvcm1hdHRlciB1c2VzIHRoZSBidWlsdGluIGBOdW1iZXIoKWAgYW5kIGB0b0ZpeGVkKClgIHRvXG4gICAgICogY29lcmNlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgZm9ybWF0SW50bE51bWJlcigpYCBmb3JtYXR0ZXIgaXMgbW9yZSBmbGV4aWJsZSwgYnV0IHNsb3dlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRGaXhlZChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkaWdpdHMgPSBvcHRpb25zLmRpZ2l0cztcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBvcHRpb25zLm1pc3NpbmcgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpLnRvRml4ZWQoZGlnaXRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVGV4dFJlbmRlcmVyLmZvcm1hdEZpeGVkID0gZm9ybWF0Rml4ZWQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2lnbmlmaWNhbnQgZmlndXJlIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBzaWduaWZpY2FudCBmaWd1cmUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgZm9ybWF0dGVyIHVzZXMgdGhlIGJ1aWx0aW4gYE51bWJlcigpYCBhbmQgYHRvUHJlY2lzaW9uKClgXG4gICAgICogdG8gY29lcmNlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgZm9ybWF0SW50bE51bWJlcigpYCBmb3JtYXR0ZXIgaXMgbW9yZSBmbGV4aWJsZSwgYnV0IHNsb3dlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRQcmVjaXNpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGlnaXRzID0gb3B0aW9ucy5kaWdpdHM7XG4gICAgICAgIHZhciBtaXNzaW5nID0gb3B0aW9ucy5taXNzaW5nIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKS50b1ByZWNpc2lvbihkaWdpdHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUZXh0UmVuZGVyZXIuZm9ybWF0UHJlY2lzaW9uID0gZm9ybWF0UHJlY2lzaW9uO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNjaWVudGlmaWMgbm90YXRpb24gZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IHNjaWVudGlmaWMgbm90YXRpb24gZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgZm9ybWF0dGVyIHVzZXMgdGhlIGJ1aWx0aW4gYE51bWJlcigpYCBhbmQgYHRvRXhwb25lbnRpYWwoKWBcbiAgICAgKiB0byBjb2VyY2UgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhlIGBmb3JtYXRJbnRsTnVtYmVyKClgIGZvcm1hdHRlciBpcyBtb3JlIGZsZXhpYmxlLCBidXQgc2xvd2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdEV4cG9uZW50aWFsKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGRpZ2l0cyA9IG9wdGlvbnMuZGlnaXRzO1xuICAgICAgICB2YXIgbWlzc2luZyA9IG9wdGlvbnMubWlzc2luZyB8fCAnJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkudG9FeHBvbmVudGlhbChkaWdpdHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUZXh0UmVuZGVyZXIuZm9ybWF0RXhwb25lbnRpYWwgPSBmb3JtYXRFeHBvbmVudGlhbDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW50ZXJuYXRpb25hbCBudW1iZXIgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGludGVybmF0aW9uYWwgbnVtYmVyIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZvcm1hdHRlciB1c2VzIHRoZSBidWlsdGluIGBJbnRsLk51bWJlckZvcm1hdGAgb2JqZWN0IHRvXG4gICAgICogY29lcmNlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIG1vc3QgZmxleGlibGUgKGJ1dCBzbG93ZXN0KSBudW1iZXIgZm9ybWF0dGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdEludGxOdW1iZXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbWlzc2luZyA9IG9wdGlvbnMubWlzc2luZyB8fCAnJztcbiAgICAgICAgdmFyIG5mdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChvcHRpb25zLmxvY2FsZXMsIG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZnQuZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVGV4dFJlbmRlcmVyLmZvcm1hdEludGxOdW1iZXIgPSBmb3JtYXRJbnRsTnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRhdGUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGRhdGUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgZm9ybWF0dGVyIHVzZXMgYERhdGUudG9EYXRlU3RyaW5nKClgIHRvIGZvcm1hdCB0aGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBub3QgYSBgRGF0ZWAgb2JqZWN0LCBgbmV3IERhdGUodmFsdWUpYCBpcyB1c2VkIHRvXG4gICAgICogY29lcmNlIHRoZSB2YWx1ZSB0byBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBUaGUgYGZvcm1hdEludGxEYXRlVGltZSgpYCBmb3JtYXR0ZXIgaXMgbW9yZSBmbGV4aWJsZSwgYnV0IHNsb3dlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXREYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIG1pc3NpbmcgPSBvcHRpb25zLm1pc3NpbmcgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9EYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKHZhbHVlKSkudG9EYXRlU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFRleHRSZW5kZXJlci5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZvcm1hdHRlciB1c2VzIGBEYXRlLnRvVGltZVN0cmluZygpYCB0byBmb3JtYXQgdGhlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgbm90IGEgYERhdGVgIG9iamVjdCwgYG5ldyBEYXRlKHZhbHVlKWAgaXMgdXNlZCB0b1xuICAgICAqIGNvZXJjZSB0aGUgdmFsdWUgdG8gYSBkYXRlLlxuICAgICAqXG4gICAgICogVGhlIGBmb3JtYXRJbnRsRGF0ZVRpbWUoKWAgZm9ybWF0dGVyIGlzIG1vcmUgZmxleGlibGUsIGJ1dCBzbG93ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0VGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtaXNzaW5nID0gb3B0aW9ucy5taXNzaW5nIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvVGltZVN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSh2YWx1ZSkpLnRvVGltZVN0cmluZygpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUZXh0UmVuZGVyZXIuZm9ybWF0VGltZSA9IGZvcm1hdFRpbWU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIElTTyBkYXRldGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgSVNPIGRhdGV0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZvcm1hdHRlciB1c2VzIGBEYXRlLnRvSVNPU3RyaW5nKClgIHRvIGZvcm1hdCB0aGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBub3QgYSBgRGF0ZWAgb2JqZWN0LCBgbmV3IERhdGUodmFsdWUpYCBpcyB1c2VkIHRvXG4gICAgICogY29lcmNlIHRoZSB2YWx1ZSB0byBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBUaGUgYGZvcm1hdEludGxEYXRlVGltZSgpYCBmb3JtYXR0ZXIgaXMgbW9yZSBmbGV4aWJsZSwgYnV0IHNsb3dlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXRJU09EYXRlVGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtaXNzaW5nID0gb3B0aW9ucy5taXNzaW5nIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKHZhbHVlKSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVGV4dFJlbmRlcmVyLmZvcm1hdElTT0RhdGVUaW1lID0gZm9ybWF0SVNPRGF0ZVRpbWU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgVVRDIGRhdGV0aW1lIGZvcm1hdCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBVVEMgZGF0ZXRpbWUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgZm9ybWF0dGVyIHVzZXMgYERhdGUudG9VVENTdHJpbmcoKWAgdG8gZm9ybWF0IHRoZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIG5vdCBhIGBEYXRlYCBvYmplY3QsIGBuZXcgRGF0ZSh2YWx1ZSlgIGlzIHVzZWQgdG9cbiAgICAgKiBjb2VyY2UgdGhlIHZhbHVlIHRvIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBgZm9ybWF0SW50bERhdGVUaW1lKClgIGZvcm1hdHRlciBpcyBtb3JlIGZsZXhpYmxlLCBidXQgc2xvd2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ0RhdGVUaW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIG1pc3NpbmcgPSBvcHRpb25zLm1pc3NpbmcgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAobmV3IERhdGUodmFsdWUpKS50b1VUQ1N0cmluZygpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBUZXh0UmVuZGVyZXIuZm9ybWF0VVRDRGF0ZVRpbWUgPSBmb3JtYXRVVENEYXRlVGltZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW50ZXJuYXRpb25hbCBkYXRldGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaW50ZXJuYXRpb25hbCBkYXRldGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBmb3JtYXR0ZXIgdXNlcyB0aGUgYnVpbHRpbiBgSW50bC5EYXRlVGltZUZvcm1hdGAgb2JqZWN0IHRvXG4gICAgICogY29lcmNlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIG1vc3QgZmxleGlibGUgKGJ1dCBzbG93ZXN0KSBkYXRldGltZSBmb3JtYXR0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0SW50bERhdGVUaW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIG1pc3NpbmcgPSBvcHRpb25zLm1pc3NpbmcgfHwgJyc7XG4gICAgICAgIHZhciBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChvcHRpb25zLmxvY2FsZXMsIG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkdGYuZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVGV4dFJlbmRlcmVyLmZvcm1hdEludGxEYXRlVGltZSA9IGZvcm1hdEludGxEYXRlVGltZTtcbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIHRoZSBoZWlnaHQgb2YgYSBmb250LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvbnQgLSBUaGUgQ1NTIGZvbnQgc3RyaW5nIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGhlaWdodCBvZiB0aGUgZm9udCBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGEgdGVtcG9yYXJ5IERPTSBub2RlIHRvIG1lYXN1cmUgdGhlIHRleHQgYm94XG4gICAgICogaGVpZ2h0IGZvciB0aGUgc3BlY2lmaWVkIGZvbnQuIFRoZSBmaXJzdCBjYWxsIGZvciBhIGdpdmVuIGZvbnRcbiAgICAgKiB3aWxsIGluY3VyIGEgRE9NIHJlZmxvdywgYnV0IHRoZSByZXR1cm4gdmFsdWUgaXMgY2FjaGVkLCBzbyBhbnlcbiAgICAgKiBzdWJzZXF1ZW50IGNhbGwgZm9yIHRoZSBzYW1lIGZvbnQgd2lsbCByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFzdXJlRm9udEhlaWdodChmb250KSB7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIGNhY2hlZCBmb250IGhlaWdodC5cbiAgICAgICAgdmFyIGhlaWdodCA9IFByaXZhdGUkNC5mb250SGVpZ2h0Q2FjaGVbZm9udF07XG4gICAgICAgIC8vIFJldHVybiB0aGUgY2FjaGVkIGZvbnQgaGVpZ2h0IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZm9udC5cbiAgICAgICAgUHJpdmF0ZSQ0LmZvbnRNZWFzdXJlbWVudEdDLmZvbnQgPSBmb250O1xuICAgICAgICB2YXIgbm9ybUZvbnQgPSBQcml2YXRlJDQuZm9udE1lYXN1cmVtZW50R0MuZm9udDtcbiAgICAgICAgLy8gU2V0IHRoZSBmb250IG9uIHRoZSBtZWFzdXJlbWVudCBub2RlLlxuICAgICAgICBQcml2YXRlJDQuZm9udE1lYXN1cmVtZW50Tm9kZS5zdHlsZS5mb250ID0gbm9ybUZvbnQ7XG4gICAgICAgIC8vIEFkZCB0aGUgbWVhc3VyZW1lbnQgbm9kZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoUHJpdmF0ZSQ0LmZvbnRNZWFzdXJlbWVudE5vZGUpO1xuICAgICAgICAvLyBNZWFzdXJlIHRoZSBub2RlIGhlaWdodC5cbiAgICAgICAgaGVpZ2h0ID0gUHJpdmF0ZSQ0LmZvbnRNZWFzdXJlbWVudE5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG1lYXN1cmVtZW50IG5vZGUgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoUHJpdmF0ZSQ0LmZvbnRNZWFzdXJlbWVudE5vZGUpO1xuICAgICAgICAvLyBDYWNoZSB0aGUgbWVhc3VyZWQgaGVpZ2h0IGZvciB0aGUgZm9udCBhbmQgbm9ybSBmb250LlxuICAgICAgICBQcml2YXRlJDQuZm9udEhlaWdodENhY2hlW2ZvbnRdID0gaGVpZ2h0O1xuICAgICAgICBQcml2YXRlJDQuZm9udEhlaWdodENhY2hlW25vcm1Gb250XSA9IGhlaWdodDtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtZWFzdXJlZCBoZWlnaHQuXG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuICAgIFRleHRSZW5kZXJlci5tZWFzdXJlRm9udEhlaWdodCA9IG1lYXN1cmVGb250SGVpZ2h0O1xufSkoVGV4dFJlbmRlcmVyIHx8IChUZXh0UmVuZGVyZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJDQ7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIG1lYXN1cmVkIGZvbnQgaGVpZ2h0cy5cbiAgICAgKi9cbiAgICBQcml2YXRlLmZvbnRIZWlnaHRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqXG4gICAgICogVGhlIERPTSBub2RlIHVzZWQgZm9yIGZvbnQgaGVpZ2h0IG1lYXN1cmVtZW50LlxuICAgICAqL1xuICAgIFByaXZhdGUuZm9udE1lYXN1cmVtZW50Tm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLnRvcCA9ICctOTk5OTlweCc7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9ICctOTk5OTlweCc7XG4gICAgICAgIG5vZGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICBub2RlLnRleHRDb250ZW50ID0gJ00nO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KSgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBHQyB1c2VkIGZvciBmb250IG1lYXN1cmVtZW50LlxuICAgICAqL1xuICAgIFByaXZhdGUuZm9udE1lYXN1cmVtZW50R0MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSkoKTtcbn0pKFByaXZhdGUkNCB8fCAoUHJpdmF0ZSQ0ID0ge30pKTtcblxuLyoqXG4gKiBBIGNsYXNzIHdoaWNoIG1hbmFnZXMgdGhlIG1hcHBpbmcgb2YgY2VsbCByZW5kZXJlcnMuXG4gKi9cbnZhciBSZW5kZXJlck1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcmVuZGVyZXIgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmYWxsYmFjayAtIFRoZSByZW5kZXJlciBvZiBsYXN0IHJlc29ydC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlck1hcCh2YWx1ZXMsIGZhbGxiYWNrKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxuICAgICAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gX19hc3NpZ24oe30sIHZhbHVlcyk7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrID0gZmFsbGJhY2sgfHwgbmV3IFRleHRSZW5kZXJlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyZXJNYXAucHJvdG90eXBlLCBcImNoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSByZW5kZXJlciBtYXAgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNlbGwgcmVuZGVyZXIgdG8gdXNlIGZvciB0aGUgZ2l2ZW4gY2VsbCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNlbGwgY29uZmlnIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJlbmRlcmVyIHRvIHVzZSBmb3IgdGhlIGNlbGwuXG4gICAgICovXG4gICAgUmVuZGVyZXJNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHJlbmRlcmVyIGZyb20gdGhlIHZhbHVlcyBtYXAuXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ZhbHVlc1tjb25maWcucmVnaW9uXTtcbiAgICAgICAgLy8gRXhlY3V0ZSBhIHJlc29sdmVyIGZ1bmN0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKHR5cGVvZiByZW5kZXJlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IHJlbmRlcmVyKGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVuZGVyZXIgb3IgdGhlIGZhbGxiYWNrLlxuICAgICAgICByZXR1cm4gcmVuZGVyZXIgfHwgdGhpcy5fZmFsbGJhY2s7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHJlbmRlcmVyIG1hcCB3aXRoIG5ldyB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdXBkYXRlZCB2YWx1ZXMgZm9yIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmFsbGJhY2sgLSBUaGUgcmVuZGVyZXIgb2YgbGFzdCByZXNvcnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgYWx3YXlzIGVtaXRzIHRoZSBgY2hhbmdlZGAgc2lnbmFsLlxuICAgICAqL1xuICAgIFJlbmRlcmVyTWFwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodmFsdWVzLCBmYWxsYmFjaykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX3ZhbHVlcyksIHZhbHVlcyk7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrID0gZmFsbGJhY2sgfHwgdGhpcy5fZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlcmVyTWFwO1xufSgpKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEFuIG9iamVjdCB3aGljaCBtYW5hZ2VzIGEgY29sbGVjdGlvbiBvZiB2YXJpYWJsZSBzaXplZCBzZWN0aW9ucy5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGNsYXNzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gSXQgaXMgZGVzaWduZWQgdG8gbWFuYWdlXG4gKiB0aGUgdmFyaWFibGUgcm93IGFuZCBjb2x1bW4gc2l6ZXMgZm9yIGEgZGF0YSBncmlkLiBVc2VyIGNvZGUgd2lsbFxuICogbm90IGludGVyYWN0IHdpdGggdGhpcyBjbGFzcyBkaXJlY3RseS5cbiAqL1xudmFyIFNlY3Rpb25MaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBzZWN0aW9uIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VjdGlvbkxpc3Qob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuX21pbmltdW1TaXplID0gb3B0aW9ucy5taW5pbXVtU2l6ZSB8fCAyO1xuICAgICAgICB0aGlzLl9kZWZhdWx0U2l6ZSA9IE1hdGgubWF4KHRoaXMuX21pbmltdW1TaXplLCBNYXRoLmZsb29yKG9wdGlvbnMuZGVmYXVsdFNpemUpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlY3Rpb25MaXN0LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIHNpemUgb2YgYWxsIHNlY3Rpb25zIGluIHRoZSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgICAgICogQ29uc3RhbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWN0aW9uTGlzdC5wcm90b3R5cGUsIFwiY291bnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBzZWN0aW9ucyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICAgICAqIENvbnN0YW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWN0aW9uTGlzdC5wcm90b3R5cGUsIFwibWluaW11bVNpemVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtaW5pbXVtIHNpemUgb2Ygc2VjdGlvbnMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAgICAgKiBDb25zdGFudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbmltdW1TaXplO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtaW5pbXVtIHNpemUgb2Ygc2VjdGlvbnMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAgICAgKiBMaW5lYXIgb24gdGhlIG51bWJlciBvZiByZXNpemVkIHNlY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgdmFsdWUuXG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9taW5pbXVtU2l6ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIG1pbmltdW0gc2l6ZS5cbiAgICAgICAgICAgIHRoaXMuX21pbmltdW1TaXplID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZGVmYXVsdCBzaXplIGlmIGxhcmdlciB0aGFuIG1pbmltdW0gc2l6ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5fZGVmYXVsdFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRTaXplID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWN0aW9uTGlzdC5wcm90b3R5cGUsIFwiZGVmYXVsdFNpemVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkZWZhdWx0IHNpemUgb2Ygc2VjdGlvbnMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAgICAgKiBDb25zdGFudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBkZWZhdWx0IHNpemUgb2Ygc2VjdGlvbnMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAgICAgKiBMaW5lYXIgb24gdGhlIG51bWJlciBvZiByZXNpemVkIHNlY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgdmFsdWUuXG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHRoaXMuX21pbmltdW1TaXplLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gICAgICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdFNpemUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGVsdGEgZGVmYXVsdCBzaXplLlxuICAgICAgICAgICAgdmFyIGRlbHRhID0gdmFsdWUgLSB0aGlzLl9kZWZhdWx0U2l6ZTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgZGVmYXVsdCBzaXplLlxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFNpemUgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVuZ3RoLlxuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IGRlbHRhICogKHRoaXMuX2NvdW50IC0gdGhpcy5fc2VjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIG1vZGlmaWVkIHNlY3Rpb25zLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlY29tcHV0ZSB0aGUgb2Zmc2V0cyBvZiB0aGUgbW9kaWZpZWQgc2VjdGlvbnMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIExvb2sgdXAgdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IG1vZGlmaWVkIHNlY3Rpb25zLlxuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5fc2VjdGlvbnNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IHNlY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gY3Vyci5pbmRleCAtIHByZXYuaW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICBjdXJyLm9mZnNldCA9IHByZXYub2Zmc2V0ICsgcHJldi5zaXplICsgY291bnQgKiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnIub2Zmc2V0ID0gY3Vyci5pbmRleCAqIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2xhbXAgYSBzaXplIHRvIHRoZSBtaW5pbXVtIHNlY3Rpb24gc2l6ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSB0byBjbGFtcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9yIHRoZSBzZWN0aW9uIG1pbmltdW0gc2l6ZSwgd2hpY2hldmVyIGlzIGxhcmdlclxuICAgICAqL1xuICAgIFNlY3Rpb25MaXN0LnByb3RvdHlwZS5jbGFtcFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fbWluaW11bVNpemUsIE1hdGguZmxvb3Ioc2l6ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIHNlY3Rpb24gd2hpY2ggY292ZXJzIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgc2VjdGlvbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgc2VjdGlvbiB3aGljaCBjb3ZlcnMgdGhlIGdpdmVuIG9mZnNldCxcbiAgICAgKiAgIG9yIGAtMWAgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMb2dhcml0aG1pYyBvbiB0aGUgbnVtYmVyIG9mIHJlc2l6ZWQgc2VjdGlvbnMuXG4gICAgICovXG4gICAgU2VjdGlvbkxpc3QucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+PSB0aGlzLl9sZW5ndGggfHwgdGhpcy5fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIHNpbXBsZSBjYXNlIG9mIG5vIG1vZGlmaWVkIHNlY3Rpb25zLlxuICAgICAgICBpZiAodGhpcy5fc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihvZmZzZXQgLyB0aGlzLl9kZWZhdWx0U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgbW9kaWZpZWQgc2VjdGlvbiBmb3IgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgICAgdmFyIGkgPSBBcnJheUV4dC5sb3dlckJvdW5kKHRoaXMuX3NlY3Rpb25zLCBvZmZzZXQsIFByaXZhdGUkNS5vZmZzZXRDbXApO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGluZGV4IG9mIGFuIGV4YWN0IG1hdGNoLlxuICAgICAgICBpZiAoaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aCAmJiB0aGlzLl9zZWN0aW9uc1tpXS5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnNbaV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIG9mIG5vIG1vZGlmaWVkIHNlY3Rpb25zIGJlZm9yZSB0aGUgb2Zmc2V0LlxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iob2Zmc2V0IC8gdGhpcy5fZGVmYXVsdFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGluZGV4IGZyb20gdGhlIHByZXZpb3VzIG1vZGlmaWVkIHNlY3Rpb24uXG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaSAtIDFdO1xuICAgICAgICB2YXIgc3BhbiA9IG9mZnNldCAtIChzZWN0aW9uLm9mZnNldCArIHNlY3Rpb24uc2l6ZSk7XG4gICAgICAgIHJldHVybiBzZWN0aW9uLmluZGV4ICsgTWF0aC5mbG9vcihzcGFuIC8gdGhpcy5fZGVmYXVsdFNpemUpICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG9mZnNldCBvZiB0aGUgc2VjdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNlY3Rpb24gb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgb2Zmc2V0IG9mIHRoZSBzZWN0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCwgb3IgYC0xYFxuICAgICAqICAgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBMb2dhcml0aG1pYyBvbiB0aGUgbnVtYmVyIG9mIHJlc2l6ZWQgc2VjdGlvbnMuXG4gICAgICovXG4gICAgU2VjdGlvbkxpc3QucHJvdG90eXBlLm9mZnNldE9mID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc2ltcGxlIGNhc2Ugb2Ygbm8gbW9kaWZpZWQgc2VjdGlvbnMuXG4gICAgICAgIGlmICh0aGlzLl9zZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCAqIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIG1vZGlmaWVkIHNlY3Rpb24gZm9yIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgICAgdmFyIGkgPSBBcnJheUV4dC5sb3dlckJvdW5kKHRoaXMuX3NlY3Rpb25zLCBpbmRleCwgUHJpdmF0ZSQ1LmluZGV4Q21wKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBvZmZzZXQgb2YgYW4gZXhhY3QgbWF0Y2guXG4gICAgICAgIGlmIChpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoICYmIHRoaXMuX3NlY3Rpb25zW2ldLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zW2ldLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugb2Ygbm8gbW9kaWZpZWQgc2VjdGlvbnMgYmVmb3JlIHRoZSBpbmRleC5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCAqIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9mZnNldCBmcm9tIHRoZSBwcmV2aW91cyBtb2RpZmllZCBzZWN0aW9uLlxuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2kgLSAxXTtcbiAgICAgICAgdmFyIHNwYW4gPSBpbmRleCAtIHNlY3Rpb24uaW5kZXggLSAxO1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5vZmZzZXQgKyBzZWN0aW9uLnNpemUgKyBzcGFuICogdGhpcy5fZGVmYXVsdFNpemU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBleHRlbnQgb2YgdGhlIHNlY3Rpb24gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBzZWN0aW9uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV4dGVudCBvZiB0aGUgc2VjdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXgsIG9yIGAtMWBcbiAgICAgKiAgIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIFVuZGVmaW5lZCBCZWhhdmlvclxuICAgICAqIEFuIGBpbmRleGAgd2hpY2ggaXMgbm9uLWludGVncmFsLlxuICAgICAqXG4gICAgICogIyMjIyBDb21wbGV4aXR5XG4gICAgICogTG9nYXJpdGhtaWMgb24gdGhlIG51bWJlciBvZiByZXNpemVkIHNlY3Rpb25zLlxuICAgICAqL1xuICAgIFNlY3Rpb25MaXN0LnByb3RvdHlwZS5leHRlbnRPZiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIHNpbXBsZSBjYXNlIG9mIG5vIG1vZGlmaWVkIHNlY3Rpb25zLlxuICAgICAgICBpZiAodGhpcy5fc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKGluZGV4ICsgMSkgKiB0aGlzLl9kZWZhdWx0U2l6ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgbW9kaWZpZWQgc2VjdGlvbiBmb3IgdGhlIGdpdmVuIGluZGV4LlxuICAgICAgICB2YXIgaSA9IEFycmF5RXh0Lmxvd2VyQm91bmQodGhpcy5fc2VjdGlvbnMsIGluZGV4LCBQcml2YXRlJDUuaW5kZXhDbXApO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG9mZnNldCBvZiBhbiBleGFjdCBtYXRjaC5cbiAgICAgICAgaWYgKGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGggJiYgdGhpcy5fc2VjdGlvbnNbaV0uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnNbaV0ub2Zmc2V0ICsgdGhpcy5fc2VjdGlvbnNbaV0uc2l6ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIG9mIG5vIG1vZGlmaWVkIHNlY3Rpb25zIGJlZm9yZSB0aGUgaW5kZXguXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKGluZGV4ICsgMSkgKiB0aGlzLl9kZWZhdWx0U2l6ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgb2Zmc2V0IGZyb20gdGhlIHByZXZpb3VzIG1vZGlmaWVkIHNlY3Rpb24uXG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaSAtIDFdO1xuICAgICAgICB2YXIgc3BhbiA9IGluZGV4IC0gc2VjdGlvbi5pbmRleDtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24ub2Zmc2V0ICsgc2VjdGlvbi5zaXplICsgc3BhbiAqIHRoaXMuX2RlZmF1bHRTaXplIC0gMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHNpemUgb2YgdGhlIHNlY3Rpb24gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBzZWN0aW9uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHNpemUgb2YgdGhlIHNlY3Rpb24gYXQgdGhlIGdpdmVuIGluZGV4LCBvciBgLTFgXG4gICAgICogICBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqXG4gICAgICogIyMjIyBVbmRlZmluZWQgQmVoYXZpb3JcbiAgICAgKiBBbiBgaW5kZXhgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExvZ2FyaXRobWljIG9uIHRoZSBudW1iZXIgb2YgcmVzaXplZCBzZWN0aW9ucy5cbiAgICAgKi9cbiAgICBTZWN0aW9uTGlzdC5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc2ltcGxlIGNhc2Ugb2Ygbm8gbW9kaWZpZWQgc2VjdGlvbnMuXG4gICAgICAgIGlmICh0aGlzLl9zZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBtb2RpZmllZCBzZWN0aW9uIGZvciB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICAgIHZhciBpID0gQXJyYXlFeHQubG93ZXJCb3VuZCh0aGlzLl9zZWN0aW9ucywgaW5kZXgsIFByaXZhdGUkNS5pbmRleENtcCk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgc2l6ZSBvZiBhbiBleGFjdCBtYXRjaC5cbiAgICAgICAgaWYgKGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGggJiYgdGhpcy5fc2VjdGlvbnNbaV0uaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnNbaV0uc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgc2l6ZSBmb3IgYWxsIG90aGVyIGNhc2VzLlxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFNpemU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgYSBzZWN0aW9uIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBzZWN0aW9uIHRvIHJlc2l6ZS4gVGhpcyBtZXRob2RcbiAgICAgKiAgIGlzIGEgbm8tb3AgaWYgdGhpcyB2YWx1ZSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBuZXcgc2l6ZSBvZiB0aGUgc2VjdGlvbi4gVGhpcyB2YWx1ZSB3aWxsIGJlXG4gICAgICogICBjbGFtcGVkIHRvIGFuIGludGVnZXIgYD49IDBgLlxuICAgICAqXG4gICAgICogIyMjIyBVbmRlZmluZWQgQmVoYXZpb3JcbiAgICAgKiBBbiBgaW5kZXhgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhciBvbiB0aGUgbnVtYmVyIG9mIHJlc2l6ZWQgc2VjdGlvbnMuXG4gICAgICovXG4gICAgU2VjdGlvbkxpc3QucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChpbmRleCwgc2l6ZSkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGFtcCB0aGUgc2l6ZSB0byBhbiBpbnRlZ2VyID49IG1pbmltdW0gc2l6ZS5cbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHRoaXMuX21pbmltdW1TaXplLCBNYXRoLmZsb29yKHNpemUpKTtcbiAgICAgICAgLy8gRmluZCB0aGUgbW9kaWZpZWQgc2VjdGlvbiBmb3IgdGhlIGdpdmVuIGluZGV4LlxuICAgICAgICB2YXIgaSA9IEFycmF5RXh0Lmxvd2VyQm91bmQodGhpcy5fc2VjdGlvbnMsIGluZGV4LCBQcml2YXRlJDUuaW5kZXhDbXApO1xuICAgICAgICAvLyBVcGRhdGUgb3IgY3JlYXRlIHRoZSBtb2RpZmllZCBzZWN0aW9uIGFzIG5lZWRlZC5cbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAoaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aCAmJiB0aGlzLl9zZWN0aW9uc1tpXS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICAgICAgICBkZWx0YSA9IHNpemUgLSBzZWN0aW9uLnNpemU7XG4gICAgICAgICAgICBzZWN0aW9uLnNpemUgPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpbmRleCAqIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX3NlY3Rpb25zLCBpLCB7IGluZGV4OiBpbmRleCwgb2Zmc2V0OiBvZmZzZXQsIHNpemU6IHNpemUgfSk7XG4gICAgICAgICAgICBkZWx0YSA9IHNpemUgLSB0aGlzLl9kZWZhdWx0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaSAtIDFdO1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBpbmRleCAtIHNlY3Rpb24uaW5kZXggLSAxO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHNlY3Rpb24ub2Zmc2V0ICsgc2VjdGlvbi5zaXplICsgc3BhbiAqIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX3NlY3Rpb25zLCBpLCB7IGluZGV4OiBpbmRleCwgb2Zmc2V0OiBvZmZzZXQsIHNpemU6IHNpemUgfSk7XG4gICAgICAgICAgICBkZWx0YSA9IHNpemUgLSB0aGlzLl9kZWZhdWx0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIGxlbmd0aC5cbiAgICAgICAgdGhpcy5fbGVuZ3RoICs9IGRlbHRhO1xuICAgICAgICAvLyBVcGRhdGUgYWxsIG1vZGlmaWVkIHNlY3Rpb25zIGFmdGVyIHRoZSByZXNpemVkIHNlY3Rpb24uXG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMSwgbiA9IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvbnNbal0ub2Zmc2V0ICs9IGRlbHRhO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgc2VjdGlvbnMgaW50byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIHNlY3Rpb25zLiBUaGlzXG4gICAgICogICB2YWx1ZSB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIGJvdW5kcyBvZiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2Ygc2VjdGlvbnMgdG8gaW5zZXJ0LiBUaGlzIG1ldGhvZFxuICAgICAqICAgaXMgYSBuby1vcCBpZiB0aGlzIHZhbHVlIGlzIGA8PSAwYC5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCBvciBgY291bnRgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhciBvbiB0aGUgbnVtYmVyIG9mIHJlc2l6ZWQgc2VjdGlvbnMuXG4gICAgICovXG4gICAgU2VjdGlvbkxpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgY291bnQpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gc2VjdGlvbnMgdG8gaW5zZXJ0LlxuICAgICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRoZSBpbmRleCB0byB0aGUgYm91bmRzIG9mIHRoZSBsaXN0LlxuICAgICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLl9jb3VudCkpO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBzZWN0aW9ucyB0byB0aGUgdG90YWxzLlxuICAgICAgICB2YXIgc3BhbiA9IGNvdW50ICogdGhpcy5fZGVmYXVsdFNpemU7XG4gICAgICAgIHRoaXMuX2NvdW50ICs9IGNvdW50O1xuICAgICAgICB0aGlzLl9sZW5ndGggKz0gc3BhbjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gbW9kaWZpZWQgc2VjdGlvbnMgdG8gdXBkYXRlLlxuICAgICAgICBpZiAodGhpcy5fc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgbW9kaWZpZWQgc2VjdGlvbiBmb3IgdGhlIGdpdmVuIGluZGV4LlxuICAgICAgICB2YXIgaSA9IEFycmF5RXh0Lmxvd2VyQm91bmQodGhpcy5fc2VjdGlvbnMsIGluZGV4LCBQcml2YXRlJDUuaW5kZXhDbXApO1xuICAgICAgICAvLyBVcGRhdGUgYWxsIG1vZGlmaWVkIHNlY3Rpb25zIGFmdGVyIHRoZSBpbnNlcnQgbG9jYXRpb24uXG4gICAgICAgIGZvciAodmFyIG4gPSB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICAgICAgICBzZWN0aW9uLmluZGV4ICs9IGNvdW50O1xuICAgICAgICAgICAgc2VjdGlvbi5vZmZzZXQgKz0gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHNlY3Rpb25zIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IHNlY3Rpb24gdG8gcmVtb3ZlLiBUaGlzXG4gICAgICogICBtZXRob2QgaXMgYSBuby1vcCBpZiB0aGlzIHZhbHVlIGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2Ygc2VjdGlvbnMgdG8gcmVtb3ZlLiBUaGlzIG1ldGhvZFxuICAgICAqICAgaXMgYSBuby1vcCBpZiB0aGlzIHZhbHVlIGlzIGA8PSAwYC5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCBvciBgY291bnRgIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhciBvbiB0aGUgbnVtYmVyIG9mIHJlc2l6ZWQgc2VjdGlvbnMuXG4gICAgICovXG4gICAgU2VjdGlvbkxpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCwgY291bnQpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIHJlbW92ZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9jb3VudCB8fCBjb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xhbXAgdGhlIGNvdW50IHRvIHRoZSBib3VuZHMgb2YgdGhlIGxpc3QuXG4gICAgICAgIGNvdW50ID0gTWF0aC5taW4odGhpcy5fY291bnQgLSBpbmRleCwgY291bnQpO1xuICAgICAgICAvLyBIYW5kbGUgdGhlIHNpbXBsZSBjYXNlIG9mIG5vIG1vZGlmaWVkIHNlY3Rpb25zIHRvIHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY291bnQgLT0gY291bnQ7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggLT0gY291bnQgKiB0aGlzLl9kZWZhdWx0U2l6ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIHNpbXBsZSBjYXNlIG9mIHJlbW92aW5nIGFsbCBzZWN0aW9ucy5cbiAgICAgICAgaWYgKGNvdW50ID09PSB0aGlzLl9jb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgbW9kaWZpZWQgc2VjdGlvbiBmb3IgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICB2YXIgaSA9IEFycmF5RXh0Lmxvd2VyQm91bmQodGhpcy5fc2VjdGlvbnMsIGluZGV4LCBQcml2YXRlJDUuaW5kZXhDbXApO1xuICAgICAgICAvLyBGaW5kIHRoZSBtb2RpZmllZCBzZWN0aW9uIGZvciB0aGUgZW5kIGluZGV4LlxuICAgICAgICB2YXIgaiA9IEFycmF5RXh0Lmxvd2VyQm91bmQodGhpcy5fc2VjdGlvbnMsIGluZGV4ICsgY291bnQsIFByaXZhdGUkNS5pbmRleENtcCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVsZXZhbnQgbW9kaWZpZWQgc2VjdGlvbnMuXG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fc2VjdGlvbnMuc3BsaWNlKGksIGogLSBpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdG90YWwgcmVtb3ZlZCBzcGFuLlxuICAgICAgICB2YXIgc3BhbiA9IChjb3VudCAtIHJlbW92ZWQubGVuZ3RoKSAqIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICBmb3IgKHZhciBrID0gMCwgbiA9IHJlbW92ZWQubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICAgICAgICBzcGFuICs9IHJlbW92ZWRba10uc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIHRvdGFscy5cbiAgICAgICAgdGhpcy5fY291bnQgLT0gY291bnQ7XG4gICAgICAgIHRoaXMuX2xlbmd0aCAtPSBzcGFuO1xuICAgICAgICAvLyBVcGRhdGUgYWxsIG1vZGlmaWVkIHNlY3Rpb25zIGFmdGVyIHRoZSByZW1vdmVkIHNwYW4uXG4gICAgICAgIGZvciAodmFyIGsgPSBpLCBuID0gdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2tdO1xuICAgICAgICAgICAgc2VjdGlvbi5pbmRleCAtPSBjb3VudDtcbiAgICAgICAgICAgIHNlY3Rpb24ub2Zmc2V0IC09IHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgc2VjdGlvbnMgd2l0aGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzZWN0aW9uIHRvIG1vdmUuIFRoaXMgbWV0aG9kXG4gICAgICogICBpcyBhIG5vLW9wIGlmIHRoaXMgdmFsdWUgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiBzZWN0aW9ucyB0byBtb3ZlLiBUaGlzIG1ldGhvZCBpcyBhXG4gICAgICogICBuby1vcCBpZiB0aGlzIHZhbHVlIGlzIGA8PSAwYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiAtIFRoZSBkZXN0aW5hdGlvbiBpbmRleCBmb3IgdGhlIGZpcnN0IHNlY3Rpb24uXG4gICAgICogICBUaGlzIHZhbHVlIHdpbGwgYmUgY2xhbXBlZCB0byB0aGUgYWxsb3dhYmxlIHJhbmdlLlxuICAgICAqXG4gICAgICogIyMjIyBVbmRlZmluZWQgQmVoYXZpb3JcbiAgICAgKiBBbiBgaW5kZXhgLCBgY291bnRgLCBvciBgZGVzdGluYXRpb25gIHdoaWNoIGlzIG5vbi1pbnRlZ3JhbC5cbiAgICAgKlxuICAgICAqICMjIyMgQ29tcGxleGl0eVxuICAgICAqIExpbmVhciBvbiB0aGUgbnVtYmVyIG9mIG1vdmVkIHJlc2l6ZWQgc2VjdGlvbnMuXG4gICAgICovXG4gICAgU2VjdGlvbkxpc3QucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBkZXN0aW5hdGlvbikge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gbW92ZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9jb3VudCB8fCBjb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzaW1wbGUgY2FzZSBvZiBubyBtb2RpZmllZCBzZWN0aW9ucy5cbiAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRoZSBtb3ZlIGNvdW50IHRvIHRoZSBsaW1pdC5cbiAgICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5fY291bnQgLSBpbmRleCk7XG4gICAgICAgIC8vIENsYW1wIHRoZSBkZXN0aW5hdGlvbiBpbmRleCB0byB0aGUgbGltaXQuXG4gICAgICAgIGRlc3RpbmF0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZGVzdGluYXRpb24pLCB0aGlzLl9jb3VudCAtIGNvdW50KTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBlZmZlY3RpdmUgbW92ZS5cbiAgICAgICAgaWYgKGluZGV4ID09PSBkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZpcnN0IGFmZmVjdGVkIGluZGV4LlxuICAgICAgICB2YXIgaTEgPSBNYXRoLm1pbihpbmRleCwgZGVzdGluYXRpb24pO1xuICAgICAgICAvLyBMb29rIHVwIHRoZSBmaXJzdCBhZmZlY3RlZCBtb2RpZmllZCBzZWN0aW9uLlxuICAgICAgICB2YXIgazEgPSBBcnJheUV4dC5sb3dlckJvdW5kKHRoaXMuX3NlY3Rpb25zLCBpMSwgUHJpdmF0ZSQ1LmluZGV4Q21wKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gYWZmZWN0ZWQgbW9kaWZpZWQgc2VjdGlvbnMuXG4gICAgICAgIGlmIChrMSA9PT0gdGhpcy5fc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGFzdCBhZmZlY3RlZCBpbmRleC5cbiAgICAgICAgdmFyIGkyID0gTWF0aC5tYXgoaW5kZXggKyBjb3VudCAtIDEsIGRlc3RpbmF0aW9uICsgY291bnQgLSAxKTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgbGFzdCBhZmZlY3RlZCBtb2RpZmllZCBzZWN0aW9uLlxuICAgICAgICB2YXIgazIgPSBBcnJheUV4dC51cHBlckJvdW5kKHRoaXMuX3NlY3Rpb25zLCBpMiwgUHJpdmF0ZSQ1LmluZGV4Q21wKSAtIDE7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIGFmZmVjdGVkIG1vZGlmaWVkIHNlY3Rpb25zLlxuICAgICAgICBpZiAoazIgPCBrMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBpdm90IGluZGV4LlxuICAgICAgICB2YXIgcGl2b3QgPSBkZXN0aW5hdGlvbiA8IGluZGV4ID8gaW5kZXggOiBpbmRleCArIGNvdW50O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb3VudCBmb3IgZWFjaCBzaWRlIG9mIHRoZSBwaXZvdC5cbiAgICAgICAgdmFyIGNvdW50MSA9IHBpdm90IC0gaTE7XG4gICAgICAgIHZhciBjb3VudDIgPSBpMiAtIHBpdm90ICsgMTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgc3BhbiBmb3IgZWFjaCBzaWRlIG9mIHRoZSBwaXZvdC5cbiAgICAgICAgdmFyIHNwYW4xID0gY291bnQxICogdGhpcy5fZGVmYXVsdFNpemU7XG4gICAgICAgIHZhciBzcGFuMiA9IGNvdW50MiAqIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIHNwYW5zIGZvciB0aGUgbW9kaWZpZWQgc2VjdGlvbnMuXG4gICAgICAgIGZvciAodmFyIGogPSBrMTsgaiA8PSBrMjsgKytqKSB7XG4gICAgICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2pdO1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uaW5kZXggPCBwaXZvdCkge1xuICAgICAgICAgICAgICAgIHNwYW4xICs9IHNlY3Rpb24uc2l6ZSAtIHRoaXMuX2RlZmF1bHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BhbjIgKz0gc2VjdGlvbi5zaXplIC0gdGhpcy5fZGVmYXVsdFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgcGl2b3Qgc2VjdGlvbi5cbiAgICAgICAgdmFyIGszID0gQXJyYXlFeHQubG93ZXJCb3VuZCh0aGlzLl9zZWN0aW9ucywgcGl2b3QsIFByaXZhdGUkNS5pbmRleENtcCk7XG4gICAgICAgIC8vIFJvdGF0ZSB0aGUgbW9kaWZpZWQgc2VjdGlvbnMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoazEgPD0gazMgJiYgazMgPD0gazIpIHtcbiAgICAgICAgICAgIEFycmF5RXh0LnJvdGF0ZSh0aGlzLl9zZWN0aW9ucywgazMgLSBrMSwgazEsIGsyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIG1vZGlmaWVkIHNlY3Rpb24gaW5kaWNlcyBhbmQgb2Zmc2V0cy5cbiAgICAgICAgZm9yICh2YXIgaiA9IGsxOyBqIDw9IGsyOyArK2opIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbal07XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5pbmRleCA8IHBpdm90KSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5pbmRleCArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5vZmZzZXQgKz0gc3BhbjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmluZGV4IC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLm9mZnNldCAtPSBzcGFuMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgYWxsIG1vZGlmaWVkIHNlY3Rpb25zIHRvIHRoZSBkZWZhdWx0IHNpemUuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKi9cbiAgICBTZWN0aW9uTGlzdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2NvdW50ICogdGhpcy5fZGVmYXVsdFNpemU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHNlY3Rpb25zIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIENvbXBsZXhpdHlcbiAgICAgKiBDb25zdGFudC5cbiAgICAgKi9cbiAgICBTZWN0aW9uTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc2VjdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBTZWN0aW9uTGlzdDtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkNTtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIEEgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3Igc2VhcmNoaW5nIGJ5IG9mZnNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvZmZzZXRDbXAoc2VjdGlvbiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBzZWN0aW9uLm9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb24ub2Zmc2V0ICsgc2VjdGlvbi5zaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBQcml2YXRlLm9mZnNldENtcCA9IG9mZnNldENtcDtcbiAgICAvKipcbiAgICAgKiBBIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIHNlYXJjaGluZyBieSBpbmRleC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleENtcChzZWN0aW9uLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5pbmRleCAtIGluZGV4O1xuICAgIH1cbiAgICBQcml2YXRlLmluZGV4Q21wID0gaW5kZXhDbXA7XG59KShQcml2YXRlJDUgfHwgKFByaXZhdGUkNSA9IHt9KSk7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSAyMDE0LTIwMTksIFBob3NwaG9ySlMgQ29udHJpYnV0b3JzXG58XG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG58XG58IFRoZSBmdWxsIGxpY2Vuc2UgaXMgaW4gdGhlIGZpbGUgTElDRU5TRSwgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvZnR3YXJlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBSZXNvbHZlIGEgY29uZmlnIG9wdGlvbiBmb3IgYSBjZWxsIGVkaXRvci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uIC0gVGhlIGNvbmZpZyBvcHRpb24gdG8gcmVzb2x2ZS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNlbGwgY29uZmlnIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZSBvcHRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVPcHRpb24ob3B0aW9uLCBjb25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbihjb25maWcpIDogb3B0aW9uO1xufVxuLyoqXG4gKiBBbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBjZWxsIGVkaXRpbmcuIEl0IHN0b3JlcyBlZGl0b3Igb3ZlcnJpZGVzLFxuICogZGVjaWRlcyB3aGljaCBlZGl0b3IgdG8gdXNlIGZvciBhIGNlbGwsIG1ha2VzIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgZWRpdG9yIGFjdGl2ZS5cbiAqL1xudmFyIENlbGxFZGl0b3JDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlbGxFZGl0b3JDb250cm9sbGVyKCkge1xuICAgICAgICAvLyBhY3RpdmUgY2VsbCBlZGl0b3JcbiAgICAgICAgdGhpcy5fZWRpdG9yID0gbnVsbDtcbiAgICAgICAgLy8gYWN0aXZlIGNlbGwgYmVpbmcgZWRpdGVkXG4gICAgICAgIHRoaXMuX2NlbGwgPSBudWxsO1xuICAgICAgICAvLyBjZWxsIGVkaXRvciBvdmVycmlkZXMgYmFzZWQgb24gY2VsbCBkYXRhIHR5cGUgaWRlbnRpZmllclxuICAgICAgICB0aGlzLl90eXBlQmFzZWRPdmVycmlkZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIGNlbGwgZWRpdG9yIG92ZXJyaWRlcyBiYXNlZCBvbiBwYXJ0aWFsIG1ldGFkYXRhIG1hdGNoXG4gICAgICAgIHRoaXMuX21ldGFkYXRhQmFzZWRPdmVycmlkZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGNlbGwgZWRpdG9yIGZvciB0aGUgY2VsbHMgbWF0Y2hpbmcgdGhlIGlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciAtIENlbGwgaWRlbnRpZmllciB0byB1c2Ugd2hlbiBtYXRjaGluZyBjZWxscy5cbiAgICAgKiBpZiBpZGVudGlmaWVyIGlzIGEgQ2VsbERhdGFUeXBlLCB0aGVuIGNlbGwgbWF0Y2hpbmcgaXMgZG9uZSB1c2luZyBkYXRhIHR5cGUgb2YgdGhlIGNlbGwsXG4gICAgICogaWYgaWRlbnRpZmllciBpcyBhIE1ldGFkYXRhLCB0aGVuIHBhcnRpYWwgbWF0Y2ggb2YgdGhlIGNlbGwgbWV0YWRhdGEgd2l0aCBpZGVudGlmaWVyIGlzIHVzZWQgZm9yIG1hdGNoLFxuICAgICAqIGlmIGlkZW50aWZpZXIgaXMgJ2RlZmF1bHQnIHRoZW4gb3ZlcnJpZGUgaXMgdXNlZCBhcyBkZWZhdWx0IGVkaXRvciB3aGVuIG5vIG90aGVyIGVkaXRvciBpcyBmb3VuZCBzdWl0YWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRvciAtIFRoZSBjZWxsIGVkaXRvciB0byB1c2Ugb3IgcmVzb2x2ZXIgdG8gdXNlIHRvIGdldCBhbiBlZGl0b3IgZm9yIG1hdGNoaW5nIGNlbGxzLlxuICAgICAqL1xuICAgIENlbGxFZGl0b3JDb250cm9sbGVyLnByb3RvdHlwZS5zZXRFZGl0b3IgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgZWRpdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX3R5cGVCYXNlZE92ZXJyaWRlcy5zZXQoaWRlbnRpZmllciwgZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9tZXRhZGF0YUlkZW50aWZpZXJUb0tleShpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQmFzZWRPdmVycmlkZXMuc2V0KGtleSwgW2lkZW50aWZpZXIsIGVkaXRvcl0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBlZGl0aW5nIGEgY2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZWxsIC0gVGhlIG9iamVjdCBob2xkaW5nIGNlbGwgY29uZmlndXJhdGlvbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY2VsbCBlZGl0aW5nIG9wdGlvbnMuXG4gICAgICovXG4gICAgQ2VsbEVkaXRvckNvbnRyb2xsZXIucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiAoY2VsbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZ3JpZCA9IGNlbGwuZ3JpZDtcbiAgICAgICAgaWYgKCFncmlkLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHcmlkIGNhbm5vdCBiZSBlZGl0ZWQhJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fY2VsbCA9IGNlbGw7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm9uQ29tbWl0ID0gb3B0aW9ucy5vbkNvbW1pdCB8fCB0aGlzLl9vbkNvbW1pdC5iaW5kKHRoaXMpO1xuICAgICAgICBvcHRpb25zLm9uQ2FuY2VsID0gb3B0aW9ucy5vbkNhbmNlbCB8fCB0aGlzLl9vbkNhbmNlbC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBpZiBhbiBlZGl0b3IgaXMgcGFzc2VkIGluIHdpdGggb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIGVkaXRpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMuZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0b3IgPSBvcHRpb25zLmVkaXRvcjtcbiAgICAgICAgICAgIG9wdGlvbnMuZWRpdG9yLmVkaXQoY2VsbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaG9vc2UgYW4gZWRpdG9yIGJhc2VkIG9uIG92ZXJyaWRlcyAvIGNlbGwgZGF0YSB0eXBlXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLl9nZXRFZGl0b3IoY2VsbCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgIGVkaXRvci5lZGl0KGNlbGwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGVkaXRpbmcuXG4gICAgICovXG4gICAgQ2VsbEVkaXRvckNvbnRyb2xsZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5fZWRpdG9yLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jZWxsID0gbnVsbDtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JDb250cm9sbGVyLnByb3RvdHlwZS5fb25Db21taXQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JpZCA9IGNlbGwuZ3JpZDtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGdyaWQuZGF0YU1vZGVsO1xuICAgICAgICBkYXRhTW9kZWwuc2V0RGF0YSgnYm9keScsIGNlbGwucm93LCBjZWxsLmNvbHVtbiwgcmVzcG9uc2UudmFsdWUpO1xuICAgICAgICBncmlkLnZpZXdwb3J0Lm5vZGUuZm9jdXMoKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmN1cnNvck1vdmVtZW50ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGdyaWQubW92ZUN1cnNvcihyZXNwb25zZS5jdXJzb3JNb3ZlbWVudCk7XG4gICAgICAgICAgICBncmlkLnNjcm9sbFRvQ3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlbGxFZGl0b3JDb250cm9sbGVyLnByb3RvdHlwZS5fb25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NlbGwuZ3JpZC52aWV3cG9ydC5ub2RlLmZvY3VzKCk7XG4gICAgfTtcbiAgICBDZWxsRWRpdG9yQ29udHJvbGxlci5wcm90b3R5cGUuX2dldERhdGFUeXBlS2V5ID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gY2VsbC5ncmlkLmRhdGFNb2RlbCA/IGNlbGwuZ3JpZC5kYXRhTW9kZWwubWV0YWRhdGEoJ2JvZHknLCBjZWxsLnJvdywgY2VsbC5jb2x1bW4pIDogbnVsbDtcbiAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gJyc7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAga2V5ID0gbWV0YWRhdGEudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEuY29uc3RyYWludCAmJiBtZXRhZGF0YS5jb25zdHJhaW50LmVudW0pIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb25zdHJhaW50LmVudW0gPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICAgIGtleSArPSAnOmR5bmFtaWMtb3B0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSArPSAnOm9wdGlvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JDb250cm9sbGVyLnByb3RvdHlwZS5fb2JqZWN0VG9LZXkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHN0ciArPSBrZXkgKyBcIjpcIiArIHRoaXMuX29iamVjdFRvS2V5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIltcIiArIGtleSArIFwiOlwiICsgdmFsdWUgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvckNvbnRyb2xsZXIucHJvdG90eXBlLl9tZXRhZGF0YUlkZW50aWZpZXJUb0tleSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0VG9LZXkobWV0YWRhdGEpO1xuICAgIH07XG4gICAgQ2VsbEVkaXRvckNvbnRyb2xsZXIucHJvdG90eXBlLl9tZXRhZGF0YU1hdGNoZXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKG1ldGFkYXRhLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllclZhbHVlID0gaWRlbnRpZmllcltrZXldO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhVmFsdWUgPSBtZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tZXRhZGF0YU1hdGNoZXNJZGVudGlmaWVyKG1ldGFkYXRhVmFsdWUsIGlkZW50aWZpZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFkYXRhVmFsdWUgIT09IGlkZW50aWZpZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENlbGxFZGl0b3JDb250cm9sbGVyLnByb3RvdHlwZS5fZ2V0TWV0YWRhdGFCYXNlZEVkaXRvciA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlZGl0b3JNYXRjaGVkO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjZWxsLmdyaWQuZGF0YU1vZGVsLm1ldGFkYXRhKCdib2R5JywgY2VsbC5yb3csIGNlbGwuY29sdW1uKTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRhZGF0YUJhc2VkT3ZlcnJpZGVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3JNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gdmFsdWVbMF0sIGVkaXRvciA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX21ldGFkYXRhTWF0Y2hlc0lkZW50aWZpZXIobWV0YWRhdGEsIGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JNYXRjaGVkID0gcmVzb2x2ZU9wdGlvbihlZGl0b3IsIGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkaXRvck1hdGNoZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaG9vc2UgdGhlIG1vc3QgYXBwcm9wcmlhdGUgY2VsbCBlZGl0b3IgdG8gdXNlIGJhc2VkIG9uIG92ZXJyaWRlcyAvIGNlbGwgZGF0YSB0eXBlLlxuICAgICAqXG4gICAgICogSWYgbm8gbWF0Y2ggaXMgZm91bmQgaW4gb3ZlcnJpZGVzIG9yIGJhc2VkIG9uIGNlbGwgZGF0YSB0eXBlLCBhbmQgaWYgY2VsbCBoYXMgYSBwcmltaXRpdmVcbiAgICAgKiBkYXRhIHR5cGUgdGhlbiBUZXh0Q2VsbEVkaXRvciBpcyB1c2VkIGFzIGRlZmF1bHQgY2VsbCBlZGl0b3IuIElmICdkZWZhdWx0JyBjZWxsIGVkaXRvclxuICAgICAqIGlzIG92ZXJyaWRkZW4sIHRoZW4gaXQgaXMgdXNlZCBpbnN0ZWFkIG9mIFRleHRDZWxsRWRpdG9yIGZvciBkZWZhdWx0LlxuICAgICAqL1xuICAgIENlbGxFZGl0b3JDb250cm9sbGVyLnByb3RvdHlwZS5fZ2V0RWRpdG9yID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgdmFyIGR0S2V5ID0gdGhpcy5fZ2V0RGF0YVR5cGVLZXkoY2VsbCk7XG4gICAgICAgIC8vIGZpbmQgYW4gZWRpdG9yIGJhc2VkIG9uIGRhdGEgdHlwZSBiYXNlZCBvdmVycmlkZVxuICAgICAgICBpZiAodGhpcy5fdHlwZUJhc2VkT3ZlcnJpZGVzLmhhcyhkdEtleSkpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLl90eXBlQmFzZWRPdmVycmlkZXMuZ2V0KGR0S2V5KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlT3B0aW9uKGVkaXRvciwgY2VsbCk7XG4gICAgICAgIH0gLy8gZmluZCBhbiBlZGl0b3IgYmFzZWQgb24gbWV0YWRhdGEgbWF0Y2ggYmFzZWQgb3ZlcnJpZGVcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbWV0YWRhdGFCYXNlZE92ZXJyaWRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2dldE1ldGFkYXRhQmFzZWRFZGl0b3IoY2VsbCk7XG4gICAgICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaG9vc2UgYW4gZWRpdG9yIGJhc2VkIG9uIGRhdGEgdHlwZVxuICAgICAgICBzd2l0Y2ggKGR0S2V5KSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dENlbGxFZGl0b3IoKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDZWxsRWRpdG9yKCk7XG4gICAgICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGVnZXJDZWxsRWRpdG9yKCk7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5DZWxsRWRpdG9yKCk7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGVDZWxsRWRpdG9yKCk7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmc6b3B0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcjpvcHRpb24nOlxuICAgICAgICAgICAgY2FzZSAnaW50ZWdlcjpvcHRpb24nOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZTpvcHRpb24nOlxuICAgICAgICAgICAgY2FzZSAnYXJyYXk6b3B0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wdGlvbkNlbGxFZGl0b3IoKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZzpkeW5hbWljLW9wdGlvbic6XG4gICAgICAgICAgICBjYXNlICdudW1iZXI6ZHluYW1pYy1vcHRpb24nOlxuICAgICAgICAgICAgY2FzZSAnaW50ZWdlcjpkeW5hbWljLW9wdGlvbic6XG4gICAgICAgICAgICBjYXNlICdkYXRlOmR5bmFtaWMtb3B0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IER5bmFtaWNPcHRpb25DZWxsRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYW4gb3ZlcnJpZGUgZXhpc3RzIGZvciAnZGVmYXVsdCcsIHRoZW4gdXNlIGl0XG4gICAgICAgIGlmICh0aGlzLl90eXBlQmFzZWRPdmVycmlkZXMuaGFzKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLl90eXBlQmFzZWRPdmVycmlkZXMuZ2V0KCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZU9wdGlvbihlZGl0b3IsIGNlbGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGNlbGwgaGFzIGEgcHJpbWl0aXZlIGRhdGEgdHlwZSB0aGVuIHVzZSBUZXh0Q2VsbEVkaXRvclxuICAgICAgICB2YXIgZGF0YSA9IGNlbGwuZ3JpZC5kYXRhTW9kZWwuZGF0YSgnYm9keScsIGNlbGwucm93LCBjZWxsLmNvbHVtbik7XG4gICAgICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dENlbGxFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBzdWl0YWJsZSBlZGl0b3IgZm91bmQgZm9yIHRoZSBjZWxsXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbEVkaXRvckNvbnRyb2xsZXI7XG59KCkpO1xuXG4vKipcbiAqIEEgd2lkZ2V0IHdoaWNoIGltcGxlbWVudHMgYSBoaWdoLXBlcmZvcm1hbmNlIHRhYnVsYXIgZGF0YSBncmlkLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIEEgZGF0YSBncmlkIGlzIGltcGxlbWVudGVkIGFzIGEgY29tcG9zaXRpb24gb2YgY2hpbGQgd2lkZ2V0cy4gVGhlc2VcbiAqIGNoaWxkIHdpZGdldHMgYXJlIGNvbnNpZGVyZWQgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLiBNYW5pcHVsYXRpbmdcbiAqIHRoZSBjaGlsZCB3aWRnZXRzIG9mIGEgZGF0YSBncmlkIGRpcmVjdGx5IGlzIHVuZGVmaW5lZCBiZWhhdmlvci5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIG5vdCBkZXNpZ25lZCB0byBiZSBzdWJjbGFzc2VkLlxuICovXG52YXIgRGF0YUdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERhdGFHcmlkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhR3JpZChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zY3JvbGxYID0gMDtcbiAgICAgICAgX3RoaXMuX3Njcm9sbFkgPSAwO1xuICAgICAgICBfdGhpcy5fdmlld3BvcnRXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLl92aWV3cG9ydEhlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLl9tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2tleUhhbmRsZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5fbW91c2VIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3ZTY3JvbGxCYXJNaW5XaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLl9oU2Nyb2xsQmFyTWluSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuX2RwaVJhdGlvID0gTWF0aC5jZWlsKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgX3RoaXMuX2RhdGFNb2RlbCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9zZWxlY3Rpb25Nb2RlbCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9lZGl0aW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygnbG0tRGF0YUdyaWQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdwLURhdGFHcmlkJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgLy8gUGFyc2UgdGhlIHNpbXBsZSBvcHRpb25zLlxuICAgICAgICBfdGhpcy5fc3R5bGUgPSBvcHRpb25zLnN0eWxlIHx8IERhdGFHcmlkLmRlZmF1bHRTdHlsZTtcbiAgICAgICAgX3RoaXMuX3N0cmV0Y2hMYXN0Um93ID0gb3B0aW9ucy5zdHJldGNoTGFzdFJvdyB8fCBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3N0cmV0Y2hMYXN0Q29sdW1uID0gb3B0aW9ucy5zdHJldGNoTGFzdENvbHVtbiB8fCBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2hlYWRlclZpc2liaWxpdHkgPSBvcHRpb25zLmhlYWRlclZpc2liaWxpdHkgfHwgJ2FsbCc7XG4gICAgICAgIF90aGlzLl9jZWxsUmVuZGVyZXJzID0gb3B0aW9ucy5jZWxsUmVuZGVyZXJzIHx8IG5ldyBSZW5kZXJlck1hcCgpO1xuICAgICAgICBfdGhpcy5fY29weUNvbmZpZyA9IG9wdGlvbnMuY29weUNvbmZpZyB8fCBEYXRhR3JpZC5kZWZhdWx0Q29weUNvbmZpZztcbiAgICAgICAgLy8gQ29ubmVjdCB0byB0aGUgcmVuZGVyZXIgbWFwIGNoYW5nZWQgc2lnbmFsLlxuICAgICAgICBfdGhpcy5fY2VsbFJlbmRlcmVycy5jaGFuZ2VkLmNvbm5lY3QoX3RoaXMuX29uUmVuZGVyZXJzQ2hhbmdlZCwgX3RoaXMpO1xuICAgICAgICAvLyBQYXJzZSB0aGUgZGVmYXVsdCBzaXplcy5cbiAgICAgICAgdmFyIGRlZmF1bHRTaXplcyA9IG9wdGlvbnMuZGVmYXVsdFNpemVzIHx8IERhdGFHcmlkLmRlZmF1bHRTaXplcztcbiAgICAgICAgdmFyIG1pbmltdW1TaXplcyA9IG9wdGlvbnMubWluaW11bVNpemVzIHx8IERhdGFHcmlkLm1pbmltdW1TaXplcztcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBzZWN0aW9ucyBsaXN0cy5cbiAgICAgICAgX3RoaXMuX3Jvd1NlY3Rpb25zID0gbmV3IFNlY3Rpb25MaXN0KHsgZGVmYXVsdFNpemU6IGRlZmF1bHRTaXplcy5yb3dIZWlnaHQsXG4gICAgICAgICAgICBtaW5pbXVtU2l6ZTogbWluaW11bVNpemVzLnJvd0hlaWdodCB9KTtcbiAgICAgICAgX3RoaXMuX2NvbHVtblNlY3Rpb25zID0gbmV3IFNlY3Rpb25MaXN0KHsgZGVmYXVsdFNpemU6IGRlZmF1bHRTaXplcy5jb2x1bW5XaWR0aCxcbiAgICAgICAgICAgIG1pbmltdW1TaXplOiBtaW5pbXVtU2l6ZXMuY29sdW1uV2lkdGggfSk7XG4gICAgICAgIF90aGlzLl9yb3dIZWFkZXJTZWN0aW9ucyA9IG5ldyBTZWN0aW9uTGlzdCh7IGRlZmF1bHRTaXplOiBkZWZhdWx0U2l6ZXMucm93SGVhZGVyV2lkdGgsXG4gICAgICAgICAgICBtaW5pbXVtU2l6ZTogbWluaW11bVNpemVzLnJvd0hlYWRlcldpZHRoIH0pO1xuICAgICAgICBfdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMgPSBuZXcgU2VjdGlvbkxpc3QoeyBkZWZhdWx0U2l6ZTogZGVmYXVsdFNpemVzLmNvbHVtbkhlYWRlckhlaWdodCxcbiAgICAgICAgICAgIG1pbmltdW1TaXplOiBtaW5pbXVtU2l6ZXMuY29sdW1uSGVhZGVySGVpZ2h0IH0pO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGNhbnZhcywgYnVmZmVyLCBhbmQgb3ZlcmxheSBvYmplY3RzLlxuICAgICAgICBfdGhpcy5fY2FudmFzID0gUHJpdmF0ZSQ2LmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICBfdGhpcy5fYnVmZmVyID0gUHJpdmF0ZSQ2LmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICBfdGhpcy5fb3ZlcmxheSA9IFByaXZhdGUkNi5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgLy8gR2V0IHRoZSBncmFwaGljcyBjb250ZXh0cyBmb3IgdGhlIGNhbnZhc2VzLlxuICAgICAgICBfdGhpcy5fY2FudmFzR0MgPSBfdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIF90aGlzLl9idWZmZXJHQyA9IF90aGlzLl9idWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlHQyA9IF90aGlzLl9vdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgb24tc2NyZWVuIGNhbnZhcy5cbiAgICAgICAgX3RoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIF90aGlzLl9jYW52YXMuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIF90aGlzLl9jYW52YXMuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBfdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gJzBweCc7XG4gICAgICAgIF90aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgb24tc2NyZWVuIG92ZXJsYXkuXG4gICAgICAgIF90aGlzLl9vdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgX3RoaXMuX292ZXJsYXkuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIF90aGlzLl9vdmVybGF5LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgX3RoaXMuX292ZXJsYXkuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICAgICAgX3RoaXMuX292ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW50ZXJuYWwgd2lkZ2V0cyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgX3RoaXMuX3ZpZXdwb3J0ID0gbmV3IFdpZGdldCgpO1xuICAgICAgICBfdGhpcy5fdmlld3BvcnQubm9kZS50YWJJbmRleCA9IC0xO1xuICAgICAgICBfdGhpcy5fdmlld3BvcnQubm9kZS5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgICAgICBfdGhpcy5fdlNjcm9sbEJhciA9IG5ldyBTY3JvbGxCYXIoeyBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyB9KTtcbiAgICAgICAgX3RoaXMuX2hTY3JvbGxCYXIgPSBuZXcgU2Nyb2xsQmFyKHsgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB9KTtcbiAgICAgICAgX3RoaXMuX3Njcm9sbENvcm5lciA9IG5ldyBXaWRnZXQoKTtcbiAgICAgICAgX3RoaXMuX2VkaXRvckNvbnRyb2xsZXIgPSBuZXcgQ2VsbEVkaXRvckNvbnRyb2xsZXIoKTtcbiAgICAgICAgLy8gQWRkIHRoZSBleHRyYSBjbGFzcyBuYW1lcyB0byB0aGUgY2hpbGQgd2lkZ2V0cy5cbiAgICAgICAgX3RoaXMuX3ZpZXdwb3J0LmFkZENsYXNzKCdsbS1EYXRhR3JpZC12aWV3cG9ydCcpO1xuICAgICAgICBfdGhpcy5fdlNjcm9sbEJhci5hZGRDbGFzcygnbG0tRGF0YUdyaWQtc2Nyb2xsQmFyJyk7XG4gICAgICAgIF90aGlzLl9oU2Nyb2xsQmFyLmFkZENsYXNzKCdsbS1EYXRhR3JpZC1zY3JvbGxCYXInKTtcbiAgICAgICAgX3RoaXMuX3Njcm9sbENvcm5lci5hZGRDbGFzcygnbG0tRGF0YUdyaWQtc2Nyb2xsQ29ybmVyJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5fdmlld3BvcnQuYWRkQ2xhc3MoJ3AtRGF0YUdyaWQtdmlld3BvcnQnKTtcbiAgICAgICAgX3RoaXMuX3ZTY3JvbGxCYXIuYWRkQ2xhc3MoJ3AtRGF0YUdyaWQtc2Nyb2xsQmFyJyk7XG4gICAgICAgIF90aGlzLl9oU2Nyb2xsQmFyLmFkZENsYXNzKCdwLURhdGFHcmlkLXNjcm9sbEJhcicpO1xuICAgICAgICBfdGhpcy5fc2Nyb2xsQ29ybmVyLmFkZENsYXNzKCdwLURhdGFHcmlkLXNjcm9sbENvcm5lcicpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIC8vIEFkZCB0aGUgb24tc2NyZWVuIGNhbnZhcyB0byB0aGUgdmlld3BvcnQgbm9kZS5cbiAgICAgICAgX3RoaXMuX3ZpZXdwb3J0Lm5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMuX2NhbnZhcyk7XG4gICAgICAgIC8vIEFkZCB0aGUgb24tc2NyZWVuIG92ZXJsYXkgdG8gdGhlIHZpZXdwb3J0IG5vZGUuXG4gICAgICAgIF90aGlzLl92aWV3cG9ydC5ub2RlLmFwcGVuZENoaWxkKF90aGlzLl9vdmVybGF5KTtcbiAgICAgICAgLy8gSW5zdGFsbCB0aGUgbWVzc2FnZSBob29rcy5cbiAgICAgICAgTWVzc2FnZUxvb3AuaW5zdGFsbE1lc3NhZ2VIb29rKF90aGlzLl92aWV3cG9ydCwgX3RoaXMpO1xuICAgICAgICBNZXNzYWdlTG9vcC5pbnN0YWxsTWVzc2FnZUhvb2soX3RoaXMuX2hTY3JvbGxCYXIsIF90aGlzKTtcbiAgICAgICAgTWVzc2FnZUxvb3AuaW5zdGFsbE1lc3NhZ2VIb29rKF90aGlzLl92U2Nyb2xsQmFyLCBfdGhpcyk7XG4gICAgICAgIC8vIEhpZGUgdGhlIHNjcm9sbCBiYXJzIGFuZCBjb3JuZXIgZnJvbSB0aGUgb3V0c2V0LlxuICAgICAgICBfdGhpcy5fdlNjcm9sbEJhci5oaWRlKCk7XG4gICAgICAgIF90aGlzLl9oU2Nyb2xsQmFyLmhpZGUoKTtcbiAgICAgICAgX3RoaXMuX3Njcm9sbENvcm5lci5oaWRlKCk7XG4gICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIHNjcm9sbCBiYXIgc2lnbmFscy5cbiAgICAgICAgX3RoaXMuX3ZTY3JvbGxCYXIudGh1bWJNb3ZlZC5jb25uZWN0KF90aGlzLl9vblRodW1iTW92ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2hTY3JvbGxCYXIudGh1bWJNb3ZlZC5jb25uZWN0KF90aGlzLl9vblRodW1iTW92ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMuX3ZTY3JvbGxCYXIucGFnZVJlcXVlc3RlZC5jb25uZWN0KF90aGlzLl9vblBhZ2VSZXF1ZXN0ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2hTY3JvbGxCYXIucGFnZVJlcXVlc3RlZC5jb25uZWN0KF90aGlzLl9vblBhZ2VSZXF1ZXN0ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMuX3ZTY3JvbGxCYXIuc3RlcFJlcXVlc3RlZC5jb25uZWN0KF90aGlzLl9vblN0ZXBSZXF1ZXN0ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2hTY3JvbGxCYXIuc3RlcFJlcXVlc3RlZC5jb25uZWN0KF90aGlzLl9vblN0ZXBSZXF1ZXN0ZWQsIF90aGlzKTtcbiAgICAgICAgLy8gU2V0IHRoZSBsYXlvdXQgY2VsbCBjb25maWcgZm9yIHRoZSBjaGlsZCB3aWRnZXRzLlxuICAgICAgICBHcmlkTGF5b3V0LnNldENlbGxDb25maWcoX3RoaXMuX3ZpZXdwb3J0LCB7IHJvdzogMCwgY29sdW1uOiAwIH0pO1xuICAgICAgICBHcmlkTGF5b3V0LnNldENlbGxDb25maWcoX3RoaXMuX3ZTY3JvbGxCYXIsIHsgcm93OiAwLCBjb2x1bW46IDEgfSk7XG4gICAgICAgIEdyaWRMYXlvdXQuc2V0Q2VsbENvbmZpZyhfdGhpcy5faFNjcm9sbEJhciwgeyByb3c6IDEsIGNvbHVtbjogMCB9KTtcbiAgICAgICAgR3JpZExheW91dC5zZXRDZWxsQ29uZmlnKF90aGlzLl9zY3JvbGxDb3JuZXIsIHsgcm93OiAxLCBjb2x1bW46IDEgfSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbGF5b3V0IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICB2YXIgbGF5b3V0ID0gbmV3IEdyaWRMYXlvdXQoe1xuICAgICAgICAgICAgcm93Q291bnQ6IDIsXG4gICAgICAgICAgICBjb2x1bW5Db3VudDogMixcbiAgICAgICAgICAgIHJvd1NwYWNpbmc6IDAsXG4gICAgICAgICAgICBjb2x1bW5TcGFjaW5nOiAwLFxuICAgICAgICAgICAgZml0UG9saWN5OiAnc2V0LW5vLWNvbnN0cmFpbnQnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgdGhlIHN0cmV0Y2ggZmFjdG9ycyBmb3IgdGhlIGdyaWQuXG4gICAgICAgIGxheW91dC5zZXRSb3dTdHJldGNoKDAsIDEpO1xuICAgICAgICBsYXlvdXQuc2V0Um93U3RyZXRjaCgxLCAwKTtcbiAgICAgICAgbGF5b3V0LnNldENvbHVtblN0cmV0Y2goMCwgMSk7XG4gICAgICAgIGxheW91dC5zZXRDb2x1bW5TdHJldGNoKDEsIDApO1xuICAgICAgICAvLyBBZGQgdGhlIGNoaWxkIHdpZGdldHMgdG8gdGhlIGxheW91dC5cbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChfdGhpcy5fdmlld3BvcnQpO1xuICAgICAgICBsYXlvdXQuYWRkV2lkZ2V0KF90aGlzLl92U2Nyb2xsQmFyKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChfdGhpcy5faFNjcm9sbEJhcik7XG4gICAgICAgIGxheW91dC5hZGRXaWRnZXQoX3RoaXMuX3Njcm9sbENvcm5lcik7XG4gICAgICAgIC8vIEluc3RhbGwgdGhlIGxheW91dCBvbiB0aGUgZGF0YSBncmlkLlxuICAgICAgICBfdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHdpZGdldHMuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlLlxuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgaGFuZGxlcnMuXG4gICAgICAgIGlmICh0aGlzLl9rZXlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbW91c2VIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZUhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tleUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3VzZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAvLyBDbGVhciB0aGUgbW9kZWxzLlxuICAgICAgICB0aGlzLl9kYXRhTW9kZWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbCA9IG51bGw7XG4gICAgICAgIC8vIENsZWFyIHRoZSBzZWN0aW9uIGxpc3RzLlxuICAgICAgICB0aGlzLl9yb3dTZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb2x1bW5TZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb2x1bW5IZWFkZXJTZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSBiYXNlIGNsYXNzLlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwiZGF0YU1vZGVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZGF0YSBtb2RlbCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFNb2RlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgZGF0YSBtb2RlbCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSByZW1vdmUgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIG1vZGVsIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhTW9kZWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVsZWFzZSB0aGUgbW91c2UuXG4gICAgICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gbnVsbDtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIGNoYW5nZSBoYW5kbGVyIGZyb20gdGhlIG9sZCBtb2RlbC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhTW9kZWwuY2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuX29uRGF0YU1vZGVsQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRoZSBjaGFuZ2UgaGFuZGxlciBmb3IgdGhlIG5ldyBtb2RlbC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmNoYW5nZWQuY29ubmVjdCh0aGlzLl9vbkRhdGFNb2RlbENoYW5nZWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBtb2RlbCByZWZlcmVuY2UuXG4gICAgICAgICAgICB0aGlzLl9kYXRhTW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBzZWN0aW9uIGxpc3RzLlxuICAgICAgICAgICAgdGhpcy5fcm93U2VjdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblNlY3Rpb25zLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRoZSBzZWN0aW9uIGxpc3RzLlxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93U2VjdGlvbnMuaW5zZXJ0KDAsIHZhbHVlLnJvd0NvdW50KCdib2R5JykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtblNlY3Rpb25zLmluc2VydCgwLCB2YWx1ZS5jb2x1bW5Db3VudCgnYm9keScpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5pbnNlcnQoMCwgdmFsdWUuY29sdW1uQ291bnQoJ3Jvdy1oZWFkZXInKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuaW5zZXJ0KDAsIHZhbHVlLnJvd0NvdW50KCdjb2x1bW4taGVhZGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFggPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsWSA9IDA7XG4gICAgICAgICAgICAvLyBTeW5jIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgIHRoaXMuX3N5bmNWaWV3cG9ydCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcInNlbGVjdGlvbk1vZGVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc2VsZWN0aW9uIG1vZGVsIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBtb2RlbCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBzZWxlY3Rpb24gbW9kZWwgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlLlxuICAgICAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGRhdGEgbW9kZWxzIGFyZSBhIG1hdGNoLlxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmRhdGFNb2RlbCAhPT0gdGhpcy5fZGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3Rpb25Nb2RlbC5kYXRhTW9kZWwgIT09IERhdGFHcmlkLmRhdGFNb2RlbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgY2hhbmdlIGhhbmRsZXIgZnJvbSB0aGUgb2xkIG1vZGVsLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuX29uU2VsZWN0aW9uc0NoYW5nZWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29ubmVjdCB0aGUgY2hhbmdlIGhhbmRsZXIgZm9yIHRoZSBuZXcgbW9kZWwuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5jaGFuZ2VkLmNvbm5lY3QodGhpcy5fb25TZWxlY3Rpb25zQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIHNlbGVjdGlvbiBtb2RlbCByZWZlcmVuY2UuXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSByZXBhaW50IG9mIHRoZSBvdmVybGF5LlxuICAgICAgICAgICAgdGhpcy5yZXBhaW50T3ZlcmxheSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcImtleUhhbmRsZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBrZXkgaGFuZGxlciBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleUhhbmRsZXI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGtleSBoYW5kbGVyIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleUhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJtb3VzZUhhbmRsZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtb3VzZSBoYW5kbGVyIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW91c2VIYW5kbGVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtb3VzZSBoYW5kbGVyIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG1vdXNlIGhhbmRsZXIgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlSGFuZGxlciA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWxlYXNlIHRoZSBtb3VzZS5cbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBtb3VzZSBoYW5kbGVyLlxuICAgICAgICAgICAgdGhpcy5fbW91c2VIYW5kbGVyID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwic3R5bGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzdHlsZSBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBzdHlsZSBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSBzdHlsZSBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBzdHlsZS5cbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gX19hc3NpZ24oe30sIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcmVwYWludCBvZiB0aGUgY29udGVudC5cbiAgICAgICAgICAgIHRoaXMucmVwYWludENvbnRlbnQoKTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcmVwYWludCBvZiB0aGUgb3ZlcmxheS5cbiAgICAgICAgICAgIHRoaXMucmVwYWludE92ZXJsYXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJjZWxsUmVuZGVyZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2VsbCByZW5kZXJlciBtYXAgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jZWxsUmVuZGVyZXJzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjZWxsIHJlbmRlcmVyIG1hcCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSByZW5kZXJlciBtYXAgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2NlbGxSZW5kZXJlcnMgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgb2xkIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX2NlbGxSZW5kZXJlcnMuY2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuX29uUmVuZGVyZXJzQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRoZSBuZXcgbWFwLlxuICAgICAgICAgICAgdmFsdWUuY2hhbmdlZC5jb25uZWN0KHRoaXMuX29uUmVuZGVyZXJzQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIHJlbmRlcmVyIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX2NlbGxSZW5kZXJlcnMgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcmVwYWludCBvZiB0aGUgZ3JpZCBjb250ZW50LlxuICAgICAgICAgICAgdGhpcy5yZXBhaW50Q29udGVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcImhlYWRlclZpc2liaWxpdHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBoZWFkZXIgdmlzaWJpbGl0eSBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlclZpc2liaWxpdHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGhlYWRlciB2aXNpYmlsaXR5IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJhaWwgaWYgdGhlIHZpc2liaWxpdHkgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWRlclZpc2liaWxpdHkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCB2aXNpYmlsaXR5LlxuICAgICAgICAgICAgdGhpcy5faGVhZGVyVmlzaWJpbGl0eSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gU3luYyB0aGUgdmlld3BvcnQuXG4gICAgICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJkZWZhdWx0U2l6ZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkZWZhdWx0IHNpemVzIGZvciB0aGUgdmFyaW91cyBzZWN0aW9ucyBvZiB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0ID0gdGhpcy5fcm93U2VjdGlvbnMuZGVmYXVsdFNpemU7XG4gICAgICAgICAgICB2YXIgY29sdW1uV2lkdGggPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5kZWZhdWx0U2l6ZTtcbiAgICAgICAgICAgIHZhciByb3dIZWFkZXJXaWR0aCA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLmRlZmF1bHRTaXplO1xuICAgICAgICAgICAgdmFyIGNvbHVtbkhlYWRlckhlaWdodCA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLmRlZmF1bHRTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHsgcm93SGVpZ2h0OiByb3dIZWlnaHQsIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCwgcm93SGVhZGVyV2lkdGg6IHJvd0hlYWRlcldpZHRoLCBjb2x1bW5IZWFkZXJIZWlnaHQ6IGNvbHVtbkhlYWRlckhlaWdodCB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBkZWZhdWx0IHNpemVzIGZvciB0aGUgdmFyaW91cyBzZWN0aW9ucyBvZiB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VjdGlvbiBkZWZhdWx0IHNpemVzLlxuICAgICAgICAgICAgdGhpcy5fcm93U2VjdGlvbnMuZGVmYXVsdFNpemUgPSB2YWx1ZS5yb3dIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5TZWN0aW9ucy5kZWZhdWx0U2l6ZSA9IHZhbHVlLmNvbHVtbldpZHRoO1xuICAgICAgICAgICAgdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMuZGVmYXVsdFNpemUgPSB2YWx1ZS5yb3dIZWFkZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLmRlZmF1bHRTaXplID0gdmFsdWUuY29sdW1uSGVhZGVySGVpZ2h0O1xuICAgICAgICAgICAgLy8gU3luYyB0aGUgdmlld3BvcnQuXG4gICAgICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJtaW5pbXVtU2l6ZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtaW5pbXVtIHNpemVzIGZvciB0aGUgdmFyaW91cyBzZWN0aW9ucyBvZiB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0ID0gdGhpcy5fcm93U2VjdGlvbnMubWluaW11bVNpemU7XG4gICAgICAgICAgICB2YXIgY29sdW1uV2lkdGggPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5taW5pbXVtU2l6ZTtcbiAgICAgICAgICAgIHZhciByb3dIZWFkZXJXaWR0aCA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLm1pbmltdW1TaXplO1xuICAgICAgICAgICAgdmFyIGNvbHVtbkhlYWRlckhlaWdodCA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLm1pbmltdW1TaXplO1xuICAgICAgICAgICAgcmV0dXJuIHsgcm93SGVpZ2h0OiByb3dIZWlnaHQsIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCwgcm93SGVhZGVyV2lkdGg6IHJvd0hlYWRlcldpZHRoLCBjb2x1bW5IZWFkZXJIZWlnaHQ6IGNvbHVtbkhlYWRlckhlaWdodCB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBtaW5pbXVtIHNpemVzIGZvciB0aGUgdmFyaW91cyBzZWN0aW9ucyBvZiB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VjdGlvbiBkZWZhdWx0IHNpemVzLlxuICAgICAgICAgICAgdGhpcy5fcm93U2VjdGlvbnMubWluaW11bVNpemUgPSB2YWx1ZS5yb3dIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5TZWN0aW9ucy5taW5pbXVtU2l6ZSA9IHZhbHVlLmNvbHVtbldpZHRoO1xuICAgICAgICAgICAgdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMubWluaW11bVNpemUgPSB2YWx1ZS5yb3dIZWFkZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLm1pbmltdW1TaXplID0gdmFsdWUuY29sdW1uSGVhZGVySGVpZ2h0O1xuICAgICAgICAgICAgLy8gU3luYyB0aGUgdmlld3BvcnQuXG4gICAgICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJjb3B5Q29uZmlnXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29weSBjb25maWd1cmF0aW9uIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29weUNvbmZpZztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY29weSBjb25maWd1cmF0aW9uIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcHlDb25maWcgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJzdHJldGNoTGFzdFJvd1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2hldGhlciB0aGUgbGFzdCByb3cgaXMgc3RyZXRjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyZXRjaExhc3RSb3c7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgd2hldGhlciB0aGUgbGFzdCByb3cgaXMgc3RyZXRjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fc3RyZXRjaExhc3RSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIHZhbHVlLlxuICAgICAgICAgICAgdGhpcy5fc3RyZXRjaExhc3RSb3cgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFN5bmMgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJzdHJldGNoTGFzdENvbHVtblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2hldGhlciB0aGUgbGFzdCBjb2x1bW4gaXMgc3RyZXRjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyZXRjaExhc3RDb2x1bW47XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgd2hldGhlciB0aGUgbGFzdCBjb2x1bW4gaXMgc3RyZXRjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fc3RyZXRjaExhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIHZhbHVlLlxuICAgICAgICAgICAgdGhpcy5fc3RyZXRjaExhc3RDb2x1bW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFN5bmMgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJoZWFkZXJXaWR0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlydHVhbCB3aWR0aCBvZiB0aGUgcm93IGhlYWRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFkZXJWaXNpYmlsaXR5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFkZXJWaXNpYmlsaXR5ID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJoZWFkZXJIZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZpcnR1YWwgaGVpZ2h0IG9mIHRoZSBjb2x1bW4gaGVhZGVycy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWRlclZpc2liaWxpdHkgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWRlclZpc2liaWxpdHkgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcImJvZHlXaWR0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlydHVhbCB3aWR0aCBvZiB0aGUgZ3JpZCBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgZG9lcyAqbm90KiBhY2NvdW50IGZvciBhIHN0cmV0Y2hlZCBsYXN0IGNvbHVtbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtblNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJib2R5SGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2aXJ0dWFsIGhlaWdodCBvZiB0aGUgZ3JpZCBib2R5LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgZG9lcyAqbm90KiBhY2NvdW50IGZvciBhIHN0cmV0Y2hlZCBsYXN0IHJvdy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd1NlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJ0b3RhbFdpZHRoXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2aXJ0dWFsIHdpZHRoIG9mIHRoZSBlbnRpcmUgZ3JpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIGRvZXMgKm5vdCogYWNjb3VudCBmb3IgYSBzdHJldGNoZWQgbGFzdCBjb2x1bW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlcldpZHRoICsgdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwidG90YWxIZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZpcnR1YWwgaGVpZ2h0IG9mIHRoZSBlbnRpcmUgZ3JpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIGRvZXMgKm5vdCogYWNjb3VudCBmb3IgYSBzdHJldGNoZWQgbGFzdCByb3cuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlckhlaWdodCArIHRoaXMuYm9keUhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJ2aWV3cG9ydFdpZHRoXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3R1YWwgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRXaWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJ2aWV3cG9ydEhlaWdodFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0dWFsIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJwYWdlV2lkdGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSB2aXNpYmxlIHBvcnRpb24gb2YgdGhlIGdyaWQgYm9keS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMudmlld3BvcnRXaWR0aCAtIHRoaXMuaGVhZGVyV2lkdGgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcInBhZ2VIZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBncmlkIGJvZHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLnZpZXdwb3J0SGVpZ2h0IC0gdGhpcy5oZWFkZXJIZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUdyaWQucHJvdG90eXBlLCBcInNjcm9sbFhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc2Nyb2xsIFggcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faFNjcm9sbEJhci52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJzY3JvbGxZXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHNjcm9sbCBZIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZTY3JvbGxCYXIudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwibWF4U2Nyb2xsWFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBzY3JvbGwgWCBwb3NpdGlvbiBmb3IgdGhlIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmJvZHlXaWR0aCAtIHRoaXMucGFnZVdpZHRoIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwibWF4U2Nyb2xsWVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBzY3JvbGwgWSBwb3NpdGlvbiBmb3IgdGhlIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmJvZHlIZWlnaHQgLSB0aGlzLnBhZ2VIZWlnaHQgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJ2aWV3cG9ydFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlld3BvcnQgd2lkZ2V0IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwiZWRpdG9yQ29udHJvbGxlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2VsbCBlZGl0b3IgY29udHJvbGxlciBvYmplY3QgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3JDb250cm9sbGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0b3JDb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJlZGl0aW5nRW5hYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjZWxsIGVkaXRpbmcgaXMgZW5hYmxlZCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRpbmdFbmFibGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0aW5nRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwiZWRpdGFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZ3JpZCBjZWxscyBhcmUgZWRpdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBlZGl0aW5nRW5hYmxlZGAgZmxhZyBtdXN0IGJlIG9uIGFuZCBncmlkIG11c3QgaGF2ZSByZXF1aXJlZFxuICAgICAgICAgKiBzZWxlY3Rpb24gbW9kZWwsIGVkaXRvciBjb250cm9sbGVyIGFuZCBkYXRhIG1vZGVsIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZGl0aW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZWRpdG9yQ29udHJvbGxlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsIGluc3RhbmNlb2YgTXV0YWJsZURhdGFNb2RlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJjYW52YXNHQ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHBhaW50aW5nIHRoZSBkYXRhIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNHQztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJyb3dTZWN0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcm93IHNlY3Rpb25zIG9mIHRoZSBkYXRhIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3dTZWN0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJjb2x1bW5TZWN0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sdW1uIHNlY3Rpb25zIG9mIHRoZSBkYXRhIGdyaWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5TZWN0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFHcmlkLnByb3RvdHlwZSwgXCJyb3dIZWFkZXJTZWN0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcm93IGhlYWRlciBzZWN0aW9ucyBvZiB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhR3JpZC5wcm90b3R5cGUsIFwiY29sdW1uSGVhZGVyU2VjdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbHVtbiBoZWFkZXIgc2VjdGlvbnMgb2YgdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIGdyaWQgdG8gdGhlIHNwZWNpZmllZCByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93IC0gVGhlIHJvdyBpbmRleCBvZiB0aGUgY2VsbC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIHJvdyBpcyBhbHJlYWR5IHZpc2libGUuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnNjcm9sbFRvUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAvLyBGZXRjaCB0aGUgcm93IGNvdW50LlxuICAgICAgICB2YXIgbnIgPSB0aGlzLl9yb3dTZWN0aW9ucy5jb3VudDtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgICAgICBpZiAobnIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbG9vciB0aGUgcm93IGluZGV4LlxuICAgICAgICByb3cgPSBNYXRoLmZsb29yKHJvdyk7XG4gICAgICAgIC8vIENsYW1wIHRoZSByb3cgaW5kZXguXG4gICAgICAgIHJvdyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvdywgbnIgLSAxKSk7XG4gICAgICAgIC8vIEdldCB0aGUgdmlydHVhbCBib3VuZHMgb2YgdGhlIHJvdy5cbiAgICAgICAgdmFyIHkxID0gdGhpcy5fcm93U2VjdGlvbnMub2Zmc2V0T2Yocm93KTtcbiAgICAgICAgdmFyIHkyID0gdGhpcy5fcm93U2VjdGlvbnMuZXh0ZW50T2Yocm93KTtcbiAgICAgICAgLy8gR2V0IHRoZSB2aXJ0dWFsIGJvdW5kcyBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgIHZhciB2eTEgPSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICB2YXIgdnkyID0gdGhpcy5fc2Nyb2xsWSArIHRoaXMucGFnZUhlaWdodCAtIDE7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZGVsdGEgdmFyaWFibGVzLlxuICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZWx0YSBZIHNjcm9sbC5cbiAgICAgICAgaWYgKHkxIDwgdnkxKSB7XG4gICAgICAgICAgICBkeSA9IHkxIC0gdnkxIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeTIgPiB2eTIpIHtcbiAgICAgICAgICAgIGR5ID0geTIgLSB2eTIgKyAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIG5vIHNjcm9sbCBpcyBuZWVkZWQuXG4gICAgICAgIGlmIChkeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCBieSB0aGUgY29tcHV0ZWQgZGVsdGEuXG4gICAgICAgIHRoaXMuc2Nyb2xsQnkoMCwgZHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRoZSBncmlkIHRvIHRoZSBzcGVjaWZpZWQgY29sdW1uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGNlbGwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBjb2x1bW4gaXMgYWxyZWFkeSB2aXNpYmxlLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5zY3JvbGxUb0NvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGNvbHVtbiBjb3VudC5cbiAgICAgICAgdmFyIG5jID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQ7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cbiAgICAgICAgaWYgKG5jID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxvb3IgdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgY29sdW1uID0gTWF0aC5mbG9vcihjb2x1bW4pO1xuICAgICAgICAvLyBDbGFtcCB0aGUgY29sdW1uIGluZGV4LlxuICAgICAgICBjb2x1bW4gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2x1bW4sIG5jIC0gMSkpO1xuICAgICAgICAvLyBHZXQgdGhlIHZpcnR1YWwgYm91bmRzIG9mIHRoZSBjb2x1bW4uXG4gICAgICAgIHZhciB4MSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKGNvbHVtbik7XG4gICAgICAgIHZhciB4MiA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmV4dGVudE9mKGNvbHVtbik7XG4gICAgICAgIC8vIEdldCB0aGUgdmlydHVhbCBib3VuZHMgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgdngxID0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgdmFyIHZ4MiA9IHRoaXMuX3Njcm9sbFggKyB0aGlzLnBhZ2VXaWR0aCAtIDE7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZGVsdGEgdmFyaWFibGVzLlxuICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZWx0YSBYIHNjcm9sbC5cbiAgICAgICAgaWYgKHgxIDwgdngxKSB7XG4gICAgICAgICAgICBkeCA9IHgxIC0gdngxIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeDIgPiB2eDIpIHtcbiAgICAgICAgICAgIGR4ID0geDIgLSB2eDIgKyAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIG5vIHNjcm9sbCBpcyBuZWVkZWQuXG4gICAgICAgIGlmIChkeCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCBieSB0aGUgY29tcHV0ZWQgZGVsdGEuXG4gICAgICAgIHRoaXMuc2Nyb2xsQnkoZHgsIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRoZSBncmlkIHRvIHRoZSBzcGVjaWZpZWQgY2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgLSBUaGUgcm93IGluZGV4IG9mIHRoZSBjZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGNlbGwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBjZWxsIGlzIGFscmVhZHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuc2Nyb2xsVG9DZWxsID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgICAgIC8vIEZldGNoIHRoZSByb3cgYW5kIGNvbHVtbiBjb3VudC5cbiAgICAgICAgdmFyIG5yID0gdGhpcy5fcm93U2VjdGlvbnMuY291bnQ7XG4gICAgICAgIHZhciBuYyA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmNvdW50O1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAgICAgIGlmIChuciA9PT0gMCB8fCBuYyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsb29yIHRoZSBjZWxsIGluZGV4LlxuICAgICAgICByb3cgPSBNYXRoLmZsb29yKHJvdyk7XG4gICAgICAgIGNvbHVtbiA9IE1hdGguZmxvb3IoY29sdW1uKTtcbiAgICAgICAgLy8gQ2xhbXAgdGhlIGNlbGwgaW5kZXguXG4gICAgICAgIHJvdyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJvdywgbnIgLSAxKSk7XG4gICAgICAgIGNvbHVtbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNvbHVtbiwgbmMgLSAxKSk7XG4gICAgICAgIC8vIEdldCB0aGUgdmlydHVhbCBib3VuZHMgb2YgdGhlIGNlbGwuXG4gICAgICAgIHZhciB4MSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKGNvbHVtbik7XG4gICAgICAgIHZhciB4MiA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmV4dGVudE9mKGNvbHVtbik7XG4gICAgICAgIHZhciB5MSA9IHRoaXMuX3Jvd1NlY3Rpb25zLm9mZnNldE9mKHJvdyk7XG4gICAgICAgIHZhciB5MiA9IHRoaXMuX3Jvd1NlY3Rpb25zLmV4dGVudE9mKHJvdyk7XG4gICAgICAgIC8vIEdldCB0aGUgdmlydHVhbCBib3VuZHMgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgdngxID0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgdmFyIHZ4MiA9IHRoaXMuX3Njcm9sbFggKyB0aGlzLnBhZ2VXaWR0aCAtIDE7XG4gICAgICAgIHZhciB2eTEgPSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICB2YXIgdnkyID0gdGhpcy5fc2Nyb2xsWSArIHRoaXMucGFnZUhlaWdodCAtIDE7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZGVsdGEgdmFyaWFibGVzLlxuICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZWx0YSBYIHNjcm9sbC5cbiAgICAgICAgaWYgKHgxIDwgdngxKSB7XG4gICAgICAgICAgICBkeCA9IHgxIC0gdngxIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeDIgPiB2eDIpIHtcbiAgICAgICAgICAgIGR4ID0geDIgLSB2eDIgKyAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZWx0YSBZIHNjcm9sbC5cbiAgICAgICAgaWYgKHkxIDwgdnkxKSB7XG4gICAgICAgICAgICBkeSA9IHkxIC0gdnkxIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeTIgPiB2eTIpIHtcbiAgICAgICAgICAgIGR5ID0geTIgLSB2eTIgKyAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIG5vIHNjcm9sbCBpcyBuZWVkZWQuXG4gICAgICAgIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjcm9sbCBieSB0aGUgY29tcHV0ZWQgZGVsdGEuXG4gICAgICAgIHRoaXMuc2Nyb2xsQnkoZHgsIGR5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgY3Vyc29yIGRvd24vdXAvbGVmdC9yaWdodCB3aGlsZSBtYWtpbmcgc3VyZSBpdCByZW1haW5zXG4gICAgICogd2l0aGluIHRoZSBib3VuZHMgb2Ygc2VsZWN0ZWQgcmVjdGFuZ2xlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIG1vdmVtZW50LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICAgICAgICBpZiAoIXRoaXMuZGF0YU1vZGVsIHx8XG4gICAgICAgICAgICAhdGhpcy5fc2VsZWN0aW9uTW9kZWwgfHxcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlciA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMoKTtcbiAgICAgICAgdmFyIG9ubHlPbmUgPSBpdGVyLm5leHQoKSAmJiAhaXRlci5uZXh0KCk7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2luZ2xlIHNlbGVjdGlvbiB0aGF0IGlzIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uXG4gICAgICAgIC8vIHRoZW4gbW92ZSB0aGUgc2VsZWN0aW9uIGFuZCBjdXJzb3Igd2l0aGluIGdyaWQgYm91bmRzXG4gICAgICAgIGlmIChvbmx5T25lKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2VsLnIxID09PSBjdXJyZW50U2VsLnIyICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFNlbC5jMSA9PT0gY3VycmVudFNlbC5jMikge1xuICAgICAgICAgICAgICAgIHZhciBkciA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gMSA6IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IC0xIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgZGMgPSBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyAxIDogZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtMSA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JvdyA9IGN1cnJlbnRTZWwucjEgKyBkcjtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29sdW1uID0gY3VycmVudFNlbC5jMSArIGRjO1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZGF0YU1vZGVsLnJvd0NvdW50KCdib2R5Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5kYXRhTW9kZWwuY29sdW1uQ291bnQoJ2JvZHknKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Um93ID49IHJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbiArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdSb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IHJvd0NvdW50IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sdW1uIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdDb2x1bW4gPj0gY29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdSb3cgPj0gcm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3Q29sdW1uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW4gPSBjb2x1bW5Db3VudCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JvdyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Um93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93ID0gcm93Q291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHIxOiBuZXdSb3csIGMxOiBuZXdDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHIyOiBuZXdSb3csIGMyOiBuZXdDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvclJvdzogbmV3Um93LCBjdXJzb3JDb2x1bW46IG5ld0NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgY2xlYXI6ICdhbGwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBzZWxlY3Rpb25zLCBtb3ZlIGN1cnNvclxuICAgICAgICAvLyB3aXRoaW4gc2VsZWN0aW9uIHJlY3RhbmdsZXNcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwubW92ZUN1cnNvcldpdGhpblNlbGVjdGlvbnMoZGlyZWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgZ3JpZCB0byB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBjdXJzb3IgaXMgYWxyZWFkeSB2aXNpYmxlIG9yXG4gICAgICogaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIG1vZGVsIGluc3RhbGxlZCBvbiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuc2Nyb2xsVG9DdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnNvciByb3cgYW5kIGNvbHVtbi5cbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmN1cnNvclJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmN1cnNvckNvbHVtbjtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRoZSBjdXJzb3IgY2VsbC5cbiAgICAgICAgdGhpcy5zY3JvbGxUb0NlbGwocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRoZSB2aWV3cG9ydCBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkeCAtIFRoZSBYIHNjcm9sbCBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZHkgLSBUaGUgWSBzY3JvbGwgYW1vdW50LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnNjcm9sbFggKyBkeCwgdGhpcy5zY3JvbGxZICsgZHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRoZSB2aWV3cG9ydCBieSBvbmUgcGFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgLSBUaGUgZGVzaXJlZCBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuc2Nyb2xsQnlQYWdlID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICBzd2l0Y2ggKGRpcikge1xuICAgICAgICAgICAgY2FzZSAndXAnOlxuICAgICAgICAgICAgICAgIGR5ID0gLXRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgICAgIGR5ID0gdGhpcy5wYWdlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgZHggPSAtdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgZHggPSB0aGlzLnBhZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbFRvKHRoaXMuc2Nyb2xsWCArIGR4LCB0aGlzLnNjcm9sbFkgKyBkeSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIHZpZXdwb3J0IGJ5IG9uZSBjZWxsLWFsaWduZWQgc3RlcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgLSBUaGUgZGVzaXJlZCBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuc2Nyb2xsQnlTdGVwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHZhciB4ID0gdGhpcy5zY3JvbGxYO1xuICAgICAgICB2YXIgeSA9IHRoaXMuc2Nyb2xsWTtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dTZWN0aW9ucztcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucztcbiAgICAgICAgc3dpdGNoIChkaXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgICAgICAgICByID0gcm93cy5pbmRleE9mKHkgLSAxKTtcbiAgICAgICAgICAgICAgICB5ID0gciA8IDAgPyB5IDogcm93cy5vZmZzZXRPZihyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgICAgIHIgPSByb3dzLmluZGV4T2YoeSk7XG4gICAgICAgICAgICAgICAgeSA9IHIgPCAwID8geSA6IHJvd3Mub2Zmc2V0T2YocikgKyByb3dzLnNpemVPZihyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGMgPSBjb2x1bW5zLmluZGV4T2YoeCAtIDEpO1xuICAgICAgICAgICAgICAgIHggPSBjIDwgMCA/IHggOiBjb2x1bW5zLm9mZnNldE9mKGMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGMgPSBjb2x1bW5zLmluZGV4T2YoeCk7XG4gICAgICAgICAgICAgICAgeCA9IGMgPCAwID8geCA6IGNvbHVtbnMub2Zmc2V0T2YoYykgKyBjb2x1bW5zLnNpemVPZihjKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbFRvKHgsIHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHggLSBUaGUgZGVzaXJlZCBYIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHkgLSBUaGUgZGVzaXJlZCBZIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIC8vIEZsb29yIGFuZCBjbGFtcCB0aGUgcG9zaXRpb24gdG8gdGhlIGFsbG93YWJsZSByYW5nZS5cbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKE1hdGguZmxvb3IoeCksIHRoaXMubWF4U2Nyb2xsWCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oTWF0aC5mbG9vcih5KSwgdGhpcy5tYXhTY3JvbGxZKSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2Nyb2xsIGJhciB2YWx1ZXMgd2l0aCB0aGUgZGVzaXJlZCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5faFNjcm9sbEJhci52YWx1ZSA9IHg7XG4gICAgICAgIHRoaXMuX3ZTY3JvbGxCYXIudmFsdWUgPSB5O1xuICAgICAgICAvLyBQb3N0IGEgc2Nyb2xsIHJlcXVlc3QgbWVzc2FnZSB0byB0aGUgdmlld3BvcnQuXG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMuX3ZpZXdwb3J0LCBQcml2YXRlJDYuU2Nyb2xsUmVxdWVzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBjb3VudCBmb3IgYSBwYXJ0aWN1bGFyIHJlZ2lvbiBpbiB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByb3cgcmVnaW9uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJvdyBjb3VudCBmb3IgdGhlIHNwZWNpZmllZCByZWdpb24uXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJvd0NvdW50ID0gZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICB2YXIgY291bnQ7XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgY291bnQgPSB0aGlzLl9yb3dTZWN0aW9ucy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb2x1bW4gY291bnQgZm9yIGEgcGFydGljdWxhciByZWdpb24gaW4gdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgY29sdW1uIHJlZ2lvbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb2x1bW4gY291bnQgZm9yIHRoZSBzcGVjaWZpZWQgcmVnaW9uLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5jb2x1bW5Db3VudCA9IGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgdmFyIGNvdW50O1xuICAgICAgICBpZiAocmVnaW9uID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IGF0IGEgdmlydHVhbCBvZmZzZXQgaW4gdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgcmVnaW9uIHdoaWNoIGhvbGRzIHRoZSByb3cgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIHZpcnR1YWwgb2Zmc2V0IG9mIHRoZSByb3cgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIHJvdywgb3IgYC0xYCBpZiB0aGUgb2Zmc2V0IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NvdW50cyBmb3IgYSBzdHJldGNoZWQgbGFzdCByb3cuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJvd0F0ID0gZnVuY3Rpb24gKHJlZ2lvbiwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG9mZnNldCBpcyBuZWdhdGl2ZS5cbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZWFybHkgZm9yIHRoZSBjb2x1bW4gaGVhZGVyIHJlZ2lvbi5cbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ2NvbHVtbi1oZWFkZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuaW5kZXhPZihvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBpbmRleC5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fcm93U2VjdGlvbnMuaW5kZXhPZihvZmZzZXQpO1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhlIHNlY3Rpb24gaXMgZm91bmQuXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgbGFzdCByb3cgaXMgbm90IHN0cmV0Y2hlZC5cbiAgICAgICAgaWYgKCF0aGlzLl9zdHJldGNoTGFzdFJvdykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBnZW9tZXRyeS5cbiAgICAgICAgdmFyIGJoID0gdGhpcy5ib2R5SGVpZ2h0O1xuICAgICAgICB2YXIgcGggPSB0aGlzLnBhZ2VIZWlnaHQ7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgbm8gcm93IHN0cmV0Y2hpbmcgaXMgcmVxdWlyZWQuXG4gICAgICAgIGlmIChwaCA8PSBiaCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAgICBpZiAob2Zmc2V0ID49IHBoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIGxhc3Qgcm93LlxuICAgICAgICByZXR1cm4gdGhpcy5fcm93U2VjdGlvbnMuY291bnQgLSAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb2x1bW4gYXQgYSB2aXJ0dWFsIG9mZnNldCBpbiB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByZWdpb24gd2hpY2ggaG9sZHMgdGhlIGNvbHVtbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgdmlydHVhbCBvZmZzZXQgb2YgdGhlIGNvbHVtbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgY29sdW1uLCBvciBgLTFgIGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGFjY291bnRzIGZvciBhIHN0cmV0Y2hlZCBsYXN0IGNvbHVtbi5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuY29sdW1uQXQgPSBmdW5jdGlvbiAocmVnaW9uLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZWFybHkgZm9yIHRoZSByb3cgaGVhZGVyIHJlZ2lvbi5cbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ3Jvdy1oZWFkZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMuaW5kZXhPZihvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBpbmRleC5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuaW5kZXhPZihvZmZzZXQpO1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhlIHNlY3Rpb24gaXMgZm91bmQuXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgbGFzdCBjb2x1bW4gaXMgbm90IHN0cmV0Y2hlZC5cbiAgICAgICAgaWYgKCF0aGlzLl9zdHJldGNoTGFzdENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBnZW9tZXRyeS5cbiAgICAgICAgdmFyIGJ3ID0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgIHZhciBwdyA9IHRoaXMucGFnZVdpZHRoO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIG5vIGNvbHVtbiBzdHJldGNoaW5nIGlzIHJlcXVpcmVkLlxuICAgICAgICBpZiAocHcgPD0gYncpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgaWYgKG9mZnNldCA+PSBwdykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHRoZSBsYXN0IGNvbHVtbi5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtblNlY3Rpb25zLmNvdW50IC0gMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgcm93IGluIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIHJlZ2lvbiB3aGljaCBob2xkcyB0aGUgcm93IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSByb3cgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgb2Zmc2V0IG9mIHRoZSByb3csIG9yIGAtMWAgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBBIHN0cmV0Y2hlZCBsYXN0IHJvdyBoYXMgbm8gZWZmZWN0IG9uIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJvd09mZnNldCA9IGZ1bmN0aW9uIChyZWdpb24sIGluZGV4KSB7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fcm93U2VjdGlvbnMub2Zmc2V0T2YoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMub2Zmc2V0T2YoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9mZnNldCBvZiBhIGNvbHVtbiBpbiB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByZWdpb24gd2hpY2ggaG9sZHMgdGhlIGNvbHVtbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgY29sdW1uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCBvZiB0aGUgY29sdW1uLCBvciBgLTFgIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogQSBzdHJldGNoZWQgbGFzdCBjb2x1bW4gaGFzIG5vIGVmZmVjdCBvbiB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5jb2x1bW5PZmZzZXQgPSBmdW5jdGlvbiAocmVnaW9uLCBpbmRleCkge1xuICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICBpZiAocmVnaW9uID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLm9mZnNldE9mKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaXplIG9mIGEgcm93IGluIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIHJlZ2lvbiB3aGljaCBob2xkcyB0aGUgcm93IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSByb3cgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgcm93LCBvciBgLTFgIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgYWNjb3VudHMgZm9yIGEgc3RyZXRjaGVkIGxhc3Qgcm93LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5yb3dTaXplID0gZnVuY3Rpb24gKHJlZ2lvbiwgaW5kZXgpIHtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGZvciB0aGUgY29sdW1uIGhlYWRlciByZWdpb24uXG4gICAgICAgIGlmIChyZWdpb24gPT09ICdjb2x1bW4taGVhZGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLnNpemVPZihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHJvdyBzaXplLlxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3Jvd1NlY3Rpb25zLnNpemVPZihpbmRleCk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIHRoZSBsYXN0IHJvdyBpcyBub3Qgc3RyZXRjaGVkLlxuICAgICAgICBpZiAoIXRoaXMuX3N0cmV0Y2hMYXN0Um93KSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgaXRzIG5vdCB0aGUgbGFzdCByb3cuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuX3Jvd1NlY3Rpb25zLmNvdW50IC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGdlb21ldHJ5LlxuICAgICAgICB2YXIgYmggPSB0aGlzLmJvZHlIZWlnaHQ7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIG5vIHN0cmV0Y2hpbmcgaXMgbmVlZGVkLlxuICAgICAgICBpZiAocGggPD0gYmgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgYWRqdXN0ZWQgc2l6ZS5cbiAgICAgICAgcmV0dXJuIHNpemUgKyAocGggLSBiaCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpemUgb2YgYSBjb2x1bW4gaW4gdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgcmVnaW9uIHdoaWNoIGhvbGRzIHRoZSBjb2x1bW4gb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGNvbHVtbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBjb2x1bW4sIG9yIGAtMWAgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NvdW50cyBmb3IgYSBzdHJldGNoZWQgbGFzdCBjb2x1bW4uXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLmNvbHVtblNpemUgPSBmdW5jdGlvbiAocmVnaW9uLCBpbmRleCkge1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgZm9yIHRoZSByb3cgaGVhZGVyIHJlZ2lvbi5cbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ3Jvdy1oZWFkZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMuc2l6ZU9mKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgY29sdW1uIHNpemUuXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuc2l6ZU9mKGluZGV4KTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhlIGxhc3QgY29sdW1uIGlzIG5vdCBzdHJldGNoZWQuXG4gICAgICAgIGlmICghdGhpcy5fc3RyZXRjaExhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBpdHMgbm90IHRoZSBsYXN0IGNvbHVtbi5cbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgZ2VvbWV0cnkuXG4gICAgICAgIHZhciBidyA9IHRoaXMuYm9keVdpZHRoO1xuICAgICAgICB2YXIgcHcgPSB0aGlzLnBhZ2VXaWR0aDtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIG5vIHN0cmV0Y2hpbmcgaXMgbmVlZGVkLlxuICAgICAgICBpZiAocHcgPD0gYncpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgYWRqdXN0ZWQgc2l6ZS5cbiAgICAgICAgcmV0dXJuIHNpemUgKyAocHcgLSBidyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgYSByb3cgaW4gdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgcmVnaW9uIHdoaWNoIGhvbGRzIHRoZSByb3cgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJvdyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgcm93LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5yZXNpemVSb3cgPSBmdW5jdGlvbiAocmVnaW9uLCBpbmRleCwgc2l6ZSkge1xuICAgICAgICB2YXIgbXNnID0gbmV3IFByaXZhdGUkNi5Sb3dSZXNpemVSZXF1ZXN0KHJlZ2lvbiwgaW5kZXgsIHNpemUpO1xuICAgICAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSh0aGlzLl92aWV3cG9ydCwgbXNnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBhIGNvbHVtbiBpbiB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByZWdpb24gd2hpY2ggaG9sZHMgdGhlIGNvbHVtbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgY29sdW1uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpemUgLSBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBjb2x1bW4uXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJlc2l6ZUNvbHVtbiA9IGZ1bmN0aW9uIChyZWdpb24sIGluZGV4LCBzaXplKSB7XG4gICAgICAgIHZhciBtc2cgPSBuZXcgUHJpdmF0ZSQ2LkNvbHVtblJlc2l6ZVJlcXVlc3QocmVnaW9uLCBpbmRleCwgc2l6ZSk7XG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMuX3ZpZXdwb3J0LCBtc2cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgbW9kaWZpZWQgcm93cyB0byB0aGVpciBkZWZhdWx0IHNpemUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIHJvdyByZWdpb24gb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJlc2V0Um93cyA9IGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93U2VjdGlvbnMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5IZWFkZXJTZWN0aW9ucy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93U2VjdGlvbnMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbHVtbi1oZWFkZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50Q29udGVudCgpO1xuICAgICAgICB0aGlzLnJlcGFpbnRPdmVybGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCBtb2RpZmllZCBjb2x1bW5zIHRvIHRoZWlyIGRlZmF1bHQgc2l6ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgY29sdW1uIHJlZ2lvbiBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUucmVzZXRDb2x1bW5zID0gZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5TZWN0aW9ucy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5TZWN0aW9ucy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm93LWhlYWRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnRDb250ZW50KCk7XG4gICAgICAgIHRoaXMucmVwYWludE92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcCBhIGNsaWVudCBwb3NpdGlvbiB0byBsb2NhbCB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRYIC0gVGhlIGNsaWVudCBYIHBvc2l0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRZIC0gVGhlIGNsaWVudCBZIHBvc2l0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsb2NhbCB2aWV3cG9ydCBjb29yZGluYXRlcyBmb3IgdGhlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5tYXBUb0xvY2FsID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHZpZXdwb3J0IHJlY3QuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5fdmlld3BvcnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcmVjdCBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQsIHRvcCA9IHJlY3QudG9wO1xuICAgICAgICAvLyBSb3VuZCB0aGUgcmVjdCBjb29yZGluYXRlcyBmb3Igc3ViLXBpeGVsIHBvc2l0aW9uaW5nLlxuICAgICAgICBsZWZ0ID0gTWF0aC5mbG9vcihsZWZ0KTtcbiAgICAgICAgdG9wID0gTWF0aC5mbG9vcih0b3ApO1xuICAgICAgICAvLyBDb252ZXJ0IHRvIGxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAgICB2YXIgbHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgICAgdmFyIGx5ID0gY2xpZW50WSAtIHRvcDtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcy5cbiAgICAgICAgcmV0dXJuIHsgbHg6IGx4LCBseTogbHkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcCBhIGNsaWVudCBwb3NpdGlvbiB0byB2aXJ0dWFsIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50WCAtIFRoZSBjbGllbnQgWCBwb3NpdGlvbiBvZiB0aGUgbW91c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50WSAtIFRoZSBjbGllbnQgWSBwb3NpdGlvbiBvZiB0aGUgbW91c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdmlydHVhbCBncmlkIGNvb3JkaW5hdGVzIGZvciB0aGUgcG9zaXRpb24uXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLm1hcFRvVmlydHVhbCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gbG9jYWwgY29vcmRpYXRlcy5cbiAgICAgICAgdmFyIF9hID0gdGhpcy5tYXBUb0xvY2FsKGNsaWVudFgsIGNsaWVudFkpLCBseCA9IF9hLmx4LCBseSA9IF9hLmx5O1xuICAgICAgICAvLyBDb252ZXJ0IHRvIHZpcnR1YWwgY29vcmRpbmF0ZXMuXG4gICAgICAgIHZhciB2eCA9IGx4ICsgdGhpcy5zY3JvbGxYIC0gdGhpcy5oZWFkZXJXaWR0aDtcbiAgICAgICAgdmFyIHZ5ID0gbHkgKyB0aGlzLnNjcm9sbFkgLSB0aGlzLmhlYWRlckhlaWdodDtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcy5cbiAgICAgICAgcmV0dXJuIHsgdng6IHZ4LCB2eTogdnkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhpdCB0ZXN0IHRoZSB2aWV3cG9ydCBmb3IgdGhlIGdpdmVuIGNsaWVudCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRYIC0gVGhlIGNsaWVudCBYIHBvc2l0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRZIC0gVGhlIGNsaWVudCBZIHBvc2l0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBoaXQgdGVzdCByZXN1bHQsIG9yIGBudWxsYCBpZiB0aGUgY2xpZW50XG4gICAgICogICBwb3NpdGlvbiBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGFjY291bnRzIGZvciBhIHN0cmV0Y2hlZCBsYXN0IHJvdyBhbmQvb3IgY29sdW1uLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbW91c2UgcG9zaXRpb24gaW50byBsb2NhbCBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIF9hID0gdGhpcy5tYXBUb0xvY2FsKGNsaWVudFgsIGNsaWVudFkpLCBseCA9IF9hLmx4LCBseSA9IF9hLmx5O1xuICAgICAgICAvLyBGZXRjaCB0aGUgaGVhZGVyIGFuZCBib2R5IGRpbWVuc2lvbnMuXG4gICAgICAgIHZhciBodyA9IHRoaXMuaGVhZGVyV2lkdGg7XG4gICAgICAgIHZhciBoaCA9IHRoaXMuaGVhZGVySGVpZ2h0O1xuICAgICAgICB2YXIgYncgPSB0aGlzLmJvZHlXaWR0aDtcbiAgICAgICAgdmFyIGJoID0gdGhpcy5ib2R5SGVpZ2h0O1xuICAgICAgICB2YXIgcGggPSB0aGlzLnBhZ2VIZWlnaHQ7XG4gICAgICAgIHZhciBwdyA9IHRoaXMucGFnZVdpZHRoO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGJvZHkgd2lkdGggZm9yIGEgc3RyZXRjaGVkIGxhc3QgY29sdW1uLlxuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RDb2x1bW4gJiYgcHcgPiBidykge1xuICAgICAgICAgICAgYncgPSBwdztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIGJvZHkgaGVpZ2h0IGZvciBhIHN0cmV0Y2hlZCBsYXN0IHJvdy5cbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Um93ICYmIHBoID4gYmgpIHtcbiAgICAgICAgICAgIGJoID0gcGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgY29ybmVyIGhlYWRlciBoaXQuXG4gICAgICAgIGlmIChseCA+PSAwICYmIGx4IDwgaHcgJiYgbHkgPj0gMCAmJiBseSA8IGhoKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHVuc2Nyb2xsZWQgdmlydHVhbCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB2eCA9IGx4O1xuICAgICAgICAgICAgdmFyIHZ5ID0gbHk7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgcm93IGFuZCBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICB2YXIgcm93XzEgPSB0aGlzLnJvd0F0KCdjb2x1bW4taGVhZGVyJywgdnkpO1xuICAgICAgICAgICAgdmFyIGNvbHVtbl8xID0gdGhpcy5jb2x1bW5BdCgncm93LWhlYWRlcicsIHZ4KTtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjZWxsIG9mZnNldCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHZhciBveCA9IHRoaXMuY29sdW1uT2Zmc2V0KCdyb3ctaGVhZGVyJywgY29sdW1uXzEpO1xuICAgICAgICAgICAgdmFyIG95ID0gdGhpcy5yb3dPZmZzZXQoJ2NvbHVtbi1oZWFkZXInLCByb3dfMSk7XG4gICAgICAgICAgICAvLyBGZXRjaCBjZWxsIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAgICB2YXIgd2lkdGhfMSA9IHRoaXMuY29sdW1uU2l6ZSgncm93LWhlYWRlcicsIGNvbHVtbl8xKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfMSA9IHRoaXMucm93U2l6ZSgnY29sdW1uLWhlYWRlcicsIHJvd18xKTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHBvc2l0aW9ucy5cbiAgICAgICAgICAgIHZhciB4XzEgPSB2eCAtIG94O1xuICAgICAgICAgICAgdmFyIHlfMSA9IHZ5IC0gb3k7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGhpdCB0ZXN0IHJlc3VsdC5cbiAgICAgICAgICAgIHJldHVybiB7IHJlZ2lvbjogJ2Nvcm5lci1oZWFkZXInLCByb3c6IHJvd18xLCBjb2x1bW46IGNvbHVtbl8xLCB4OiB4XzEsIHk6IHlfMSwgd2lkdGg6IHdpZHRoXzEsIGhlaWdodDogaGVpZ2h0XzEgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgYSBjb2x1bW4gaGVhZGVyIGhpdC5cbiAgICAgICAgaWYgKGx5ID49IDAgJiYgbHkgPCBoaCAmJiBseCA+PSAwICYmIGx4IDwgKGh3ICsgYncpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHVuc2Nyb2xsZWQgdmlydHVhbCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB2eCA9IGx4ICsgdGhpcy5fc2Nyb2xsWCAtIGh3O1xuICAgICAgICAgICAgdmFyIHZ5ID0gbHk7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgcm93IGFuZCBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICB2YXIgcm93XzIgPSB0aGlzLnJvd0F0KCdjb2x1bW4taGVhZGVyJywgdnkpO1xuICAgICAgICAgICAgdmFyIGNvbHVtbl8yID0gdGhpcy5jb2x1bW5BdCgnYm9keScsIHZ4KTtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjZWxsIG9mZnNldCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHZhciBveCA9IHRoaXMuY29sdW1uT2Zmc2V0KCdib2R5JywgY29sdW1uXzIpO1xuICAgICAgICAgICAgdmFyIG95ID0gdGhpcy5yb3dPZmZzZXQoJ2NvbHVtbi1oZWFkZXInLCByb3dfMik7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgY2VsbCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICAgICAgdmFyIHdpZHRoXzIgPSB0aGlzLmNvbHVtblNpemUoJ2JvZHknLCBjb2x1bW5fMik7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0XzIgPSB0aGlzLnJvd1NpemUoJ2NvbHVtbi1oZWFkZXInLCByb3dfMik7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBwb3NpdGlvbnMuXG4gICAgICAgICAgICB2YXIgeF8yID0gdnggLSBveDtcbiAgICAgICAgICAgIHZhciB5XzIgPSB2eSAtIG95O1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBoaXQgdGVzdCByZXN1bHQuXG4gICAgICAgICAgICByZXR1cm4geyByZWdpb246ICdjb2x1bW4taGVhZGVyJywgcm93OiByb3dfMiwgY29sdW1uOiBjb2x1bW5fMiwgeDogeF8yLCB5OiB5XzIsIHdpZHRoOiB3aWR0aF8yLCBoZWlnaHQ6IGhlaWdodF8yIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcm93IGhlYWRlciBoaXQuXG4gICAgICAgIGlmIChseCA+PSAwICYmIGx4IDwgaHcgJiYgbHkgPj0gMCAmJiBseSA8IChoaCArIGJoKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byB1bnNjcm9sbGVkIHZpcnR1YWwgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICB2YXIgdnggPSBseDtcbiAgICAgICAgICAgIHZhciB2eSA9IGx5ICsgdGhpcy5fc2Nyb2xsWSAtIGhoO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHJvdyBhbmQgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgdmFyIHJvd18zID0gdGhpcy5yb3dBdCgnYm9keScsIHZ5KTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5fMyA9IHRoaXMuY29sdW1uQXQoJ3Jvdy1oZWFkZXInLCB2eCk7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgY2VsbCBvZmZzZXQgcG9zaXRpb24uXG4gICAgICAgICAgICB2YXIgb3ggPSB0aGlzLmNvbHVtbk9mZnNldCgncm93LWhlYWRlcicsIGNvbHVtbl8zKTtcbiAgICAgICAgICAgIHZhciBveSA9IHRoaXMucm93T2Zmc2V0KCdib2R5Jywgcm93XzMpO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGNlbGwgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgICAgIHZhciB3aWR0aF8zID0gdGhpcy5jb2x1bW5TaXplKCdyb3ctaGVhZGVyJywgY29sdW1uXzMpO1xuICAgICAgICAgICAgdmFyIGhlaWdodF8zID0gdGhpcy5yb3dTaXplKCdib2R5Jywgcm93XzMpO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgcG9zaXRpb25zLlxuICAgICAgICAgICAgdmFyIHhfMyA9IHZ4IC0gb3g7XG4gICAgICAgICAgICB2YXIgeV8zID0gdnkgLSBveTtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgaGl0IHRlc3QgcmVzdWx0LlxuICAgICAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiAncm93LWhlYWRlcicsIHJvdzogcm93XzMsIGNvbHVtbjogY29sdW1uXzMsIHg6IHhfMywgeTogeV8zLCB3aWR0aDogd2lkdGhfMywgaGVpZ2h0OiBoZWlnaHRfMyB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBhIGJvZHkgaGl0LlxuICAgICAgICBpZiAobHggPj0gaHcgJiYgbHggPCAoaHcgKyBidykgJiYgbHkgPj0gaGggJiYgbHkgPCAoaGggKyBiaCkpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gdW5zY3JvbGxlZCB2aXJ0dWFsIGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgdmFyIHZ4ID0gbHggKyB0aGlzLl9zY3JvbGxYIC0gaHc7XG4gICAgICAgICAgICB2YXIgdnkgPSBseSArIHRoaXMuX3Njcm9sbFkgLSBoaDtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSByb3cgYW5kIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgIHZhciByb3dfNCA9IHRoaXMucm93QXQoJ2JvZHknLCB2eSk7XG4gICAgICAgICAgICB2YXIgY29sdW1uXzQgPSB0aGlzLmNvbHVtbkF0KCdib2R5JywgdngpO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGNlbGwgb2Zmc2V0IHBvc2l0aW9uLlxuICAgICAgICAgICAgdmFyIG94ID0gdGhpcy5jb2x1bW5PZmZzZXQoJ2JvZHknLCBjb2x1bW5fNCk7XG4gICAgICAgICAgICB2YXIgb3kgPSB0aGlzLnJvd09mZnNldCgnYm9keScsIHJvd180KTtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjZWxsIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAgICB2YXIgd2lkdGhfNCA9IHRoaXMuY29sdW1uU2l6ZSgnYm9keScsIGNvbHVtbl80KTtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfNCA9IHRoaXMucm93U2l6ZSgnYm9keScsIHJvd180KTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHBhcnQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICB2YXIgeF80ID0gdnggLSBveDtcbiAgICAgICAgICAgIHZhciB5XzQgPSB2eSAtIG95O1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgICAgICByZXR1cm4geyByZWdpb246ICdib2R5Jywgcm93OiByb3dfNCwgY29sdW1uOiBjb2x1bW5fNCwgeDogeF80LCB5OiB5XzQsIHdpZHRoOiB3aWR0aF80LCBoZWlnaHQ6IGhlaWdodF80IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgdm9pZCBzcGFjZSBoaXQuXG4gICAgICAgIHZhciByb3cgPSAtMTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IC0xO1xuICAgICAgICB2YXIgeCA9IC0xO1xuICAgICAgICB2YXIgeSA9IC0xO1xuICAgICAgICB2YXIgd2lkdGggPSAtMTtcbiAgICAgICAgdmFyIGhlaWdodCA9IC0xO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGhpdCB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIHsgcmVnaW9uOiAndm9pZCcsIHJvdzogcm93LCBjb2x1bW46IGNvbHVtbiwgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29weSB0aGUgY3VycmVudCBzZWxlY3Rpb24gdG8gdGhlIHN5c3RlbSBjbGlwYm9hcmQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGdyaWQgbXVzdCBoYXZlIGEgZGF0YSBtb2RlbCBhbmQgYSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGUgYmVoYXZpb3IgY2FuIGJlIGNvbmZpZ3VyZWQgdmlhIGBEYXRhR3JpZC5jb3B5Q29uZmlnYC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuY29weVRvQ2xpcGJvYXJkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBGZXRjaCB0aGUgZGF0YSBtb2RlbC5cbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuX2RhdGFNb2RlbDtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBkYXRhIG1vZGVsLlxuICAgICAgICBpZiAoIWRhdGFNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIHZhciBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvZXJjZSB0aGUgc2VsZWN0aW9ucyB0byBhbiBhcnJheS5cbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0b0FycmF5KHNlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMoKSk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIHNlbGVjdGlvbnMuXG4gICAgICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsZXJ0IHRoYXQgbXVsdGlwbGUgc2VsZWN0aW9ucyBjYW5ub3QgYmUgY29waWVkLlxuICAgICAgICBpZiAoc2VsZWN0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBhbGVydCgnQ2Fubm90IGNvcHkgbXVsdGlwbGUgZ3JpZCBzZWxlY3Rpb25zLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBtb2RlbCBjb3VudHMuXG4gICAgICAgIHZhciBiciA9IGRhdGFNb2RlbC5yb3dDb3VudCgnYm9keScpO1xuICAgICAgICB2YXIgYmMgPSBkYXRhTW9kZWwuY29sdW1uQ291bnQoJ2JvZHknKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGNvcHkuXG4gICAgICAgIGlmIChiciA9PT0gMCB8fCBiYyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVucGFjayB0aGUgc2VsZWN0aW9uLlxuICAgICAgICB2YXIgX2MgPSBzZWxlY3Rpb25zWzBdLCByMSA9IF9jLnIxLCBjMSA9IF9jLmMxLCByMiA9IF9jLnIyLCBjMiA9IF9jLmMyO1xuICAgICAgICAvLyBDbGFtcCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBtb2RlbCBib3VuZHMuXG4gICAgICAgIHIxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocjEsIGJyIC0gMSkpO1xuICAgICAgICBjMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMxLCBiYyAtIDEpKTtcbiAgICAgICAgcjIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMiwgYnIgLSAxKSk7XG4gICAgICAgIGMyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYzIsIGJjIC0gMSkpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGxpbWl0cyBhcmUgd2VsbC1vcmRlcmQuXG4gICAgICAgIGlmIChyMiA8IHIxKVxuICAgICAgICAgICAgX2EgPSBbcjIsIHIxXSwgcjEgPSBfYVswXSwgcjIgPSBfYVsxXTtcbiAgICAgICAgaWYgKGMyIDwgYzEpXG4gICAgICAgICAgICBfYiA9IFtjMiwgYzFdLCBjMSA9IF9iWzBdLCBjMiA9IF9iWzFdO1xuICAgICAgICAvLyBGZXRjaCB0aGUgaGVhZGVyIGNvdW50cy5cbiAgICAgICAgdmFyIHJoYyA9IGRhdGFNb2RlbC5jb2x1bW5Db3VudCgncm93LWhlYWRlcicpO1xuICAgICAgICB2YXIgY2hyID0gZGF0YU1vZGVsLnJvd0NvdW50KCdjb2x1bW4taGVhZGVyJyk7XG4gICAgICAgIC8vIFVucGFjayB0aGUgY29weSBjb25maWcuXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSB0aGlzLl9jb3B5Q29uZmlnLnNlcGFyYXRvcjtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2NvcHlDb25maWcuZm9ybWF0O1xuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuX2NvcHlDb25maWcuaGVhZGVycztcbiAgICAgICAgdmFyIHdhcm5pbmdUaHJlc2hvbGQgPSB0aGlzLl9jb3B5Q29uZmlnLndhcm5pbmdUaHJlc2hvbGQ7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjZWxscyB0byBiZSBjb3BpZWQuXG4gICAgICAgIHZhciByb3dDb3VudCA9IHIyIC0gcjEgKyAxO1xuICAgICAgICB2YXIgY29sQ291bnQgPSBjMiAtIGMxICsgMTtcbiAgICAgICAgc3dpdGNoIChoZWFkZXJzKSB7XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByaGMgPSAwO1xuICAgICAgICAgICAgICAgIGNociA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb3cnOlxuICAgICAgICAgICAgICAgIGNociA9IDA7XG4gICAgICAgICAgICAgICAgY29sQ291bnQgKz0gcmhjO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29sdW1uJzpcbiAgICAgICAgICAgICAgICByaGMgPSAwO1xuICAgICAgICAgICAgICAgIHJvd0NvdW50ICs9IGNocjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgcm93Q291bnQgKz0gY2hyO1xuICAgICAgICAgICAgICAgIGNvbENvdW50ICs9IHJoYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBjZWxsIGNvdW50LlxuICAgICAgICB2YXIgY2VsbENvdW50ID0gcm93Q291bnQgKiBjb2xDb3VudDtcbiAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gY2FuY2VsIGEgbGFyZ2UgY29weSByZXF1ZXN0LlxuICAgICAgICBpZiAoY2VsbENvdW50ID4gd2FybmluZ1RocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IFwiQ29weWluZyBcIiArIGNlbGxDb3VudCArIFwiIGNlbGxzIG1heSB0YWtlIGEgd2hpbGUuIENvbnRpbnVlP1wiO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuY29uZmlybShtc2cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZm9ybWF0IGFyZ3MuXG4gICAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICAgICAgcmVnaW9uOiAnYm9keScsXG4gICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICAvLyBBbGxvY2F0ZSB0aGUgYXJyYXkgb2Ygcm93cy5cbiAgICAgICAgdmFyIHJvd3MgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHJvd3MuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Q291bnQ7ICsraikge1xuICAgICAgICAgICAgLy8gQWxsb2NhdGUgdGhlIGFycmF5IG9mIGNlbGxzLlxuICAgICAgICAgICAgdmFyIGNlbGxzID0gbmV3IEFycmF5KGNvbENvdW50KTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgY29sdW1ucy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgZm9ybWF0IHZhcmlhYmxlcy5cbiAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgZm9ybWF0IHZhcmlhYmxlcy5cbiAgICAgICAgICAgICAgICBpZiAoaiA8IGNociAmJiBpIDwgcmhjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbiA9ICdjb3JuZXItaGVhZGVyJztcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gajtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA8IGNocikge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSAnY29sdW1uLWhlYWRlcic7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGkgLSByaGMgKyBjMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IHJoYykge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSAncm93LWhlYWRlcic7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGogLSBjaHIgKyByMTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbiA9ICdib2R5JztcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gaiAtIGNociArIHIxO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBpIC0gcmhjICsgYzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRoZSBmb3JtYXQgYXJncy5cbiAgICAgICAgICAgICAgICBhcmdzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgICAgICAgICBhcmdzLnJvdyA9IHJvdztcbiAgICAgICAgICAgICAgICBhcmdzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBhcmdzLnZhbHVlID0gZGF0YU1vZGVsLmRhdGEocmVnaW9uLCByb3csIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgYXJncy5tZXRhZGF0YSA9IGRhdGFNb2RlbC5tZXRhZGF0YShyZWdpb24sIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIGNlbGwuXG4gICAgICAgICAgICAgICAgY2VsbHNbaV0gPSBmb3JtYXQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSByb3cgb2YgY2VsbHMuXG4gICAgICAgICAgICByb3dzW2pdID0gY2VsbHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCB0aGUgY2VsbHMgaW50byBsaW5lcy5cbiAgICAgICAgdmFyIGxpbmVzID0gcm93cy5tYXAoZnVuY3Rpb24gKGNlbGxzKSB7IHJldHVybiBjZWxscy5qb2luKHNlcGFyYXRvcik7IH0pO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBsaW5lcyBpbnRvIHRleHQuXG4gICAgICAgIHZhciB0ZXh0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgIC8vIENvcHkgdGhlIHRleHQgdG8gdGhlIGNsaXBib2FyZC5cbiAgICAgICAgQ2xpcGJvYXJkRXh0LmNvcHlUZXh0KHRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIG1lc3NhZ2Ugc2VudCB0byB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHNlbnQgdG8gdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUucHJvY2Vzc01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIC8vIElnbm9yZSBjaGlsZCBzaG93L2hpZGUgbWVzc2FnZXMuIFRoZSBkYXRhIGdyaWQgY29udHJvbHMgdGhlXG4gICAgICAgIC8vIHZpc2liaWxpdHkgb2YgaXRzIGNoaWxkcmVuLCBhbmQgd2lsbCBtYW51YWxseSBkaXNwYXRjaCB0aGVcbiAgICAgICAgLy8gZml0LXJlcXVlc3QgbWVzc2FnZXMgYXMgYSByZXN1bHQgb2YgdmlzaWJpbGl0eSBjaGFuZ2UuXG4gICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2NoaWxkLXNob3duJyB8fCBtc2cudHlwZSA9PT0gJ2NoaWxkLWhpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNvbXB1dGUgdGhlIHNjcm9sbCBiYXIgbWluaW11bXMgYmVmb3JlIHRoZSBsYXlvdXQgcmVmaXRzLlxuICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdmaXQtcmVxdWVzdCcpIHtcbiAgICAgICAgICAgIHZhciB2c2JMaW1pdHMgPSBFbGVtZW50RXh0LnNpemVMaW1pdHModGhpcy5fdlNjcm9sbEJhci5ub2RlKTtcbiAgICAgICAgICAgIHZhciBoc2JMaW1pdHMgPSBFbGVtZW50RXh0LnNpemVMaW1pdHModGhpcy5faFNjcm9sbEJhci5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMuX3ZTY3JvbGxCYXJNaW5XaWR0aCA9IHZzYkxpbWl0cy5taW5XaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hTY3JvbGxCYXJNaW5IZWlnaHQgPSBoc2JMaW1pdHMubWluSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgYWxsIG90aGVyIG1lc3NhZ2VzIGFzIG5vcm1hbC5cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZS5jYWxsKHRoaXMsIG1zZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmNlcHQgYSBtZXNzYWdlIHNlbnQgdG8gYSBtZXNzYWdlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSB0YXJnZXQgaGFuZGxlciBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgLSBUaGUgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXNzYWdlIHNob3VsZCBjb250aW51ZSB0byBiZSBwcm9jZXNzZWRcbiAgICAgKiAgIGFzIG5vcm1hbCwgb3IgYGZhbHNlYCBpZiBwcm9jZXNzaW5nIHNob3VsZCBjZWFzZSBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUubWVzc2FnZUhvb2sgPSBmdW5jdGlvbiAoaGFuZGxlciwgbXNnKSB7XG4gICAgICAgIC8vIFByb2Nlc3Mgdmlld3BvcnQgbWVzc2FnZXMuXG4gICAgICAgIGlmIChoYW5kbGVyID09PSB0aGlzLl92aWV3cG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1ZpZXdwb3J0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvY2VzcyBob3Jpem9udGFsIHNjcm9sbCBiYXIgbWVzc2FnZXMuXG4gICAgICAgIGlmIChoYW5kbGVyID09PSB0aGlzLl9oU2Nyb2xsQmFyICYmIG1zZy50eXBlID09PSAnYWN0aXZhdGUtcmVxdWVzdCcpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9jZXNzIHZlcnRpY2FsIHNjcm9sbCBiYXIgbWVzc2FnZXMuXG4gICAgICAgIGlmIChoYW5kbGVyID09PSB0aGlzLl92U2Nyb2xsQmFyICYmIG1zZy50eXBlID09PSAnYWN0aXZhdGUtcmVxdWVzdCcpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIG1lc3NhZ2VzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBET00gZXZlbnQgc2VudCB0byB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIERPTSBgRXZlbnRMaXN0ZW5lcmAgaW50ZXJmYWNlIGFuZCBpc1xuICAgICAqIGNhbGxlZCBpbiByZXNwb25zZSB0byBldmVudHMgb24gdGhlIGRhdGEgZ3JpZCdzIERPTSBub2RlLiBJdFxuICAgICAqIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRLZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlVXAoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGJsY2xpY2snOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlRG91YmxlQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VMZWF2ZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0Q29udGV4dE1lbnUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dFdoZWVsKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaERQSSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWN0aXZhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLm9uQWN0aXZhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLnZpZXdwb3J0Lm5vZGUuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1hdHRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5yZXBhaW50Q29udGVudCgpO1xuICAgICAgICB0aGlzLnJlcGFpbnRPdmVybGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUub25BZnRlckRldGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtc2hvdydgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLm9uQmVmb3JlU2hvdyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5yZXBhaW50Q29udGVudCgpO1xuICAgICAgICB0aGlzLnJlcGFpbnRPdmVybGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdyZXNpemUnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRvckNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRvckNvbnRyb2xsZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhIHJlcGFpbnQgb2YgYWxsIG9mIHRoZSBncmlkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJlcGFpbnRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbXNnID0gbmV3IFByaXZhdGUkNi5QYWludFJlcXVlc3QoJ2FsbCcsIDAsIDAsIDAsIDApO1xuICAgICAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSh0aGlzLl92aWV3cG9ydCwgbXNnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGEgcmVwYWludCBvZiBzcGVjaWZpYyBncmlkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLnJlcGFpbnRSZWdpb24gPSBmdW5jdGlvbiAocmVnaW9uLCByMSwgYzEsIHIyLCBjMikge1xuICAgICAgICB2YXIgbXNnID0gbmV3IFByaXZhdGUkNi5QYWludFJlcXVlc3QocmVnaW9uLCByMSwgYzEsIHIyLCBjMik7XG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMuX3ZpZXdwb3J0LCBtc2cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSByZXBhaW50IG9mIHRoZSBvdmVybGF5LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5yZXBhaW50T3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTWVzc2FnZUxvb3AucG9zdE1lc3NhZ2UodGhpcy5fdmlld3BvcnQsIFByaXZhdGUkNi5PdmVybGF5UGFpbnRSZXF1ZXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGUgY2FudmFzIGlzIGF0IGxlYXN0IHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0YWluIHRoZSB2YWxpZCBjYW52YXMgY29udGVudC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX3Jlc2l6ZUNhbnZhc0lmTmVlZGVkID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gU2NhbGUgdGhlIHNpemUgYnkgdGhlIGRwaSByYXRpby5cbiAgICAgICAgd2lkdGggPSB3aWR0aCAqIHRoaXMuX2RwaVJhdGlvO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiB0aGlzLl9kcGlSYXRpbztcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW11bSBjYW52YXMgc2l6ZSBmb3IgdGhlIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgIHZhciBtYXhXID0gKE1hdGguY2VpbCgod2lkdGggKyAxKSAvIDUxMikgKyAxKSAqIDUxMjtcbiAgICAgICAgdmFyIG1heEggPSAoTWF0aC5jZWlsKChoZWlnaHQgKyAxKSAvIDUxMikgKyAxKSAqIDUxMjtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAgICAgdmFyIGN1clcgPSB0aGlzLl9jYW52YXMud2lkdGg7XG4gICAgICAgIHZhciBjdXJIID0gdGhpcy5fY2FudmFzLmhlaWdodDtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgY2FudmFzIHNpemUgaXMgd2l0aGluIGJvdW5kcy5cbiAgICAgICAgaWYgKGN1clcgPj0gd2lkdGggJiYgY3VySCA+PSBoZWlnaHQgJiYgY3VyVyA8PSBtYXhXICYmIGN1ckggPD0gbWF4SCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGV4cGFuZGVkIGNhbnZhcyBzaXplLlxuICAgICAgICB2YXIgZXhwVyA9IG1heFcgLSA1MTI7XG4gICAgICAgIHZhciBleHBIID0gbWF4SCAtIDUxMjtcbiAgICAgICAgLy8gU2V0IHRoZSB0cmFuc2Zvcm1zIHRvIHRoZSBpZGVudGl0eSBtYXRyaXguXG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyR0Muc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLl9vdmVybGF5R0Muc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAvLyBSZXNpemUgdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjdXJXIDwgd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci53aWR0aCA9IGV4cFc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyVyA+IG1heFcpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci53aWR0aCA9IG1heFc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzaXplIHRoZSBidWZmZXIgaGVpZ2h0IGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKGN1ckggPCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5oZWlnaHQgPSBleHBIO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ckggPiBtYXhIKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIuaGVpZ2h0ID0gbWF4SDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlcmUgaXMgY29udGVudCB0byBibGl0LlxuICAgICAgICB2YXIgbmVlZEJsaXQgPSBjdXJIID4gMCAmJiBjdXJIID4gMCAmJiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMDtcbiAgICAgICAgLy8gQ29weSB0aGUgdmFsaWQgY2FudmFzIGNvbnRlbnQgaW50byB0aGUgYnVmZmVyIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG5lZWRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJHQy5kcmF3SW1hZ2UodGhpcy5fY2FudmFzLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNpemUgdGhlIGNhbnZhcyB3aWR0aCBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjdXJXIDwgd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGV4cFc7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSBleHBXIC8gdGhpcy5fZHBpUmF0aW8gKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyVyA+IG1heFcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IG1heFc7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSBtYXhXIC8gdGhpcy5fZHBpUmF0aW8gKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzaXplIHRoZSBjYW52YXMgaGVpZ2h0IGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKGN1ckggPCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBleHBIO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmhlaWdodCA9IGV4cEggLyB0aGlzLl9kcGlSYXRpbyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJIID4gbWF4SCkge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IG1heEg7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gbWF4SCAvIHRoaXMuX2RwaVJhdGlvICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvcHkgdGhlIHZhbGlkIGNhbnZhcyBjb250ZW50IGZyb20gdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChuZWVkQmxpdCkge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzR0MuZHJhd0ltYWdlKHRoaXMuX2J1ZmZlciwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29weSB0aGUgdmFsaWQgb3ZlcmxheSBjb250ZW50IGludG8gdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChuZWVkQmxpdCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyR0MuZHJhd0ltYWdlKHRoaXMuX292ZXJsYXksIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2l6ZSB0aGUgb3ZlcmxheSB3aWR0aCBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjdXJXIDwgd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkud2lkdGggPSBleHBXO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5zdHlsZS53aWR0aCA9IGV4cFcgLyB0aGlzLl9kcGlSYXRpbyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJXID4gbWF4Vykge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS53aWR0aCA9IG1heFc7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5LnN0eWxlLndpZHRoID0gbWF4VyAvIHRoaXMuX2RwaVJhdGlvICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2l6ZSB0aGUgb3ZlcmxheSBoZWlnaHQgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoY3VySCA8IGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5oZWlnaHQgPSBleHBIO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5zdHlsZS5oZWlnaHQgPSBleHBIIC8gdGhpcy5fZHBpUmF0aW8gKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VySCA+IG1heEgpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuaGVpZ2h0ID0gbWF4SDtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gbWF4SCAvIHRoaXMuX2RwaVJhdGlvICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvcHkgdGhlIHZhbGlkIG92ZXJsYXkgY29udGVudCBmcm9tIHRoZSBidWZmZXIgaWYgbmVlZGVkLlxuICAgICAgICBpZiAobmVlZEJsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlHQy5kcmF3SW1hZ2UodGhpcy5fYnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3luYyB0aGUgc2Nyb2xsIGJhcnMgYW5kIHNjcm9sbCBzdGF0ZSB3aXRoIHRoZSB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiB0aGUgdmlzaWJpbGl0eSBvZiBlaXRoZXIgc2Nyb2xsIGJhciBjaGFuZ2VzLCBhIHN5bmNocm9ub3VzXG4gICAgICogZml0LXJlcXVlc3Qgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIHRoZSBkYXRhIGdyaWQgdG8gaW1tZWRpYXRlbHlcbiAgICAgKiByZXNpemUgdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fc3luY1Njcm9sbFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGZXRjaCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAgICAgICAgdmFyIGJ3ID0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgIHZhciBiaCA9IHRoaXMuYm9keUhlaWdodDtcbiAgICAgICAgdmFyIHB3ID0gdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHNjcm9sbCBiYXIgdmlzaWJpbGl0eS5cbiAgICAgICAgdmFyIGhhc1ZTY3JvbGwgPSAhdGhpcy5fdlNjcm9sbEJhci5pc0hpZGRlbjtcbiAgICAgICAgdmFyIGhhc0hTY3JvbGwgPSAhdGhpcy5faFNjcm9sbEJhci5pc0hpZGRlbjtcbiAgICAgICAgLy8gR2V0IHRoZSBtaW5pbXVtIHNpemVzIG9mIHRoZSBzY3JvbGwgYmFycy5cbiAgICAgICAgdmFyIHZzdyA9IHRoaXMuX3ZTY3JvbGxCYXJNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhzaCA9IHRoaXMuX2hTY3JvbGxCYXJNaW5IZWlnaHQ7XG4gICAgICAgIC8vIEdldCB0aGUgcGFnZSBzaXplIGFzIGlmIG5vIHNjcm9sbCBiYXJzIGFyZSB2aXNpYmxlLlxuICAgICAgICB2YXIgYXB3ID0gcHcgKyAoaGFzVlNjcm9sbCA/IHZzdyA6IDApO1xuICAgICAgICB2YXIgYXBoID0gcGggKyAoaGFzSFNjcm9sbCA/IGhzaCA6IDApO1xuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgc2Nyb2xsIGJhcnMgYXJlIG5lZWRlZCBmb3IgdGhlIGFkanVzdGVkIHNpemUuXG4gICAgICAgIHZhciBuZWVkVlNjcm9sbCA9IGFwaCA8IGJoIC0gMTtcbiAgICAgICAgdmFyIG5lZWRIU2Nyb2xsID0gYXB3IDwgYncgLSAxO1xuICAgICAgICAvLyBSZS10ZXN0IHRoZSBob3Jpem9udGFsIHNjcm9sbCBpZiBhIHZlcnRpY2FsIHNjcm9sbCBpcyBuZWVkZWQuXG4gICAgICAgIGlmIChuZWVkVlNjcm9sbCAmJiAhbmVlZEhTY3JvbGwpIHtcbiAgICAgICAgICAgIG5lZWRIU2Nyb2xsID0gKGFwdyAtIHZzdykgPCBidyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGVzdCB0aGUgdmVydGljYWwgc2Nyb2xsIGlmIGEgaG9yaXpvbnRhbCBzY3JvbGwgaXMgbmVlZGVkLlxuICAgICAgICBpZiAobmVlZEhTY3JvbGwgJiYgIW5lZWRWU2Nyb2xsKSB7XG4gICAgICAgICAgICBuZWVkVlNjcm9sbCA9IChhcGggLSBoc2gpIDwgYmggLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB2aXNpYmlsaXR5IGNoYW5nZXMsIGltbWVkaWF0ZWx5IHJlZml0IHRoZSBncmlkLlxuICAgICAgICBpZiAobmVlZFZTY3JvbGwgIT09IGhhc1ZTY3JvbGwgfHwgbmVlZEhTY3JvbGwgIT09IGhhc0hTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZTY3JvbGxCYXIuc2V0SGlkZGVuKCFuZWVkVlNjcm9sbCk7XG4gICAgICAgICAgICB0aGlzLl9oU2Nyb2xsQmFyLnNldEhpZGRlbighbmVlZEhTY3JvbGwpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQ29ybmVyLnNldEhpZGRlbighbmVlZFZTY3JvbGwgfHwgIW5lZWRIU2Nyb2xsKTtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHRoaXMsIFdpZGdldC5Nc2cuRml0UmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzY3JvbGwgYmFyIGxpbWl0cy5cbiAgICAgICAgdGhpcy5fdlNjcm9sbEJhci5tYXhpbXVtID0gdGhpcy5tYXhTY3JvbGxZO1xuICAgICAgICB0aGlzLl92U2Nyb2xsQmFyLnBhZ2UgPSB0aGlzLnBhZ2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hTY3JvbGxCYXIubWF4aW11bSA9IHRoaXMubWF4U2Nyb2xsWDtcbiAgICAgICAgdGhpcy5faFNjcm9sbEJhci5wYWdlID0gdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgIC8vIFJlLWNsYW1wIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbFgsIHRoaXMuX3Njcm9sbFkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3luYyB0aGUgdmlld3BvcnQgdG8gdGhlIGdpdmVuIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHNjaGVkdWxlcyBhIGZ1bGwgcmVwYWludCBhbmQgc3luY3MgdGhlIHNjcm9sbCBzdGF0ZS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX3N5bmNWaWV3cG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBhaW50Q29udGVudCgpO1xuICAgICAgICB0aGlzLnJlcGFpbnRPdmVybGF5KCk7XG4gICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIG1lc3NhZ2Ugc2VudCB0byB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX3Byb2Nlc3NWaWV3cG9ydE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25WaWV3cG9ydFJlc2l6ZShtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsLXJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uVmlld3BvcnRTY3JvbGxSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwYWludC1yZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vblZpZXdwb3J0UGFpbnRSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvdmVybGF5LXBhaW50LXJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uVmlld3BvcnRPdmVybGF5UGFpbnRSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb3ctcmVzaXplLXJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uVmlld3BvcnRSb3dSZXNpemVSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb2x1bW4tcmVzaXplLXJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uVmlld3BvcnRDb2x1bW5SZXNpemVSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBob29rIGludm9rZWQgb24gYSB2aWV3cG9ydCBgJ3Jlc2l6ZSdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9vblZpZXdwb3J0UmVzaXplID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB2aWV3cG9ydCBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbnBhY2sgdGhlIG1lc3NhZ2UgZGF0YS5cbiAgICAgICAgdmFyIHdpZHRoID0gbXNnLndpZHRoLCBoZWlnaHQgPSBtc2cuaGVpZ2h0O1xuICAgICAgICAvLyBNZWFzdXJlIHRoZSB2aWV3cG9ydCBub2RlIGlmIHRoZSBkaW1lbnNpb25zIGFyZSB1bmtub3duLlxuICAgICAgICBpZiAod2lkdGggPT09IC0xKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX3ZpZXdwb3J0Lm5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX3ZpZXdwb3J0Lm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJvdW5kIHRoZSBkaW1lbnNpb25zIHRvIHRoZSBuZWFyZXN0IHBpeGVsLlxuICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdmFyIG9sZFdpZHRoID0gdGhpcy5fdmlld3BvcnRXaWR0aDtcbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAvLyBVcGRhdGVkIGludGVybmFsIHZpZXdwb3J0IHNpemUuXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIC8vIFJlc2l6ZSB0aGUgY2FudmFzIGlmIG5lZWRlZC5cbiAgICAgICAgdGhpcy5fcmVzaXplQ2FudmFzSWZOZWVkZWQod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm90aGluZyB0byBwYWludC5cbiAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhaW50IHRoZSB3aG9sZSBncmlkIGlmIHRoZSBvbGQgc2l6ZSB3YXMgemVyby5cbiAgICAgICAgaWYgKG9sZFdpZHRoID09PSAwIHx8IG9sZEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9wYWludE92ZXJsYXkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgcmlnaHQgZWRnZSBhcyBuZWVkZWQuXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdENvbHVtbiAmJiB0aGlzLnBhZ2VXaWR0aCA+IHRoaXMuYm9keVdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgYnggPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5vZmZzZXRPZih0aGlzLl9jb2x1bW5TZWN0aW9ucy5jb3VudCAtIDEpO1xuICAgICAgICAgICAgdmFyIHggPSBNYXRoLm1pbih0aGlzLmhlYWRlcldpZHRoICsgYngsIG9sZFdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KHgsIDAsIHdpZHRoIC0geCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aWR0aCA+IG9sZFdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q29udGVudChvbGRXaWR0aCwgMCwgd2lkdGggLSBvbGRXaWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgYm90dG9tIGVkZ2UgYXMgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RSb3cgJiYgdGhpcy5wYWdlSGVpZ2h0ID4gdGhpcy5ib2R5SGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYnkgPSB0aGlzLl9yb3dTZWN0aW9ucy5vZmZzZXRPZih0aGlzLl9yb3dTZWN0aW9ucy5jb3VudCAtIDEpO1xuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLm1pbih0aGlzLmhlYWRlckhlaWdodCArIGJ5LCBvbGRIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgeSwgd2lkdGgsIGhlaWdodCAtIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCA+IG9sZEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgb2xkSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0IC0gb2xkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgb3ZlcmxheS5cbiAgICAgICAgdGhpcy5fcGFpbnRPdmVybGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaG9vayBpbnZva2VkIG9uIGEgdmlld3BvcnQgYCdzY3JvbGwtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9vblZpZXdwb3J0U2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5faFNjcm9sbEJhci52YWx1ZSwgdGhpcy5fdlNjcm9sbEJhci52YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaG9vayBpbnZva2VkIG9uIGEgdmlld3BvcnQgYCdwYWludC1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX29uVmlld3BvcnRQYWludFJlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZpZXdwb3J0IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZpZXdwb3J0IGhhcyB6ZXJvIGFyZWEuXG4gICAgICAgIGlmICh0aGlzLl92aWV3cG9ydFdpZHRoID09PSAwIHx8IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHVwIHRoZSBwYWludCBsaW1pdHMuXG4gICAgICAgIHZhciB4TWluID0gMDtcbiAgICAgICAgdmFyIHlNaW4gPSAwO1xuICAgICAgICB2YXIgeE1heCA9IHRoaXMuX3ZpZXdwb3J0V2lkdGggLSAxO1xuICAgICAgICB2YXIgeU1heCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0IC0gMTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgdmFyIHN4ID0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgdmFyIHN5ID0gdGhpcy5fc2Nyb2xsWTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGhlYWRlciBkaW1lbnNpb25zLlxuICAgICAgICB2YXIgaHcgPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICB2YXIgaGggPSB0aGlzLmhlYWRlckhlaWdodDtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlY3Rpb24gbGlzdHMuXG4gICAgICAgIHZhciBycyA9IHRoaXMuX3Jvd1NlY3Rpb25zO1xuICAgICAgICB2YXIgY3MgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucztcbiAgICAgICAgdmFyIHJocyA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zO1xuICAgICAgICB2YXIgY2hzID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnM7XG4gICAgICAgIC8vIFVucGFjayB0aGUgbWVzc2FnZSBkYXRhLlxuICAgICAgICB2YXIgcmVnaW9uID0gbXNnLnJlZ2lvbiwgcjEgPSBtc2cucjEsIGMxID0gbXNnLmMxLCByMiA9IG1zZy5yMiwgYzIgPSBtc2cuYzI7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgcGFpbnQgdmFyaWFibGVzLlxuICAgICAgICB2YXIgeDE7XG4gICAgICAgIHZhciB5MTtcbiAgICAgICAgdmFyIHgyO1xuICAgICAgICB2YXIgeTI7XG4gICAgICAgIC8vIEZpbGwgdGhlIHBhaW50IHZhcmlhYmxlcyBiYXNlZCBvbiB0aGUgcGFpbnQgcmVnaW9uLlxuICAgICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICB4MSA9IHhNaW47XG4gICAgICAgICAgICAgICAgeTEgPSB5TWluO1xuICAgICAgICAgICAgICAgIHgyID0geE1heDtcbiAgICAgICAgICAgICAgICB5MiA9IHlNYXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICByMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHIxLCBycy5jb3VudCkpO1xuICAgICAgICAgICAgICAgIGMxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYzEsIGNzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgcjIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMiwgcnMuY291bnQpKTtcbiAgICAgICAgICAgICAgICBjMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMyLCBjcy5jb3VudCkpO1xuICAgICAgICAgICAgICAgIHgxID0gY3Mub2Zmc2V0T2YoYzEpIC0gc3ggKyBodztcbiAgICAgICAgICAgICAgICB5MSA9IHJzLm9mZnNldE9mKHIxKSAtIHN5ICsgaGg7XG4gICAgICAgICAgICAgICAgeDIgPSBjcy5leHRlbnRPZihjMikgLSBzeCArIGh3O1xuICAgICAgICAgICAgICAgIHkyID0gcnMuZXh0ZW50T2YocjIpIC0gc3kgKyBoaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jvdy1oZWFkZXInOlxuICAgICAgICAgICAgICAgIHIxID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocjEsIHJzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgYzEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjMSwgcmhzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgcjIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMiwgcnMuY291bnQpKTtcbiAgICAgICAgICAgICAgICBjMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMyLCByaHMuY291bnQpKTtcbiAgICAgICAgICAgICAgICB4MSA9IHJocy5vZmZzZXRPZihjMSk7XG4gICAgICAgICAgICAgICAgeTEgPSBycy5vZmZzZXRPZihyMSkgLSBzeSArIGhoO1xuICAgICAgICAgICAgICAgIHgyID0gcmhzLmV4dGVudE9mKGMyKTtcbiAgICAgICAgICAgICAgICB5MiA9IHJzLmV4dGVudE9mKHIyKSAtIHN5ICsgaGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb2x1bW4taGVhZGVyJzpcbiAgICAgICAgICAgICAgICByMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHIxLCBjaHMuY291bnQpKTtcbiAgICAgICAgICAgICAgICBjMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGMxLCBjcy5jb3VudCkpO1xuICAgICAgICAgICAgICAgIHIyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocjIsIGNocy5jb3VudCkpO1xuICAgICAgICAgICAgICAgIGMyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYzIsIGNzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgeDEgPSBjcy5vZmZzZXRPZihjMSkgLSBzeCArIGh3O1xuICAgICAgICAgICAgICAgIHkxID0gY2hzLm9mZnNldE9mKHIxKTtcbiAgICAgICAgICAgICAgICB4MiA9IGNzLmV4dGVudE9mKGMyKSAtIHN4ICsgaHc7XG4gICAgICAgICAgICAgICAgeTIgPSBjaHMuZXh0ZW50T2YocjIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29ybmVyLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgcjEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMSwgY2hzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgYzEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjMSwgcmhzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgcjIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyMiwgY2hzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgYzIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjMiwgcmhzLmNvdW50KSk7XG4gICAgICAgICAgICAgICAgeDEgPSByaHMub2Zmc2V0T2YoYzEpO1xuICAgICAgICAgICAgICAgIHkxID0gY2hzLm9mZnNldE9mKHIxKTtcbiAgICAgICAgICAgICAgICB4MiA9IHJocy5leHRlbnRPZihjMik7XG4gICAgICAgICAgICAgICAgeTIgPSBjaHMuZXh0ZW50T2YocjIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGRpcnR5IHJlY3QgaXMgb3V0c2lkZSB0aGUgYm91bmRzLlxuICAgICAgICBpZiAoeDIgPCB4TWluIHx8IHkyIDwgeU1pbiB8fCB4MSA+IHhNYXggfHwgeTEgPiB5TWF4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xhbXAgdGhlIGRpcnR5IHJlY3QgdG8gdGhlIHBhaW50IGJvdW5kcy5cbiAgICAgICAgeDEgPSBNYXRoLm1heCh4TWluLCBNYXRoLm1pbih4MSwgeE1heCkpO1xuICAgICAgICB5MSA9IE1hdGgubWF4KHlNaW4sIE1hdGgubWluKHkxLCB5TWF4KSk7XG4gICAgICAgIHgyID0gTWF0aC5tYXgoeE1pbiwgTWF0aC5taW4oeDIsIHhNYXgpKTtcbiAgICAgICAgeTIgPSBNYXRoLm1heCh5TWluLCBNYXRoLm1pbih5MiwgeU1heCkpO1xuICAgICAgICAvLyBQYWludCB0aGUgY29udGVudCBvZiB0aGUgZGlydHkgcmVjdC5cbiAgICAgICAgdGhpcy5wYWludENvbnRlbnQoeDEsIHkxLCB4MiAtIHgxICsgMSwgeTIgLSB5MSArIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhvb2sgaW52b2tlZCBvbiBhIHZpZXdwb3J0IGAnb3ZlcmxheS1wYWludC1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX29uVmlld3BvcnRPdmVybGF5UGFpbnRSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB2aWV3cG9ydCBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB2aWV3cG9ydCBoYXMgemVybyBhcmVhLlxuICAgICAgICBpZiAodGhpcy5fdmlld3BvcnRXaWR0aCA9PT0gMCB8fCB0aGlzLl92aWV3cG9ydEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhaW50IHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxuICAgICAgICB0aGlzLl9wYWludE92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBob29rIGludm9rZWQgb24gYSB2aWV3cG9ydCBgJ3Jvdy1yZXNpemUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9vblZpZXdwb3J0Um93UmVzaXplUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKG1zZy5yZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplUm93KG1zZy5pbmRleCwgbXNnLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplQ29sdW1uSGVhZGVyKG1zZy5pbmRleCwgbXNnLnNpemUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaG9vayBpbnZva2VkIG9uIGEgdmlld3BvcnQgYCdjb2x1bW4tcmVzaXplLXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25WaWV3cG9ydENvbHVtblJlc2l6ZVJlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChtc2cucmVnaW9uID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUNvbHVtbihtc2cuaW5kZXgsIG1zZy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZVJvd0hlYWRlcihtc2cuaW5kZXgsIG1zZy5zaXplKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGh1bWJNb3ZlZGAgc2lnbmFsIGZyb20gYSBzY3JvbGwgYmFyLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25UaHVtYk1vdmVkID0gZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSh0aGlzLl92aWV3cG9ydCwgUHJpdmF0ZSQ2LlNjcm9sbFJlcXVlc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgcGFnZVJlcXVlc3RlZGAgc2lnbmFsIGZyb20gYSBzY3JvbGwgYmFyLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25QYWdlUmVxdWVzdGVkID0gZnVuY3Rpb24gKHNlbmRlciwgZGlyKSB7XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHRoaXMuX3ZTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnlQYWdlKGRpciA9PT0gJ2RlY3JlbWVudCcgPyAndXAnIDogJ2Rvd24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnlQYWdlKGRpciA9PT0gJ2RlY3JlbWVudCcgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgc3RlcFJlcXVlc3RlZGAgc2lnbmFsIGZyb20gYSBzY3JvbGwgYmFyLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25TdGVwUmVxdWVzdGVkID0gZnVuY3Rpb24gKHNlbmRlciwgZGlyKSB7XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHRoaXMuX3ZTY3JvbGxCYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnlTdGVwKGRpciA9PT0gJ2RlY3JlbWVudCcgPyAndXAnIDogJ2Rvd24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnlTdGVwKGRpciA9PT0gJ2RlY3JlbWVudCcgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaWduYWwgaGFuZGxlciBmb3IgdGhlIGRhdGEgbW9kZWwgYGNoYW5nZWRgIHNpZ25hbC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX29uRGF0YU1vZGVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcbiAgICAgICAgc3dpdGNoIChhcmdzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Jvd3MtaW5zZXJ0ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uUm93c0luc2VydGVkKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29sdW1ucy1pbnNlcnRlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Db2x1bW5zSW5zZXJ0ZWQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb3dzLXJlbW92ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uUm93c1JlbW92ZWQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb2x1bW5zLXJlbW92ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uQ29sdW1uc1JlbW92ZWQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb3dzLW1vdmVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJvd3NNb3ZlZChhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbHVtbnMtbW92ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX29uQ29sdW1uc01vdmVkKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VsbHMtY2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DZWxsc0NoYW5nZWQoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb2RlbC1yZXNldCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Nb2RlbFJlc2V0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNpZ25hbCBoYW5kbGVyIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsIGBjaGFuZ2VkYCBzaWduYWwuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9vblNlbGVjdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICB0aGlzLnJlcGFpbnRPdmVybGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcm93cyBiZWluZyBpbnNlcnRlZCBpbiB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX29uUm93c0luc2VydGVkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgLy8gVW5wYWNrIHRoZSBhcmcgZGF0YS5cbiAgICAgICAgdmFyIHJlZ2lvbiA9IGFyZ3MucmVnaW9uLCBpbmRleCA9IGFyZ3MuaW5kZXgsIHNwYW4gPSBhcmdzLnNwYW47XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIHNlY3Rpb25zIHRvIGluc2VydC5cbiAgICAgICAgaWYgKHNwYW4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIHJlbGV2YW50IHNlY3Rpb24gbGlzdC5cbiAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgbGlzdCA9IHRoaXMuX3Jvd1NlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdCA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCB0aGUgc3BhbiwgbWFpbnRhaW5pbmcgdGhlIHNjcm9sbCBwb3NpdGlvbiBhcyBuZWVkZWQuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxZID09PSB0aGlzLm1heFNjcm9sbFkgJiYgdGhpcy5tYXhTY3JvbGxZID4gMCkge1xuICAgICAgICAgICAgbGlzdC5pbnNlcnQoaW5kZXgsIHNwYW4pO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsWSA9IHRoaXMubWF4U2Nyb2xsWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QuaW5zZXJ0KGluZGV4LCBzcGFuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTeW5jIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5fc3luY1ZpZXdwb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY29sdW1ucyBiZWluZyBpbnNlcnRlZCBpbnRvIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25Db2x1bW5zSW5zZXJ0ZWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAvLyBVbnBhY2sgdGhlIGFyZyBkYXRhLlxuICAgICAgICB2YXIgcmVnaW9uID0gYXJncy5yZWdpb24sIGluZGV4ID0gYXJncy5pbmRleCwgc3BhbiA9IGFyZ3Muc3BhbjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gc2VjdGlvbnMgdG8gaW5zZXJ0LlxuICAgICAgICBpZiAoc3BhbiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgcmVsZXZhbnQgc2VjdGlvbiBsaXN0LlxuICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBsaXN0ID0gdGhpcy5fY29sdW1uU2VjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ID0gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBzcGFuLCBtYWludGFpbmluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFzIG5lZWRlZC5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFggPT09IHRoaXMubWF4U2Nyb2xsWCAmJiB0aGlzLm1heFNjcm9sbFggPiAwKSB7XG4gICAgICAgICAgICBsaXN0Lmluc2VydChpbmRleCwgc3Bhbik7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxYID0gdGhpcy5tYXhTY3JvbGxYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5pbnNlcnQoaW5kZXgsIHNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN5bmMgdGhlIHZpZXdwb3J0LlxuICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSByb3dzIGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX29uUm93c1JlbW92ZWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAvLyBVbnBhY2sgdGhlIGFyZyBkYXRhLlxuICAgICAgICB2YXIgcmVnaW9uID0gYXJncy5yZWdpb24sIGluZGV4ID0gYXJncy5pbmRleCwgc3BhbiA9IGFyZ3Muc3BhbjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gc2VjdGlvbnMgdG8gcmVtb3ZlLlxuICAgICAgICBpZiAoc3BhbiA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgcmVsZXZhbnQgc2VjdGlvbiBsaXN0LlxuICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBsaXN0ID0gdGhpcy5fcm93U2VjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgaW5kZXggb3IgaXMgaW52YWxpZFxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3QuY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHNwYW4sIG1haW50YWluaW5nIHRoZSBzY3JvbGwgcG9zaXRpb24gYXMgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsWSA9PT0gdGhpcy5tYXhTY3JvbGxZICYmIHRoaXMubWF4U2Nyb2xsWSA+IDApIHtcbiAgICAgICAgICAgIGxpc3QucmVtb3ZlKGluZGV4LCBzcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFkgPSB0aGlzLm1heFNjcm9sbFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0LnJlbW92ZShpbmRleCwgc3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3luYyB0aGUgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuX3N5bmNWaWV3cG9ydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNvbHVtbnMgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25Db2x1bW5zUmVtb3ZlZCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIC8vIFVucGFjayB0aGUgYXJnIGRhdGEuXG4gICAgICAgIHZhciByZWdpb24gPSBhcmdzLnJlZ2lvbiwgaW5kZXggPSBhcmdzLmluZGV4LCBzcGFuID0gYXJncy5zcGFuO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBzZWN0aW9ucyB0byByZW1vdmUuXG4gICAgICAgIGlmIChzcGFuIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHRoZSByZWxldmFudCBzZWN0aW9uIGxpc3QuXG4gICAgICAgIHZhciBsaXN0O1xuICAgICAgICBpZiAocmVnaW9uID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIGxpc3QgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QgPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZSBpbmRleCBvciBpcyBpbnZhbGlkXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdC5jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc3BhbiwgbWFpbnRhaW5pbmcgdGhlIHNjcm9sbCBwb3NpdGlvbiBhcyBuZWVkZWQuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxYID09PSB0aGlzLm1heFNjcm9sbFggJiYgdGhpcy5tYXhTY3JvbGxYID4gMCkge1xuICAgICAgICAgICAgbGlzdC5yZW1vdmUoaW5kZXgsIHNwYW4pO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsWCA9IHRoaXMubWF4U2Nyb2xsWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QucmVtb3ZlKGluZGV4LCBzcGFuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTeW5jIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5fc3luY1ZpZXdwb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcm93cyBtb3ZpbmcgaW4gdGhlIGRhdGEgbW9kZWwuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9vblJvd3NNb3ZlZCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIC8vIFVucGFjayB0aGUgYXJnIGRhdGEuXG4gICAgICAgIHZhciByZWdpb24gPSBhcmdzLnJlZ2lvbiwgaW5kZXggPSBhcmdzLmluZGV4LCBzcGFuID0gYXJncy5zcGFuLCBkZXN0aW5hdGlvbiA9IGFyZ3MuZGVzdGluYXRpb247XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIHNlY3Rpb25zIHRvIG1vdmUuXG4gICAgICAgIGlmIChzcGFuIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHRoZSByZWxldmFudCBzZWN0aW9uIGxpc3QuXG4gICAgICAgIHZhciBsaXN0O1xuICAgICAgICBpZiAocmVnaW9uID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIGxpc3QgPSB0aGlzLl9yb3dTZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QgPSB0aGlzLl9jb2x1bW5IZWFkZXJTZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdC5jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRoZSBtb3ZlIHNwYW4gdG8gdGhlIGxpbWl0LlxuICAgICAgICBzcGFuID0gTWF0aC5taW4oc3BhbiwgbGlzdC5jb3VudCAtIGluZGV4KTtcbiAgICAgICAgLy8gQ2xhbXAgdGhlIGRlc3RpbmF0aW9uIGluZGV4IHRvIHRoZSBsaW1pdC5cbiAgICAgICAgZGVzdGluYXRpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBkZXN0aW5hdGlvbiksIGxpc3QuY291bnQgLSBzcGFuKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBlZmZlY3RpdmUgbW92ZS5cbiAgICAgICAgaWYgKGluZGV4ID09PSBkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZpcnN0IGFmZmVjdGVkIGluZGV4LlxuICAgICAgICB2YXIgcjEgPSBNYXRoLm1pbihpbmRleCwgZGVzdGluYXRpb24pO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBsYXN0IGFmZmVjdGVkIGluZGV4LlxuICAgICAgICB2YXIgcjIgPSBNYXRoLm1heChpbmRleCArIHNwYW4gLSAxLCBkZXN0aW5hdGlvbiArIHNwYW4gLSAxKTtcbiAgICAgICAgLy8gTW92ZSB0aGUgc2VjdGlvbnMgaW4gdGhlIGxpc3QuXG4gICAgICAgIGxpc3QubW92ZShpbmRleCwgc3BhbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAvLyBTY2hlZHVsZSBhIHJlcGFpbnQgb2YgdGhlIGRpcnR5IGNlbGxzLlxuICAgICAgICBpZiAocmVnaW9uID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHRoaXMucmVwYWludFJlZ2lvbignYm9keScsIHIxLCAwLCByMiwgSW5maW5pdHkpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50UmVnaW9uKCdyb3ctaGVhZGVyJywgcjEsIDAsIHIyLCBJbmZpbml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnRSZWdpb24oJ2NvbHVtbi1oZWFkZXInLCByMSwgMCwgcjIsIEluZmluaXR5KTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludFJlZ2lvbignY29ybmVyLWhlYWRlcicsIHIxLCAwLCByMiwgSW5maW5pdHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN5bmMgdGhlIHZpZXdwb3J0LlxuICAgICAgICB0aGlzLl9zeW5jVmlld3BvcnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjb2x1bW5zIG1vdmluZyBpbiB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX29uQ29sdW1uc01vdmVkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgLy8gVW5wYWNrIHRoZSBhcmcgZGF0YS5cbiAgICAgICAgdmFyIHJlZ2lvbiA9IGFyZ3MucmVnaW9uLCBpbmRleCA9IGFyZ3MuaW5kZXgsIHNwYW4gPSBhcmdzLnNwYW4sIGRlc3RpbmF0aW9uID0gYXJncy5kZXN0aW5hdGlvbjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gc2VjdGlvbnMgdG8gbW92ZS5cbiAgICAgICAgaWYgKHNwYW4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIHJlbGV2YW50IHNlY3Rpb24gbGlzdC5cbiAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgbGlzdCA9IHRoaXMuX2NvbHVtblNlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdCA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBsaXN0LmNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xhbXAgdGhlIG1vdmUgc3BhbiB0byB0aGUgbGltaXQuXG4gICAgICAgIHNwYW4gPSBNYXRoLm1pbihzcGFuLCBsaXN0LmNvdW50IC0gaW5kZXgpO1xuICAgICAgICAvLyBDbGFtcCB0aGUgZGVzdGluYXRpb24gaW5kZXggdG8gdGhlIGxpbWl0LlxuICAgICAgICBkZXN0aW5hdGlvbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGRlc3RpbmF0aW9uKSwgbGlzdC5jb3VudCAtIHNwYW4pO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIGVmZmVjdGl2ZSBtb3ZlLlxuICAgICAgICBpZiAoaW5kZXggPT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW92ZSB0aGUgc2VjdGlvbnMgaW4gdGhlIGxpc3QuXG4gICAgICAgIGxpc3QubW92ZShpbmRleCwgc3BhbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBmaXJzdCBhZmZlY3RlZCBpbmRleC5cbiAgICAgICAgdmFyIGMxID0gTWF0aC5taW4oaW5kZXgsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGFzdCBhZmZlY3RlZCBpbmRleC5cbiAgICAgICAgdmFyIGMyID0gTWF0aC5tYXgoaW5kZXggKyBzcGFuIC0gMSwgZGVzdGluYXRpb24gKyBzcGFuIC0gMSk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGEgcmVwYWludCBvZiB0aGUgZGlydHkgY2VsbHMuXG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50UmVnaW9uKCdib2R5JywgMCwgYzEsIEluZmluaXR5LCBjMik7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnRSZWdpb24oJ2NvbHVtbi1oZWFkZXInLCAwLCBjMSwgSW5maW5pdHksIGMyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwYWludFJlZ2lvbigncm93LWhlYWRlcicsIDAsIGMxLCBJbmZpbml0eSwgYzIpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50UmVnaW9uKCdjb3JuZXItaGVhZGVyJywgMCwgYzEsIEluZmluaXR5LCBjMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3luYyB0aGUgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuX3N5bmNWaWV3cG9ydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNlbGxzIGNoYW5naW5nIGluIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25DZWxsc0NoYW5nZWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAvLyBVbnBhY2sgdGhlIGFyZyBkYXRhLlxuICAgICAgICB2YXIgcmVnaW9uID0gYXJncy5yZWdpb24sIHJvdyA9IGFyZ3Mucm93LCBjb2x1bW4gPSBhcmdzLmNvbHVtbiwgcm93U3BhbiA9IGFyZ3Mucm93U3BhbiwgY29sdW1uU3BhbiA9IGFyZ3MuY29sdW1uU3BhbjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gY2VsbHMgdG8gbW9kaWZ5LlxuICAgICAgICBpZiAocm93U3BhbiA8PSAwICYmIGNvbHVtblNwYW4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNoYW5nZWQgY2VsbCBib3VuZHMuXG4gICAgICAgIHZhciByMSA9IHJvdztcbiAgICAgICAgdmFyIGMxID0gY29sdW1uO1xuICAgICAgICB2YXIgcjIgPSByMSArIHJvd1NwYW4gLSAxO1xuICAgICAgICB2YXIgYzIgPSBjMSArIGNvbHVtblNwYW4gLSAxO1xuICAgICAgICAvLyBTY2hlZHVsZSBhIHJlcGFpbnQgb2YgdGhlIGNlbGwgY29udGVudC5cbiAgICAgICAgdGhpcy5yZXBhaW50UmVnaW9uKHJlZ2lvbiwgcjEsIGMxLCByMiwgYzIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgZnVsbCBkYXRhIG1vZGVsIHJlc2V0LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fb25Nb2RlbFJlc2V0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgdmFyaW91cyBjdXJyZW50IHNlY3Rpb24gY291bnRzLlxuICAgICAgICB2YXIgbnIgPSB0aGlzLl9yb3dTZWN0aW9ucy5jb3VudDtcbiAgICAgICAgdmFyIG5jID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQ7XG4gICAgICAgIHZhciBucmggPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5jb3VudDtcbiAgICAgICAgdmFyIG5jaCA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLmNvdW50O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZWx0YSBjb3VudCBmb3IgZWFjaCByZWdpb24uXG4gICAgICAgIHZhciBkciA9IHRoaXMuX2RhdGFNb2RlbC5yb3dDb3VudCgnYm9keScpIC0gbnI7XG4gICAgICAgIHZhciBkYyA9IHRoaXMuX2RhdGFNb2RlbC5jb2x1bW5Db3VudCgnYm9keScpIC0gbmM7XG4gICAgICAgIHZhciBkcmggPSB0aGlzLl9kYXRhTW9kZWwuY29sdW1uQ291bnQoJ3Jvdy1oZWFkZXInKSAtIG5yaDtcbiAgICAgICAgdmFyIGRjaCA9IHRoaXMuX2RhdGFNb2RlbC5yb3dDb3VudCgnY29sdW1uLWhlYWRlcicpIC0gbmNoO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJvdyBzZWN0aW9ucywgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoZHIgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dTZWN0aW9ucy5pbnNlcnQobnIsIGRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkciA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd1NlY3Rpb25zLnJlbW92ZShuciArIGRyLCAtZHIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29sdW1uIHNlY3Rpb25zLCBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChkYyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblNlY3Rpb25zLmluc2VydChuYywgZGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRjIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uU2VjdGlvbnMucmVtb3ZlKG5jICsgZGMsIC1kYyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSByb3cgaGVhZGVyIHNlY3Rpb25zLCBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChkcmggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5pbnNlcnQobnJoLCBkcmgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRyaCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLnJlbW92ZShucmggKyBkcmgsIC1kcmgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29sdW1uIGhlYWRlciBzZWN0aW9ucywgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoZGNoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuaW5zZXJ0KG5jaCwgZGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkY2ggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5IZWFkZXJTZWN0aW9ucy5yZW1vdmUobmNoICsgZGNoLCAtZGNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTeW5jIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5fc3luY1ZpZXdwb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNpZ25hbCBoYW5kbGVyIGZvciB0aGUgcmVuZGVyZXIgbWFwIGBjaGFuZ2VkYCBzaWduYWwuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9vblJlbmRlcmVyc0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVwYWludENvbnRlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdrZXlkb3duJ2AgZXZlbnQgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9ldnRLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9rZXlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlIYW5kbGVyLm9uS2V5RG93bih0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdtb3VzZWRvd24nYCBldmVudCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2V2dE1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBJZ25vcmUgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxlZnQgbW91c2UgYnV0dG9uLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGdyaWQuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBBZGQgdGhlIGV4dHJhIGRvY3VtZW50IGxpc3RlbmVycy5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgLy8gRmxpcCB0aGUgbW91c2Vkb3duIGZsYWcuXG4gICAgICAgIHRoaXMuX21vdXNlZG93biA9IHRydWU7XG4gICAgICAgIC8vIERpc3BhdGNoIHRvIHRoZSBtb3VzZSBoYW5kbGVyLlxuICAgICAgICBpZiAodGhpcy5fbW91c2VIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZUhhbmRsZXIub25Nb3VzZURvd24odGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vtb3ZlJ2AgZXZlbnQgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9ldnRNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24gaWYgdGhlIG1vdXNlIGlzIGRvd24uXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIG1vdXNlIGhhbmRsZXIuXG4gICAgICAgIGlmICghdGhpcy5fbW91c2VIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcGF0Y2ggdG8gdGhlIG1vdXNlIGhhbmRsZXIuXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlSGFuZGxlci5vbk1vdXNlTW92ZSh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZUhhbmRsZXIub25Nb3VzZUhvdmVyKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNldXAnYCBldmVudCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2V2dE1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbi5cbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggdG8gdGhlIG1vdXNlIGhhbmRsZXIuXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlSGFuZGxlci5vbk1vdXNlVXAodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlLlxuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdkYmxjbGljaydgIGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fZXZ0TW91c2VEb3VibGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBJZ25vcmUgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxlZnQgbW91c2UgYnV0dG9uLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBEaXNwYXRjaCB0byB0aGUgbW91c2UgaGFuZGxlci5cbiAgICAgICAgaWYgKHRoaXMuX21vdXNlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VIYW5kbGVyLm9uTW91c2VEb3VibGVDbGljayh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsZWFzZSB0aGUgbW91c2UuXG4gICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNlbGVhdmUnYCBldmVudCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2V2dE1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlZG93bikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21vdXNlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VIYW5kbGVyLm9uTW91c2VMZWF2ZSh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdjb250ZXh0bWVudSdgIGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fZXZ0Q29udGV4dE1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlZG93bikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX21vdXNlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VIYW5kbGVyLm9uQ29udGV4dE1lbnUodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnd2hlZWwnYCBldmVudCBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2V2dFdoZWVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgYGFjY2VsYCBpcyBoZWxkLlxuICAgICAgICBpZiAoUGxhdGZvcm0uYWNjZWxLZXkoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBtb3VzZSBoYW5kbGVyLlxuICAgICAgICBpZiAoIXRoaXMuX21vdXNlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggdG8gdGhlIG1vdXNlIGhhbmRsZXIuXG4gICAgICAgIHRoaXMuX21vdXNlSGFuZGxlci5vbldoZWVsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIG1vdXNlIGdyYWIuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9yZWxlYXNlTW91c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBtb3VzZWRvd24gZmxhZy5cbiAgICAgICAgdGhpcy5fbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIC8vIFJlbGFzZSB0aGUgbW91c2UgaGFuZGxlci5cbiAgICAgICAgaWYgKHRoaXMuX21vdXNlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VIYW5kbGVyLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGRvY3VtZW50IGxpc3RlbmVycy5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggdGhlIGRwaSByYXRpby5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX3JlZnJlc2hEUEkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYmVzdCBpbnRlZ3JhbCB2YWx1ZSBmb3IgdGhlIGRwaSByYXRpby5cbiAgICAgICAgdmFyIGRwaVJhdGlvID0gTWF0aC5jZWlsKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgY29tcHV0ZWQgZHBpIHJhdGlvIGhhcyBub3QgY2hhbmdlZC5cbiAgICAgICAgaWYgKHRoaXMuX2RwaVJhdGlvID09PSBkcGlSYXRpbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgZHBpIHJhdGlvLlxuICAgICAgICB0aGlzLl9kcGlSYXRpbyA9IGRwaVJhdGlvO1xuICAgICAgICAvLyBTY2hlZHVsZSBhIHJlcGFpbnQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgIHRoaXMucmVwYWludENvbnRlbnQoKTtcbiAgICAgICAgLy8gU2NoZWR1bGUgYSByZXBhaW50IG9mIHRoZSBvdmVybGF5LlxuICAgICAgICB0aGlzLnJlcGFpbnRPdmVybGF5KCk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FudmFzIHNpemUgZm9yIHRoZSBuZXcgZHBpIHJhdGlvLlxuICAgICAgICB0aGlzLl9yZXNpemVDYW52YXNJZk5lZWRlZCh0aGlzLl92aWV3cG9ydFdpZHRoLCB0aGlzLl92aWV3cG9ydEhlaWdodCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgY2FudmFzIHN0eWxlIGlzIHNjYWxlZCBmb3IgdGhlIG5ldyByYXRpby5cbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5fY2FudmFzLndpZHRoIC8gdGhpcy5fZHBpUmF0aW8gKyBcInB4XCI7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLl9jYW52YXMuaGVpZ2h0IC8gdGhpcy5fZHBpUmF0aW8gKyBcInB4XCI7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgb3ZlcmxheSBzdHlsZSBpcyBzY2FsZWQgZm9yIHRoZSBuZXcgcmF0aW8uXG4gICAgICAgIHRoaXMuX292ZXJsYXkuc3R5bGUud2lkdGggPSB0aGlzLl9vdmVybGF5LndpZHRoIC8gdGhpcy5fZHBpUmF0aW8gKyBcInB4XCI7XG4gICAgICAgIHRoaXMuX292ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fb3ZlcmxheS5oZWlnaHQgLyB0aGlzLl9kcGlSYXRpbyArIFwicHhcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBhIHJvdyBzZWN0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fcmVzaXplUm93ID0gZnVuY3Rpb24gKGluZGV4LCBzaXplKSB7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBzZWN0aW9uIGxpc3QuXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fcm93U2VjdGlvbnM7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBsaXN0LmNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgb2xkIHNpemUgb2YgdGhlIHNlY3Rpb24uXG4gICAgICAgIHZhciBvbGRTaXplID0gbGlzdC5zaXplT2YoaW5kZXgpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIG5ldyBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgbmV3U2l6ZSA9IGxpc3QuY2xhbXBTaXplKHNpemUpO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBzaXplIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgaWYgKG9sZFNpemUgPT09IG5ld1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNpemUgdGhlIHNlY3Rpb24gaW4gdGhlIGxpc3QuXG4gICAgICAgIGxpc3QucmVzaXplKGluZGV4LCBuZXdTaXplKTtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgdncgPSB0aGlzLl92aWV3cG9ydFdpZHRoO1xuICAgICAgICB2YXIgdmggPSB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90aGluZyB0byBwYWludCwgc3luYyB0aGUgc2Nyb2xsIHN0YXRlLlxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0LmlzVmlzaWJsZSB8fCB2dyA9PT0gMCB8fCB2aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgc2l6ZSBkZWx0YS5cbiAgICAgICAgdmFyIGRlbHRhID0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIGNvbHVtbiBoZWFkZXIgaGVpZ2h0LlxuICAgICAgICB2YXIgaGggPSB0aGlzLmhlYWRlckhlaWdodDtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdmlld3BvcnQgb2Zmc2V0IG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgb2Zmc2V0ID0gbGlzdC5vZmZzZXRPZihpbmRleCkgKyBoaCAtIHRoaXMuX3Njcm9sbFk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm90aGluZyB0byBwYWludC5cbiAgICAgICAgaWYgKGhoID49IHZoIHx8IG9mZnNldCA+PSB2aCkge1xuICAgICAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgdGhlIHNlY3Rpb24gaXMgbm90IHZpc2libGUuXG4gICAgICAgIGlmIChvZmZzZXQgKyBvbGRTaXplIDw9IGhoKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxZICs9IGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFpbnQgb3JpZ2luIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgcG9zID0gTWF0aC5tYXgoaGgsIG9mZnNldCk7XG4gICAgICAgIC8vIFBhaW50IGZyb20gdGhlIHNlY3Rpb24gb253YXJkIGlmIGl0IHNwYW5zIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgaWYgKG9mZnNldCArIG9sZFNpemUgPj0gdmggfHwgb2Zmc2V0ICsgbmV3U2l6ZSA+PSB2aCkge1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgcG9zLCB2dywgdmggLSBwb3MpO1xuICAgICAgICAgICAgdGhpcy5fcGFpbnRPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLl9zeW5jU2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBYIGJsaXQgZGltZW5zaW9ucy5cbiAgICAgICAgdmFyIHN4ID0gMDtcbiAgICAgICAgdmFyIHN3ID0gdnc7XG4gICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIFkgYmxpdCBkaW1lbnNpb25zLlxuICAgICAgICB2YXIgc3k7XG4gICAgICAgIHZhciBzaDtcbiAgICAgICAgdmFyIGR5O1xuICAgICAgICBpZiAob2Zmc2V0ICsgbmV3U2l6ZSA8PSBoaCkge1xuICAgICAgICAgICAgc3kgPSBoaCAtIGRlbHRhO1xuICAgICAgICAgICAgc2ggPSB2aCAtIHN5O1xuICAgICAgICAgICAgZHkgPSBoaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN5ID0gb2Zmc2V0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIHNoID0gdmggLSBzeTtcbiAgICAgICAgICAgIGR5ID0gc3kgKyBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCbGl0IHRoZSB2YWxpZCBjb250ZW50IHRvIHRoZSBkZXN0aW5hdGlvbi5cbiAgICAgICAgdGhpcy5fYmxpdENvbnRlbnQodGhpcy5fY2FudmFzLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5KTtcbiAgICAgICAgLy8gUmVwYWludCB0aGUgc2VjdGlvbiBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChuZXdTaXplID4gMCAmJiBvZmZzZXQgKyBuZXdTaXplID4gaGgpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KDAsIHBvcywgdncsIG9mZnNldCArIG5ld1NpemUgLSBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhaW50IHRoZSB0cmFpbGluZyBzcGFjZSBhcyBuZWVkZWQuXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdFJvdyAmJiB0aGlzLnBhZ2VIZWlnaHQgPiB0aGlzLmJvZHlIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5fcm93U2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICAgICAgdmFyIHkgPSBoaCArIHRoaXMuX3Jvd1NlY3Rpb25zLm9mZnNldE9mKHIpO1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgeSwgdncsIHZoIC0geSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q29udGVudCgwLCB2aCArIGRlbHRhLCB2dywgLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgb3ZlcmxheS5cbiAgICAgICAgdGhpcy5fcGFpbnRPdmVybGF5KCk7XG4gICAgICAgIC8vIFN5bmMgdGhlIHNjcm9sbCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgYSBjb2x1bW4gc2VjdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX3Jlc2l6ZUNvbHVtbiA9IGZ1bmN0aW9uIChpbmRleCwgc2l6ZSkge1xuICAgICAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgc2VjdGlvbiBsaXN0LlxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbHVtblNlY3Rpb25zO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdC5jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIG9sZCBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgb2xkU2l6ZSA9IGxpc3Quc2l6ZU9mKGluZGV4KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBuZXcgc2l6ZSBvZiB0aGUgc2VjdGlvbi5cbiAgICAgICAgdmFyIG5ld1NpemUgPSBsaXN0LmNsYW1wU2l6ZShzaXplKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgc2l6ZSBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgIGlmIChvbGRTaXplID09PSBuZXdTaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzaXplIHRoZSBzZWN0aW9uIGluIHRoZSBsaXN0LlxuICAgICAgICBsaXN0LnJlc2l6ZShpbmRleCwgbmV3U2l6ZSk7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdmFyIHZ3ID0gdGhpcy5fdmlld3BvcnRXaWR0aDtcbiAgICAgICAgdmFyIHZoID0gdGhpcy5fdmlld3BvcnRIZWlnaHQ7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdGhpbmcgdG8gcGFpbnQsIHN5bmMgdGhlIHNjcm9sbCBzdGF0ZS5cbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydC5pc1Zpc2libGUgfHwgdncgPT09IDAgfHwgdmggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHNpemUgZGVsdGEuXG4gICAgICAgIHZhciBkZWx0YSA9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICAvLyBMb29rIHVwIHRoZSByb3cgaGVhZGVyIHdpZHRoLlxuICAgICAgICB2YXIgaHcgPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSB2aWV3cG9ydCBvZmZzZXQgb2YgdGhlIHNlY3Rpb24uXG4gICAgICAgIHZhciBvZmZzZXQgPSBsaXN0Lm9mZnNldE9mKGluZGV4KSArIGh3IC0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIHBhaW50LlxuICAgICAgICBpZiAoaHcgPj0gdncgfHwgb2Zmc2V0ID49IHZ3KSB7XG4gICAgICAgICAgICB0aGlzLl9zeW5jU2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiB0aGUgc2VjdGlvbiBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKG9mZnNldCArIG9sZFNpemUgPD0gaHcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFggKz0gZGVsdGE7XG4gICAgICAgICAgICB0aGlzLl9zeW5jU2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwYWludCBvcmlnaW4gb2YgdGhlIHNlY3Rpb24uXG4gICAgICAgIHZhciBwb3MgPSBNYXRoLm1heChodywgb2Zmc2V0KTtcbiAgICAgICAgLy8gUGFpbnQgZnJvbSB0aGUgc2VjdGlvbiBvbndhcmQgaWYgaXQgc3BhbnMgdGhlIHZpZXdwb3J0LlxuICAgICAgICBpZiAob2Zmc2V0ICsgb2xkU2l6ZSA+PSB2dyB8fCBvZmZzZXQgKyBuZXdTaXplID49IHZ3KSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q29udGVudChwb3MsIDAsIHZ3IC0gcG9zLCB2aCk7XG4gICAgICAgICAgICB0aGlzLl9wYWludE92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIFkgYmxpdCBkaW1lbnNpb25zLlxuICAgICAgICB2YXIgc3kgPSAwO1xuICAgICAgICB2YXIgc2ggPSB2aDtcbiAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgWCBibGl0IGRpbWVuc2lvbnMuXG4gICAgICAgIHZhciBzeDtcbiAgICAgICAgdmFyIHN3O1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIGlmIChvZmZzZXQgKyBuZXdTaXplIDw9IGh3KSB7XG4gICAgICAgICAgICBzeCA9IGh3IC0gZGVsdGE7XG4gICAgICAgICAgICBzdyA9IHZ3IC0gc3g7XG4gICAgICAgICAgICBkeCA9IGh3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ggPSBvZmZzZXQgKyBvbGRTaXplO1xuICAgICAgICAgICAgc3cgPSB2dyAtIHN4O1xuICAgICAgICAgICAgZHggPSBzeCArIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJsaXQgdGhlIHZhbGlkIGNvbnRlbnQgdG8gdGhlIGRlc3RpbmF0aW9uLlxuICAgICAgICB0aGlzLl9ibGl0Q29udGVudCh0aGlzLl9jYW52YXMsIHN4LCBzeSwgc3csIHNoLCBkeCwgZHkpO1xuICAgICAgICAvLyBSZXBhaW50IHRoZSBzZWN0aW9uIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG5ld1NpemUgPiAwICYmIG9mZnNldCArIG5ld1NpemUgPiBodykge1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQocG9zLCAwLCBvZmZzZXQgKyBuZXdTaXplIC0gcG9zLCB2aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFpbnQgdGhlIHRyYWlsaW5nIHNwYWNlIGFzIG5lZWRlZC5cbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Q29sdW1uICYmIHRoaXMucGFnZVdpZHRoID4gdGhpcy5ib2R5V2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICAgICAgdmFyIHggPSBodyArIHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKGMpO1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoeCwgMCwgdncgLSB4LCB2aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q29udGVudCh2dyArIGRlbHRhLCAwLCAtZGVsdGEsIHZoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgb3ZlcmxheS5cbiAgICAgICAgdGhpcy5fcGFpbnRPdmVybGF5KCk7XG4gICAgICAgIC8vIFN5bmMgdGhlIHNjcm9sbCBzdGF0ZSBhZnRlciBwYWludGluZy5cbiAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgYSByb3cgaGVhZGVyIHNlY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9yZXNpemVSb3dIZWFkZXIgPSBmdW5jdGlvbiAoaW5kZXgsIHNpemUpIHtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IHNlY3Rpb24gbGlzdC5cbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucztcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3QuY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHRoZSBvbGQgc2l6ZSBvZiB0aGUgc2VjdGlvbi5cbiAgICAgICAgdmFyIG9sZFNpemUgPSBsaXN0LnNpemVPZihpbmRleCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgbmV3IHNpemUgb2YgdGhlIHNlY3Rpb24uXG4gICAgICAgIHZhciBuZXdTaXplID0gbGlzdC5jbGFtcFNpemUoc2l6ZSk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHNpemUgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICBpZiAob2xkU2l6ZSA9PT0gbmV3U2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2l6ZSB0aGUgc2VjdGlvbiBpbiB0aGUgbGlzdC5cbiAgICAgICAgbGlzdC5yZXNpemUoaW5kZXgsIG5ld1NpemUpO1xuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgIHZhciB2dyA9IHRoaXMuX3ZpZXdwb3J0V2lkdGg7XG4gICAgICAgIHZhciB2aCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3RoaW5nIHRvIHBhaW50LCBzeW5jIHRoZSBzY3JvbGwgc3RhdGUuXG4gICAgICAgIGlmICghdGhpcy5fdmlld3BvcnQuaXNWaXNpYmxlIHx8IHZ3ID09PSAwIHx8IHZoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zeW5jU2Nyb2xsU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBzaXplIGRlbHRhLlxuICAgICAgICB2YXIgZGVsdGEgPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgb2Zmc2V0IG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgb2Zmc2V0ID0gbGlzdC5vZmZzZXRPZihpbmRleCk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHNlY3Rpb24gaXMgZnVsbHkgb3V0c2lkZSB0aGUgdmlld3BvcnQuXG4gICAgICAgIGlmIChvZmZzZXQgPj0gdncpIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhaW50IHRoZSBlbnRpcmUgdGFpbCBpZiB0aGUgc2VjdGlvbiBzcGFucyB0aGUgdmlld3BvcnQuXG4gICAgICAgIGlmIChvZmZzZXQgKyBvbGRTaXplID49IHZ3IHx8IG9mZnNldCArIG5ld1NpemUgPj0gdncpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KG9mZnNldCwgMCwgdncgLSBvZmZzZXQsIHZoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhaW50T3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYmxpdCBjb250ZW50IGRpbWVuc2lvbnMuXG4gICAgICAgIHZhciBzeCA9IG9mZnNldCArIG9sZFNpemU7XG4gICAgICAgIHZhciBzeSA9IDA7XG4gICAgICAgIHZhciBzdyA9IHZ3IC0gc3g7XG4gICAgICAgIHZhciBzaCA9IHZoO1xuICAgICAgICB2YXIgZHggPSBzeCArIGRlbHRhO1xuICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICAvLyBCbGl0IHRoZSB2YWxpZCBjb250ZW50cyB0byB0aGUgZGVzdGluYXRpb24uXG4gICAgICAgIHRoaXMuX2JsaXRDb250ZW50KHRoaXMuX2NhbnZhcywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSk7XG4gICAgICAgIC8vIFJlcGFpbnQgdGhlIGhlYWRlciBzZWN0aW9uIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG5ld1NpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q29udGVudChvZmZzZXQsIDAsIG5ld1NpemUsIHZoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgdHJhaWxpbmcgc3BhY2UgYXMgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RDb2x1bW4gJiYgdGhpcy5wYWdlV2lkdGggPiB0aGlzLmJvZHlXaWR0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuaGVhZGVyV2lkdGggKyB0aGlzLl9jb2x1bW5TZWN0aW9ucy5vZmZzZXRPZihjKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KHgsIDAsIHZ3IC0geCwgdmgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQodncgKyBkZWx0YSwgMCwgLWRlbHRhLCB2aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFpbnQgdGhlIG92ZXJsYXkuXG4gICAgICAgIHRoaXMuX3BhaW50T3ZlcmxheSgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBzY3JvbGwgc3RhdGUgYWZ0ZXIgcGFpbnRpbmcuXG4gICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzaXplIGEgY29sdW1uIGhlYWRlciBzZWN0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fcmVzaXplQ29sdW1uSGVhZGVyID0gZnVuY3Rpb24gKGluZGV4LCBzaXplKSB7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBzZWN0aW9uIGxpc3QuXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnM7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBsaXN0LmNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgb2xkIHNpemUgb2YgdGhlIHNlY3Rpb24uXG4gICAgICAgIHZhciBvbGRTaXplID0gbGlzdC5zaXplT2YoaW5kZXgpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIG5ldyBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgbmV3U2l6ZSA9IGxpc3QuY2xhbXBTaXplKHNpemUpO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBzaXplIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgaWYgKG9sZFNpemUgPT09IG5ld1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNpemUgdGhlIHNlY3Rpb24gaW4gdGhlIGxpc3QuXG4gICAgICAgIGxpc3QucmVzaXplKGluZGV4LCBuZXdTaXplKTtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgdncgPSB0aGlzLl92aWV3cG9ydFdpZHRoO1xuICAgICAgICB2YXIgdmggPSB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90aGluZyB0byBwYWludCwgc3luYyB0aGUgc2Nyb2xsIHN0YXRlLlxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0LmlzVmlzaWJsZSB8fCB2dyA9PT0gMCB8fCB2aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFpbnQgdGhlIG92ZXJsYXkuXG4gICAgICAgIHRoaXMuX3BhaW50T3ZlcmxheSgpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBzaXplIGRlbHRhLlxuICAgICAgICB2YXIgZGVsdGEgPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgb2Zmc2V0IG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICB2YXIgb2Zmc2V0ID0gbGlzdC5vZmZzZXRPZihpbmRleCk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHNlY3Rpb24gaXMgZnVsbHkgb3V0c2lkZSB0aGUgdmlld3BvcnQuXG4gICAgICAgIGlmIChvZmZzZXQgPj0gdmgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhaW50IHRoZSBlbnRpcmUgdGFpbCBpZiB0aGUgc2VjdGlvbiBzcGFucyB0aGUgdmlld3BvcnQuXG4gICAgICAgIGlmIChvZmZzZXQgKyBvbGRTaXplID49IHZoIHx8IG9mZnNldCArIG5ld1NpemUgPj0gdmgpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KDAsIG9mZnNldCwgdncsIHZoIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3BhaW50T3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5fc3luY1Njcm9sbFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYmxpdCBjb250ZW50IGRpbWVuc2lvbnMuXG4gICAgICAgIHZhciBzeCA9IDA7XG4gICAgICAgIHZhciBzeSA9IG9mZnNldCArIG9sZFNpemU7XG4gICAgICAgIHZhciBzdyA9IHZ3O1xuICAgICAgICB2YXIgc2ggPSB2aCAtIHN5O1xuICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICB2YXIgZHkgPSBzeSArIGRlbHRhO1xuICAgICAgICAvLyBCbGl0IHRoZSB2YWxpZCBjb250ZW50cyB0byB0aGUgZGVzdGluYXRpb24uXG4gICAgICAgIHRoaXMuX2JsaXRDb250ZW50KHRoaXMuX2NhbnZhcywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSk7XG4gICAgICAgIC8vIFJlcGFpbnQgdGhlIGhlYWRlciBzZWN0aW9uIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG5ld1NpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q29udGVudCgwLCBvZmZzZXQsIHZ3LCBuZXdTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWludCB0aGUgdHJhaWxpbmcgc3BhY2UgYXMgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RSb3cgJiYgdGhpcy5wYWdlSGVpZ2h0ID4gdGhpcy5ib2R5SGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuX3Jvd1NlY3Rpb25zLmNvdW50IC0gMTtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5oZWFkZXJIZWlnaHQgKyB0aGlzLl9yb3dTZWN0aW9ucy5vZmZzZXRPZihyKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KDAsIHksIHZ3LCB2aCAtIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgdmggKyBkZWx0YSwgdncsIC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFpbnQgdGhlIG92ZXJsYXkuXG4gICAgICAgIHRoaXMuX3BhaW50T3ZlcmxheSgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBzY3JvbGwgc3RhdGUgYWZ0ZXIgcGFpbnRpbmcuXG4gICAgICAgIHRoaXMuX3N5bmNTY3JvbGxTdGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIGltbWVkaWF0ZWx5IHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fc2Nyb2xsVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAvLyBGbG9vciBhbmQgY2xhbXAgdGhlIHBvc2l0aW9uIHRvIHRoZSBhbGxvd2FibGUgcmFuZ2UuXG4gICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihNYXRoLmZsb29yKHgpLCB0aGlzLm1heFNjcm9sbFgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKE1hdGguZmxvb3IoeSksIHRoaXMubWF4U2Nyb2xsWSkpO1xuICAgICAgICAvLyBTeW5jaHJvbml6ZSB0aGUgc2Nyb2xsIGJhciB2YWx1ZXMuXG4gICAgICAgIHRoaXMuX2hTY3JvbGxCYXIudmFsdWUgPSB4O1xuICAgICAgICB0aGlzLl92U2Nyb2xsQmFyLnZhbHVlID0geTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGVsdGEgc2Nyb2xsIGFtb3VudC5cbiAgICAgICAgdmFyIGR4ID0geCAtIHRoaXMuX3Njcm9sbFg7XG4gICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIGVmZmVjdGl2ZSBzY3JvbGwuXG4gICAgICAgIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHZpZXdwb3J0IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsWCA9IHg7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxZID0geTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3ZpZXdwb3J0V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgdmlld3BvcnQgaXMgZW1wdHkuXG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFggPSB4O1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsWSA9IHk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIGNvbnRlbnQgb3JpZ2luLlxuICAgICAgICB2YXIgY29udGVudFggPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICB2YXIgY29udGVudFkgPSB0aGlzLmhlYWRlckhlaWdodDtcbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIGNvbnRlbnQgZGltZW5zaW9ucy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IHdpZHRoIC0gY29udGVudFg7XG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0ID0gaGVpZ2h0IC0gY29udGVudFk7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gY29udGVudCB0byBkcmF3LlxuICAgICAgICBpZiAoY29udGVudFdpZHRoIDw9IDAgJiYgY29udGVudEhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxYID0geDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFyZWEgd2hpY2ggbmVlZHMgcGFpbnRpbmcgZm9yIHRoZSBgZHhgIHNjcm9sbC5cbiAgICAgICAgdmFyIGR4QXJlYSA9IDA7XG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBjb250ZW50V2lkdGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID49IGNvbnRlbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIGR4QXJlYSA9IGNvbnRlbnRXaWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGR4QXJlYSA9IE1hdGguYWJzKGR4KSAqIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhcmVhIHdoaWNoIG5lZWRzIHBhaW50aW5nIGZvciB0aGUgYGR5YCBzY3JvbGwuXG4gICAgICAgIHZhciBkeUFyZWEgPSAwO1xuICAgICAgICBpZiAoZHkgIT09IDAgJiYgY29udGVudEhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeSkgPj0gY29udGVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGR5QXJlYSA9IHdpZHRoICogY29udGVudEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGR5QXJlYSA9IHdpZHRoICogTWF0aC5hYnMoZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBhcmVhIHN1bSBpcyBsYXJnZXIgdGhhbiB0aGUgdG90YWwsIHBhaW50IGV2ZXJ5dGhpbmcuXG4gICAgICAgIGlmICgoZHhBcmVhICsgZHlBcmVhKSA+PSAod2lkdGggKiBoZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxYID0geDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFkgPSB5O1xuICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9wYWludE92ZXJsYXkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIFkgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLl9zY3JvbGxZID0geTtcbiAgICAgICAgLy8gU2Nyb2xsIHRoZSBZIGF4aXMgaWYgbmVlZGVkLiBJZiB0aGUgc2Nyb2xsIGRpc3RhbmNlIGV4Y2VlZHNcbiAgICAgICAgLy8gdGhlIHZpc2libGUgaGVpZ2h0LCBwYWludCBldmVyeXRoaW5nLiBPdGhlcndpc2UsIGJsaXQgdGhlXG4gICAgICAgIC8vIHZhbGlkIGNvbnRlbnQgYW5kIHBhaW50IHRoZSBkaXJ0eSByZWdpb24uXG4gICAgICAgIGlmIChkeSAhPT0gMCAmJiBjb250ZW50SGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR5KSA+PSBjb250ZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgY29udGVudFksIHdpZHRoLCBjb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB4XzUgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5XzUgPSBkeSA8IDAgPyBjb250ZW50WSA6IGNvbnRlbnRZICsgZHk7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IGNvbnRlbnRIZWlnaHQgLSBNYXRoLmFicyhkeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmxpdENvbnRlbnQodGhpcy5fY2FudmFzLCB4XzUsIHlfNSwgdywgaCwgeF81LCB5XzUgLSBkeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludENvbnRlbnQoMCwgZHkgPCAwID8gY29udGVudFkgOiBoZWlnaHQgLSBkeSwgd2lkdGgsIE1hdGguYWJzKGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBYIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5fc2Nyb2xsWCA9IHg7XG4gICAgICAgIC8vIFNjcm9sbCB0aGUgWCBheGlzIGlmIG5lZWRlZC4gSWYgdGhlIHNjcm9sbCBkaXN0YW5jZSBleGNlZWRzXG4gICAgICAgIC8vIHRoZSB2aXNpYmxlIHdpZHRoLCBwYWludCBldmVyeXRoaW5nLiBPdGhlcndpc2UsIGJsaXQgdGhlXG4gICAgICAgIC8vIHZhbGlkIGNvbnRlbnQgYW5kIHBhaW50IHRoZSBkaXJ0eSByZWdpb24uXG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBjb250ZW50V2lkdGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID49IGNvbnRlbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KGNvbnRlbnRYLCAwLCBjb250ZW50V2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeF82ID0gZHggPCAwID8gY29udGVudFggOiBjb250ZW50WCArIGR4O1xuICAgICAgICAgICAgICAgIHZhciB5XzYgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gY29udGVudFdpZHRoIC0gTWF0aC5hYnMoZHgpO1xuICAgICAgICAgICAgICAgIHZhciBoID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JsaXRDb250ZW50KHRoaXMuX2NhbnZhcywgeF82LCB5XzYsIHcsIGgsIHhfNiAtIGR4LCB5XzYpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRDb250ZW50KGR4IDwgMCA/IGNvbnRlbnRYIDogd2lkdGggLSBkeCwgMCwgTWF0aC5hYnMoZHgpLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBhaW50IHRoZSBvdmVybGF5LlxuICAgICAgICB0aGlzLl9wYWludE92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJsaXQgY29udGVudCBpbnRvIHRoZSBvbi1zY3JlZW4gZ3JpZCBjYW52YXMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVjdCBzaG91bGQgYmUgZXhwcmVzc2VkIGluIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogVGhpcyBhdXRvbWF0aWNhbGx5IGFjY291bnRzIGZvciB0aGUgZHBpIHJhdGlvLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fYmxpdENvbnRlbnQgPSBmdW5jdGlvbiAoc291cmNlLCB4LCB5LCB3LCBoLCBkeCwgZHkpIHtcbiAgICAgICAgLy8gU2NhbGUgdGhlIGJsaXQgY29vcmRpbmF0ZXMgYnkgdGhlIGRwaSByYXRpby5cbiAgICAgICAgeCAqPSB0aGlzLl9kcGlSYXRpbztcbiAgICAgICAgeSAqPSB0aGlzLl9kcGlSYXRpbztcbiAgICAgICAgdyAqPSB0aGlzLl9kcGlSYXRpbztcbiAgICAgICAgaCAqPSB0aGlzLl9kcGlSYXRpbztcbiAgICAgICAgZHggKj0gdGhpcy5fZHBpUmF0aW87XG4gICAgICAgIGR5ICo9IHRoaXMuX2RwaVJhdGlvO1xuICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGdjIHN0YXRlLlxuICAgICAgICB0aGlzLl9jYW52YXNHQy5zYXZlKCk7XG4gICAgICAgIC8vIFNldCB0aGUgdHJhbnNmb3JtIHRvIHRoZSBpZGVudGl0eSBtYXRyaXguXG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgc3BlY2lmaWVkIGNvbnRlbnQuXG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLmRyYXdJbWFnZShzb3VyY2UsIHgsIHksIHcsIGgsIGR4LCBkeSwgdywgaCk7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIGdjIHN0YXRlLlxuICAgICAgICB0aGlzLl9jYW52YXNHQy5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgZ3JpZCBjb250ZW50IGZvciB0aGUgZ2l2ZW4gZGlydHkgcmVjdC5cbiAgICAgKlxuICAgICAqIFRoZSByZWN0IHNob3VsZCBiZSBleHByZXNzZWQgaW4gdmFsaWQgdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBwcmltYXJ5IHBhaW50IGVudHJ5IHBvaW50LiBUaGUgaW5kaXZpZHVhbCBgX2RyYXcqYFxuICAgICAqIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIG1ldGhvZCBkaXNwYXRjaGVzXG4gICAgICogdG8gdGhlIGRyYXdpbmcgbWV0aG9kcyBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUucGFpbnRDb250ZW50ID0gZnVuY3Rpb24gKHJ4LCByeSwgcncsIHJoKSB7XG4gICAgICAgIC8vIFNjYWxlIHRoZSBjYW52YXMgYW5kIGJ1ZmZlciBHQyBmb3IgdGhlIGRwaSByYXRpby5cbiAgICAgICAgdGhpcy5fY2FudmFzR0Muc2V0VHJhbnNmb3JtKHRoaXMuX2RwaVJhdGlvLCAwLCAwLCB0aGlzLl9kcGlSYXRpbywgMCwgMCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckdDLnNldFRyYW5zZm9ybSh0aGlzLl9kcGlSYXRpbywgMCwgMCwgdGhpcy5fZHBpUmF0aW8sIDAsIDApO1xuICAgICAgICAvLyBDbGVhciB0aGUgZGlydHkgcmVjdCBvZiBhbGwgY29udGVudC5cbiAgICAgICAgdGhpcy5fY2FudmFzR0MuY2xlYXJSZWN0KHJ4LCByeSwgcncsIHJoKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgdm9pZCByZWdpb24uXG4gICAgICAgIHRoaXMuX2RyYXdWb2lkUmVnaW9uKHJ4LCByeSwgcncsIHJoKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgYm9keSByZWdpb24uXG4gICAgICAgIHRoaXMuX2RyYXdCb2R5UmVnaW9uKHJ4LCByeSwgcncsIHJoKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgcm93IGhlYWRlciByZWdpb24uXG4gICAgICAgIHRoaXMuX2RyYXdSb3dIZWFkZXJSZWdpb24ocngsIHJ5LCBydywgcmgpO1xuICAgICAgICAvLyBEcmF3IHRoZSBjb2x1bW4gaGVhZGVyIHJlZ2lvbi5cbiAgICAgICAgdGhpcy5fZHJhd0NvbHVtbkhlYWRlclJlZ2lvbihyeCwgcnksIHJ3LCByaCk7XG4gICAgICAgIC8vIERyYXcgdGhlIGNvcm5lciBoZWFkZXIgcmVnaW9uLlxuICAgICAgICB0aGlzLmRyYXdDb3JuZXJIZWFkZXJSZWdpb24ocngsIHJ5LCBydywgcmgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIG92ZXJsYXkgY29udGVudCBmb3IgdGhlIGVudGlyZSBncmlkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpbWFyeSBvdmVybGF5IHBhaW50IGVudHJ5IHBvaW50LiBUaGUgaW5kaXZpZHVhbFxuICAgICAqIGBfZHJhdypgIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIG1ldGhvZFxuICAgICAqIGRpc3BhdGNoZXMgdG8gdGhlIGRyYXdpbmcgbWV0aG9kcyBpbiB0aGUgY29ycmVjdCBvcmRlci5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX3BhaW50T3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2NhbGUgdGhlIG92ZXJsYXkgR0MgZm9yIHRoZSBkcGkgcmF0aW8uXG4gICAgICAgIHRoaXMuX292ZXJsYXlHQy5zZXRUcmFuc2Zvcm0odGhpcy5fZHBpUmF0aW8sIDAsIDAsIHRoaXMuX2RwaVJhdGlvLCAwLCAwKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIG92ZXJsYXkgb2YgYWxsIGNvbnRlbnQuXG4gICAgICAgIHRoaXMuX292ZXJsYXlHQy5jbGVhclJlY3QoMCwgMCwgdGhpcy5fb3ZlcmxheS53aWR0aCwgdGhpcy5fb3ZlcmxheS5oZWlnaHQpO1xuICAgICAgICAvLyBEcmF3IHRoZSBib2R5IHNlbGVjdGlvbnMuXG4gICAgICAgIHRoaXMuX2RyYXdCb2R5U2VsZWN0aW9ucygpO1xuICAgICAgICAvLyBEcmF3IHRoZSByb3cgaGVhZGVyIHNlbGVjdGlvbnMuXG4gICAgICAgIHRoaXMuX2RyYXdSb3dIZWFkZXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vIERyYXcgdGhlIGNvbHVtbiBoZWFkZXIgc2VsZWN0aW9ucy5cbiAgICAgICAgdGhpcy5fZHJhd0NvbHVtbkhlYWRlclNlbGVjdGlvbnMoKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgY3Vyc29yLlxuICAgICAgICB0aGlzLl9kcmF3Q3Vyc29yKCk7XG4gICAgICAgIC8vIERyYXcgdGhlIHNoYWRvd3MuXG4gICAgICAgIHRoaXMuX2RyYXdTaGFkb3dzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSB2b2lkIHJlZ2lvbiBmb3IgdGhlIGRpcnR5IHJlY3QuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9kcmF3Vm9pZFJlZ2lvbiA9IGZ1bmN0aW9uIChyeCwgcnksIHJ3LCByaCkge1xuICAgICAgICAvLyBMb29rIHVwIHRoZSB2b2lkIGNvbG9yLlxuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLl9zdHlsZS52b2lkQ29sb3I7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gdm9pZCBjb2xvci5cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbGwgdGhlIGRpcnR5IHJlY3Qgd2l0aCB0aGUgdm9pZCBjb2xvci5cbiAgICAgICAgdGhpcy5fY2FudmFzR0MuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLmZpbGxSZWN0KHJ4LCByeSwgcncsIHJoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGJvZHkgcmVnaW9uIHdoaWNoIGludGVyc2VjdHMgdGhlIGRpcnR5IHJlY3QuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9kcmF3Qm9keVJlZ2lvbiA9IGZ1bmN0aW9uIChyeCwgcnksIHJ3LCByaCkge1xuICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgY29udGVudCBkaW1lbnNpb25zLlxuICAgICAgICB2YXIgY29udGVudFcgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5sZW5ndGggLSB0aGlzLl9zY3JvbGxYO1xuICAgICAgICB2YXIgY29udGVudEggPSB0aGlzLl9yb3dTZWN0aW9ucy5sZW5ndGggLSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQgdG8gZHJhdy5cbiAgICAgICAgaWYgKGNvbnRlbnRXIDw9IDAgfHwgY29udGVudEggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgdmlzaWJsZSBjb250ZW50IG9yaWdpbi5cbiAgICAgICAgdmFyIGNvbnRlbnRYID0gdGhpcy5oZWFkZXJXaWR0aDtcbiAgICAgICAgdmFyIGNvbnRlbnRZID0gdGhpcy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGRpcnR5IHJlY3QgZG9lcyBub3QgaW50ZXJzZWN0IHRoZSBjb250ZW50IGFyZWEuXG4gICAgICAgIGlmIChyeCArIHJ3IDw9IGNvbnRlbnRYKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ5ICsgcmggPD0gY29udGVudFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnggPj0gY29udGVudFggKyBjb250ZW50Vykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyeSA+PSBjb250ZW50WSArIGNvbnRlbnRIKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGdlb21ldHJ5LlxuICAgICAgICB2YXIgYmggPSB0aGlzLmJvZHlIZWlnaHQ7XG4gICAgICAgIHZhciBidyA9IHRoaXMuYm9keVdpZHRoO1xuICAgICAgICB2YXIgcGggPSB0aGlzLnBhZ2VIZWlnaHQ7XG4gICAgICAgIHZhciBwdyA9IHRoaXMucGFnZVdpZHRoO1xuICAgICAgICAvLyBHZXQgdGhlIHVwcGVyIGFuZCBsb3dlciBib3VuZHMgb2YgdGhlIGRpcnR5IGNvbnRlbnQgYXJlYS5cbiAgICAgICAgdmFyIHgxID0gTWF0aC5tYXgocngsIGNvbnRlbnRYKTtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5tYXgocnksIGNvbnRlbnRZKTtcbiAgICAgICAgdmFyIHgyID0gTWF0aC5taW4ocnggKyBydyAtIDEsIGNvbnRlbnRYICsgY29udGVudFcgLSAxKTtcbiAgICAgICAgdmFyIHkyID0gTWF0aC5taW4ocnkgKyByaCAtIDEsIGNvbnRlbnRZICsgY29udGVudEggLSAxKTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgZGlydHkgY29udGVudCBib3VuZHMgaW50byBjZWxsIGJvdW5kcy5cbiAgICAgICAgdmFyIHIxID0gdGhpcy5fcm93U2VjdGlvbnMuaW5kZXhPZih5MSAtIGNvbnRlbnRZICsgdGhpcy5fc2Nyb2xsWSk7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmluZGV4T2YoeDEgLSBjb250ZW50WCArIHRoaXMuX3Njcm9sbFgpO1xuICAgICAgICB2YXIgcjIgPSB0aGlzLl9yb3dTZWN0aW9ucy5pbmRleE9mKHkyIC0gY29udGVudFkgKyB0aGlzLl9zY3JvbGxZKTtcbiAgICAgICAgdmFyIGMyID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuaW5kZXhPZih4MiAtIGNvbnRlbnRYICsgdGhpcy5fc2Nyb2xsWCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBtYXggcm93IGFuZCBjb2x1bW4uXG4gICAgICAgIHZhciBtYXhSb3cgPSB0aGlzLl9yb3dTZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgIHZhciBtYXhDb2x1bW4gPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgIC8vIEhhbmRsZSBhIGRpcnR5IGNvbnRlbnQgYXJlYSBsYXJnZXIgdGhhbiB0aGUgY2VsbCBjb3VudC5cbiAgICAgICAgaWYgKHIyIDwgMCkge1xuICAgICAgICAgICAgcjIgPSBtYXhSb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMyIDwgMCkge1xuICAgICAgICAgICAgYzIgPSBtYXhDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCB0aGUgY2VsbCBib3VuZHMgYmFjayB0byB2aXNpYmxlIGNvb3JkaW5hdGVzLlxuICAgICAgICB2YXIgeCA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKGMxKSArIGNvbnRlbnRYIC0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl9yb3dTZWN0aW9ucy5vZmZzZXRPZihyMSkgKyBjb250ZW50WSAtIHRoaXMuX3Njcm9sbFk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgcGFpbnQgcmVnaW9uIHNpemUgdmFyaWFibGVzLlxuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgICAgLy8gQWxsb2NhdGUgdGhlIHNlY3Rpb24gc2l6ZXMgYXJyYXlzLlxuICAgICAgICB2YXIgcm93U2l6ZXMgPSBuZXcgQXJyYXkocjIgLSByMSArIDEpO1xuICAgICAgICB2YXIgY29sdW1uU2l6ZXMgPSBuZXcgQXJyYXkoYzIgLSBjMSArIDEpO1xuICAgICAgICAvLyBHZXQgdGhlIHJvdyBzaXplcyBmb3IgdGhlIHJlZ2lvbi5cbiAgICAgICAgZm9yICh2YXIgaiA9IHIxOyBqIDw9IHIyOyArK2opIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fcm93U2VjdGlvbnMuc2l6ZU9mKGopO1xuICAgICAgICAgICAgcm93U2l6ZXNbaiAtIHIxXSA9IHNpemU7XG4gICAgICAgICAgICBoZWlnaHQgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGNvbHVtbiBzaXplcyBmb3IgdGhlIHJlZ2lvbi5cbiAgICAgICAgZm9yICh2YXIgaSA9IGMxOyBpIDw9IGMyOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuc2l6ZU9mKGkpO1xuICAgICAgICAgICAgY29sdW1uU2l6ZXNbaSAtIGMxXSA9IHNpemU7XG4gICAgICAgICAgICB3aWR0aCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkanVzdCB0aGUgZ2VvbWV0cnkgaWYgdGhlIGxhc3Qgcm93IGlzIHN0cmVjaGVkLlxuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RSb3cgJiYgcGggPiBiaCAmJiByMiA9PT0gbWF4Um93KSB7XG4gICAgICAgICAgICB2YXIgZGggPSB0aGlzLnBhZ2VIZWlnaHQgLSB0aGlzLmJvZHlIZWlnaHQ7XG4gICAgICAgICAgICByb3dTaXplc1tyb3dTaXplcy5sZW5ndGggLSAxXSArPSBkaDtcbiAgICAgICAgICAgIGhlaWdodCArPSBkaDtcbiAgICAgICAgICAgIHkyICs9IGRoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkanVzdCB0aGUgZ2VvbWV0cnkgaWYgdGhlIGxhc3QgY29sdW1uIGlzIHN0cmVjaGVkLlxuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RDb2x1bW4gJiYgcHcgPiBidyAmJiBjMiA9PT0gbWF4Q29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgZHcgPSB0aGlzLnBhZ2VXaWR0aCAtIHRoaXMuYm9keVdpZHRoO1xuICAgICAgICAgICAgY29sdW1uU2l6ZXNbY29sdW1uU2l6ZXMubGVuZ3RoIC0gMV0gKz0gZHc7XG4gICAgICAgICAgICB3aWR0aCArPSBkdztcbiAgICAgICAgICAgIHgyICs9IGR3O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcGFpbnQgcmVnaW9uIG9iamVjdC5cbiAgICAgICAgdmFyIHJnbiA9IHtcbiAgICAgICAgICAgIHJlZ2lvbjogJ2JvZHknLFxuICAgICAgICAgICAgeE1pbjogeDEsIHlNaW46IHkxLFxuICAgICAgICAgICAgeE1heDogeDIsIHlNYXg6IHkyLFxuICAgICAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHJvdzogcjEsIGNvbHVtbjogYzEsXG4gICAgICAgICAgICByb3dTaXplczogcm93U2l6ZXMsIGNvbHVtblNpemVzOiBjb2x1bW5TaXplc1xuICAgICAgICB9O1xuICAgICAgICAvLyBEcmF3IHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICB0aGlzLl9kcmF3QmFja2dyb3VuZChyZ24sIHRoaXMuX3N0eWxlLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIC8vIERyYXcgdGhlIHJvdyBiYWNrZ3JvdW5kLlxuICAgICAgICB0aGlzLl9kcmF3Um93QmFja2dyb3VuZChyZ24sIHRoaXMuX3N0eWxlLnJvd0JhY2tncm91bmRDb2xvcik7XG4gICAgICAgIC8vIERyYXcgdGhlIGNvbHVtbiBiYWNrZ3JvdW5kLlxuICAgICAgICB0aGlzLl9kcmF3Q29sdW1uQmFja2dyb3VuZChyZ24sIHRoaXMuX3N0eWxlLmNvbHVtbkJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIC8vIERyYXcgdGhlIGNlbGwgY29udGVudCBmb3IgdGhlIHBhaW50IHJlZ2lvbi5cbiAgICAgICAgdGhpcy5fZHJhd0NlbGxzKHJnbik7XG4gICAgICAgIC8vIERyYXcgdGhlIGhvcml6b250YWwgZ3JpZCBsaW5lcy5cbiAgICAgICAgdGhpcy5fZHJhd0hvcml6b250YWxHcmlkTGluZXMocmduLCB0aGlzLl9zdHlsZS5ob3Jpem9udGFsR3JpZExpbmVDb2xvciB8fFxuICAgICAgICAgICAgdGhpcy5fc3R5bGUuZ3JpZExpbmVDb2xvcik7XG4gICAgICAgIC8vIERyYXcgdGhlIHZlcnRpY2FsIGdyaWQgbGluZXMuXG4gICAgICAgIHRoaXMuX2RyYXdWZXJ0aWNhbEdyaWRMaW5lcyhyZ24sIHRoaXMuX3N0eWxlLnZlcnRpY2FsR3JpZExpbmVDb2xvciB8fFxuICAgICAgICAgICAgdGhpcy5fc3R5bGUuZ3JpZExpbmVDb2xvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSByb3cgaGVhZGVyIHJlZ2lvbiB3aGljaCBpbnRlcnNlY3RzIHRoZSBkaXJ0eSByZWN0LlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fZHJhd1Jvd0hlYWRlclJlZ2lvbiA9IGZ1bmN0aW9uIChyeCwgcnksIHJ3LCByaCkge1xuICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgY29udGVudCBkaW1lbnNpb25zLlxuICAgICAgICB2YXIgY29udGVudFcgPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICB2YXIgY29udGVudEggPSB0aGlzLmJvZHlIZWlnaHQgLSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQgdG8gZHJhdy5cbiAgICAgICAgaWYgKGNvbnRlbnRXIDw9IDAgfHwgY29udGVudEggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgdmlzaWJsZSBjb250ZW50IG9yaWdpbi5cbiAgICAgICAgdmFyIGNvbnRlbnRYID0gMDtcbiAgICAgICAgdmFyIGNvbnRlbnRZID0gdGhpcy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGRpcnR5IHJlY3QgZG9lcyBub3QgaW50ZXJzZWN0IHRoZSBjb250ZW50IGFyZWEuXG4gICAgICAgIGlmIChyeCArIHJ3IDw9IGNvbnRlbnRYKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ5ICsgcmggPD0gY29udGVudFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnggPj0gY29udGVudFggKyBjb250ZW50Vykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyeSA+PSBjb250ZW50WSArIGNvbnRlbnRIKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGdlb21ldHJ5LlxuICAgICAgICB2YXIgYmggPSB0aGlzLmJvZHlIZWlnaHQ7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgLy8gR2V0IHRoZSB1cHBlciBhbmQgbG93ZXIgYm91bmRzIG9mIHRoZSBkaXJ0eSBjb250ZW50IGFyZWEuXG4gICAgICAgIHZhciB4MSA9IHJ4O1xuICAgICAgICB2YXIgeTEgPSBNYXRoLm1heChyeSwgY29udGVudFkpO1xuICAgICAgICB2YXIgeDIgPSBNYXRoLm1pbihyeCArIHJ3IC0gMSwgY29udGVudFggKyBjb250ZW50VyAtIDEpO1xuICAgICAgICB2YXIgeTIgPSBNYXRoLm1pbihyeSArIHJoIC0gMSwgY29udGVudFkgKyBjb250ZW50SCAtIDEpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBkaXJ0eSBjb250ZW50IGJvdW5kcyBpbnRvIGNlbGwgYm91bmRzLlxuICAgICAgICB2YXIgcjEgPSB0aGlzLl9yb3dTZWN0aW9ucy5pbmRleE9mKHkxIC0gY29udGVudFkgKyB0aGlzLl9zY3JvbGxZKTtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMuaW5kZXhPZih4MSk7XG4gICAgICAgIHZhciByMiA9IHRoaXMuX3Jvd1NlY3Rpb25zLmluZGV4T2YoeTIgLSBjb250ZW50WSArIHRoaXMuX3Njcm9sbFkpO1xuICAgICAgICB2YXIgYzIgPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5pbmRleE9mKHgyKTtcbiAgICAgICAgLy8gRmV0Y2ggbWF4IHJvdyBhbmQgY29sdW1uLlxuICAgICAgICB2YXIgbWF4Um93ID0gdGhpcy5fcm93U2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICB2YXIgbWF4Q29sdW1uID0gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICAvLyBIYW5kbGUgYSBkaXJ0eSBjb250ZW50IGFyZWEgbGFyZ2VyIHRoYW4gdGhlIGNlbGwgY291bnQuXG4gICAgICAgIGlmIChyMiA8IDApIHtcbiAgICAgICAgICAgIHIyID0gbWF4Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjMiA8IDApIHtcbiAgICAgICAgICAgIGMyID0gbWF4Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGNlbGwgYm91bmRzIGJhY2sgdG8gdmlzaWJsZSBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIHggPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5vZmZzZXRPZihjMSk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5fcm93U2VjdGlvbnMub2Zmc2V0T2YocjEpICsgY29udGVudFkgLSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHBhaW50IHJlZ2lvbiBzaXplIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIC8vIEFsbG9jYXRlIHRoZSBzZWN0aW9uIHNpemVzIGFycmF5cy5cbiAgICAgICAgdmFyIHJvd1NpemVzID0gbmV3IEFycmF5KHIyIC0gcjEgKyAxKTtcbiAgICAgICAgdmFyIGNvbHVtblNpemVzID0gbmV3IEFycmF5KGMyIC0gYzEgKyAxKTtcbiAgICAgICAgLy8gR2V0IHRoZSByb3cgc2l6ZXMgZm9yIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIGogPSByMTsgaiA8PSByMjsgKytqKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3Jvd1NlY3Rpb25zLnNpemVPZihqKTtcbiAgICAgICAgICAgIHJvd1NpemVzW2ogLSByMV0gPSBzaXplO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBjb2x1bW4gc2l6ZXMgZm9yIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSBjMTsgaSA8PSBjMjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLnNpemVPZihpKTtcbiAgICAgICAgICAgIGNvbHVtblNpemVzW2kgLSBjMV0gPSBzaXplO1xuICAgICAgICAgICAgd2lkdGggKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIGdlb21ldHJ5IGlmIHRoZSBsYXN0IHJvdyBpcyBzdHJldGNoZWQuXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdFJvdyAmJiBwaCA+IGJoICYmIHIyID09PSBtYXhSb3cpIHtcbiAgICAgICAgICAgIHZhciBkaCA9IHRoaXMucGFnZUhlaWdodCAtIHRoaXMuYm9keUhlaWdodDtcbiAgICAgICAgICAgIHJvd1NpemVzW3Jvd1NpemVzLmxlbmd0aCAtIDFdICs9IGRoO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGRoO1xuICAgICAgICAgICAgeTIgKz0gZGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwYWludCByZWdpb24gb2JqZWN0LlxuICAgICAgICB2YXIgcmduID0ge1xuICAgICAgICAgICAgcmVnaW9uOiAncm93LWhlYWRlcicsXG4gICAgICAgICAgICB4TWluOiB4MSwgeU1pbjogeTEsXG4gICAgICAgICAgICB4TWF4OiB4MiwgeU1heDogeTIsXG4gICAgICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcm93OiByMSwgY29sdW1uOiBjMSxcbiAgICAgICAgICAgIHJvd1NpemVzOiByb3dTaXplcywgY29sdW1uU2l6ZXM6IGNvbHVtblNpemVzXG4gICAgICAgIH07XG4gICAgICAgIC8vIERyYXcgdGhlIGJhY2tncm91bmQuXG4gICAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKHJnbiwgdGhpcy5fc3R5bGUuaGVhZGVyQmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgY2VsbCBjb250ZW50IGZvciB0aGUgcGFpbnQgcmVnaW9uLlxuICAgICAgICB0aGlzLl9kcmF3Q2VsbHMocmduKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgaG9yaXpvbnRhbCBncmlkIGxpbmVzLlxuICAgICAgICB0aGlzLl9kcmF3SG9yaXpvbnRhbEdyaWRMaW5lcyhyZ24sIHRoaXMuX3N0eWxlLmhlYWRlckhvcml6b250YWxHcmlkTGluZUNvbG9yIHx8XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5oZWFkZXJHcmlkTGluZUNvbG9yKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgdmVydGljYWwgZ3JpZCBsaW5lcy5cbiAgICAgICAgdGhpcy5fZHJhd1ZlcnRpY2FsR3JpZExpbmVzKHJnbiwgdGhpcy5fc3R5bGUuaGVhZGVyVmVydGljYWxHcmlkTGluZUNvbG9yIHx8XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5oZWFkZXJHcmlkTGluZUNvbG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGNvbHVtbiBoZWFkZXIgcmVnaW9uIHdoaWNoIGludGVyc2VjdHMgdGhlIGRpcnR5IHJlY3QuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9kcmF3Q29sdW1uSGVhZGVyUmVnaW9uID0gZnVuY3Rpb24gKHJ4LCByeSwgcncsIHJoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgdmlzaWJsZSBjb250ZW50IGRpbWVuc2lvbnMuXG4gICAgICAgIHZhciBjb250ZW50VyA9IHRoaXMuYm9keVdpZHRoIC0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgdmFyIGNvbnRlbnRIID0gdGhpcy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gY29udGVudCB0byBkcmF3LlxuICAgICAgICBpZiAoY29udGVudFcgPD0gMCB8fCBjb250ZW50SCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIGNvbnRlbnQgb3JpZ2luLlxuICAgICAgICB2YXIgY29udGVudFggPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICB2YXIgY29udGVudFkgPSAwO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBkaXJ0eSByZWN0IGRvZXMgbm90IGludGVyc2VjdCB0aGUgY29udGVudCBhcmVhLlxuICAgICAgICBpZiAocnggKyBydyA8PSBjb250ZW50WCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyeSArIHJoIDw9IGNvbnRlbnRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ4ID49IGNvbnRlbnRYICsgY29udGVudFcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnkgPj0gY29udGVudFkgKyBjb250ZW50SCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBnZW9tZXRyeS5cbiAgICAgICAgdmFyIGJ3ID0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgIHZhciBwdyA9IHRoaXMucGFnZVdpZHRoO1xuICAgICAgICAvLyBHZXQgdGhlIHVwcGVyIGFuZCBsb3dlciBib3VuZHMgb2YgdGhlIGRpcnR5IGNvbnRlbnQgYXJlYS5cbiAgICAgICAgdmFyIHgxID0gTWF0aC5tYXgocngsIGNvbnRlbnRYKTtcbiAgICAgICAgdmFyIHkxID0gcnk7XG4gICAgICAgIHZhciB4MiA9IE1hdGgubWluKHJ4ICsgcncgLSAxLCBjb250ZW50WCArIGNvbnRlbnRXIC0gMSk7XG4gICAgICAgIHZhciB5MiA9IE1hdGgubWluKHJ5ICsgcmggLSAxLCBjb250ZW50WSArIGNvbnRlbnRIIC0gMSk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGRpcnR5IGNvbnRlbnQgYm91bmRzIGludG8gY2VsbCBib3VuZHMuXG4gICAgICAgIHZhciByMSA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLmluZGV4T2YoeTEpO1xuICAgICAgICB2YXIgYzEgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5pbmRleE9mKHgxIC0gY29udGVudFggKyB0aGlzLl9zY3JvbGxYKTtcbiAgICAgICAgdmFyIHIyID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuaW5kZXhPZih5Mik7XG4gICAgICAgIHZhciBjMiA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmluZGV4T2YoeDIgLSBjb250ZW50WCArIHRoaXMuX3Njcm9sbFgpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgbWF4IHJvdyBhbmQgY29sdW1uLlxuICAgICAgICB2YXIgbWF4Um93ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICB2YXIgbWF4Q29sdW1uID0gdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICAvLyBIYW5kbGUgYSBkaXJ0eSBjb250ZW50IGFyZWEgbGFyZ2VyIHRoYW4gdGhlIGNlbGwgY291bnQuXG4gICAgICAgIGlmIChyMiA8IDApIHtcbiAgICAgICAgICAgIHIyID0gbWF4Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjMiA8IDApIHtcbiAgICAgICAgICAgIGMyID0gbWF4Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGNlbGwgYm91bmRzIGJhY2sgdG8gdmlzaWJsZSBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIHggPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5vZmZzZXRPZihjMSkgKyBjb250ZW50WCAtIHRoaXMuX3Njcm9sbFg7XG4gICAgICAgIHZhciB5ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMub2Zmc2V0T2YocjEpO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHBhaW50IHJlZ2lvbiBzaXplIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIC8vIEFsbG9jYXRlIHRoZSBzZWN0aW9uIHNpemVzIGFycmF5cy5cbiAgICAgICAgdmFyIHJvd1NpemVzID0gbmV3IEFycmF5KHIyIC0gcjEgKyAxKTtcbiAgICAgICAgdmFyIGNvbHVtblNpemVzID0gbmV3IEFycmF5KGMyIC0gYzEgKyAxKTtcbiAgICAgICAgLy8gR2V0IHRoZSByb3cgc2l6ZXMgZm9yIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIGogPSByMTsgaiA8PSByMjsgKytqKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLnNpemVPZihqKTtcbiAgICAgICAgICAgIHJvd1NpemVzW2ogLSByMV0gPSBzaXplO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBjb2x1bW4gc2l6ZXMgZm9yIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSBjMTsgaSA8PSBjMjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLnNpemVPZihpKTtcbiAgICAgICAgICAgIGNvbHVtblNpemVzW2kgLSBjMV0gPSBzaXplO1xuICAgICAgICAgICAgd2lkdGggKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIGdlb21ldHJ5IGlmIHRoZSBsYXN0IGNvbHVtbiBpcyBzdHJldGNoZWQuXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdENvbHVtbiAmJiBwdyA+IGJ3ICYmIGMyID09PSBtYXhDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBkdyA9IHRoaXMucGFnZVdpZHRoIC0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgICAgICBjb2x1bW5TaXplc1tjb2x1bW5TaXplcy5sZW5ndGggLSAxXSArPSBkdztcbiAgICAgICAgICAgIHdpZHRoICs9IGR3O1xuICAgICAgICAgICAgeDIgKz0gZHc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwYWludCByZWdpb24gb2JqZWN0LlxuICAgICAgICB2YXIgcmduID0ge1xuICAgICAgICAgICAgcmVnaW9uOiAnY29sdW1uLWhlYWRlcicsXG4gICAgICAgICAgICB4TWluOiB4MSwgeU1pbjogeTEsXG4gICAgICAgICAgICB4TWF4OiB4MiwgeU1heDogeTIsXG4gICAgICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcm93OiByMSwgY29sdW1uOiBjMSxcbiAgICAgICAgICAgIHJvd1NpemVzOiByb3dTaXplcywgY29sdW1uU2l6ZXM6IGNvbHVtblNpemVzXG4gICAgICAgIH07XG4gICAgICAgIC8vIERyYXcgdGhlIGJhY2tncm91bmQuXG4gICAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKHJnbiwgdGhpcy5fc3R5bGUuaGVhZGVyQmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgY2VsbCBjb250ZW50IGZvciB0aGUgcGFpbnQgcmVnaW9uLlxuICAgICAgICB0aGlzLl9kcmF3Q2VsbHMocmduKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgaG9yaXpvbnRhbCBncmlkIGxpbmVzLlxuICAgICAgICB0aGlzLl9kcmF3SG9yaXpvbnRhbEdyaWRMaW5lcyhyZ24sIHRoaXMuX3N0eWxlLmhlYWRlckhvcml6b250YWxHcmlkTGluZUNvbG9yIHx8XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5oZWFkZXJHcmlkTGluZUNvbG9yKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgdmVydGljYWwgZ3JpZCBsaW5lcy5cbiAgICAgICAgdGhpcy5fZHJhd1ZlcnRpY2FsR3JpZExpbmVzKHJnbiwgdGhpcy5fc3R5bGUuaGVhZGVyVmVydGljYWxHcmlkTGluZUNvbG9yIHx8XG4gICAgICAgICAgICB0aGlzLl9zdHlsZS5oZWFkZXJHcmlkTGluZUNvbG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGNvcm5lciBoZWFkZXIgcmVnaW9uIHdoaWNoIGludGVyc2VjdHMgdGhlIGRpcnR5IHJlY3QuXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLmRyYXdDb3JuZXJIZWFkZXJSZWdpb24gPSBmdW5jdGlvbiAocngsIHJ5LCBydywgcmgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIGNvbnRlbnQgZGltZW5zaW9ucy5cbiAgICAgICAgdmFyIGNvbnRlbnRXID0gdGhpcy5oZWFkZXJXaWR0aDtcbiAgICAgICAgdmFyIGNvbnRlbnRIID0gdGhpcy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gY29udGVudCB0byBkcmF3LlxuICAgICAgICBpZiAoY29udGVudFcgPD0gMCB8fCBjb250ZW50SCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIGNvbnRlbnQgb3JpZ2luLlxuICAgICAgICB2YXIgY29udGVudFggPSAwO1xuICAgICAgICB2YXIgY29udGVudFkgPSAwO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBkaXJ0eSByZWN0IGRvZXMgbm90IGludGVyc2VjdCB0aGUgY29udGVudCBhcmVhLlxuICAgICAgICBpZiAocnggKyBydyA8PSBjb250ZW50WCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyeSArIHJoIDw9IGNvbnRlbnRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ4ID49IGNvbnRlbnRYICsgY29udGVudFcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnkgPj0gY29udGVudFkgKyBjb250ZW50SCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgdXBwZXIgYW5kIGxvd2VyIGJvdW5kcyBvZiB0aGUgZGlydHkgY29udGVudCBhcmVhLlxuICAgICAgICB2YXIgeDEgPSByeDtcbiAgICAgICAgdmFyIHkxID0gcnk7XG4gICAgICAgIHZhciB4MiA9IE1hdGgubWluKHJ4ICsgcncgLSAxLCBjb250ZW50WCArIGNvbnRlbnRXIC0gMSk7XG4gICAgICAgIHZhciB5MiA9IE1hdGgubWluKHJ5ICsgcmggLSAxLCBjb250ZW50WSArIGNvbnRlbnRIIC0gMSk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGRpcnR5IGNvbnRlbnQgYm91bmRzIGludG8gY2VsbCBib3VuZHMuXG4gICAgICAgIHZhciByMSA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLmluZGV4T2YoeTEpO1xuICAgICAgICB2YXIgYzEgPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5pbmRleE9mKHgxKTtcbiAgICAgICAgdmFyIHIyID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuaW5kZXhPZih5Mik7XG4gICAgICAgIHZhciBjMiA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLmluZGV4T2YoeDIpO1xuICAgICAgICAvLyBIYW5kbGUgYSBkaXJ0eSBjb250ZW50IGFyZWEgbGFyZ2VyIHRoYW4gdGhlIGNlbGwgY291bnQuXG4gICAgICAgIGlmIChyMiA8IDApIHtcbiAgICAgICAgICAgIHIyID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjMiA8IDApIHtcbiAgICAgICAgICAgIGMyID0gdGhpcy5fcm93SGVhZGVyU2VjdGlvbnMuY291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGNlbGwgYm91bmRzIGJhY2sgdG8gdmlzaWJsZSBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIHggPSB0aGlzLl9yb3dIZWFkZXJTZWN0aW9ucy5vZmZzZXRPZihjMSk7XG4gICAgICAgIHZhciB5ID0gdGhpcy5fY29sdW1uSGVhZGVyU2VjdGlvbnMub2Zmc2V0T2YocjEpO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHBhaW50IHJlZ2lvbiBzaXplIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIC8vIEFsbG9jYXRlIHRoZSBzZWN0aW9uIHNpemVzIGFycmF5cy5cbiAgICAgICAgdmFyIHJvd1NpemVzID0gbmV3IEFycmF5KHIyIC0gcjEgKyAxKTtcbiAgICAgICAgdmFyIGNvbHVtblNpemVzID0gbmV3IEFycmF5KGMyIC0gYzEgKyAxKTtcbiAgICAgICAgLy8gR2V0IHRoZSByb3cgc2l6ZXMgZm9yIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIGogPSByMTsgaiA8PSByMjsgKytqKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2NvbHVtbkhlYWRlclNlY3Rpb25zLnNpemVPZihqKTtcbiAgICAgICAgICAgIHJvd1NpemVzW2ogLSByMV0gPSBzaXplO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBjb2x1bW4gc2l6ZXMgZm9yIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSBjMTsgaSA8PSBjMjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3Jvd0hlYWRlclNlY3Rpb25zLnNpemVPZihpKTtcbiAgICAgICAgICAgIGNvbHVtblNpemVzW2kgLSBjMV0gPSBzaXplO1xuICAgICAgICAgICAgd2lkdGggKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBhaW50IHJlZ2lvbiBvYmplY3QuXG4gICAgICAgIHZhciByZ24gPSB7XG4gICAgICAgICAgICByZWdpb246ICdjb3JuZXItaGVhZGVyJyxcbiAgICAgICAgICAgIHhNaW46IHgxLCB5TWluOiB5MSxcbiAgICAgICAgICAgIHhNYXg6IHgyLCB5TWF4OiB5MixcbiAgICAgICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICByb3c6IHIxLCBjb2x1bW46IGMxLFxuICAgICAgICAgICAgcm93U2l6ZXM6IHJvd1NpemVzLCBjb2x1bW5TaXplczogY29sdW1uU2l6ZXNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRHJhdyB0aGUgYmFja2dyb3VuZC5cbiAgICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQocmduLCB0aGlzLl9zdHlsZS5oZWFkZXJCYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAvLyBEcmF3IHRoZSBjZWxsIGNvbnRlbnQgZm9yIHRoZSBwYWludCByZWdpb24uXG4gICAgICAgIHRoaXMuX2RyYXdDZWxscyhyZ24pO1xuICAgICAgICAvLyBEcmF3IHRoZSBob3Jpem9udGFsIGdyaWQgbGluZXMuXG4gICAgICAgIHRoaXMuX2RyYXdIb3Jpem9udGFsR3JpZExpbmVzKHJnbiwgdGhpcy5fc3R5bGUuaGVhZGVySG9yaXpvbnRhbEdyaWRMaW5lQ29sb3IgfHxcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlLmhlYWRlckdyaWRMaW5lQ29sb3IpO1xuICAgICAgICAvLyBEcmF3IHRoZSB2ZXJ0aWNhbCBncmlkIGxpbmVzLlxuICAgICAgICB0aGlzLl9kcmF3VmVydGljYWxHcmlkTGluZXMocmduLCB0aGlzLl9zdHlsZS5oZWFkZXJWZXJ0aWNhbEdyaWRMaW5lQ29sb3IgfHxcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlLmhlYWRlckdyaWRMaW5lQ29sb3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgYmFja2dyb3VuZCBmb3IgdGhlIGdpdmVuIHBhaW50IHJlZ2lvbi5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKHJnbiwgY29sb3IpIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBjb2xvciB0byBkcmF3LlxuICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5wYWNrIHRoZSByZWdpb24uXG4gICAgICAgIHZhciB4TWluID0gcmduLnhNaW4sIHlNaW4gPSByZ24ueU1pbiwgeE1heCA9IHJnbi54TWF4LCB5TWF4ID0gcmduLnlNYXg7XG4gICAgICAgIC8vIEZpbGwgdGhlIHJlZ2lvbiB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuXG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jYW52YXNHQy5maWxsUmVjdCh4TWluLCB5TWluLCB4TWF4IC0geE1pbiArIDEsIHlNYXggLSB5TWluICsgMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSByb3cgYmFja2dyb3VuZCBmb3IgdGhlIGdpdmVuIHBhaW50IHJlZ2lvbi5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdSb3dCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKHJnbiwgY29sb3JGbikge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGNvbG9yIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoIWNvbG9yRm4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBYIGJvdW5kcyBmb3IgdGhlIHJvdy5cbiAgICAgICAgdmFyIHgxID0gTWF0aC5tYXgocmduLnhNaW4sIHJnbi54KTtcbiAgICAgICAgdmFyIHgyID0gTWF0aC5taW4ocmduLnggKyByZ24ud2lkdGggLSAxLCByZ24ueE1heCk7XG4gICAgICAgIC8vIERyYXcgdGhlIGJhY2tncm91bmQgZm9yIHRoZSByb3dzIGluIHRoZSByZWdpb24uXG4gICAgICAgIGZvciAodmFyIHkgPSByZ24ueSwgaiA9IDAsIG4gPSByZ24ucm93U2l6ZXMubGVuZ3RoOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgc2l6ZSBvZiB0aGUgcm93LlxuICAgICAgICAgICAgdmFyIHNpemUgPSByZ24ucm93U2l6ZXNbal07XG4gICAgICAgICAgICAvLyBTa2lwIHplcm8gc2l6ZWQgcm93cy5cbiAgICAgICAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGJhY2tncm91bmQgY29sb3IgZm9yIHRoZSByb3cuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvckZuKHJnbi5yb3cgKyBqKTtcbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHJvdyB3aXRoIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IE1hdGgubWF4KHJnbi55TWluLCB5KTtcbiAgICAgICAgICAgICAgICB2YXIgeTIgPSBNYXRoLm1pbih5ICsgc2l6ZSAtIDEsIHJnbi55TWF4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXNHQy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXNHQy5maWxsUmVjdCh4MSwgeTEsIHgyIC0geDEgKyAxLCB5MiAtIHkxICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIHJ1bm5pbmcgWSBjb29yZGluYXRlLlxuICAgICAgICAgICAgeSArPSBzaXplO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSBjb2x1bW4gYmFja2dyb3VuZCBmb3IgdGhlIGdpdmVuIHBhaW50IHJlZ2lvbi5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdDb2x1bW5CYWNrZ3JvdW5kID0gZnVuY3Rpb24gKHJnbiwgY29sb3JGbikge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGNvbG9yIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoIWNvbG9yRm4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBZIGJvdW5kcyBmb3IgdGhlIGNvbHVtbi5cbiAgICAgICAgdmFyIHkxID0gTWF0aC5tYXgocmduLnlNaW4sIHJnbi55KTtcbiAgICAgICAgdmFyIHkyID0gTWF0aC5taW4ocmduLnkgKyByZ24uaGVpZ2h0IC0gMSwgcmduLnlNYXgpO1xuICAgICAgICAvLyBEcmF3IHRoZSBiYWNrZ3JvdW5kIGZvciB0aGUgY29sdW1ucyBpbiB0aGUgcmVnaW9uLlxuICAgICAgICBmb3IgKHZhciB4ID0gcmduLngsIGkgPSAwLCBuID0gcmduLmNvbHVtblNpemVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHNpemUgb2YgdGhlIGNvbHVtbi5cbiAgICAgICAgICAgIHZhciBzaXplID0gcmduLmNvbHVtblNpemVzW2ldO1xuICAgICAgICAgICAgLy8gU2tpcCB6ZXJvIHNpemVkIGNvbHVtbnMuXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgY29sdW1uLlxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JGbihyZ24uY29sdW1uICsgaSk7XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSBjb2x1bW4gd2l0aCB0aGUgYmFja2dyb3VuZCBjb2xvciBpZiBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLm1heChyZ24ueE1pbiwgeCk7XG4gICAgICAgICAgICAgICAgdmFyIHgyID0gTWF0aC5taW4oeCArIHNpemUgLSAxLCByZ24ueE1heCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzR0MuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzR0MuZmlsbFJlY3QoeDEsIHkxLCB4MiAtIHgxICsgMSwgeTIgLSB5MSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBydW5uaW5nIFggY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIHggKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgY2VsbHMgZm9yIHRoZSBnaXZlbiBwYWludCByZWdpb24uXG4gICAgICovXG4gICAgRGF0YUdyaWQucHJvdG90eXBlLl9kcmF3Q2VsbHMgPSBmdW5jdGlvbiAocmduKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gZGF0YSBtb2RlbC5cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdXAgdGhlIGNlbGwgY29uZmlnIG9iamVjdCBmb3IgcmVuZGVyaW5nLlxuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgICAgICAgIHJlZ2lvbjogcmduLnJlZ2lvbiwgcm93OiAwLCBjb2x1bW46IDAsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCwgbWV0YWRhdGE6IERhdGFNb2RlbC5lbXB0eU1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNhdmUgdGhlIGJ1ZmZlciBnYyBiZWZvcmUgd3JhcHBpbmcuXG4gICAgICAgIHRoaXMuX2J1ZmZlckdDLnNhdmUoKTtcbiAgICAgICAgLy8gV3JhcCB0aGUgYnVmZmVyIGdjIGZvciBwYWludGluZyB0aGUgY2VsbHMuXG4gICAgICAgIHZhciBnYyA9IG5ldyBHcmFwaGljc0NvbnRleHQodGhpcy5fYnVmZmVyR0MpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBhY3R1YWwgWSBib3VuZHMgZm9yIHRoZSBjZWxsIHJhbmdlLlxuICAgICAgICB2YXIgeTEgPSBNYXRoLm1heChyZ24ueU1pbiwgcmduLnkpO1xuICAgICAgICB2YXIgeTIgPSBNYXRoLm1pbihyZ24ueSArIHJnbi5oZWlnaHQgLSAxLCByZ24ueU1heCk7XG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgY29sdW1ucyBpbiB0aGUgcmVnaW9uLlxuICAgICAgICBmb3IgKHZhciB4ID0gcmduLngsIGkgPSAwLCBuID0gcmduLmNvbHVtblNpemVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHNpemUgb2YgdGhlIGNvbHVtbi5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJnbi5jb2x1bW5TaXplc1tpXTtcbiAgICAgICAgICAgIC8vIFNraXAgemVybyBzaXplZCBjb2x1bW5zLlxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICB2YXIgY29sdW1uID0gcmduLmNvbHVtbiArIGk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbmZpZyBmb3IgdGhlIGN1cnJlbnQgY29sdW1uLlxuICAgICAgICAgICAgY29uZmlnLnggPSB4O1xuICAgICAgICAgICAgY29uZmlnLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjb25maWcuY29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGJ1ZmZlciByZWN0IGZvciB0aGUgY29sdW1uLlxuICAgICAgICAgICAgZ2MuY2xlYXJSZWN0KHgsIHJnbi55LCB3aWR0aCwgcmduLmhlaWdodCk7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBHQyBzdGF0ZS5cbiAgICAgICAgICAgIGdjLnNhdmUoKTtcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciB0aGUgcm93cyBpbiB0aGUgY29sdW1uLlxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHJnbi55LCBqID0gMCwgbl8xID0gcmduLnJvd1NpemVzLmxlbmd0aDsgaiA8IG5fMTsgKytqKSB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHNpemUgb2YgdGhlIHJvdy5cbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmduLnJvd1NpemVzW2pdO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgemVybyBzaXplZCByb3dzLlxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gcmduLnJvdyArIGo7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmb3IgdGhlIGNlbGwuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZGF0YU1vZGVsLmRhdGEocmduLnJlZ2lvbiwgcm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbWV0YWRhdGEgZm9yIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRoaXMuX2RhdGFNb2RlbC5tZXRhZGF0YShyZ24ucmVnaW9uLCByb3csIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBEYXRhTW9kZWwuZW1wdHlNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbmZpZyBmb3IgdGhlIGN1cnJlbnQgY2VsbC5cbiAgICAgICAgICAgICAgICBjb25maWcueSA9IHk7XG4gICAgICAgICAgICAgICAgY29uZmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25maWcucm93ID0gcm93O1xuICAgICAgICAgICAgICAgIGNvbmZpZy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVuZGVyZXIgZm9yIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX2NlbGxSZW5kZXJlcnMuZ2V0KGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgR0Mgc3RhdGUuXG4gICAgICAgICAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICAgICAgICAgIC8vIFBhaW50IHRoZSBjZWxsIGludG8gdGhlIG9mZi1zY3JlZW4gYnVmZmVyLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnBhaW50KGdjLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgR0Mgc3RhdGUuXG4gICAgICAgICAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCB0aGUgcnVubmluZyBZIGNvb3JkaW5hdGUuXG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBHQyBzdGF0ZS5cbiAgICAgICAgICAgIGdjLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGFjdHVhbCBYIGJvdW5kcyBmb3IgdGhlIGNvbHVtbi5cbiAgICAgICAgICAgIHZhciB4MSA9IE1hdGgubWF4KHJnbi54TWluLCB4KTtcbiAgICAgICAgICAgIHZhciB4MiA9IE1hdGgubWluKHggKyB3aWR0aCAtIDEsIHJnbi54TWF4KTtcbiAgICAgICAgICAgIC8vIEJsaXQgdGhlIG9mZi1zY3JlZW4gYnVmZmVyIGNvbHVtbiBpbnRvIHRoZSBvbi1zY3JlZW4gY2FudmFzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgKm11Y2gqIGZhc3RlciB0aGFuIGRyYXdpbmcgZGlyZWN0bHkgaW50byB0aGUgb24tc2NyZWVuXG4gICAgICAgICAgICAvLyBjYW52YXMgd2l0aCBhIGNsaXAgcmVjdCBvbiB0aGUgY29sdW1uLiBNYW5hZ2VkIGNvbHVtbiBjbGlwcGluZ1xuICAgICAgICAgICAgLy8gaXMgcmVxdWlyZWQgdG8gcHJldmVudCBjZWxsIHJlbmRlcmVycyBmcm9tIG5lZWRpbmcgdG8gc2V0IHVwIGFcbiAgICAgICAgICAgIC8vIGNsaXAgcmVjdCBmb3IgaGFuZGxpbmcgaG9yaXpvbnRhbCBvdmVyZmxvdyB0ZXh0IChzbG93ISkuXG4gICAgICAgICAgICB0aGlzLl9ibGl0Q29udGVudCh0aGlzLl9idWZmZXIsIHgxLCB5MSwgeDIgLSB4MSArIDEsIHkyIC0geTEgKyAxLCB4MSwgeTEpO1xuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBydW5uaW5nIFggY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIHggKz0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgd3JhcHBlZCBnYy5cbiAgICAgICAgZ2MuZGlzcG9zZSgpO1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBmaW5hbCBidWZmZXIgZ2Mgc3RhdGUuXG4gICAgICAgIHRoaXMuX2J1ZmZlckdDLnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGhvcml6b250YWwgZ3JpZCBsaW5lcyBmb3IgdGhlIGdpdmVuIHBhaW50IHJlZ2lvbi5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdIb3Jpem9udGFsR3JpZExpbmVzID0gZnVuY3Rpb24gKHJnbiwgY29sb3IpIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBjb2xvciB0byBkcmF3LlxuICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgWCBib3VuZHMgZm9yIHRoZSBob3Jpem9udGFsIGxpbmVzLlxuICAgICAgICB2YXIgeDEgPSBNYXRoLm1heChyZ24ueE1pbiwgcmduLngpO1xuICAgICAgICB2YXIgeDIgPSBNYXRoLm1pbihyZ24ueCArIHJnbi53aWR0aCwgcmduLnhNYXggKyAxKTtcbiAgICAgICAgLy8gQmVnaW4gdGhlIHBhdGggZm9yIHRoZSBncmlkIGxpbmVzLlxuICAgICAgICB0aGlzLl9jYW52YXNHQy5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gU2V0IHRoZSBsaW5lIHdpZHRoIGZvciB0aGUgZ3JpZCBsaW5lcy5cbiAgICAgICAgdGhpcy5fY2FudmFzR0MubGluZVdpZHRoID0gMTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGdlb21ldHJ5LlxuICAgICAgICB2YXIgYmggPSB0aGlzLmJvZHlIZWlnaHQ7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG51bWJlciBvZiBncmlkIGxpbmVzIHRvIGJlIGRyYXduLlxuICAgICAgICB2YXIgbiA9IHJnbi5yb3dTaXplcy5sZW5ndGg7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgY291bnQgZG93biBpZiB0aGUgbGFzdCBsaW5lIHNob3VsZG4ndCBiZSBkcmF3bi5cbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Um93ICYmIHBoID4gYmgpIHtcbiAgICAgICAgICAgIGlmIChyZ24ucm93ICsgbiA9PT0gdGhpcy5fcm93U2VjdGlvbnMuY291bnQpIHtcbiAgICAgICAgICAgICAgICBuIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyB0aGUgaG9yaXpvbnRhbCBncmlkIGxpbmVzLlxuICAgICAgICBmb3IgKHZhciB5ID0gcmduLnksIGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgc2l6ZSBvZiB0aGUgcm93LlxuICAgICAgICAgICAgdmFyIHNpemUgPSByZ24ucm93U2l6ZXNbal07XG4gICAgICAgICAgICAvLyBTa2lwIHplcm8gc2l6ZWQgcm93cy5cbiAgICAgICAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBZIHBvc2l0aW9uIG9mIHRoZSBsaW5lLlxuICAgICAgICAgICAgdmFyIHBvcyA9IHkgKyBzaXplIC0gMTtcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGxpbmUgaWYgaXQncyBpbiByYW5nZSBvZiB0aGUgZGlydHkgcmVjdC5cbiAgICAgICAgICAgIGlmIChwb3MgPj0gcmduLnlNaW4gJiYgcG9zIDw9IHJnbi55TWF4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzR0MubW92ZVRvKHgxLCBwb3MgKyAwLjUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhc0dDLmxpbmVUbyh4MiwgcG9zICsgMC41KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluY3JlbWVudCB0aGUgcnVubmluZyBZIGNvb3JkaW5hdGUuXG4gICAgICAgICAgICB5ICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3Ryb2tlIHRoZSBsaW5lcyB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuXG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLnN0cm9rZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgdmVydGljYWwgZ3JpZCBsaW5lcyBmb3IgdGhlIGdpdmVuIHBhaW50IHJlZ2lvbi5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdWZXJ0aWNhbEdyaWRMaW5lcyA9IGZ1bmN0aW9uIChyZ24sIGNvbG9yKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gY29sb3IgdG8gZHJhdy5cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIFkgYm91bmRzIGZvciB0aGUgdmVydGljYWwgbGluZXMuXG4gICAgICAgIHZhciB5MSA9IE1hdGgubWF4KHJnbi55TWluLCByZ24ueSk7XG4gICAgICAgIHZhciB5MiA9IE1hdGgubWluKHJnbi55ICsgcmduLmhlaWdodCwgcmduLnlNYXggKyAxKTtcbiAgICAgICAgLy8gQmVnaW4gdGhlIHBhdGggZm9yIHRoZSBncmlkIGxpbmVzXG4gICAgICAgIHRoaXMuX2NhbnZhc0dDLmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyBTZXQgdGhlIGxpbmUgd2lkdGggZm9yIHRoZSBncmlkIGxpbmVzLlxuICAgICAgICB0aGlzLl9jYW52YXNHQy5saW5lV2lkdGggPSAxO1xuICAgICAgICAvLyBGZXRjaCB0aGUgZ2VvbWV0cnkuXG4gICAgICAgIHZhciBidyA9IHRoaXMuYm9keVdpZHRoO1xuICAgICAgICB2YXIgcHcgPSB0aGlzLnBhZ2VXaWR0aDtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG51bWJlciBvZiBncmlkIGxpbmVzIHRvIGJlIGRyYXduLlxuICAgICAgICB2YXIgbiA9IHJnbi5jb2x1bW5TaXplcy5sZW5ndGg7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgY291bnQgZG93biBpZiB0aGUgbGFzdCBsaW5lIHNob3VsZG4ndCBiZSBkcmF3bi5cbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Q29sdW1uICYmIHB3ID4gYncpIHtcbiAgICAgICAgICAgIGlmIChyZ24uY29sdW1uICsgbiA9PT0gdGhpcy5fY29sdW1uU2VjdGlvbnMuY291bnQpIHtcbiAgICAgICAgICAgICAgICBuIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyB0aGUgdmVydGljYWwgZ3JpZCBsaW5lcy5cbiAgICAgICAgZm9yICh2YXIgeCA9IHJnbi54LCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHNpemUgb2YgdGhlIGNvbHVtbi5cbiAgICAgICAgICAgIHZhciBzaXplID0gcmduLmNvbHVtblNpemVzW2ldO1xuICAgICAgICAgICAgLy8gU2tpcCB6ZXJvIHNpemVkIGNvbHVtbnMuXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgWCBwb3NpdGlvbiBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIHZhciBwb3MgPSB4ICsgc2l6ZSAtIDE7XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBsaW5lIGlmIGl0J3MgaW4gcmFuZ2Ugb2YgdGhlIGRpcnR5IHJlY3QuXG4gICAgICAgICAgICBpZiAocG9zID49IHJnbi54TWluICYmIHBvcyA8PSByZ24ueE1heCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhc0dDLm1vdmVUbyhwb3MgKyAwLjUsIHkxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXNHQy5saW5lVG8ocG9zICsgMC41LCB5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIHJ1bm5pbmcgWCBjb29yZGluYXRlLlxuICAgICAgICAgICAgeCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cm9rZSB0aGUgbGluZXMgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLlxuICAgICAgICB0aGlzLl9jYW52YXNHQy5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLl9jYW52YXNHQy5zdHJva2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGJvZHkgc2VsZWN0aW9ucyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdCb2R5U2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5fc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIHNlbGVjdGlvbnMuXG4gICAgICAgIGlmICghbW9kZWwgfHwgbW9kZWwuaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gY29sb3JzLlxuICAgICAgICB2YXIgZmlsbCA9IHRoaXMuX3N0eWxlLnNlbGVjdGlvbkZpbGxDb2xvcjtcbiAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuX3N0eWxlLnNlbGVjdGlvbkJvcmRlckNvbG9yO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZHJhdy5cbiAgICAgICAgaWYgKCFmaWxsICYmICFzdHJva2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgc2Nyb2xsIGdlb21ldHJ5LlxuICAgICAgICB2YXIgc3ggPSB0aGlzLl9zY3JvbGxYO1xuICAgICAgICB2YXIgc3kgPSB0aGlzLl9zY3JvbGxZO1xuICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IHZpc2libGUgY2VsbCBvZiB0aGUgZ3JpZC5cbiAgICAgICAgdmFyIHIxID0gdGhpcy5fcm93U2VjdGlvbnMuaW5kZXhPZihzeSk7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmluZGV4T2Yoc3gpO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGFyZSBubyB2aXNpYmxlIGNlbGxzLlxuICAgICAgICBpZiAocjEgPCAwIHx8IGMxIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBleHRyYSBnZW9tZXRyeS5cbiAgICAgICAgdmFyIGJ3ID0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgIHZhciBiaCA9IHRoaXMuYm9keUhlaWdodDtcbiAgICAgICAgdmFyIHB3ID0gdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgdmFyIGh3ID0gdGhpcy5oZWFkZXJXaWR0aDtcbiAgICAgICAgdmFyIGhoID0gdGhpcy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCB2aXNpYmxlIGNlbGwgb2YgdGhlIGdyaWQuXG4gICAgICAgIHZhciByMiA9IHRoaXMuX3Jvd1NlY3Rpb25zLmluZGV4T2Yoc3kgKyBwaCk7XG4gICAgICAgIHZhciBjMiA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLmluZGV4T2Yoc3ggKyBwdyk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBtYXggcm93IGFuZCBjb2x1bW4uXG4gICAgICAgIHZhciBtYXhSb3cgPSB0aGlzLl9yb3dTZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgIHZhciBtYXhDb2x1bW4gPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgIC8vIENsYW1wIHRoZSBsYXN0IGNlbGwgaWYgdGhlIHZvaWQgc3BhY2UgaXMgdmlzaWJsZS5cbiAgICAgICAgcjIgPSByMiA8IDAgPyBtYXhSb3cgOiByMjtcbiAgICAgICAgYzIgPSBjMiA8IDAgPyBtYXhDb2x1bW4gOiBjMjtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG92ZXJsYXkgZ2MuXG4gICAgICAgIHZhciBnYyA9IHRoaXMuX292ZXJsYXlHQztcbiAgICAgICAgLy8gU2F2ZSB0aGUgZ2Mgc3RhdGUuXG4gICAgICAgIGdjLnNhdmUoKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBib2R5IGNsaXBwaW5nIHJlY3QuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5yZWN0KGh3LCBoaCwgcHcsIHBoKTtcbiAgICAgICAgZ2MuY2xpcCgpO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGdjIHN0eWxlLlxuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBnYy5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgICAgICAgIGdjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBzZWxlY3Rpb25zLlxuICAgICAgICB2YXIgaXQgPSBtb2RlbC5zZWxlY3Rpb25zKCk7XG4gICAgICAgIHZhciBzO1xuICAgICAgICB3aGlsZSAoKHMgPSBpdC5uZXh0KCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIHNlY3Rpb24gaWYgaXQncyBub3QgdmlzaWJsZS5cbiAgICAgICAgICAgIGlmIChzLnIxIDwgcjEgJiYgcy5yMiA8IHIxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocy5yMSA+IHIyICYmIHMucjIgPiByMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMuYzEgPCBjMSAmJiBzLmMyIDwgYzEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzLmMxID4gYzIgJiYgcy5jMiA+IGMyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGFtcCB0aGUgY2VsbCB0byB0aGUgbW9kZWwgYm91bmRzLlxuICAgICAgICAgICAgdmFyIHNyMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHMucjEsIG1heFJvdykpO1xuICAgICAgICAgICAgdmFyIHNjMSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHMuYzEsIG1heENvbHVtbikpO1xuICAgICAgICAgICAgdmFyIHNyMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKHMucjIsIG1heFJvdykpO1xuICAgICAgICAgICAgdmFyIHNjMiA9IE1hdGgubWF4KDAsIE1hdGgubWluKHMuYzIsIG1heENvbHVtbikpO1xuICAgICAgICAgICAgLy8gU3dhcCBpbmRleCBvcmRlciBpZiBuZWVkZWQuXG4gICAgICAgICAgICB2YXIgdG1wID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHNyMSA+IHNyMikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHNyMTtcbiAgICAgICAgICAgICAgICBzcjEgPSBzcjI7XG4gICAgICAgICAgICAgICAgc3IyID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjMSA+IHNjMikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHNjMTtcbiAgICAgICAgICAgICAgICBzYzEgPSBzYzI7XG4gICAgICAgICAgICAgICAgc2MyID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB4MSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKHNjMSkgLSBzeCArIGh3O1xuICAgICAgICAgICAgdmFyIHkxID0gdGhpcy5fcm93U2VjdGlvbnMub2Zmc2V0T2Yoc3IxKSAtIHN5ICsgaGg7XG4gICAgICAgICAgICB2YXIgeDIgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5leHRlbnRPZihzYzIpIC0gc3ggKyBodztcbiAgICAgICAgICAgIHZhciB5MiA9IHRoaXMuX3Jvd1NlY3Rpb25zLmV4dGVudE9mKHNyMikgLSBzeSArIGhoO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSB0cmFpbGluZyBYIGNvb3JkaW5hdGUgZm9yIGNvbHVtbiBzdHJldGNoLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Q29sdW1uICYmIHB3ID4gYncgJiYgc2MyID09PSBtYXhDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB4MiA9IGh3ICsgcHcgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSB0cmFpbGluZyBZIGNvb3JkaW5hdGUgZm9yIHJvdyBzdHJldGNoLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Um93ICYmIHBoID4gYmggJiYgc3IyID09PSBtYXhSb3cpIHtcbiAgICAgICAgICAgICAgICB5MiA9IGhoICsgcGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIGJvdW5kcyB0byBqdXN0IG91dHNpZGUgb2YgdGhlIGNsaXBwaW5nIHJlY3QuXG4gICAgICAgICAgICB4MSA9IE1hdGgubWF4KGh3IC0gMSwgeDEpO1xuICAgICAgICAgICAgeTEgPSBNYXRoLm1heChoaCAtIDEsIHkxKTtcbiAgICAgICAgICAgIHgyID0gTWF0aC5taW4oaHcgKyBwdyArIDEsIHgyKTtcbiAgICAgICAgICAgIHkyID0gTWF0aC5taW4oaGggKyBwaCArIDEsIHkyKTtcbiAgICAgICAgICAgIC8vIFNraXAgemVybyBzaXplZCByYW5nZXMuXG4gICAgICAgICAgICBpZiAoeDIgPCB4MSB8fCB5MiA8IHkxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSByZWN0IGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeDEsIHkxLCB4MiAtIHgxICsgMSwgeTIgLSB5MSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3Ryb2tlIHRoZSByZWN0IGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgICAgICBnYy5zdHJva2VSZWN0KHgxIC0gLjUsIHkxIC0gLjUsIHgyIC0geDEgKyAxLCB5MiAtIHkxICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgZ2Mgc3RhdGUuXG4gICAgICAgIGdjLnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIHJvdyBoZWFkZXIgc2VsZWN0aW9ucyBmb3IgdGhlIGRhdGEgZ3JpZC5cbiAgICAgKi9cbiAgICBEYXRhR3JpZC5wcm90b3R5cGUuX2RyYXdSb3dIZWFkZXJTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gc2VsZWN0aW9ucyBvciBpZiB0aGUgc2VsZWN0aW9uTW9kZSBpcyB0aGUgZW50aXJlIGNvbHVtbi5cbiAgICAgICAgaWYgKCFtb2RlbCB8fCBtb2RlbC5pc0VtcHR5IHx8IG1vZGVsLnNlbGVjdGlvbk1vZGUgPT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSByb3cgaGVhZGVycyBhcmUgbm90IHZpc2libGUuXG4gICAgICAgIGlmICh0aGlzLmhlYWRlcldpZHRoID09PSAwIHx8IHRoaXMucGFnZUhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gY29sb3JzLlxuICAgICAgICB2YXIgZmlsbCA9IHRoaXMuX3N0eWxlLmhlYWRlclNlbGVjdGlvbkZpbGxDb2xvcjtcbiAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuX3N0eWxlLmhlYWRlclNlbGVjdGlvbkJvcmRlckNvbG9yO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZHJhdy5cbiAgICAgICAgaWYgKCFmaWxsICYmICFzdHJva2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBjb21tb24gZ2VvbWV0cnkuXG4gICAgICAgIHZhciBzeSA9IHRoaXMuX3Njcm9sbFk7XG4gICAgICAgIHZhciBiaCA9IHRoaXMuYm9keUhlaWdodDtcbiAgICAgICAgdmFyIHBoID0gdGhpcy5wYWdlSGVpZ2h0O1xuICAgICAgICB2YXIgaHcgPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICB2YXIgaGggPSB0aGlzLmhlYWRlckhlaWdodDtcbiAgICAgICAgdmFyIHJzID0gdGhpcy5fcm93U2VjdGlvbnM7XG4gICAgICAgIC8vIEZldGNoIHRoZSBvdmVybGF5IGdjLlxuICAgICAgICB2YXIgZ2MgPSB0aGlzLl9vdmVybGF5R0M7XG4gICAgICAgIC8vIFNhdmUgdGhlIGdjIHN0YXRlLlxuICAgICAgICBnYy5zYXZlKCk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgaGVhZGVyIGNsaXBwaW5nIHJlY3QuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5yZWN0KDAsIGhoLCBodywgcGgpO1xuICAgICAgICBnYy5jbGlwKCk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZ2Mgc3R5bGUuXG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGdjLnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgICAgICAgZ2MubGluZVdpZHRoID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgbWF4IHJvdy5cbiAgICAgICAgdmFyIG1heFJvdyA9IHJzLmNvdW50IC0gMTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHZpc2libGUgcm93cy5cbiAgICAgICAgdmFyIHIxID0gcnMuaW5kZXhPZihzeSk7XG4gICAgICAgIHZhciByMiA9IHJzLmluZGV4T2Yoc3kgKyBwaCAtIDEpO1xuICAgICAgICByMiA9IHIyIDwgMCA/IG1heFJvdyA6IHIyO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHZpc2libGUgcm93cy5cbiAgICAgICAgZm9yICh2YXIgaiA9IHIxOyBqIDw9IHIyOyArK2opIHtcbiAgICAgICAgICAgIC8vIFNraXAgcm93cyB3aGljaCBhcmVuJ3Qgc2VsZWN0ZWQuXG4gICAgICAgICAgICBpZiAoIW1vZGVsLmlzUm93U2VsZWN0ZWQoaikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcm93LlxuICAgICAgICAgICAgdmFyIHkgPSBycy5vZmZzZXRPZihqKSAtIHN5ICsgaGg7XG4gICAgICAgICAgICB2YXIgaCA9IHJzLnNpemVPZihqKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgaGVpZ2h0IGZvciByb3cgc3RyZXRjaC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdFJvdyAmJiBwaCA+IGJoICYmIGogPT09IG1heFJvdykge1xuICAgICAgICAgICAgICAgIGggPSBoaCArIHBoIC0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgemVybyBzaXplZCByb3dzLlxuICAgICAgICAgICAgaWYgKGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHJlY3QgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICBnYy5maWxsUmVjdCgwLCB5LCBodywgaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBib3JkZXIgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGdjLm1vdmVUbyhodyAtIC41LCB5IC0gMSk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKGh3IC0gLjUsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0b3JlIHRoZSBnYyBzdGF0ZS5cbiAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgY29sdW1uIGhlYWRlciBzZWxlY3Rpb25zIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fZHJhd0NvbHVtbkhlYWRlclNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZldGNoIHRoZSBzZWxlY3Rpb24gbW9kZWwuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBzZWxlY3Rpb25zIG9yIGlmIHRoZSBzZWxlY3Rpb25Nb2RlIGlzIHRoZSBlbnRpcmUgcm93XG4gICAgICAgIGlmICghbW9kZWwgfHwgbW9kZWwuaXNFbXB0eSB8fCBtb2RlbC5zZWxlY3Rpb25Nb2RlID09ICdyb3cnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgY29sdW1uIGhlYWRlcnMgYXJlIG5vdCB2aXNpYmxlLlxuICAgICAgICBpZiAodGhpcy5oZWFkZXJIZWlnaHQgPT09IDAgfHwgdGhpcy5wYWdlV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgc2VsZWN0aW9uIGNvbG9ycy5cbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLl9zdHlsZS5oZWFkZXJTZWxlY3Rpb25GaWxsQ29sb3I7XG4gICAgICAgIHZhciBzdHJva2UgPSB0aGlzLl9zdHlsZS5oZWFkZXJTZWxlY3Rpb25Cb3JkZXJDb2xvcjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXcuXG4gICAgICAgIGlmICghZmlsbCAmJiAhc3Ryb2tlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggY29tbW9uIGdlb21ldHJ5LlxuICAgICAgICB2YXIgc3ggPSB0aGlzLl9zY3JvbGxYO1xuICAgICAgICB2YXIgYncgPSB0aGlzLmJvZHlXaWR0aDtcbiAgICAgICAgdmFyIHB3ID0gdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgIHZhciBodyA9IHRoaXMuaGVhZGVyV2lkdGg7XG4gICAgICAgIHZhciBoaCA9IHRoaXMuaGVhZGVySGVpZ2h0O1xuICAgICAgICB2YXIgY3MgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucztcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG92ZXJsYXkgZ2MuXG4gICAgICAgIHZhciBnYyA9IHRoaXMuX292ZXJsYXlHQztcbiAgICAgICAgLy8gU2F2ZSB0aGUgZ2Mgc3RhdGUuXG4gICAgICAgIGdjLnNhdmUoKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBoZWFkZXIgY2xpcHBpbmcgcmVjdC5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLnJlY3QoaHcsIDAsIHB3LCBoaCk7XG4gICAgICAgIGdjLmNsaXAoKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBnYyBzdHlsZS5cbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICAgICAgICBnYy5saW5lV2lkdGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBtYXggY29sdW1uLlxuICAgICAgICB2YXIgbWF4Q29sID0gY3MuY291bnQgLSAxO1xuICAgICAgICAvLyBGZXRjaCB0aGUgdmlzaWJsZSBjb2x1bW5zLlxuICAgICAgICB2YXIgYzEgPSBjcy5pbmRleE9mKHN4KTtcbiAgICAgICAgdmFyIGMyID0gY3MuaW5kZXhPZihzeCArIHB3IC0gMSk7XG4gICAgICAgIGMyID0gYzIgPCAwID8gbWF4Q29sIDogYzI7XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdmlzaWJsZSBjb2x1bW5zLlxuICAgICAgICBmb3IgKHZhciBpID0gYzE7IGkgPD0gYzI7ICsraSkge1xuICAgICAgICAgICAgLy8gU2tpcCBjb2x1bW5zIHdoaWNoIGFyZW4ndCBzZWxlY3RlZC5cbiAgICAgICAgICAgIGlmICghbW9kZWwuaXNDb2x1bW5TZWxlY3RlZChpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb2x1bW4uXG4gICAgICAgICAgICB2YXIgeCA9IGNzLm9mZnNldE9mKGkpIC0gc3ggKyBodztcbiAgICAgICAgICAgIHZhciB3ID0gY3Muc2l6ZU9mKGkpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSB3aWR0aCBmb3IgY29sdW1uIHN0cmV0Y2guXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RyZXRjaExhc3RDb2x1bW4gJiYgcHcgPiBidyAmJiBpID09PSBtYXhDb2wpIHtcbiAgICAgICAgICAgICAgICB3ID0gaHcgKyBwdyAtIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTa2lwIHplcm8gc2l6ZWQgY29sdW1ucy5cbiAgICAgICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSByZWN0IGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgMCwgdywgaGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgYm9yZGVyIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oeCAtIDEsIGhoIC0gLjUpO1xuICAgICAgICAgICAgICAgIGdjLmxpbmVUbyh4ICsgdywgaGggLSAuNSk7XG4gICAgICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgZ2Mgc3RhdGUuXG4gICAgICAgIGdjLnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIG92ZXJsYXkgY3Vyc29yIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fZHJhd0N1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5fc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gY3Vyc29yLlxuICAgICAgICBpZiAoIW1vZGVsIHx8IG1vZGVsLmlzRW1wdHkgfHwgbW9kZWwuc2VsZWN0aW9uTW9kZSAhPT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgc3R5bGUgaW5mb3JtYXRpb24uXG4gICAgICAgIHZhciBmaWxsID0gdGhpcy5fc3R5bGUuY3Vyc29yRmlsbENvbG9yO1xuICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5fc3R5bGUuY3Vyc29yQm9yZGVyQ29sb3I7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm90aGluZyB0byBkcmF3LlxuICAgICAgICBpZiAoIWZpbGwgJiYgIXN0cm9rZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBjdXJzb3IgbG9jYXRpb24uXG4gICAgICAgIHZhciByb3cgPSBtb2RlbC5jdXJzb3JSb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSBtb2RlbC5jdXJzb3JDb2x1bW47XG4gICAgICAgIC8vIEZldGNoIHRoZSBtYXggcm93IGFuZCBjb2x1bW4uXG4gICAgICAgIHZhciBtYXhSb3cgPSB0aGlzLl9yb3dTZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgIHZhciBtYXhDb2x1bW4gPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5jb3VudCAtIDE7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGN1cnNvciBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAgICBpZiAocm93IDwgMCB8fCByb3cgPiBtYXhSb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uIDwgMCB8fCBjb2x1bW4gPiBtYXhDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBnZW9tZXRyeS5cbiAgICAgICAgdmFyIHN4ID0gdGhpcy5fc2Nyb2xsWDtcbiAgICAgICAgdmFyIHN5ID0gdGhpcy5fc2Nyb2xsWTtcbiAgICAgICAgdmFyIGJ3ID0gdGhpcy5ib2R5V2lkdGg7XG4gICAgICAgIHZhciBiaCA9IHRoaXMuYm9keUhlaWdodDtcbiAgICAgICAgdmFyIHB3ID0gdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgdmFyIGh3ID0gdGhpcy5oZWFkZXJXaWR0aDtcbiAgICAgICAgdmFyIGhoID0gdGhpcy5oZWFkZXJIZWlnaHQ7XG4gICAgICAgIHZhciB2dyA9IHRoaXMuX3ZpZXdwb3J0V2lkdGg7XG4gICAgICAgIHZhciB2aCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAvLyBHZXQgdGhlIGN1cnNvciBib3VuZHMgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgICAgIHZhciB4MSA9IHRoaXMuX2NvbHVtblNlY3Rpb25zLm9mZnNldE9mKGNvbHVtbikgLSBzeCArIGh3O1xuICAgICAgICB2YXIgeDIgPSB0aGlzLl9jb2x1bW5TZWN0aW9ucy5leHRlbnRPZihjb2x1bW4pIC0gc3ggKyBodztcbiAgICAgICAgdmFyIHkxID0gdGhpcy5fcm93U2VjdGlvbnMub2Zmc2V0T2Yocm93KSAtIHN5ICsgaGg7XG4gICAgICAgIHZhciB5MiA9IHRoaXMuX3Jvd1NlY3Rpb25zLmV4dGVudE9mKHJvdykgLSBzeSArIGhoO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIHRyYWlsaW5nIFggY29vcmRpbmF0ZSBmb3IgY29sdW1uIHN0cmV0Y2guXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdENvbHVtbiAmJiBwdyA+IGJ3ICYmIGNvbHVtbiA9PT0gbWF4Q29sdW1uKSB7XG4gICAgICAgICAgICB4MiA9IHZ3IC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIHRyYWlsaW5nIFkgY29vcmRpbmF0ZSBmb3Igcm93IHN0cmV0Y2guXG4gICAgICAgIGlmICh0aGlzLl9zdHJldGNoTGFzdFJvdyAmJiBwaCA+IGJoICYmIHJvdyA9PT0gbWF4Um93KSB7XG4gICAgICAgICAgICB5MiA9IHZoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIHplcm8gc2l6ZWQgY3Vyc29ycy5cbiAgICAgICAgaWYgKHgyIDwgeDEgfHwgeTIgPCB5MSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGN1cnNvciBpcyBvZmYgdGhlIHNjcmVlbi5cbiAgICAgICAgaWYgKCh4MSAtIDEpID49IHZ3IHx8ICh5MSAtIDEpID49IHZoIHx8ICh4MiArIDEpIDwgaHcgfHwgKHkyICsgMSkgPCBoaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBvdmVybGF5IGdjLlxuICAgICAgICB2YXIgZ2MgPSB0aGlzLl9vdmVybGF5R0M7XG4gICAgICAgIC8vIFNhdmUgdGhlIGdjIHN0YXRlLlxuICAgICAgICBnYy5zYXZlKCk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgYm9keSBjbGlwcGluZyByZWN0LlxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MucmVjdChodywgaGgsIHB3LCBwaCk7XG4gICAgICAgIGdjLmNsaXAoKTtcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIG92ZXJsYXkgY29udGVudC5cbiAgICAgICAgZ2MuY2xlYXJSZWN0KHgxLCB5MSwgeDIgLSB4MSArIDEsIHkyIC0geTEgKyAxKTtcbiAgICAgICAgLy8gRmlsbCB0aGUgY3Vyc29yIHJlY3QgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBmaWxsIHN0eWxlLlxuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIGN1cnNvciByZWN0LlxuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeDEsIHkxLCB4MiAtIHgxICsgMSwgeTIgLSB5MSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cm9rZSB0aGUgY3Vyc29yIGJvcmRlciBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgc3Ryb2tlIHN0eWxlLlxuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICAgICAgICBnYy5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgLy8gU3Ryb2tlIHRoZSBjdXJzb3IgcmVjdC5cbiAgICAgICAgICAgIGdjLnN0cm9rZVJlY3QoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0b3JlIHRoZSBnYyBzdGF0ZS5cbiAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgb3ZlcmxheSBzaGFkb3dzIGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLnByb3RvdHlwZS5fZHJhd1NoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZldGNoIHRoZSBzY3JvbGwgc2hhZG93IGZyb20gdGhlIHN0eWxlLlxuICAgICAgICB2YXIgc2hhZG93ID0gdGhpcy5fc3R5bGUuc2Nyb2xsU2hhZG93O1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIHNoYWRvdyB0byBkcmF3LlxuICAgICAgICBpZiAoIXNoYWRvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgIHZhciBzeCA9IHRoaXMuX3Njcm9sbFg7XG4gICAgICAgIHZhciBzeSA9IHRoaXMuX3Njcm9sbFk7XG4gICAgICAgIC8vIEZldGNoIG1heGltdW0gc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICB2YXIgc3hNYXggPSB0aGlzLm1heFNjcm9sbFg7XG4gICAgICAgIHZhciBzeU1heCA9IHRoaXMubWF4U2Nyb2xsWTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGhlYWRlciB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICB2YXIgaHcgPSB0aGlzLmhlYWRlcldpZHRoO1xuICAgICAgICB2YXIgaGggPSB0aGlzLmhlYWRlckhlaWdodDtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHBhZ2Ugd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgdmFyIHB3ID0gdGhpcy5wYWdlV2lkdGg7XG4gICAgICAgIHZhciBwaCA9IHRoaXMucGFnZUhlaWdodDtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHZpZXdwb3J0IHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgIHZhciB2dyA9IHRoaXMuX3ZpZXdwb3J0V2lkdGg7XG4gICAgICAgIHZhciB2aCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAvLyBGZXRjaCB0aGUgYm9keSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICB2YXIgYncgPSB0aGlzLmJvZHlXaWR0aDtcbiAgICAgICAgdmFyIGJoID0gdGhpcy5ib2R5SGVpZ2h0O1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGJvZHkgc2l6ZSBmb3Igcm93IGFuZCBjb2x1bW4gc3RyZXRjaC5cbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Um93ICYmIHBoID4gYmgpIHtcbiAgICAgICAgICAgIGJoID0gcGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hMYXN0Q29sdW1uICYmIHB3ID4gYncpIHtcbiAgICAgICAgICAgIGJ3ID0gcHc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIGdjIG9iamVjdC5cbiAgICAgICAgdmFyIGdjID0gdGhpcy5fb3ZlcmxheUdDO1xuICAgICAgICAvLyBTYXZlIHRoZSBnYyBzdGF0ZS5cbiAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICAvLyBEcmF3IHRoZSBjb2x1bW4gaGVhZGVyIHNoYWRvdyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChzeSA+IDApIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgZ3JhZGllbnQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICAgICAgdmFyIHkwID0gaGg7XG4gICAgICAgICAgICB2YXIgeDEgPSAwO1xuICAgICAgICAgICAgdmFyIHkxID0geTAgKyBzaGFkb3cuc2l6ZTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZ3JhZGllbnQgb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGdyYWQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MCwgeTAsIHgxLCB5MSk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGdyYWRpZW50IHN0b3BzLlxuICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoMCwgc2hhZG93LmNvbG9yMSk7XG4gICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgwLjUsIHNoYWRvdy5jb2xvcjIpO1xuICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoMSwgc2hhZG93LmNvbG9yMyk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIHJlY3QgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICB2YXIgeSA9IGhoO1xuICAgICAgICAgICAgdmFyIHcgPSBodyArIE1hdGgubWluKHB3LCBidyAtIHN4KTtcbiAgICAgICAgICAgIHZhciBoID0gc2hhZG93LnNpemU7XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSBzaGFkb3cgcmVjdCB3aXRoIHRoZSBmaWxsIHN0eWxlLlxuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gZ3JhZDtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERyYXcgdGhlIHJvdyBoZWFkZXIgc2hhZG93IGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKHN4ID4gMCkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBncmFkaWVudCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB4MCA9IGh3O1xuICAgICAgICAgICAgdmFyIHkwID0gMDtcbiAgICAgICAgICAgIHZhciB4MSA9IHgwICsgc2hhZG93LnNpemU7XG4gICAgICAgICAgICB2YXIgeTEgPSAwO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBncmFkaWVudCBvYmplY3QuXG4gICAgICAgICAgICB2YXIgZ3JhZCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZ3JhZGllbnQgc3RvcHMuXG4gICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgwLCBzaGFkb3cuY29sb3IxKTtcbiAgICAgICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDAuNSwgc2hhZG93LmNvbG9yMik7XG4gICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxLCBzaGFkb3cuY29sb3IzKTtcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgcmVjdCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB4ID0gaHc7XG4gICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICB2YXIgdyA9IHNoYWRvdy5zaXplO1xuICAgICAgICAgICAgdmFyIGggPSBoaCArIE1hdGgubWluKHBoLCBiaCAtIHN5KTtcbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHNoYWRvdyByZWN0IHdpdGggdGhlIGZpbGwgc3R5bGUuXG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBncmFkO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyB0aGUgY29sdW1uIGZvb3RlciBzaGFkb3cgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoc3kgPCBzeU1heCkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBncmFkaWVudCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB4MCA9IDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB2aDtcbiAgICAgICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgICAgICB2YXIgeTEgPSB2aCAtIHNoYWRvdy5zaXplO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBncmFkaWVudCBvYmplY3QuXG4gICAgICAgICAgICB2YXIgZ3JhZCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZ3JhZGllbnQgc3RvcHMuXG4gICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgwLCBzaGFkb3cuY29sb3IxKTtcbiAgICAgICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDAuNSwgc2hhZG93LmNvbG9yMik7XG4gICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxLCBzaGFkb3cuY29sb3IzKTtcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgcmVjdCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgIHZhciB5ID0gdmggLSBzaGFkb3cuc2l6ZTtcbiAgICAgICAgICAgIHZhciB3ID0gaHcgKyBNYXRoLm1pbihwdywgYncgLSBzeCk7XG4gICAgICAgICAgICB2YXIgaCA9IHNoYWRvdy5zaXplO1xuICAgICAgICAgICAgLy8gRmlsbCB0aGUgc2hhZG93IHJlY3Qgd2l0aCB0aGUgZmlsbCBzdHlsZS5cbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IGdyYWQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEcmF3IHRoZSByb3cgZm9vdGVyIHNoYWRvdyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChzeCA8IHN4TWF4KSB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIGdyYWRpZW50IGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgdmFyIHgwID0gdnc7XG4gICAgICAgICAgICB2YXIgeTAgPSAwO1xuICAgICAgICAgICAgdmFyIHgxID0gdncgLSBzaGFkb3cuc2l6ZTtcbiAgICAgICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGdyYWRpZW50IG9iamVjdC5cbiAgICAgICAgICAgIHZhciBncmFkID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBncmFkaWVudCBzdG9wcy5cbiAgICAgICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDAsIHNoYWRvdy5jb2xvcjEpO1xuICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoMC41LCBzaGFkb3cuY29sb3IyKTtcbiAgICAgICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDEsIHNoYWRvdy5jb2xvcjMpO1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSByZWN0IGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgdmFyIHggPSB2dyAtIHNoYWRvdy5zaXplO1xuICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgdmFyIHcgPSBzaGFkb3cuc2l6ZTtcbiAgICAgICAgICAgIHZhciBoID0gaGggKyBNYXRoLm1pbihwaCwgYmggLSBzeSk7XG4gICAgICAgICAgICAvLyBGaWxsIHRoZSBzaGFkb3cgcmVjdCB3aXRoIHRoZSBmaWxsIHN0eWxlLlxuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gZ3JhZDtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIGdjIHN0YXRlLlxuICAgICAgICBnYy5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YUdyaWQ7XG59KFdpZGdldCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYERhdGFHcmlkYCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKERhdGFHcmlkKSB7XG4gICAgLyoqXG4gICAgICogQSBnZW5lcmljIGZvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIGNvcHkgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGZvcm1hdCBhcmdzIGZvciB0aGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYFN0cmluZygpYCB0byBjb2VyY2UgYSB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5Rm9ybWF0R2VuZXJpYyhhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLnZhbHVlID09PSBudWxsIHx8IGFyZ3MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcoYXJncy52YWx1ZSk7XG4gICAgfVxuICAgIERhdGFHcmlkLmNvcHlGb3JtYXRHZW5lcmljID0gY29weUZvcm1hdEdlbmVyaWM7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdGhlbWUgZm9yIGEgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLmRlZmF1bHRTdHlsZSA9IHtcbiAgICAgICAgdm9pZENvbG9yOiAnI0YzRjNGMycsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNGRkZGRkYnLFxuICAgICAgICBncmlkTGluZUNvbG9yOiAncmdiYSgyMCwgMjAsIDIwLCAwLjE1KScsXG4gICAgICAgIGhlYWRlckJhY2tncm91bmRDb2xvcjogJyNGM0YzRjMnLFxuICAgICAgICBoZWFkZXJHcmlkTGluZUNvbG9yOiAncmdiYSgyMCwgMjAsIDIwLCAwLjI1KScsXG4gICAgICAgIHNlbGVjdGlvbkZpbGxDb2xvcjogJ3JnYmEoNDksIDExOSwgMjI5LCAwLjIpJyxcbiAgICAgICAgc2VsZWN0aW9uQm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDEwNywgMjQ3LCAxLjApJyxcbiAgICAgICAgY3Vyc29yQm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDEwNywgMjQ3LCAxLjApJyxcbiAgICAgICAgaGVhZGVyU2VsZWN0aW9uRmlsbENvbG9yOiAncmdiYSgyMCwgMjAsIDIwLCAwLjEpJyxcbiAgICAgICAgaGVhZGVyU2VsZWN0aW9uQm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDEwNywgMjQ3LCAxLjApJyxcbiAgICAgICAgc2Nyb2xsU2hhZG93OiB7XG4gICAgICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgICAgIGNvbG9yMTogJ3JnYmEoMCwgMCwgMCwgMC4yMCknLFxuICAgICAgICAgICAgY29sb3IyOiAncmdiYSgwLCAwLCAwLCAwLjA1KScsXG4gICAgICAgICAgICBjb2xvcjM6ICdyZ2JhKDAsIDAsIDAsIDAuMDApJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzaXplcyBmb3IgYSBkYXRhIGdyaWQuXG4gICAgICovXG4gICAgRGF0YUdyaWQuZGVmYXVsdFNpemVzID0ge1xuICAgICAgICByb3dIZWlnaHQ6IDIwLFxuICAgICAgICBjb2x1bW5XaWR0aDogNjQsXG4gICAgICAgIHJvd0hlYWRlcldpZHRoOiA2NCxcbiAgICAgICAgY29sdW1uSGVhZGVySGVpZ2h0OiAyMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbWluaW11bSBzaXplcyBmb3IgYSBkYXRhIGdyaWQuXG4gICAgICovXG4gICAgRGF0YUdyaWQubWluaW11bVNpemVzID0ge1xuICAgICAgICByb3dIZWlnaHQ6IDIwLFxuICAgICAgICBjb2x1bW5XaWR0aDogMTAsXG4gICAgICAgIHJvd0hlYWRlcldpZHRoOiAxMCxcbiAgICAgICAgY29sdW1uSGVhZGVySGVpZ2h0OiAyMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29weSBjb25maWcgZm9yIGEgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIERhdGFHcmlkLmRlZmF1bHRDb3B5Q29uZmlnID0ge1xuICAgICAgICBzZXBhcmF0b3I6ICdcXHQnLFxuICAgICAgICBmb3JtYXQ6IGNvcHlGb3JtYXRHZW5lcmljLFxuICAgICAgICBoZWFkZXJzOiAnbm9uZScsXG4gICAgICAgIHdhcm5pbmdUaHJlc2hvbGQ6IDFlNlxuICAgIH07XG59KShEYXRhR3JpZCB8fCAoRGF0YUdyaWQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJDY7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBBIHNpbmdsZXRvbiBgc2Nyb2xsLXJlcXVlc3RgIGNvbmZsYXRhYmxlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgUHJpdmF0ZS5TY3JvbGxSZXF1ZXN0ID0gbmV3IENvbmZsYXRhYmxlTWVzc2FnZSgnc2Nyb2xsLXJlcXVlc3QnKTtcbiAgICAvKipcbiAgICAgKiBBIHNpbmdsZXRvbiBgb3ZlcmxheS1wYWludC1yZXF1ZXN0YCBjb25mbGF0YWJsZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIFByaXZhdGUuT3ZlcmxheVBhaW50UmVxdWVzdCA9IG5ldyBDb25mbGF0YWJsZU1lc3NhZ2UoJ292ZXJsYXktcGFpbnQtcmVxdWVzdCcpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB6ZXJvLXNpemVkIGNhbnZhcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSAwO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG4gICAgLyoqXG4gICAgICogQSBjb25mbGF0YWJsZSBtZXNzYWdlIHdoaWNoIG1lcmdlcyBkaXJ0eSBwYWludCByZWdpb25zLlxuICAgICAqL1xuICAgIHZhciBQYWludFJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhQYWludFJlcXVlc3QsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcGFpbnQgcmVxdWVzdCBtZXNzYWdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSBjZWxsIHJlZ2lvbiBmb3IgdGhlIHBhaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcjEgLSBUaGUgdG9wLWxlZnQgcm93IG9mIHRoZSBkaXJ0eSByZWdpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjMSAtIFRoZSB0b3AtbGVmdCBjb2x1bW4gb2YgdGhlIGRpcnR5IHJlZ2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHIyIC0gVGhlIGJvdHRvbS1yaWdodCByb3cgb2YgdGhlIGRpcnR5IHJlZ2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGMyIC0gVGhlIGJvdHRvbS1yaWdodCBjb2x1bW4gb2YgdGhlIGRpcnR5IHJlZ2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFBhaW50UmVxdWVzdChyZWdpb24sIHIxLCBjMSwgcjIsIGMyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAncGFpbnQtcmVxdWVzdCcpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5fcmVnaW9uID0gcmVnaW9uO1xuICAgICAgICAgICAgX3RoaXMuX3IxID0gcjE7XG4gICAgICAgICAgICBfdGhpcy5fYzEgPSBjMTtcbiAgICAgICAgICAgIF90aGlzLl9yMiA9IHIyO1xuICAgICAgICAgICAgX3RoaXMuX2MyID0gYzI7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhaW50UmVxdWVzdC5wcm90b3R5cGUsIFwicmVnaW9uXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGNlbGwgcmVnaW9uIGZvciB0aGUgcGFpbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhaW50UmVxdWVzdC5wcm90b3R5cGUsIFwicjFcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdG9wLWxlZnQgcm93IG9mIHRoZSBkaXJ0eSByZWdpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFpbnRSZXF1ZXN0LnByb3RvdHlwZSwgXCJjMVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB0b3AtbGVmdCBjb2x1bW4gb2YgdGhlIGRpcnR5IHJlZ2lvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2MxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWludFJlcXVlc3QucHJvdG90eXBlLCBcInIyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGJvdHRvbS1yaWdodCByb3cgb2YgdGhlIGRpcnR5IHJlZ2lvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3IyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWludFJlcXVlc3QucHJvdG90eXBlLCBcImMyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGJvdHRvbS1yaWdodCBjb2x1bW4gb2YgdGhlIGRpcnR5IHJlZ2lvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2MyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25mbGF0ZSB0aGlzIG1lc3NhZ2Ugd2l0aCBhbm90aGVyIHBhaW50IHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBQYWludFJlcXVlc3QucHJvdG90eXBlLmNvbmZsYXRlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSByZXF1ZXN0IGlzIGFscmVhZHkgcGFpbnRpbmcgZXZlcnl0aGluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWdpb24gPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbnkgcmVnaW9uIGNhbiBjb25mbGF0ZSB3aXRoIHRoZSBgJ2FsbCdgIHJlZ2lvbi5cbiAgICAgICAgICAgIGlmIChvdGhlci5fcmVnaW9uID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lvbiA9ICdhbGwnO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgY29uZmxhdGUgd2l0aCBhIGRpZmZlcmVudCByZWdpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVnaW9uICE9PSBvdGhlci5fcmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29uZmxhdGUgdGhlIHJlZ2lvbiB0byB0aGUgdG90YWwgYm91bmRhcnkuXG4gICAgICAgICAgICB0aGlzLl9yMSA9IE1hdGgubWluKHRoaXMuX3IxLCBvdGhlci5fcjEpO1xuICAgICAgICAgICAgdGhpcy5fYzEgPSBNYXRoLm1pbih0aGlzLl9jMSwgb3RoZXIuX2MxKTtcbiAgICAgICAgICAgIHRoaXMuX3IyID0gTWF0aC5tYXgodGhpcy5fcjIsIG90aGVyLl9yMik7XG4gICAgICAgICAgICB0aGlzLl9jMiA9IE1hdGgubWF4KHRoaXMuX2MyLCBvdGhlci5fYzIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQYWludFJlcXVlc3Q7XG4gICAgfShDb25mbGF0YWJsZU1lc3NhZ2UpKTtcbiAgICBQcml2YXRlLlBhaW50UmVxdWVzdCA9IFBhaW50UmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBBIGNvbmZsYXRhYmxlIG1lc3NhZ2UgZm9yIHJlc2l6aW5nIHJvd3MuXG4gICAgICovXG4gICAgdmFyIFJvd1Jlc2l6ZVJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSb3dSZXNpemVSZXF1ZXN0LCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHJvdyByZXNpemUgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByb3cgcmVnaW9uIHdoaWNoIGhvbGRzIHRoZSBzZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2Ygcm93IGluIHRoZSByZWdpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHRhcmdldCBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUm93UmVzaXplUmVxdWVzdChyZWdpb24sIGluZGV4LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAncm93LXJlc2l6ZS1yZXF1ZXN0JykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLl9yZWdpb24gPSByZWdpb247XG4gICAgICAgICAgICBfdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIF90aGlzLl9zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm93UmVzaXplUmVxdWVzdC5wcm90b3R5cGUsIFwicmVnaW9uXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJvdyByZWdpb24gd2hpY2ggaG9sZHMgdGhlIHNlY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvd1Jlc2l6ZVJlcXVlc3QucHJvdG90eXBlLCBcImluZGV4XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByb3cgaW4gdGhlIHJlZ2lvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3dSZXNpemVSZXF1ZXN0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHRhcmdldCBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmxhdGUgdGhpcyBtZXNzYWdlIHdpdGggYW5vdGhlciByb3cgcmVzaXplIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBSb3dSZXNpemVSZXF1ZXN0LnByb3RvdHlwZS5jb25mbGF0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZ2lvbiAhPT0gb3RoZXIuX3JlZ2lvbiB8fCB0aGlzLl9pbmRleCAhPT0gb3RoZXIuX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IG90aGVyLl9zaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb3dSZXNpemVSZXF1ZXN0O1xuICAgIH0oQ29uZmxhdGFibGVNZXNzYWdlKSk7XG4gICAgUHJpdmF0ZS5Sb3dSZXNpemVSZXF1ZXN0ID0gUm93UmVzaXplUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBBIGNvbmZsYXRhYmxlIG1lc3NhZ2UgZm9yIHJlc2l6aW5nIGNvbHVtbnMuXG4gICAgICovXG4gICAgdmFyIENvbHVtblJlc2l6ZVJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDb2x1bW5SZXNpemVSZXF1ZXN0LCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IGNvbHVtbiByZXNpemUgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSBjb2x1bW4gcmVnaW9uIHdoaWNoIGhvbGRzIHRoZSBzZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgY29sdW1uIGluIHRoZSByZWdpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHRhcmdldCBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29sdW1uUmVzaXplUmVxdWVzdChyZWdpb24sIGluZGV4LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnY29sdW1uLXJlc2l6ZS1yZXF1ZXN0JykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLl9yZWdpb24gPSByZWdpb247XG4gICAgICAgICAgICBfdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIF90aGlzLl9zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sdW1uUmVzaXplUmVxdWVzdC5wcm90b3R5cGUsIFwicmVnaW9uXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGNvbHVtbiByZWdpb24gd2hpY2ggaG9sZHMgdGhlIHNlY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbHVtblJlc2l6ZVJlcXVlc3QucHJvdG90eXBlLCBcImluZGV4XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gaW4gdGhlIHJlZ2lvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2x1bW5SZXNpemVSZXF1ZXN0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHRhcmdldCBzaXplIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmxhdGUgdGhpcyBtZXNzYWdlIHdpdGggYW5vdGhlciBjb2x1bW4gcmVzaXplIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBDb2x1bW5SZXNpemVSZXF1ZXN0LnByb3RvdHlwZS5jb25mbGF0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZ2lvbiAhPT0gb3RoZXIuX3JlZ2lvbiB8fCB0aGlzLl9pbmRleCAhPT0gb3RoZXIuX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IG90aGVyLl9zaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2x1bW5SZXNpemVSZXF1ZXN0O1xuICAgIH0oQ29uZmxhdGFibGVNZXNzYWdlKSk7XG4gICAgUHJpdmF0ZS5Db2x1bW5SZXNpemVSZXF1ZXN0ID0gQ29sdW1uUmVzaXplUmVxdWVzdDtcbn0pKFByaXZhdGUkNiB8fCAoUHJpdmF0ZSQ2ID0ge30pKTtcblxuLyoqXG4gKiBBIGRhdGEgbW9kZWwgaW1wbGVtZW50YXRpb24gZm9yIGluLW1lbW9yeSBKU09OIGRhdGEuXG4gKi9cbnZhciBKU09OTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05Nb2RlbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkYXRhIG1vZGVsIHdpdGggc3RhdGljIEpTT04gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBKU09OTW9kZWwob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgc3BsaXQgPSBQcml2YXRlJDcuc3BsaXRGaWVsZHMob3B0aW9ucy5zY2hlbWEpO1xuICAgICAgICBfdGhpcy5fZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgX3RoaXMuX2JvZHlGaWVsZHMgPSBzcGxpdC5ib2R5RmllbGRzO1xuICAgICAgICBfdGhpcy5faGVhZGVyRmllbGRzID0gc3BsaXQuaGVhZGVyRmllbGRzO1xuICAgICAgICBfdGhpcy5fbWlzc2luZ1ZhbHVlcyA9IFByaXZhdGUkNy5jcmVhdGVNaXNzaW5nTWFwKG9wdGlvbnMuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBjb3VudCBmb3IgYSByZWdpb24gaW4gdGhlIGRhdGEgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIHJvdyByZWdpb24gb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSByb3cgY291bnQgZm9yIHRoZSByZWdpb24uXG4gICAgICovXG4gICAgSlNPTk1vZGVsLnByb3RvdHlwZS5yb3dDb3VudCA9IGZ1bmN0aW9uIChyZWdpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7IC8vIFRPRE8gbXVsdGlwbGUgY29sdW1uLWhlYWRlciByb3dzP1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb2x1bW4gY291bnQgZm9yIGEgcmVnaW9uIGluIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSBjb2x1bW4gcmVnaW9uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgY29sdW1uIGNvdW50IGZvciB0aGUgcmVnaW9uLlxuICAgICAqL1xuICAgIEpTT05Nb2RlbC5wcm90b3R5cGUuY29sdW1uQ291bnQgPSBmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdib2R5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlGaWVsZHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJGaWVsZHMubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXRhIHZhbHVlIGZvciBhIGNlbGwgaW4gdGhlIGRhdGEgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIGNlbGwgcmVnaW9uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvdyAtIFRoZSByb3cgaW5kZXggb2YgdGhlIGNlbGwgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY2VsbCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGRhdGEgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgY2VsbC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBBIGBtaXNzaW5nVmFsdWVgIGFzIGRlZmluZWQgYnkgdGhlIHNjaGVtYSBpcyBjb252ZXJ0ZWQgdG8gYG51bGxgLlxuICAgICAqL1xuICAgIEpTT05Nb2RlbC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIChyZWdpb24sIHJvdywgY29sdW1uKSB7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZmllbGQgYW5kIHZhbHVlIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIGZpZWxkO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIGZpZWxkIGFuZCB2YWx1ZSBmb3IgdGhlIHJlZ2lvbi5cbiAgICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fYm9keUZpZWxkc1tjb2x1bW5dO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZGF0YVtyb3ddW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29sdW1uLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9ib2R5RmllbGRzW2NvbHVtbl07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC50aXRsZSB8fCBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm93LWhlYWRlcic6XG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9oZWFkZXJGaWVsZHNbY29sdW1uXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2RhdGFbcm93XVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nvcm5lci1oZWFkZXInOlxuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5faGVhZGVyRmllbGRzW2NvbHVtbl07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC50aXRsZSB8fCBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgdmFsdWUgaXMgYSBtaXNzaW5nIHZhbHVlLlxuICAgICAgICB2YXIgbWlzc2luZyA9ICh0aGlzLl9taXNzaW5nVmFsdWVzICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0aGlzLl9taXNzaW5nVmFsdWVzW3ZhbHVlXSA9PT0gdHJ1ZSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZmluYWwgdmFsdWUuXG4gICAgICAgIHJldHVybiBtaXNzaW5nID8gbnVsbCA6IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtZXRhZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSBjZWxsIHJlZ2lvbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgLSBUaGUgcm93IGluZGV4IG9mIHRoZSBjZWxsIG9mIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGNlbGwgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgZm9yIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIEpTT05Nb2RlbC5wcm90b3R5cGUubWV0YWRhdGEgPSBmdW5jdGlvbiAocmVnaW9uLCByb3csIGNvbHVtbikge1xuICAgICAgICBpZiAocmVnaW9uID09PSAnYm9keScgfHwgcmVnaW9uID09PSAnY29sdW1uLWhlYWRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5RmllbGRzW2NvbHVtbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlckZpZWxkc1tjb2x1bW5dO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05Nb2RlbDtcbn0oRGF0YU1vZGVsKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkNztcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBzY2hlbWEgZmllbGRzIGludG8gaGVhZGVyIGFuZCBib2R5IGZpZWxkcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdEZpZWxkcyhzY2hlbWEpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBwcmltYXJ5IGtleXMuXG4gICAgICAgIHZhciBwcmltYXJ5S2V5cztcbiAgICAgICAgaWYgKHNjaGVtYS5wcmltYXJ5S2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByaW1hcnlLZXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYS5wcmltYXJ5S2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcHJpbWFyeUtleXMgPSBbc2NoZW1hLnByaW1hcnlLZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJpbWFyeUtleXMgPSBzY2hlbWEucHJpbWFyeUtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXBhcmF0ZSB0aGUgZmllbGRzIGZvciB0aGUgYm9keSBhbmQgaGVhZGVyLlxuICAgICAgICB2YXIgYm9keUZpZWxkcyA9IFtdO1xuICAgICAgICB2YXIgaGVhZGVyRmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzY2hlbWEuZmllbGRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKHByaW1hcnlLZXlzLmluZGV4T2YoZmllbGQubmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYm9keUZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlckZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHNlcGFyYXRlZCBmaWVsZHMuXG4gICAgICAgIHJldHVybiB7IGJvZHlGaWVsZHM6IGJvZHlGaWVsZHMsIGhlYWRlckZpZWxkczogaGVhZGVyRmllbGRzIH07XG4gICAgfVxuICAgIFByaXZhdGUuc3BsaXRGaWVsZHMgPSBzcGxpdEZpZWxkcztcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtaXNzaW5nIHZhbHVlcyBtYXAgZm9yIGEgc2NoZW1hLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbWlzc2luZyB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ01hcChzY2hlbWEpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gbWlzc2luZyB2YWx1ZXMuXG4gICAgICAgIGlmICghc2NoZW1hLm1pc3NpbmdWYWx1ZXMgfHwgc2NoZW1hLm1pc3NpbmdWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb2xsZWN0IHRoZSBtaXNzaW5nIHZhbHVlcyBpbnRvIGEgbWFwLlxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNjaGVtYS5taXNzaW5nVmFsdWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2FbX2ldO1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwb3B1bGF0ZWQgbWFwLlxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZU1pc3NpbmdNYXAgPSBjcmVhdGVNaXNzaW5nTWFwO1xufSkoUHJpdmF0ZSQ3IHx8IChQcml2YXRlJDcgPSB7fSkpO1xuXG5leHBvcnQgeyBCYXNpY0tleUhhbmRsZXIsIEJhc2ljTW91c2VIYW5kbGVyLCBCYXNpY1NlbGVjdGlvbk1vZGVsLCBCb29sZWFuQ2VsbEVkaXRvciwgQ2VsbEVkaXRvciwgQ2VsbFJlbmRlcmVyLCBEYXRhR3JpZCwgRGF0YU1vZGVsLCBEYXRlQ2VsbEVkaXRvciwgRHluYW1pY09wdGlvbkNlbGxFZGl0b3IsIEdyYXBoaWNzQ29udGV4dCwgSW5wdXRDZWxsRWRpdG9yLCBJbnRlZ2VyQ2VsbEVkaXRvciwgSW50ZWdlcklucHV0VmFsaWRhdG9yLCBKU09OTW9kZWwsIE11dGFibGVEYXRhTW9kZWwsIE51bWJlckNlbGxFZGl0b3IsIE51bWJlcklucHV0VmFsaWRhdG9yLCBPcHRpb25DZWxsRWRpdG9yLCBQYXNzSW5wdXRWYWxpZGF0b3IsIFByaXZhdGUsIFJlbmRlcmVyTWFwLCBTZWxlY3Rpb25Nb2RlbCwgVGV4dENlbGxFZGl0b3IsIFRleHRJbnB1dFZhbGlkYXRvciwgVGV4dFJlbmRlcmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/datagrid/dist/index.es6.js\n")},"./node_modules/@lumino/disposable/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "DisposableDelegate": () => (/* binding */ DisposableDelegate),\n/* harmony export */   "DisposableSet": () => (/* binding */ DisposableSet),\n/* harmony export */   "ObservableDisposableDelegate": () => (/* binding */ ObservableDisposableDelegate),\n/* harmony export */   "ObservableDisposableSet": () => (/* binding */ ObservableDisposableSet)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@lumino/algorithm/dist/index.es6.js");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@lumino/signaling/dist/index.es6.js");\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * A disposable object which delegates to a callback function.\n */\nvar DisposableDelegate = /** @class */ (function () {\n    /**\n     * Construct a new disposable delegate.\n     *\n     * @param fn - The callback function to invoke on dispose.\n     */\n    function DisposableDelegate(fn) {\n        this._fn = fn;\n    }\n    Object.defineProperty(DisposableDelegate.prototype, "isDisposed", {\n        /**\n         * Test whether the delegate has been disposed.\n         */\n        get: function () {\n            return !this._fn;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the delegate and invoke the callback function.\n     */\n    DisposableDelegate.prototype.dispose = function () {\n        if (!this._fn) {\n            return;\n        }\n        var fn = this._fn;\n        this._fn = null;\n        fn();\n    };\n    return DisposableDelegate;\n}());\n/**\n * An observable disposable object which delegates to a callback function.\n */\nvar ObservableDisposableDelegate = /** @class */ (function (_super) {\n    __extends(ObservableDisposableDelegate, _super);\n    function ObservableDisposableDelegate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(_this);\n        return _this;\n    }\n    Object.defineProperty(ObservableDisposableDelegate.prototype, "disposed", {\n        /**\n         * A signal emitted when the delegate is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the delegate and invoke the callback function.\n     */\n    ObservableDisposableDelegate.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        _super.prototype.dispose.call(this);\n        this._disposed.emit(undefined);\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);\n    };\n    return ObservableDisposableDelegate;\n}(DisposableDelegate));\n/**\n * An object which manages a collection of disposable items.\n */\nvar DisposableSet = /** @class */ (function () {\n    /**\n     * Construct a new disposable set.\n     */\n    function DisposableSet() {\n        this._isDisposed = false;\n        this._items = new Set();\n    }\n    Object.defineProperty(DisposableSet.prototype, "isDisposed", {\n        /**\n         * Test whether the set has been disposed.\n         */\n        get: function () {\n            return this._isDisposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the set and the items it contains.\n     *\n     * #### Notes\n     * Items are disposed in the order they are added to the set.\n     */\n    DisposableSet.prototype.dispose = function () {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._items.forEach(function (item) { item.dispose(); });\n        this._items.clear();\n    };\n    /**\n     * Test whether the set contains a specific item.\n     *\n     * @param item - The item of interest.\n     *\n     * @returns `true` if the set contains the item, `false` otherwise.\n     */\n    DisposableSet.prototype.contains = function (item) {\n        return this._items.has(item);\n    };\n    /**\n     * Add a disposable item to the set.\n     *\n     * @param item - The item to add to the set.\n     *\n     * #### Notes\n     * If the item is already contained in the set, this is a no-op.\n     */\n    DisposableSet.prototype.add = function (item) {\n        this._items.add(item);\n    };\n    /**\n     * Remove a disposable item from the set.\n     *\n     * @param item - The item to remove from the set.\n     *\n     * #### Notes\n     * If the item is not contained in the set, this is a no-op.\n     */\n    DisposableSet.prototype.remove = function (item) {\n        this._items.delete(item);\n    };\n    /**\n     * Remove all items from the set.\n     */\n    DisposableSet.prototype.clear = function () {\n        this._items.clear();\n    };\n    return DisposableSet;\n}());\n/**\n * The namespace for the `DisposableSet` class statics.\n */\n(function (DisposableSet) {\n    /**\n     * Create a disposable set from an iterable of items.\n     *\n     * @param items - The iterable or array-like object of interest.\n     *\n     * @returns A new disposable initialized with the given items.\n     */\n    function from(items) {\n        var set = new DisposableSet();\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(items, function (item) { set.add(item); });\n        return set;\n    }\n    DisposableSet.from = from;\n})(DisposableSet || (DisposableSet = {}));\n/**\n * An observable object which manages a collection of disposable items.\n */\nvar ObservableDisposableSet = /** @class */ (function (_super) {\n    __extends(ObservableDisposableSet, _super);\n    function ObservableDisposableSet() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(_this);\n        return _this;\n    }\n    Object.defineProperty(ObservableDisposableSet.prototype, "disposed", {\n        /**\n         * A signal emitted when the set is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the set and the items it contains.\n     *\n     * #### Notes\n     * Items are disposed in the order they are added to the set.\n     */\n    ObservableDisposableSet.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        _super.prototype.dispose.call(this);\n        this._disposed.emit(undefined);\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);\n    };\n    return ObservableDisposableSet;\n}(DisposableSet));\n/**\n * The namespace for the `ObservableDisposableSet` class statics.\n */\n(function (ObservableDisposableSet) {\n    /**\n     * Create an observable disposable set from an iterable of items.\n     *\n     * @param items - The iterable or array-like object of interest.\n     *\n     * @returns A new disposable initialized with the given items.\n     */\n    function from(items) {\n        var set = new ObservableDisposableSet();\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(items, function (item) { set.add(item); });\n        return set;\n    }\n    ObservableDisposableSet.from = from;\n})(ObservableDisposableSet || (ObservableDisposableSet = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9kaXNwb3NhYmxlL2Rpc3QvaW5kZXguZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5QztBQUNFOztBQUUzQztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJLDBCQUEwQixnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJLDBCQUEwQixnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7O0FBRXlDO0FBQ3BHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vZGlzcG9zYWJsZS9kaXN0L2luZGV4LmVzNi5qcz80NDRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVhY2ggfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBBIGRpc3Bvc2FibGUgb2JqZWN0IHdoaWNoIGRlbGVnYXRlcyB0byBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG52YXIgRGlzcG9zYWJsZURlbGVnYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBkaXNwb3NhYmxlIGRlbGVnYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBvbiBkaXNwb3NlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpc3Bvc2FibGVEZWxlZ2F0ZShmbikge1xuICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcG9zYWJsZURlbGVnYXRlLnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgZGVsZWdhdGUgaGFzIGJlZW4gZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fZm47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIGRlbGVnYXRlIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIERpc3Bvc2FibGVEZWxlZ2F0ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9IHRoaXMuX2ZuO1xuICAgICAgICB0aGlzLl9mbiA9IG51bGw7XG4gICAgICAgIGZuKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzcG9zYWJsZURlbGVnYXRlO1xufSgpKTtcbi8qKlxuICogQW4gb2JzZXJ2YWJsZSBkaXNwb3NhYmxlIG9iamVjdCB3aGljaCBkZWxlZ2F0ZXMgdG8gYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xudmFyIE9ic2VydmFibGVEaXNwb3NhYmxlRGVsZWdhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ic2VydmFibGVEaXNwb3NhYmxlRGVsZWdhdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZURpc3Bvc2FibGVEZWxlZ2F0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9kaXNwb3NlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlRGlzcG9zYWJsZURlbGVnYXRlLnByb3RvdHlwZSwgXCJkaXNwb3NlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGRlbGVnYXRlIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIGRlbGVnYXRlIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE9ic2VydmFibGVEaXNwb3NhYmxlRGVsZWdhdGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQuZW1pdCh1bmRlZmluZWQpO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVEaXNwb3NhYmxlRGVsZWdhdGU7XG59KERpc3Bvc2FibGVEZWxlZ2F0ZSkpO1xuLyoqXG4gKiBBbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhIGNvbGxlY3Rpb24gb2YgZGlzcG9zYWJsZSBpdGVtcy5cbiAqL1xudmFyIERpc3Bvc2FibGVTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGRpc3Bvc2FibGUgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpc3Bvc2FibGVTZXQoKSB7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXNwb3NhYmxlU2V0LnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgc2V0IGhhcyBiZWVuIGRpc3Bvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgc2V0IGFuZCB0aGUgaXRlbXMgaXQgY29udGFpbnMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSXRlbXMgYXJlIGRpc3Bvc2VkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBhZGRlZCB0byB0aGUgc2V0LlxuICAgICAqL1xuICAgIERpc3Bvc2FibGVTZXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgaXRlbS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLl9pdGVtcy5jbGVhcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoZSBzZXQgY29udGFpbnMgYSBzcGVjaWZpYyBpdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2V0IGNvbnRhaW5zIHRoZSBpdGVtLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBEaXNwb3NhYmxlU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5oYXMoaXRlbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBkaXNwb3NhYmxlIGl0ZW0gdG8gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIGl0ZW0gaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIHNldCwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIERpc3Bvc2FibGVTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmFkZChpdGVtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRpc3Bvc2FibGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIGl0ZW0gaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgc2V0LCB0aGlzIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgRGlzcG9zYWJsZVNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5faXRlbXMuZGVsZXRlKGl0ZW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBpdGVtcyBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgRGlzcG9zYWJsZVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmNsZWFyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzcG9zYWJsZVNldDtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgRGlzcG9zYWJsZVNldGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlU2V0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGlzcG9zYWJsZSBzZXQgZnJvbSBhbiBpdGVyYWJsZSBvZiBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGRpc3Bvc2FibGUgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gaXRlbXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbShpdGVtcykge1xuICAgICAgICB2YXIgc2V0ID0gbmV3IERpc3Bvc2FibGVTZXQoKTtcbiAgICAgICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHsgc2V0LmFkZChpdGVtKTsgfSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIERpc3Bvc2FibGVTZXQuZnJvbSA9IGZyb207XG59KShEaXNwb3NhYmxlU2V0IHx8IChEaXNwb3NhYmxlU2V0ID0ge30pKTtcbi8qKlxuICogQW4gb2JzZXJ2YWJsZSBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhIGNvbGxlY3Rpb24gb2YgZGlzcG9zYWJsZSBpdGVtcy5cbiAqL1xudmFyIE9ic2VydmFibGVEaXNwb3NhYmxlU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYnNlcnZhYmxlRGlzcG9zYWJsZVNldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlRGlzcG9zYWJsZVNldCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9kaXNwb3NlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlRGlzcG9zYWJsZVNldC5wcm90b3R5cGUsIFwiZGlzcG9zZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBzZXQgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgc2V0IGFuZCB0aGUgaXRlbXMgaXQgY29udGFpbnMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSXRlbXMgYXJlIGRpc3Bvc2VkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBhZGRlZCB0byB0aGUgc2V0LlxuICAgICAqL1xuICAgIE9ic2VydmFibGVEaXNwb3NhYmxlU2V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgU2lnbmFsLmNsZWFyRGF0YSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlRGlzcG9zYWJsZVNldDtcbn0oRGlzcG9zYWJsZVNldCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYE9ic2VydmFibGVEaXNwb3NhYmxlU2V0YCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKE9ic2VydmFibGVEaXNwb3NhYmxlU2V0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9ic2VydmFibGUgZGlzcG9zYWJsZSBzZXQgZnJvbSBhbiBpdGVyYWJsZSBvZiBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyAtIFRoZSBpdGVyYWJsZSBvciBhcnJheS1saWtlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGRpc3Bvc2FibGUgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gaXRlbXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbShpdGVtcykge1xuICAgICAgICB2YXIgc2V0ID0gbmV3IE9ic2VydmFibGVEaXNwb3NhYmxlU2V0KCk7XG4gICAgICAgIGVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7IHNldC5hZGQoaXRlbSk7IH0pO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBPYnNlcnZhYmxlRGlzcG9zYWJsZVNldC5mcm9tID0gZnJvbTtcbn0pKE9ic2VydmFibGVEaXNwb3NhYmxlU2V0IHx8IChPYnNlcnZhYmxlRGlzcG9zYWJsZVNldCA9IHt9KSk7XG5cbmV4cG9ydCB7IERpc3Bvc2FibGVEZWxlZ2F0ZSwgRGlzcG9zYWJsZVNldCwgT2JzZXJ2YWJsZURpc3Bvc2FibGVEZWxlZ2F0ZSwgT2JzZXJ2YWJsZURpc3Bvc2FibGVTZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lumino/disposable/dist/index.es6.js\n')},"./node_modules/@lumino/domutils/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ClipboardExt\": () => (/* binding */ ClipboardExt),\n/* harmony export */   \"ElementExt\": () => (/* binding */ ElementExt),\n/* harmony export */   \"Platform\": () => (/* binding */ Platform),\n/* harmony export */   \"Selector\": () => (/* binding */ Selector)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for clipboard related functionality.\n */\nvar ClipboardExt;\n(function (ClipboardExt) {\n    /**\n     * Copy text to the system clipboard.\n     *\n     * @param text - The text to copy to the clipboard.\n     */\n    function copyText(text) {\n        // Fetch the document body.\n        var body = document.body;\n        // Set up the clipboard event listener.\n        var handler = function (event) {\n            // Stop the event propagation.\n            event.preventDefault();\n            event.stopPropagation();\n            // Set the clipboard data.\n            event.clipboardData.setData('text', text);\n            // Remove the event listener.\n            body.removeEventListener('copy', handler, true);\n        };\n        // Add the event listener.\n        body.addEventListener('copy', handler, true);\n        // Trigger the event.\n        document.execCommand('copy');\n    }\n    ClipboardExt.copyText = copyText;\n})(ClipboardExt || (ClipboardExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for element related utilities.\n */\nvar ElementExt;\n(function (ElementExt) {\n    /**\n     * Compute the box sizing for an element.\n     *\n     * @param element - The element of interest.\n     *\n     * @returns The box sizing data for the specified element.\n     */\n    function boxSizing(element) {\n        var style = window.getComputedStyle(element);\n        var bt = parseFloat(style.borderTopWidth) || 0;\n        var bl = parseFloat(style.borderLeftWidth) || 0;\n        var br = parseFloat(style.borderRightWidth) || 0;\n        var bb = parseFloat(style.borderBottomWidth) || 0;\n        var pt = parseFloat(style.paddingTop) || 0;\n        var pl = parseFloat(style.paddingLeft) || 0;\n        var pr = parseFloat(style.paddingRight) || 0;\n        var pb = parseFloat(style.paddingBottom) || 0;\n        var hs = bl + pl + pr + br;\n        var vs = bt + pt + pb + bb;\n        return {\n            borderTop: bt,\n            borderLeft: bl,\n            borderRight: br,\n            borderBottom: bb,\n            paddingTop: pt,\n            paddingLeft: pl,\n            paddingRight: pr,\n            paddingBottom: pb,\n            horizontalSum: hs,\n            verticalSum: vs\n        };\n    }\n    ElementExt.boxSizing = boxSizing;\n    /**\n     * Compute the size limits for an element.\n     *\n     * @param element - The element of interest.\n     *\n     * @returns The size limit data for the specified element.\n     */\n    function sizeLimits(element) {\n        var style = window.getComputedStyle(element);\n        var minWidth = parseFloat(style.minWidth) || 0;\n        var minHeight = parseFloat(style.minHeight) || 0;\n        var maxWidth = parseFloat(style.maxWidth) || Infinity;\n        var maxHeight = parseFloat(style.maxHeight) || Infinity;\n        maxWidth = Math.max(minWidth, maxWidth);\n        maxHeight = Math.max(minHeight, maxHeight);\n        return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };\n    }\n    ElementExt.sizeLimits = sizeLimits;\n    /**\n     * Test whether a client position lies within an element.\n     *\n     * @param element - The DOM element of interest.\n     *\n     * @param clientX - The client X coordinate of interest.\n     *\n     * @param clientY - The client Y coordinate of interest.\n     *\n     * @returns Whether the point is within the given element.\n     */\n    function hitTest(element, clientX, clientY) {\n        var rect = element.getBoundingClientRect();\n        return (clientX >= rect.left &&\n            clientX < rect.right &&\n            clientY >= rect.top &&\n            clientY < rect.bottom);\n    }\n    ElementExt.hitTest = hitTest;\n    /**\n     * Vertically scroll an element into view if needed.\n     *\n     * @param area - The scroll area element.\n     *\n     * @param element - The element of interest.\n     *\n     * #### Notes\n     * This follows the \"nearest\" behavior of the native `scrollIntoView`\n     * method, which is not supported by all browsers.\n     * https://drafts.csswg.org/cssom-view/#element-scrolling-members\n     *\n     * If the element fully covers the visible area or is fully contained\n     * within the visible area, no scrolling will take place. Otherwise,\n     * the nearest edges of the area and element are aligned.\n     */\n    function scrollIntoViewIfNeeded(area, element) {\n        var ar = area.getBoundingClientRect();\n        var er = element.getBoundingClientRect();\n        if (er.top <= ar.top && er.bottom >= ar.bottom) {\n            return;\n        }\n        if (er.top < ar.top && er.height <= ar.height) {\n            area.scrollTop -= ar.top - er.top;\n            return;\n        }\n        if (er.bottom > ar.bottom && er.height >= ar.height) {\n            area.scrollTop -= ar.top - er.top;\n            return;\n        }\n        if (er.top < ar.top && er.height > ar.height) {\n            area.scrollTop -= ar.bottom - er.bottom;\n            return;\n        }\n        if (er.bottom > ar.bottom && er.height < ar.height) {\n            area.scrollTop -= ar.bottom - er.bottom;\n            return;\n        }\n    }\n    ElementExt.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;\n})(ElementExt || (ElementExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for platform related utilities.\n */\nvar Platform;\n(function (Platform) {\n    /**\n     * A flag indicating whether the platform is Mac.\n     */\n    Platform.IS_MAC = !!navigator.platform.match(/Mac/i);\n    /**\n     * A flag indicating whether the platform is Windows.\n     */\n    Platform.IS_WIN = !!navigator.platform.match(/Win/i);\n    /**\n     * A flag indicating whether the browser is IE.\n     */\n    Platform.IS_IE = /Trident/.test(navigator.userAgent);\n    /**\n     * A flag indicating whether the browser is Edge.\n     */\n    Platform.IS_EDGE = /Edge/.test(navigator.userAgent);\n    /**\n     * Test whether the `accel` key is pressed.\n     *\n     * @param event - The keyboard or mouse event of interest.\n     *\n     * @returns Whether the `accel` key is pressed.\n     *\n     * #### Notes\n     * On Mac the `accel` key is the command key. On all other\n     * platforms the `accel` key is the control key.\n     */\n    function accelKey(event) {\n        return Platform.IS_MAC ? event.metaKey : event.ctrlKey;\n    }\n    Platform.accelKey = accelKey;\n})(Platform || (Platform = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for selector related utilities.\n */\nvar Selector;\n(function (Selector) {\n    /**\n     * Calculate the specificity of a single CSS selector.\n     *\n     * @param selector - The CSS selector of interest.\n     *\n     * @returns The specificity of the selector.\n     *\n     * #### Undefined Behavior\n     * The selector is invalid.\n     *\n     * #### Notes\n     * This is based on https://www.w3.org/TR/css3-selectors/#specificity\n     *\n     * A larger number represents a more specific selector.\n     *\n     * The smallest possible specificity is `0`.\n     *\n     * The result is represented as a hex number `0x<aa><bb><cc>` where\n     * each component is the count of the respective selector clause.\n     *\n     * If the selector contains commas, only the first clause is used.\n     *\n     * The computed result is cached, so subsequent calculations for the\n     * same selector are extremely fast.\n     */\n    function calculateSpecificity(selector) {\n        if (selector in Private.specificityCache) {\n            return Private.specificityCache[selector];\n        }\n        var result = Private.calculateSingle(selector);\n        return Private.specificityCache[selector] = result;\n    }\n    Selector.calculateSpecificity = calculateSpecificity;\n    /**\n     * Test whether a selector is a valid CSS selector.\n     *\n     * @param selector - The CSS selector of interest.\n     *\n     * @returns `true` if the selector is valid, `false` otherwise.\n     *\n     * #### Notes\n     * The computed result is cached, so subsequent tests for the same\n     * selector are extremely fast.\n     */\n    function isValid(selector) {\n        if (selector in Private.validityCache) {\n            return Private.validityCache[selector];\n        }\n        var result = true;\n        try {\n            Private.testElem.querySelector(selector);\n        }\n        catch (err) {\n            result = false;\n        }\n        return Private.validityCache[selector] = result;\n    }\n    Selector.isValid = isValid;\n    /**\n     * Test whether an element matches a CSS selector.\n     *\n     * @param element - The element of interest.\n     *\n     * @param selector - The valid CSS selector of interest.\n     *\n     * @returns `true` if the element is a match, `false` otherwise.\n     *\n     * #### Notes\n     * This function uses the builtin browser capabilities when possible,\n     * falling back onto a document query otherwise.\n     */\n    function matches(element, selector) {\n        return Private.protoMatchFunc.call(element, selector);\n    }\n    Selector.matches = matches;\n})(Selector || (Selector = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A cache of computed selector specificity values.\n     */\n    Private.specificityCache = Object.create(null);\n    /**\n     * A cache of computed selector validity.\n     */\n    Private.validityCache = Object.create(null);\n    /**\n     * An empty element for testing selector validity.\n     */\n    Private.testElem = document.createElement('div');\n    /**\n     * A cross-browser CSS selector matching prototype function.\n     */\n    Private.protoMatchFunc = (function () {\n        var proto = Element.prototype;\n        return (proto.matches ||\n            proto.matchesSelector ||\n            proto.mozMatchesSelector ||\n            proto.msMatchesSelector ||\n            proto.oMatchesSelector ||\n            proto.webkitMatchesSelector ||\n            (function (selector) {\n                var elem = this;\n                var matches = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];\n                return Array.prototype.indexOf.call(matches, elem) !== -1;\n            }));\n    })();\n    /**\n     * Calculate the specificity of a single selector.\n     *\n     * The behavior is undefined if the selector is invalid.\n     */\n    function calculateSingle(selector) {\n        // Ignore anything after the first comma.\n        selector = selector.split(',', 1)[0];\n        // Setup the aggregate counters.\n        var a = 0;\n        var b = 0;\n        var c = 0;\n        // Apply a regex to the front of the selector. If it succeeds, that\n        // portion of the selector is removed. Returns a success/fail flag.\n        function match(re) {\n            var match = selector.match(re);\n            if (match === null) {\n                return false;\n            }\n            selector = selector.slice(match[0].length);\n            return true;\n        }\n        // Replace the negation pseudo-class (which is ignored),\n        // but keep its inner content (which is not ignored).\n        selector = selector.replace(NEGATION_RE, ' $1 ');\n        // Continue matching until the selector is consumed.\n        while (selector.length > 0) {\n            // Match an ID selector.\n            if (match(ID_RE)) {\n                a++;\n                continue;\n            }\n            // Match a class selector.\n            if (match(CLASS_RE)) {\n                b++;\n                continue;\n            }\n            // Match an attribute selector.\n            if (match(ATTR_RE)) {\n                b++;\n                continue;\n            }\n            // Match a pseudo-element selector. This is done before matching\n            // a pseudo-class since this regex overlaps with that regex.\n            if (match(PSEUDO_ELEM_RE)) {\n                c++;\n                continue;\n            }\n            // Match a pseudo-class selector.\n            if (match(PSEDUO_CLASS_RE)) {\n                b++;\n                continue;\n            }\n            // Match a plain type selector.\n            if (match(TYPE_RE)) {\n                c++;\n                continue;\n            }\n            // Finally, match any ignored characters.\n            if (match(IGNORE_RE)) {\n                continue;\n            }\n            // At this point, the selector is assumed to be invalid.\n            return 0;\n        }\n        // Clamp each component to a reasonable base.\n        a = Math.min(a, 0xFF);\n        b = Math.min(b, 0xFF);\n        c = Math.min(c, 0xFF);\n        // Combine the components into a single result.\n        return (a << 16) | (b << 8) | c;\n    }\n    Private.calculateSingle = calculateSingle;\n    /**\n     * A regex which matches an ID selector at string start.\n     */\n    var ID_RE = /^#[^\\s\\+>~#\\.\\[:]+/;\n    /**\n     * A regex which matches a class selector at string start.\n     */\n    var CLASS_RE = /^\\.[^\\s\\+>~#\\.\\[:]+/;\n    /**\n     * A regex which matches an attribute selector at string start.\n     */\n    var ATTR_RE = /^\\[[^\\]]+\\]/;\n    /**\n     * A regex which matches a type selector at string start.\n     */\n    var TYPE_RE = /^[^\\s\\+>~#\\.\\[:]+/;\n    /**\n     * A regex which matches a pseudo-element selector at string start.\n     */\n    var PSEUDO_ELEM_RE = /^(::[^\\s\\+>~#\\.\\[:]+|:first-line|:first-letter|:before|:after)/;\n    /**\n     * A regex which matches a pseudo-class selector at string start.\n     */\n    var PSEDUO_CLASS_RE = /^:[^\\s\\+>~#\\.\\[:]+/;\n    /**\n     * A regex which matches ignored characters at string start.\n     */\n    var IGNORE_RE = /^[\\s\\+>~\\*]+/;\n    /**\n     * A regex which matches the negation pseudo-class globally.\n     */\n    var NEGATION_RE = /:not\\(([^\\)]+)\\)/g;\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9kb211dGlscy9kaXN0L2luZGV4LmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTZCO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vZG9tdXRpbHMvZGlzdC9pbmRleC5lczYuanM/OGRiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE5LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgY2xpcGJvYXJkIHJlbGF0ZWQgZnVuY3Rpb25hbGl0eS5cbiAqL1xudmFyIENsaXBib2FyZEV4dDtcbihmdW5jdGlvbiAoQ2xpcGJvYXJkRXh0KSB7XG4gICAgLyoqXG4gICAgICogQ29weSB0ZXh0IHRvIHRoZSBzeXN0ZW0gY2xpcGJvYXJkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBjb3B5IHRvIHRoZSBjbGlwYm9hcmQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVRleHQodGV4dCkge1xuICAgICAgICAvLyBGZXRjaCB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGNsaXBib2FyZCBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBjbGlwYm9hcmQgZGF0YS5cbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dCcsIHRleHQpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29weScsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgZXZlbnQuXG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgfVxuICAgIENsaXBib2FyZEV4dC5jb3B5VGV4dCA9IGNvcHlUZXh0O1xufSkoQ2xpcGJvYXJkRXh0IHx8IChDbGlwYm9hcmRFeHQgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgZWxlbWVudCByZWxhdGVkIHV0aWxpdGllcy5cbiAqL1xudmFyIEVsZW1lbnRFeHQ7XG4oZnVuY3Rpb24gKEVsZW1lbnRFeHQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBib3ggc2l6aW5nIGZvciBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBib3ggc2l6aW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBib3hTaXppbmcoZWxlbWVudCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgdmFyIGJ0ID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIGJsID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDA7XG4gICAgICAgIHZhciBiciA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIGJiID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIHB0ID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwO1xuICAgICAgICB2YXIgcGwgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdMZWZ0KSB8fCAwO1xuICAgICAgICB2YXIgcHIgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdSaWdodCkgfHwgMDtcbiAgICAgICAgdmFyIHBiID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwO1xuICAgICAgICB2YXIgaHMgPSBibCArIHBsICsgcHIgKyBicjtcbiAgICAgICAgdmFyIHZzID0gYnQgKyBwdCArIHBiICsgYmI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3JkZXJUb3A6IGJ0LFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYmwsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYnIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IGJiLFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogcHQsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogcGwsXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHByLFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogcGIsXG4gICAgICAgICAgICBob3Jpem9udGFsU3VtOiBocyxcbiAgICAgICAgICAgIHZlcnRpY2FsU3VtOiB2c1xuICAgICAgICB9O1xuICAgIH1cbiAgICBFbGVtZW50RXh0LmJveFNpemluZyA9IGJveFNpemluZztcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBzaXplIGxpbWl0cyBmb3IgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBsaW1pdCBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZUxpbWl0cyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgbWluV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLm1pbldpZHRoKSB8fCAwO1xuICAgICAgICB2YXIgbWluSGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5taW5IZWlnaHQpIHx8IDA7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUubWF4V2lkdGgpIHx8IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5tYXhIZWlnaHQpIHx8IEluZmluaXR5O1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1pbldpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHsgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCB9O1xuICAgIH1cbiAgICBFbGVtZW50RXh0LnNpemVMaW1pdHMgPSBzaXplTGltaXRzO1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIGNsaWVudCBwb3NpdGlvbiBsaWVzIHdpdGhpbiBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgRE9NIGVsZW1lbnQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50WCAtIFRoZSBjbGllbnQgWCBjb29yZGluYXRlIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudFkgLSBUaGUgY2xpZW50IFkgY29vcmRpbmF0ZSBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoaXRUZXN0KGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gKGNsaWVudFggPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgICAgICBjbGllbnRYIDwgcmVjdC5yaWdodCAmJlxuICAgICAgICAgICAgY2xpZW50WSA+PSByZWN0LnRvcCAmJlxuICAgICAgICAgICAgY2xpZW50WSA8IHJlY3QuYm90dG9tKTtcbiAgICB9XG4gICAgRWxlbWVudEV4dC5oaXRUZXN0ID0gaGl0VGVzdDtcbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbGx5IHNjcm9sbCBhbiBlbGVtZW50IGludG8gdmlldyBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJlYSAtIFRoZSBzY3JvbGwgYXJlYSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGZvbGxvd3MgdGhlIFwibmVhcmVzdFwiIGJlaGF2aW9yIG9mIHRoZSBuYXRpdmUgYHNjcm9sbEludG9WaWV3YFxuICAgICAqIG1ldGhvZCwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMuXG4gICAgICogaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLXZpZXcvI2VsZW1lbnQtc2Nyb2xsaW5nLW1lbWJlcnNcbiAgICAgKlxuICAgICAqIElmIHRoZSBlbGVtZW50IGZ1bGx5IGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhIG9yIGlzIGZ1bGx5IGNvbnRhaW5lZFxuICAgICAqIHdpdGhpbiB0aGUgdmlzaWJsZSBhcmVhLCBubyBzY3JvbGxpbmcgd2lsbCB0YWtlIHBsYWNlLiBPdGhlcndpc2UsXG4gICAgICogdGhlIG5lYXJlc3QgZWRnZXMgb2YgdGhlIGFyZWEgYW5kIGVsZW1lbnQgYXJlIGFsaWduZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChhcmVhLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBhciA9IGFyZWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBlciA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChlci50b3AgPD0gYXIudG9wICYmIGVyLmJvdHRvbSA+PSBhci5ib3R0b20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIudG9wIDwgYXIudG9wICYmIGVyLmhlaWdodCA8PSBhci5oZWlnaHQpIHtcbiAgICAgICAgICAgIGFyZWEuc2Nyb2xsVG9wIC09IGFyLnRvcCAtIGVyLnRvcDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuYm90dG9tID4gYXIuYm90dG9tICYmIGVyLmhlaWdodCA+PSBhci5oZWlnaHQpIHtcbiAgICAgICAgICAgIGFyZWEuc2Nyb2xsVG9wIC09IGFyLnRvcCAtIGVyLnRvcDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIudG9wIDwgYXIudG9wICYmIGVyLmhlaWdodCA+IGFyLmhlaWdodCkge1xuICAgICAgICAgICAgYXJlYS5zY3JvbGxUb3AgLT0gYXIuYm90dG9tIC0gZXIuYm90dG9tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlci5ib3R0b20gPiBhci5ib3R0b20gJiYgZXIuaGVpZ2h0IDwgYXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICBhcmVhLnNjcm9sbFRvcCAtPSBhci5ib3R0b20gLSBlci5ib3R0b207XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgRWxlbWVudEV4dC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkID0gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZDtcbn0pKEVsZW1lbnRFeHQgfHwgKEVsZW1lbnRFeHQgPSB7fSkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgcGxhdGZvcm0gcmVsYXRlZCB1dGlsaXRpZXMuXG4gKi9cbnZhciBQbGF0Zm9ybTtcbihmdW5jdGlvbiAoUGxhdGZvcm0pIHtcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwbGF0Zm9ybSBpcyBNYWMuXG4gICAgICovXG4gICAgUGxhdGZvcm0uSVNfTUFDID0gISFuYXZpZ2F0b3IucGxhdGZvcm0ubWF0Y2goL01hYy9pKTtcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwbGF0Zm9ybSBpcyBXaW5kb3dzLlxuICAgICAqL1xuICAgIFBsYXRmb3JtLklTX1dJTiA9ICEhbmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKC9XaW4vaSk7XG4gICAgLyoqXG4gICAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgYnJvd3NlciBpcyBJRS5cbiAgICAgKi9cbiAgICBQbGF0Zm9ybS5JU19JRSA9IC9UcmlkZW50Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIC8qKlxuICAgICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRWRnZS5cbiAgICAgKi9cbiAgICBQbGF0Zm9ybS5JU19FREdFID0gL0VkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoZSBgYWNjZWxgIGtleSBpcyBwcmVzc2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGtleWJvYXJkIG9yIG1vdXNlIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgYGFjY2VsYCBrZXkgaXMgcHJlc3NlZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBPbiBNYWMgdGhlIGBhY2NlbGAga2V5IGlzIHRoZSBjb21tYW5kIGtleS4gT24gYWxsIG90aGVyXG4gICAgICogcGxhdGZvcm1zIHRoZSBgYWNjZWxgIGtleSBpcyB0aGUgY29udHJvbCBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWNjZWxLZXkoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtLklTX01BQyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuICAgIH1cbiAgICBQbGF0Zm9ybS5hY2NlbEtleSA9IGFjY2VsS2V5O1xufSkoUGxhdGZvcm0gfHwgKFBsYXRmb3JtID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgUGhvc3Bob3JKUyBDb250cmlidXRvcnNcbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBMSUNFTlNFLCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHNlbGVjdG9yIHJlbGF0ZWQgdXRpbGl0aWVzLlxuICovXG52YXIgU2VsZWN0b3I7XG4oZnVuY3Rpb24gKFNlbGVjdG9yKSB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGVjaWZpY2l0eSBvZiBhIHNpbmdsZSBDU1Mgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBUaGUgQ1NTIHNlbGVjdG9yIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHNwZWNpZmljaXR5IG9mIHRoZSBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogVGhlIHNlbGVjdG9yIGlzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBiYXNlZCBvbiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3NwZWNpZmljaXR5XG4gICAgICpcbiAgICAgKiBBIGxhcmdlciBudW1iZXIgcmVwcmVzZW50cyBhIG1vcmUgc3BlY2lmaWMgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGUgc21hbGxlc3QgcG9zc2libGUgc3BlY2lmaWNpdHkgaXMgYDBgLlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdCBpcyByZXByZXNlbnRlZCBhcyBhIGhleCBudW1iZXIgYDB4PGFhPjxiYj48Y2M+YCB3aGVyZVxuICAgICAqIGVhY2ggY29tcG9uZW50IGlzIHRoZSBjb3VudCBvZiB0aGUgcmVzcGVjdGl2ZSBzZWxlY3RvciBjbGF1c2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc2VsZWN0b3IgY29udGFpbnMgY29tbWFzLCBvbmx5IHRoZSBmaXJzdCBjbGF1c2UgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIFRoZSBjb21wdXRlZCByZXN1bHQgaXMgY2FjaGVkLCBzbyBzdWJzZXF1ZW50IGNhbGN1bGF0aW9ucyBmb3IgdGhlXG4gICAgICogc2FtZSBzZWxlY3RvciBhcmUgZXh0cmVtZWx5IGZhc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU3BlY2lmaWNpdHkoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yIGluIFByaXZhdGUuc3BlY2lmaWNpdHlDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGUuc3BlY2lmaWNpdHlDYWNoZVtzZWxlY3Rvcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFByaXZhdGUuY2FsY3VsYXRlU2luZ2xlKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIFByaXZhdGUuc3BlY2lmaWNpdHlDYWNoZVtzZWxlY3Rvcl0gPSByZXN1bHQ7XG4gICAgfVxuICAgIFNlbGVjdG9yLmNhbGN1bGF0ZVNwZWNpZmljaXR5ID0gY2FsY3VsYXRlU3BlY2lmaWNpdHk7XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEgc2VsZWN0b3IgaXMgYSB2YWxpZCBDU1Mgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBUaGUgQ1NTIHNlbGVjdG9yIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzZWxlY3RvciBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGNvbXB1dGVkIHJlc3VsdCBpcyBjYWNoZWQsIHNvIHN1YnNlcXVlbnQgdGVzdHMgZm9yIHRoZSBzYW1lXG4gICAgICogc2VsZWN0b3IgYXJlIGV4dHJlbWVseSBmYXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVmFsaWQoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yIGluIFByaXZhdGUudmFsaWRpdHlDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGUudmFsaWRpdHlDYWNoZVtzZWxlY3Rvcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBQcml2YXRlLnRlc3RFbGVtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcml2YXRlLnZhbGlkaXR5Q2FjaGVbc2VsZWN0b3JdID0gcmVzdWx0O1xuICAgIH1cbiAgICBTZWxlY3Rvci5pc1ZhbGlkID0gaXNWYWxpZDtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYW4gZWxlbWVudCBtYXRjaGVzIGEgQ1NTIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIFRoZSB2YWxpZCBDU1Mgc2VsZWN0b3Igb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQgaXMgYSBtYXRjaCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBidWlsdGluIGJyb3dzZXIgY2FwYWJpbGl0aWVzIHdoZW4gcG9zc2libGUsXG4gICAgICogZmFsbGluZyBiYWNrIG9udG8gYSBkb2N1bWVudCBxdWVyeSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5wcm90b01hdGNoRnVuYy5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgU2VsZWN0b3IubWF0Y2hlcyA9IG1hdGNoZXM7XG59KShTZWxlY3RvciB8fCAoU2VsZWN0b3IgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiBjb21wdXRlZCBzZWxlY3RvciBzcGVjaWZpY2l0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgUHJpdmF0ZS5zcGVjaWZpY2l0eUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIGNvbXB1dGVkIHNlbGVjdG9yIHZhbGlkaXR5LlxuICAgICAqL1xuICAgIFByaXZhdGUudmFsaWRpdHlDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQW4gZW1wdHkgZWxlbWVudCBmb3IgdGVzdGluZyBzZWxlY3RvciB2YWxpZGl0eS5cbiAgICAgKi9cbiAgICBQcml2YXRlLnRlc3RFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLyoqXG4gICAgICogQSBjcm9zcy1icm93c2VyIENTUyBzZWxlY3RvciBtYXRjaGluZyBwcm90b3R5cGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgUHJpdmF0ZS5wcm90b01hdGNoRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gKHByb3RvLm1hdGNoZXMgfHxcbiAgICAgICAgICAgIHByb3RvLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBwcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgcHJvdG8ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZWxlbS5vd25lckRvY3VtZW50ID8gZWxlbS5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIDogW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobWF0Y2hlcywgZWxlbSkgIT09IC0xO1xuICAgICAgICAgICAgfSkpO1xuICAgIH0pKCk7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGVjaWZpY2l0eSBvZiBhIHNpbmdsZSBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgdGhlIHNlbGVjdG9yIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU2luZ2xlKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIElnbm9yZSBhbnl0aGluZyBhZnRlciB0aGUgZmlyc3QgY29tbWEuXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc3BsaXQoJywnLCAxKVswXTtcbiAgICAgICAgLy8gU2V0dXAgdGhlIGFnZ3JlZ2F0ZSBjb3VudGVycy5cbiAgICAgICAgdmFyIGEgPSAwO1xuICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgLy8gQXBwbHkgYSByZWdleCB0byB0aGUgZnJvbnQgb2YgdGhlIHNlbGVjdG9yLiBJZiBpdCBzdWNjZWVkcywgdGhhdFxuICAgICAgICAvLyBwb3J0aW9uIG9mIHRoZSBzZWxlY3RvciBpcyByZW1vdmVkLiBSZXR1cm5zIGEgc3VjY2Vzcy9mYWlsIGZsYWcuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoKHJlKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChyZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBuZWdhdGlvbiBwc2V1ZG8tY2xhc3MgKHdoaWNoIGlzIGlnbm9yZWQpLFxuICAgICAgICAvLyBidXQga2VlcCBpdHMgaW5uZXIgY29udGVudCAod2hpY2ggaXMgbm90IGlnbm9yZWQpLlxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoTkVHQVRJT05fUkUsICcgJDEgJyk7XG4gICAgICAgIC8vIENvbnRpbnVlIG1hdGNoaW5nIHVudGlsIHRoZSBzZWxlY3RvciBpcyBjb25zdW1lZC5cbiAgICAgICAgd2hpbGUgKHNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE1hdGNoIGFuIElEIHNlbGVjdG9yLlxuICAgICAgICAgICAgaWYgKG1hdGNoKElEX1JFKSkge1xuICAgICAgICAgICAgICAgIGErKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hdGNoIGEgY2xhc3Mgc2VsZWN0b3IuXG4gICAgICAgICAgICBpZiAobWF0Y2goQ0xBU1NfUkUpKSB7XG4gICAgICAgICAgICAgICAgYisrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWF0Y2ggYW4gYXR0cmlidXRlIHNlbGVjdG9yLlxuICAgICAgICAgICAgaWYgKG1hdGNoKEFUVFJfUkUpKSB7XG4gICAgICAgICAgICAgICAgYisrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWF0Y2ggYSBwc2V1ZG8tZWxlbWVudCBzZWxlY3Rvci4gVGhpcyBpcyBkb25lIGJlZm9yZSBtYXRjaGluZ1xuICAgICAgICAgICAgLy8gYSBwc2V1ZG8tY2xhc3Mgc2luY2UgdGhpcyByZWdleCBvdmVybGFwcyB3aXRoIHRoYXQgcmVnZXguXG4gICAgICAgICAgICBpZiAobWF0Y2goUFNFVURPX0VMRU1fUkUpKSB7XG4gICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWF0Y2ggYSBwc2V1ZG8tY2xhc3Mgc2VsZWN0b3IuXG4gICAgICAgICAgICBpZiAobWF0Y2goUFNFRFVPX0NMQVNTX1JFKSkge1xuICAgICAgICAgICAgICAgIGIrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hdGNoIGEgcGxhaW4gdHlwZSBzZWxlY3Rvci5cbiAgICAgICAgICAgIGlmIChtYXRjaChUWVBFX1JFKSkge1xuICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIG1hdGNoIGFueSBpZ25vcmVkIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAobWF0Y2goSUdOT1JFX1JFKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHNlbGVjdG9yIGlzIGFzc3VtZWQgdG8gYmUgaW52YWxpZC5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIGVhY2ggY29tcG9uZW50IHRvIGEgcmVhc29uYWJsZSBiYXNlLlxuICAgICAgICBhID0gTWF0aC5taW4oYSwgMHhGRik7XG4gICAgICAgIGIgPSBNYXRoLm1pbihiLCAweEZGKTtcbiAgICAgICAgYyA9IE1hdGgubWluKGMsIDB4RkYpO1xuICAgICAgICAvLyBDb21iaW5lIHRoZSBjb21wb25lbnRzIGludG8gYSBzaW5nbGUgcmVzdWx0LlxuICAgICAgICByZXR1cm4gKGEgPDwgMTYpIHwgKGIgPDwgOCkgfCBjO1xuICAgIH1cbiAgICBQcml2YXRlLmNhbGN1bGF0ZVNpbmdsZSA9IGNhbGN1bGF0ZVNpbmdsZTtcbiAgICAvKipcbiAgICAgKiBBIHJlZ2V4IHdoaWNoIG1hdGNoZXMgYW4gSUQgc2VsZWN0b3IgYXQgc3RyaW5nIHN0YXJ0LlxuICAgICAqL1xuICAgIHZhciBJRF9SRSA9IC9eI1teXFxzXFwrPn4jXFwuXFxbOl0rLztcbiAgICAvKipcbiAgICAgKiBBIHJlZ2V4IHdoaWNoIG1hdGNoZXMgYSBjbGFzcyBzZWxlY3RvciBhdCBzdHJpbmcgc3RhcnQuXG4gICAgICovXG4gICAgdmFyIENMQVNTX1JFID0gL15cXC5bXlxcc1xcKz5+I1xcLlxcWzpdKy87XG4gICAgLyoqXG4gICAgICogQSByZWdleCB3aGljaCBtYXRjaGVzIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBhdCBzdHJpbmcgc3RhcnQuXG4gICAgICovXG4gICAgdmFyIEFUVFJfUkUgPSAvXlxcW1teXFxdXStcXF0vO1xuICAgIC8qKlxuICAgICAqIEEgcmVnZXggd2hpY2ggbWF0Y2hlcyBhIHR5cGUgc2VsZWN0b3IgYXQgc3RyaW5nIHN0YXJ0LlxuICAgICAqL1xuICAgIHZhciBUWVBFX1JFID0gL15bXlxcc1xcKz5+I1xcLlxcWzpdKy87XG4gICAgLyoqXG4gICAgICogQSByZWdleCB3aGljaCBtYXRjaGVzIGEgcHNldWRvLWVsZW1lbnQgc2VsZWN0b3IgYXQgc3RyaW5nIHN0YXJ0LlxuICAgICAqL1xuICAgIHZhciBQU0VVRE9fRUxFTV9SRSA9IC9eKDo6W15cXHNcXCs+fiNcXC5cXFs6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvO1xuICAgIC8qKlxuICAgICAqIEEgcmVnZXggd2hpY2ggbWF0Y2hlcyBhIHBzZXVkby1jbGFzcyBzZWxlY3RvciBhdCBzdHJpbmcgc3RhcnQuXG4gICAgICovXG4gICAgdmFyIFBTRURVT19DTEFTU19SRSA9IC9eOlteXFxzXFwrPn4jXFwuXFxbOl0rLztcbiAgICAvKipcbiAgICAgKiBBIHJlZ2V4IHdoaWNoIG1hdGNoZXMgaWdub3JlZCBjaGFyYWN0ZXJzIGF0IHN0cmluZyBzdGFydC5cbiAgICAgKi9cbiAgICB2YXIgSUdOT1JFX1JFID0gL15bXFxzXFwrPn5cXCpdKy87XG4gICAgLyoqXG4gICAgICogQSByZWdleCB3aGljaCBtYXRjaGVzIHRoZSBuZWdhdGlvbiBwc2V1ZG8tY2xhc3MgZ2xvYmFsbHkuXG4gICAgICovXG4gICAgdmFyIE5FR0FUSU9OX1JFID0gLzpub3RcXCgoW15cXCldKylcXCkvZztcbn0pKFByaXZhdGUgfHwgKFByaXZhdGUgPSB7fSkpO1xuXG5leHBvcnQgeyBDbGlwYm9hcmRFeHQsIEVsZW1lbnRFeHQsIFBsYXRmb3JtLCBTZWxlY3RvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXM2LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lumino/domutils/dist/index.es6.js\n")},"./node_modules/@lumino/dragdrop/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Drag\": () => (/* binding */ Drag)\n/* harmony export */ });\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/disposable/dist/index.es6.js\");\n\n\n/**\n * An object which manages a drag-drop operation.\n *\n * A drag object dispatches four different events to drop targets:\n *\n * - `'lm-dragenter'` - Dispatched when the mouse enters the target\n *   element. This event must be canceled in order to receive any\n *   of the other events.\n *\n * - `'lm-dragover'` - Dispatched when the mouse moves over the drop\n *   target. It must cancel the event and set the `dropAction` to one\n *   of the supported actions in order to receive drop events.\n *\n * - `'lm-dragleave'` - Dispatched when the mouse leaves the target\n *   element. This includes moving the mouse into child elements.\n *\n * - `'lm-drop'`- Dispatched when the mouse is released over the target\n *   element when the target indicates an appropriate drop action. If\n *   the event is canceled, the indicated drop action is returned to\n *   the initiator through the resolved promise.\n *\n * A drag operation can be terminated at any time by pressing `Escape`\n * or by disposing the drag object.\n *\n * A drag object has the ability to automatically scroll a scrollable\n * element when the mouse is hovered near one of its edges. To enable\n * this, add the `data-lm-dragscroll` attribute to any element which\n * the drag object should consider for scrolling.\n *\n * #### Notes\n * This class is designed to be used when dragging and dropping custom\n * data *within* a single application. It is *not* a replacement for\n * the native drag-drop API. Instead, it provides an API which allows\n * drag operations to be initiated programmatically and enables the\n * transfer of arbitrary non-string objects; features which are not\n * possible with the native drag-drop API.\n */\nvar Drag = /** @class */ (function () {\n    /**\n     * Construct a new drag object.\n     *\n     * @param options - The options for initializing the drag.\n     */\n    function Drag(options) {\n        var _this = this;\n        /**\n         * The scroll loop handler function.\n         */\n        this._onScrollFrame = function () {\n            // Bail early if there is no scroll target.\n            if (!_this._scrollTarget) {\n                return;\n            }\n            // Unpack the scroll target.\n            var _a = _this._scrollTarget, element = _a.element, edge = _a.edge, distance = _a.distance;\n            // Calculate the scroll delta using nonlinear acceleration.\n            var d = Private.SCROLL_EDGE_SIZE - distance;\n            var f = Math.pow(d / Private.SCROLL_EDGE_SIZE, 2);\n            var s = Math.max(1, Math.round(f * Private.SCROLL_EDGE_SIZE));\n            // Scroll the element in the specified direction.\n            switch (edge) {\n                case 'top':\n                    element.scrollTop -= s;\n                    break;\n                case 'left':\n                    element.scrollLeft -= s;\n                    break;\n                case 'right':\n                    element.scrollLeft += s;\n                    break;\n                case 'bottom':\n                    element.scrollTop += s;\n                    break;\n            }\n            // Request the next cycle of the scroll loop.\n            requestAnimationFrame(_this._onScrollFrame);\n        };\n        this._disposed = false;\n        this._dropAction = 'none';\n        this._override = null;\n        this._currentTarget = null;\n        this._currentElement = null;\n        this._promise = null;\n        this._scrollTarget = null;\n        this._resolve = null;\n        this.mimeData = options.mimeData;\n        this.dragImage = options.dragImage || null;\n        this.proposedAction = options.proposedAction || 'copy';\n        this.supportedActions = options.supportedActions || 'all';\n        this.source = options.source || null;\n    }\n    /**\n     * Dispose of the resources held by the drag object.\n     *\n     * #### Notes\n     * This will cancel the drag operation if it is active.\n     */\n    Drag.prototype.dispose = function () {\n        // Do nothing if the drag object is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        // If there is a current target, dispatch a drag leave event.\n        if (this._currentTarget) {\n            var event_1 = Private.createMouseEvent('mouseup', -1, -1);\n            Private.dispatchDragLeave(this, this._currentTarget, null, event_1);\n        }\n        // Finalize the drag object with `'none'`.\n        this._finalize('none');\n    };\n    Object.defineProperty(Drag.prototype, \"isDisposed\", {\n        /**\n         * Test whether the drag object is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start the drag operation at the specified client position.\n     *\n     * @param clientX - The client X position for the drag start.\n     *\n     * @param clientY - The client Y position for the drag start.\n     *\n     * @returns A promise which resolves to the result of the drag.\n     *\n     * #### Notes\n     * If the drag has already been started, the promise created by the\n     * first call to `start` is returned.\n     *\n     * If the drag operation has ended, or if the drag object has been\n     * disposed, the returned promise will resolve to `'none'`.\n     *\n     * The drag object will be automatically disposed when drag operation\n     * completes. This means `Drag` objects are for single-use only.\n     *\n     * This method assumes the left mouse button is already held down.\n     */\n    Drag.prototype.start = function (clientX, clientY) {\n        var _this = this;\n        // If the drag object is already disposed, resolve to `None`.\n        if (this._disposed) {\n            return Promise.resolve('none');\n        }\n        // If the drag has already been started, return the promise.\n        if (this._promise) {\n            return this._promise;\n        }\n        // Install the document listeners for the drag object.\n        this._addListeners();\n        // Attach the drag image at the specified client position.\n        this._attachDragImage(clientX, clientY);\n        // Create the promise which will be resolved on completion.\n        this._promise = new Promise(function (resolve, reject) {\n            _this._resolve = resolve;\n        });\n        // Trigger a fake move event to kick off the drag operation.\n        var event = Private.createMouseEvent('mousemove', clientX, clientY);\n        document.dispatchEvent(event);\n        // Return the pending promise for the drag operation.\n        return this._promise;\n    };\n    /**\n     * Handle the DOM events for the drag operation.\n     *\n     * @param event - The DOM event sent to the drag object.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the document. It should not be\n     * called directly by user code.\n     */\n    Drag.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            default:\n                // Stop all other events during drag-drop.\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * Move the drag image element to the specified location.\n     *\n     * This is a no-op if there is no drag image element.\n     */\n    Drag.prototype.moveDragImage = function (clientX, clientY) {\n        if (!this.dragImage) {\n            return;\n        }\n        var style = this.dragImage.style;\n        style.top = clientY + \"px\";\n        style.left = clientX + \"px\";\n    };\n    /**\n     * Handle the `'mousemove'` event for the drag object.\n     */\n    Drag.prototype._evtMouseMove = function (event) {\n        // Stop all input events during drag-drop.\n        event.preventDefault();\n        event.stopPropagation();\n        // Update the current target node and dispatch enter/leave events.\n        this._updateCurrentTarget(event);\n        // Update the drag scroll element.\n        this._updateDragScroll(event);\n        // Move the drag image to the specified client position. This is\n        // performed *after* dispatching to prevent unnecessary reflows.\n        this.moveDragImage(event.clientX, event.clientY);\n    };\n    /**\n     * Handle the `'mouseup'` event for the drag object.\n     */\n    Drag.prototype._evtMouseUp = function (event) {\n        // Stop all input events during drag-drop.\n        event.preventDefault();\n        event.stopPropagation();\n        // Do nothing if the left button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Update the current target node and dispatch enter/leave events.\n        // This prevents a subtle issue where the DOM mutates under the\n        // cursor after the last move event but before the drop event.\n        this._updateCurrentTarget(event);\n        // If there is no current target, finalize with `'none'`.\n        if (!this._currentTarget) {\n            this._finalize('none');\n            return;\n        }\n        // If the last drop action was `'none'`, dispatch a leave event\n        // to the current target and finalize the drag with `'none'`.\n        if (this._dropAction === 'none') {\n            Private.dispatchDragLeave(this, this._currentTarget, null, event);\n            this._finalize('none');\n            return;\n        }\n        // Dispatch the drop event at the current target and finalize\n        // with the resulting drop action.\n        var action = Private.dispatchDrop(this, this._currentTarget, event);\n        this._finalize(action);\n    };\n    /**\n     * Handle the `'keydown'` event for the drag object.\n     */\n    Drag.prototype._evtKeyDown = function (event) {\n        // Stop all input events during drag-drop.\n        event.preventDefault();\n        event.stopPropagation();\n        // Cancel the drag if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            this.dispose();\n        }\n    };\n    /**\n     * Add the document event listeners for the drag object.\n     */\n    Drag.prototype._addListeners = function () {\n        document.addEventListener('mousedown', this, true);\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('mouseenter', this, true);\n        document.addEventListener('mouseleave', this, true);\n        document.addEventListener('mouseover', this, true);\n        document.addEventListener('mouseout', this, true);\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('keyup', this, true);\n        document.addEventListener('keypress', this, true);\n        document.addEventListener('contextmenu', this, true);\n    };\n    /**\n     * Remove the document event listeners for the drag object.\n     */\n    Drag.prototype._removeListeners = function () {\n        document.removeEventListener('mousedown', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('mouseenter', this, true);\n        document.removeEventListener('mouseleave', this, true);\n        document.removeEventListener('mouseover', this, true);\n        document.removeEventListener('mouseout', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('keyup', this, true);\n        document.removeEventListener('keypress', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    };\n    /**\n     * Update the drag scroll element under the mouse.\n     */\n    Drag.prototype._updateDragScroll = function (event) {\n        // Find the scroll target under the mouse.\n        var target = Private.findScrollTarget(event);\n        // Bail if there is nothing to scroll.\n        if (!this._scrollTarget && !target) {\n            return;\n        }\n        // Start the scroll loop if needed.\n        if (!this._scrollTarget) {\n            setTimeout(this._onScrollFrame, 500);\n        }\n        // Update the scroll target.\n        this._scrollTarget = target;\n    };\n    /**\n     * Update the current target node using the given mouse event.\n     */\n    Drag.prototype._updateCurrentTarget = function (event) {\n        // Fetch common local state.\n        var prevTarget = this._currentTarget;\n        var currTarget = this._currentTarget;\n        var prevElem = this._currentElement;\n        // Find the current indicated element at the given position.\n        var currElem = document.elementFromPoint(event.clientX, event.clientY);\n        // Update the current element reference.\n        this._currentElement = currElem;\n        // If the indicated element changes from the previous iteration,\n        // and is different from the current target, dispatch the exit\n        // event to the target.\n        if (currElem !== prevElem && currElem !== currTarget) {\n            Private.dispatchDragExit(this, currTarget, currElem, event);\n        }\n        // If the indicated element changes from the previous iteration,\n        // and is different from the current target, dispatch the enter\n        // event and compute the new target element.\n        if (currElem !== prevElem && currElem !== currTarget) {\n            currTarget = Private.dispatchDragEnter(this, currElem, currTarget, event);\n        }\n        // If the current target element has changed, update the current\n        // target reference and dispatch the leave event to the old target.\n        if (currTarget !== prevTarget) {\n            this._currentTarget = currTarget;\n            Private.dispatchDragLeave(this, prevTarget, currTarget, event);\n        }\n        // Dispatch the drag over event and update the drop action.\n        var action = Private.dispatchDragOver(this, currTarget, event);\n        this._setDropAction(action);\n    };\n    /**\n     * Attach the drag image element at the specified location.\n     *\n     * This is a no-op if there is no drag image element.\n     */\n    Drag.prototype._attachDragImage = function (clientX, clientY) {\n        if (!this.dragImage) {\n            return;\n        }\n        this.dragImage.classList.add('lm-mod-drag-image');\n        /* <DEPRECATED> */\n        this.dragImage.classList.add('p-mod-drag-image');\n        /* </DEPRECATED> */\n        var style = this.dragImage.style;\n        style.pointerEvents = 'none';\n        style.position = 'fixed';\n        style.top = clientY + \"px\";\n        style.left = clientX + \"px\";\n        document.body.appendChild(this.dragImage);\n    };\n    /**\n     * Detach the drag image element from the DOM.\n     *\n     * This is a no-op if there is no drag image element.\n     */\n    Drag.prototype._detachDragImage = function () {\n        if (!this.dragImage) {\n            return;\n        }\n        var parent = this.dragImage.parentNode;\n        if (!parent) {\n            return;\n        }\n        parent.removeChild(this.dragImage);\n    };\n    /**\n     * Set the internal drop action state and update the drag cursor.\n     */\n    Drag.prototype._setDropAction = function (action) {\n        action = Private.validateAction(action, this.supportedActions);\n        if (this._override && this._dropAction === action) {\n            return;\n        }\n        switch (action) {\n            case 'none':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('no-drop');\n                break;\n            case 'copy':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('copy');\n                break;\n            case 'link':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('alias');\n                break;\n            case 'move':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('move');\n                break;\n        }\n    };\n    /**\n     * Finalize the drag operation and resolve the drag promise.\n     */\n    Drag.prototype._finalize = function (action) {\n        // Store the resolve function as a temp variable.\n        var resolve = this._resolve;\n        // Remove the document event listeners.\n        this._removeListeners();\n        // Detach the drag image.\n        this._detachDragImage();\n        // Dispose of the cursor override.\n        if (this._override) {\n            this._override.dispose();\n            this._override = null;\n        }\n        // Clear the mime data.\n        this.mimeData.clear();\n        // Clear the rest of the internal drag state.\n        this._disposed = true;\n        this._dropAction = 'none';\n        this._currentTarget = null;\n        this._currentElement = null;\n        this._scrollTarget = null;\n        this._promise = null;\n        this._resolve = null;\n        // Finally, resolve the promise to the given drop action.\n        if (resolve) {\n            resolve(action);\n        }\n    };\n    return Drag;\n}());\n/**\n * The namespace for the `Drag` class statics.\n */\n(function (Drag) {\n    /**\n     * Override the cursor icon for the entire document.\n     *\n     * @param cursor - The string representing the cursor style.\n     *\n     * @returns A disposable which will clear the override when disposed.\n     *\n     * #### Notes\n     * The most recent call to `overrideCursor` takes precedence.\n     * Disposing an old override has no effect on the current override.\n     *\n     * This utility function is used by the `Drag` class to override the\n     * mouse cursor during a drag-drop operation, but it can also be used\n     * by other classes to fix the cursor icon during normal mouse drags.\n     *\n     * #### Example\n     * ```typescript\n     * import { Drag } from '@lumino/dragdrop';\n     *\n     * // Force the cursor to be 'wait' for the entire document.\n     * let override = Drag.overrideCursor('wait');\n     *\n     * // Clear the override by disposing the return value.\n     * override.dispose();\n     * ```\n     */\n    function overrideCursor(cursor) {\n        var id = ++overrideCursorID;\n        document.body.style.cursor = cursor;\n        document.body.classList.add('lm-mod-override-cursor');\n        /* <DEPRECATED> */\n        document.body.classList.add('p-mod-override-cursor');\n        /* </DEPRECATED> */\n        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__.DisposableDelegate(function () {\n            if (id === overrideCursorID) {\n                document.body.style.cursor = '';\n                document.body.classList.remove('lm-mod-override-cursor');\n                /* <DEPRECATED> */\n                document.body.classList.remove('p-mod-override-cursor');\n                /* </DEPRECATED> */\n            }\n        });\n    }\n    Drag.overrideCursor = overrideCursor;\n    /**\n     * The internal id for the active cursor override.\n     */\n    var overrideCursorID = 0;\n})(Drag || (Drag = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The size of a drag scroll edge, in pixels.\n     */\n    Private.SCROLL_EDGE_SIZE = 20;\n    /**\n     * Validate the given action is one of the supported actions.\n     *\n     * Returns the given action or `'none'` if the action is unsupported.\n     */\n    function validateAction(action, supported) {\n        return (actionTable[action] & supportedTable[supported]) ? action : 'none';\n    }\n    Private.validateAction = validateAction;\n    /**\n     * Create a left mouse event at the given position.\n     *\n     * @param type - The event type for the mouse event.\n     *\n     * @param clientX - The client X position.\n     *\n     * @param clientY - The client Y position.\n     *\n     * @returns A newly created and initialized mouse event.\n     */\n    function createMouseEvent(type, clientX, clientY) {\n        var event = document.createEvent('MouseEvent');\n        event.initMouseEvent(type, true, true, window, 0, 0, 0, clientX, clientY, false, false, false, false, 0, null);\n        return event;\n    }\n    Private.createMouseEvent = createMouseEvent;\n    /**\n     * Find the drag scroll target under the mouse, if any.\n     */\n    function findScrollTarget(event) {\n        // Look up the client mouse position.\n        var x = event.clientX;\n        var y = event.clientY;\n        // Get the element under the mouse.\n        var element = document.elementFromPoint(x, y);\n        // Search for a scrollable target based on the mouse position.\n        // The null assert in third clause of for-loop is required due to:\n        // https://github.com/Microsoft/TypeScript/issues/14143\n        for (; element; element = element.parentElement) {\n            // Ignore elements which are not marked as scrollable.\n            var scrollable = element.hasAttribute('data-lm-dragscroll');\n            /* <DEPRECATED> */\n            scrollable = scrollable || element.hasAttribute('data-p-dragscroll');\n            /* </DEPRECATED> */\n            if (!scrollable) {\n                continue;\n            }\n            // Set up the coordinate offsets for the element.\n            var offsetX = 0;\n            var offsetY = 0;\n            if (element === document.body) {\n                offsetX = window.pageXOffset;\n                offsetY = window.pageYOffset;\n            }\n            // Get the element bounds in viewport coordinates.\n            var r = element.getBoundingClientRect();\n            var top_1 = r.top + offsetY;\n            var left = r.left + offsetX;\n            var right = left + r.width;\n            var bottom = top_1 + r.height;\n            // Skip the element if it's not under the mouse.\n            if (x < left || x >= right || y < top_1 || y >= bottom) {\n                continue;\n            }\n            // Compute the distance to each edge.\n            var dl = x - left + 1;\n            var dt = y - top_1 + 1;\n            var dr = right - x;\n            var db = bottom - y;\n            // Find the smallest of the edge distances.\n            var distance = Math.min(dl, dt, dr, db);\n            // Skip the element if the mouse is not within a scroll edge.\n            if (distance > Private.SCROLL_EDGE_SIZE) {\n                continue;\n            }\n            // Set up the edge result variable.\n            var edge = void 0;\n            // Find the edge for the computed distance.\n            switch (distance) {\n                case db:\n                    edge = 'bottom';\n                    break;\n                case dt:\n                    edge = 'top';\n                    break;\n                case dr:\n                    edge = 'right';\n                    break;\n                case dl:\n                    edge = 'left';\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n            // Compute how much the element can scroll in width and height.\n            var dsw = element.scrollWidth - element.clientWidth;\n            var dsh = element.scrollHeight - element.clientHeight;\n            // Determine if the element should be scrolled for the edge.\n            var shouldScroll = void 0;\n            switch (edge) {\n                case 'top':\n                    shouldScroll = dsh > 0 && element.scrollTop > 0;\n                    break;\n                case 'left':\n                    shouldScroll = dsw > 0 && element.scrollLeft > 0;\n                    break;\n                case 'right':\n                    shouldScroll = dsw > 0 && element.scrollLeft < dsw;\n                    break;\n                case 'bottom':\n                    shouldScroll = dsh > 0 && element.scrollTop < dsh;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n            // Skip the element if it should not be scrolled.\n            if (!shouldScroll) {\n                continue;\n            }\n            // Return the drag scroll target.\n            return { element: element, edge: edge, distance: distance };\n        }\n        // No drag scroll target was found.\n        return null;\n    }\n    Private.findScrollTarget = findScrollTarget;\n    /**\n     * Dispatch a drag enter event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param currElem - The currently indicated element, or `null`. This\n     *   is the \"immediate user selection\" from the whatwg spec.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * @returns The element to use as the current drag target. This is the\n     *   \"current target element\" from the whatwg spec, and may be `null`.\n     *\n     * #### Notes\n     * This largely implements the drag enter portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragEnter(drag, currElem, currTarget, event) {\n        // If the current element is null, return null as the new target.\n        if (!currElem) {\n            return null;\n        }\n        // Dispatch a drag enter event to the current element.\n        var dragEvent = createDragEvent('lm-dragenter', drag, event, currTarget);\n        var canceled = !currElem.dispatchEvent(dragEvent);\n        // If the event was canceled, use the current element as the new target.\n        if (canceled) {\n            return currElem;\n        }\n        /* <DEPRECATED> */\n        dragEvent = createDragEvent('p-dragenter', drag, event, currTarget);\n        canceled = !currElem.dispatchEvent(dragEvent);\n        if (canceled) {\n            return currElem;\n        }\n        /* </DEPRECATED> */\n        // If the current element is the document body, keep the original target.\n        if (currElem === document.body) {\n            return currTarget;\n        }\n        // Dispatch a drag enter event on the document body.\n        dragEvent = createDragEvent('lm-dragenter', drag, event, currTarget);\n        document.body.dispatchEvent(dragEvent);\n        /* <DEPRECATED> */\n        dragEvent = createDragEvent('p-dragenter', drag, event, currTarget);\n        document.body.dispatchEvent(dragEvent);\n        /* </DEPRECATED> */\n        // Ignore the event cancellation, and use the body as the new target.\n        return document.body;\n    }\n    Private.dispatchDragEnter = dispatchDragEnter;\n    /**\n     * Dispatch a drag exit event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param prevTarget - The previous target element, or `null`. This\n     *   is the previous \"current target element\" from the whatwg spec.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * #### Notes\n     * This largely implements the drag exit portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragExit(drag, prevTarget, currTarget, event) {\n        // If the previous target is null, do nothing.\n        if (!prevTarget) {\n            return;\n        }\n        // Dispatch the drag exit event to the previous target.\n        var dragEvent = createDragEvent('lm-dragexit', drag, event, currTarget);\n        prevTarget.dispatchEvent(dragEvent);\n        /* <DEPRECATED> */\n        dragEvent = createDragEvent('p-dragexit', drag, event, currTarget);\n        prevTarget.dispatchEvent(dragEvent);\n        /* </DEPRECATED> */\n    }\n    Private.dispatchDragExit = dispatchDragExit;\n    /**\n     * Dispatch a drag leave event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param prevTarget - The previous target element, or `null`. This\n     *   is the previous \"current target element\" from the whatwg spec.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * #### Notes\n     * This largely implements the drag leave portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragLeave(drag, prevTarget, currTarget, event) {\n        // If the previous target is null, do nothing.\n        if (!prevTarget) {\n            return;\n        }\n        // Dispatch the drag leave event to the previous target.\n        var dragEvent = createDragEvent('lm-dragleave', drag, event, currTarget);\n        prevTarget.dispatchEvent(dragEvent);\n        /* <DEPRECATED> */\n        dragEvent = createDragEvent('p-dragleave', drag, event, currTarget);\n        prevTarget.dispatchEvent(dragEvent);\n        /* </DEPRECATED> */\n    }\n    Private.dispatchDragLeave = dispatchDragLeave;\n    /**\n     * Dispatch a drag over event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * @returns The `DropAction` result of the drag over event.\n     *\n     * #### Notes\n     * This largely implements the drag over portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragOver(drag, currTarget, event) {\n        // If there is no current target, the drop action is none.\n        if (!currTarget) {\n            return 'none';\n        }\n        // Dispatch the drag over event to the current target.\n        var dragEvent = createDragEvent('lm-dragover', drag, event, null);\n        var canceled = !currTarget.dispatchEvent(dragEvent);\n        // If the event was canceled, return the drop action result.\n        if (canceled) {\n            return dragEvent.dropAction;\n        }\n        /* <DEPRECATED> */\n        dragEvent = createDragEvent('p-dragover', drag, event, null);\n        canceled = !currTarget.dispatchEvent(dragEvent);\n        if (canceled) {\n            return dragEvent.dropAction;\n        }\n        /* </DEPRECATED> */\n        // Otherwise, the effective drop action is none.\n        return 'none';\n    }\n    Private.dispatchDragOver = dispatchDragOver;\n    /**\n     * Dispatch a drop event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * @returns The `DropAction` result of the drop event.\n     *\n     * #### Notes\n     * This largely implements the drag over portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDrop(drag, currTarget, event) {\n        // If there is no current target, the drop action is none.\n        if (!currTarget) {\n            return 'none';\n        }\n        // Dispatch the drop event to the current target.\n        var dragEvent = createDragEvent('lm-drop', drag, event, null);\n        var canceled = !currTarget.dispatchEvent(dragEvent);\n        // If the event was canceled, return the drop action result.\n        if (canceled) {\n            return dragEvent.dropAction;\n        }\n        /* <DEPRECATED> */\n        dragEvent = createDragEvent('p-drop', drag, event, null);\n        canceled = !currTarget.dispatchEvent(dragEvent);\n        if (canceled) {\n            return dragEvent.dropAction;\n        }\n        /* </DEPRECATED> */\n        // Otherwise, the effective drop action is none.\n        return 'none';\n    }\n    Private.dispatchDrop = dispatchDrop;\n    /**\n     * A lookup table from drop action to bit value.\n     */\n    var actionTable = {\n        'none': 0x0,\n        'copy': 0x1,\n        'link': 0x2,\n        'move': 0x4\n    };\n    /**\n     * A lookup table from supported action to drop action bit mask.\n     */\n    var supportedTable = {\n        'none': actionTable['none'],\n        'copy': actionTable['copy'],\n        'link': actionTable['link'],\n        'move': actionTable['move'],\n        'copy-link': actionTable['copy'] | actionTable['link'],\n        'copy-move': actionTable['copy'] | actionTable['move'],\n        'link-move': actionTable['link'] | actionTable['move'],\n        'all': actionTable['copy'] | actionTable['link'] | actionTable['move']\n    };\n    /**\n     * Create a new initialized `IDragEvent` from the given data.\n     *\n     * @param type - The event type for the drag event.\n     *\n     * @param drag - The drag object to use for seeding the drag data.\n     *\n     * @param event - The mouse event to use for seeding the mouse data.\n     *\n     * @param related - The related target for the event, or `null`.\n     *\n     * @returns A new object which implements `IDragEvent`.\n     */\n    function createDragEvent(type, drag, event, related) {\n        // Create a new mouse event to use as the drag event. Currently,\n        // JS engines do now allow user-defined Event subclasses.\n        var dragEvent = document.createEvent('MouseEvent');\n        // Initialize the mouse event data.\n        dragEvent.initMouseEvent(type, true, true, window, 0, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, related);\n        // Forcefully add the custom drag event properties.\n        dragEvent.dropAction = 'none';\n        dragEvent.mimeData = drag.mimeData;\n        dragEvent.proposedAction = drag.proposedAction;\n        dragEvent.supportedActions = drag.supportedActions;\n        dragEvent.source = drag.source;\n        // Return the fully initialized drag event.\n        return dragEvent;\n    }\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9kcmFnZHJvcC9kaXN0L2luZGV4LmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUVYO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vZHJhZ2Ryb3AvZGlzdC9pbmRleC5lczYuanM/YTNlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXNwb3NhYmxlRGVsZWdhdGUgfSBmcm9tICdAbHVtaW5vL2Rpc3Bvc2FibGUnO1xuXG4vKipcbiAqIEFuIG9iamVjdCB3aGljaCBtYW5hZ2VzIGEgZHJhZy1kcm9wIG9wZXJhdGlvbi5cbiAqXG4gKiBBIGRyYWcgb2JqZWN0IGRpc3BhdGNoZXMgZm91ciBkaWZmZXJlbnQgZXZlbnRzIHRvIGRyb3AgdGFyZ2V0czpcbiAqXG4gKiAtIGAnbG0tZHJhZ2VudGVyJ2AgLSBEaXNwYXRjaGVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgdGFyZ2V0XG4gKiAgIGVsZW1lbnQuIFRoaXMgZXZlbnQgbXVzdCBiZSBjYW5jZWxlZCBpbiBvcmRlciB0byByZWNlaXZlIGFueVxuICogICBvZiB0aGUgb3RoZXIgZXZlbnRzLlxuICpcbiAqIC0gYCdsbS1kcmFnb3ZlcidgIC0gRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBkcm9wXG4gKiAgIHRhcmdldC4gSXQgbXVzdCBjYW5jZWwgdGhlIGV2ZW50IGFuZCBzZXQgdGhlIGBkcm9wQWN0aW9uYCB0byBvbmVcbiAqICAgb2YgdGhlIHN1cHBvcnRlZCBhY3Rpb25zIGluIG9yZGVyIHRvIHJlY2VpdmUgZHJvcCBldmVudHMuXG4gKlxuICogLSBgJ2xtLWRyYWdsZWF2ZSdgIC0gRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIHRhcmdldFxuICogICBlbGVtZW50LiBUaGlzIGluY2x1ZGVzIG1vdmluZyB0aGUgbW91c2UgaW50byBjaGlsZCBlbGVtZW50cy5cbiAqXG4gKiAtIGAnbG0tZHJvcCdgLSBEaXNwYXRjaGVkIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkIG92ZXIgdGhlIHRhcmdldFxuICogICBlbGVtZW50IHdoZW4gdGhlIHRhcmdldCBpbmRpY2F0ZXMgYW4gYXBwcm9wcmlhdGUgZHJvcCBhY3Rpb24uIElmXG4gKiAgIHRoZSBldmVudCBpcyBjYW5jZWxlZCwgdGhlIGluZGljYXRlZCBkcm9wIGFjdGlvbiBpcyByZXR1cm5lZCB0b1xuICogICB0aGUgaW5pdGlhdG9yIHRocm91Z2ggdGhlIHJlc29sdmVkIHByb21pc2UuXG4gKlxuICogQSBkcmFnIG9wZXJhdGlvbiBjYW4gYmUgdGVybWluYXRlZCBhdCBhbnkgdGltZSBieSBwcmVzc2luZyBgRXNjYXBlYFxuICogb3IgYnkgZGlzcG9zaW5nIHRoZSBkcmFnIG9iamVjdC5cbiAqXG4gKiBBIGRyYWcgb2JqZWN0IGhhcyB0aGUgYWJpbGl0eSB0byBhdXRvbWF0aWNhbGx5IHNjcm9sbCBhIHNjcm9sbGFibGVcbiAqIGVsZW1lbnQgd2hlbiB0aGUgbW91c2UgaXMgaG92ZXJlZCBuZWFyIG9uZSBvZiBpdHMgZWRnZXMuIFRvIGVuYWJsZVxuICogdGhpcywgYWRkIHRoZSBgZGF0YS1sbS1kcmFnc2Nyb2xsYCBhdHRyaWJ1dGUgdG8gYW55IGVsZW1lbnQgd2hpY2hcbiAqIHRoZSBkcmFnIG9iamVjdCBzaG91bGQgY29uc2lkZXIgZm9yIHNjcm9sbGluZy5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2hlbiBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgY3VzdG9tXG4gKiBkYXRhICp3aXRoaW4qIGEgc2luZ2xlIGFwcGxpY2F0aW9uLiBJdCBpcyAqbm90KiBhIHJlcGxhY2VtZW50IGZvclxuICogdGhlIG5hdGl2ZSBkcmFnLWRyb3AgQVBJLiBJbnN0ZWFkLCBpdCBwcm92aWRlcyBhbiBBUEkgd2hpY2ggYWxsb3dzXG4gKiBkcmFnIG9wZXJhdGlvbnMgdG8gYmUgaW5pdGlhdGVkIHByb2dyYW1tYXRpY2FsbHkgYW5kIGVuYWJsZXMgdGhlXG4gKiB0cmFuc2ZlciBvZiBhcmJpdHJhcnkgbm9uLXN0cmluZyBvYmplY3RzOyBmZWF0dXJlcyB3aGljaCBhcmUgbm90XG4gKiBwb3NzaWJsZSB3aXRoIHRoZSBuYXRpdmUgZHJhZy1kcm9wIEFQSS5cbiAqL1xudmFyIERyYWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGRyYWcgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBkcmFnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERyYWcob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjcm9sbCBsb29wIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblNjcm9sbEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBpcyBubyBzY3JvbGwgdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKCFfdGhpcy5fc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5wYWNrIHRoZSBzY3JvbGwgdGFyZ2V0LlxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuX3Njcm9sbFRhcmdldCwgZWxlbWVudCA9IF9hLmVsZW1lbnQsIGVkZ2UgPSBfYS5lZGdlLCBkaXN0YW5jZSA9IF9hLmRpc3RhbmNlO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY3JvbGwgZGVsdGEgdXNpbmcgbm9ubGluZWFyIGFjY2VsZXJhdGlvbi5cbiAgICAgICAgICAgIHZhciBkID0gUHJpdmF0ZS5TQ1JPTExfRURHRV9TSVpFIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICB2YXIgZiA9IE1hdGgucG93KGQgLyBQcml2YXRlLlNDUk9MTF9FREdFX1NJWkUsIDIpO1xuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGYgKiBQcml2YXRlLlNDUk9MTF9FREdFX1NJWkUpKTtcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0aGUgZWxlbWVudCBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIHN3aXRjaCAoZWRnZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wIC09IHM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgLT0gcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgKz0gcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSBuZXh0IGN5Y2xlIG9mIHRoZSBzY3JvbGwgbG9vcC5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy5fb25TY3JvbGxGcmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Ryb3BBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX292ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICB0aGlzLm1pbWVEYXRhID0gb3B0aW9ucy5taW1lRGF0YTtcbiAgICAgICAgdGhpcy5kcmFnSW1hZ2UgPSBvcHRpb25zLmRyYWdJbWFnZSB8fCBudWxsO1xuICAgICAgICB0aGlzLnByb3Bvc2VkQWN0aW9uID0gb3B0aW9ucy5wcm9wb3NlZEFjdGlvbiB8fCAnY29weSc7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkQWN0aW9ucyA9IG9wdGlvbnMuc3VwcG9ydGVkQWN0aW9ucyB8fCAnYWxsJztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBvcHRpb25zLnNvdXJjZSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgZHJhZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIGNhbmNlbCB0aGUgZHJhZyBvcGVyYXRpb24gaWYgaXQgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIERyYWcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGRyYWcgb2JqZWN0IGlzIGFscmVhZHkgZGlzcG9zZWQuXG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBjdXJyZW50IHRhcmdldCwgZGlzcGF0Y2ggYSBkcmFnIGxlYXZlIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBQcml2YXRlLmNyZWF0ZU1vdXNlRXZlbnQoJ21vdXNldXAnLCAtMSwgLTEpO1xuICAgICAgICAgICAgUHJpdmF0ZS5kaXNwYXRjaERyYWdMZWF2ZSh0aGlzLCB0aGlzLl9jdXJyZW50VGFyZ2V0LCBudWxsLCBldmVudF8xKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgZHJhZyBvYmplY3Qgd2l0aCBgJ25vbmUnYC5cbiAgICAgICAgdGhpcy5fZmluYWxpemUoJ25vbmUnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEcmFnLnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgZHJhZyBvYmplY3QgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIGRyYWcgb3BlcmF0aW9uIGF0IHRoZSBzcGVjaWZpZWQgY2xpZW50IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudFggLSBUaGUgY2xpZW50IFggcG9zaXRpb24gZm9yIHRoZSBkcmFnIHN0YXJ0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudFkgLSBUaGUgY2xpZW50IFkgcG9zaXRpb24gZm9yIHRoZSBkcmFnIHN0YXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgdGhlIGRyYWcuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIGRyYWcgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkLCB0aGUgcHJvbWlzZSBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGZpcnN0IGNhbGwgdG8gYHN0YXJ0YCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBkcmFnIG9wZXJhdGlvbiBoYXMgZW5kZWQsIG9yIGlmIHRoZSBkcmFnIG9iamVjdCBoYXMgYmVlblxuICAgICAqIGRpc3Bvc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIHJlc29sdmUgdG8gYCdub25lJ2AuXG4gICAgICpcbiAgICAgKiBUaGUgZHJhZyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRpc3Bvc2VkIHdoZW4gZHJhZyBvcGVyYXRpb25cbiAgICAgKiBjb21wbGV0ZXMuIFRoaXMgbWVhbnMgYERyYWdgIG9iamVjdHMgYXJlIGZvciBzaW5nbGUtdXNlIG9ubHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBhbHJlYWR5IGhlbGQgZG93bi5cbiAgICAgKi9cbiAgICBEcmFnLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSBkcmFnIG9iamVjdCBpcyBhbHJlYWR5IGRpc3Bvc2VkLCByZXNvbHZlIHRvIGBOb25lYC5cbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdub25lJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGRyYWcgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkLCByZXR1cm4gdGhlIHByb21pc2UuXG4gICAgICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnN0YWxsIHRoZSBkb2N1bWVudCBsaXN0ZW5lcnMgZm9yIHRoZSBkcmFnIG9iamVjdC5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIEF0dGFjaCB0aGUgZHJhZyBpbWFnZSBhdCB0aGUgc3BlY2lmaWVkIGNsaWVudCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5fYXR0YWNoRHJhZ0ltYWdlKGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uLlxuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpZ2dlciBhIGZha2UgbW92ZSBldmVudCB0byBraWNrIG9mZiB0aGUgZHJhZyBvcGVyYXRpb24uXG4gICAgICAgIHZhciBldmVudCA9IFByaXZhdGUuY3JlYXRlTW91c2VFdmVudCgnbW91c2Vtb3ZlJywgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHBlbmRpbmcgcHJvbWlzZSBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIERPTSBldmVudCBzZW50IHRvIHRoZSBkcmFnIG9iamVjdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBET00gYEV2ZW50TGlzdGVuZXJgIGludGVyZmFjZSBhbmQgaXNcbiAgICAgKiBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gZXZlbnRzIG9uIHRoZSBkb2N1bWVudC4gSXQgc2hvdWxkIG5vdCBiZVxuICAgICAqIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgRHJhZy5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZVVwKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dEtleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTdG9wIGFsbCBvdGhlciBldmVudHMgZHVyaW5nIGRyYWctZHJvcC5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBkcmFnIGltYWdlIGVsZW1lbnQgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBuby1vcCBpZiB0aGVyZSBpcyBubyBkcmFnIGltYWdlIGVsZW1lbnQuXG4gICAgICovXG4gICAgRHJhZy5wcm90b3R5cGUubW92ZURyYWdJbWFnZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnSW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmRyYWdJbWFnZS5zdHlsZTtcbiAgICAgICAgc3R5bGUudG9wID0gY2xpZW50WSArIFwicHhcIjtcbiAgICAgICAgc3R5bGUubGVmdCA9IGNsaWVudFggKyBcInB4XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vtb3ZlJ2AgZXZlbnQgZm9yIHRoZSBkcmFnIG9iamVjdC5cbiAgICAgKi9cbiAgICBEcmFnLnByb3RvdHlwZS5fZXZ0TW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGlucHV0IGV2ZW50cyBkdXJpbmcgZHJhZy1kcm9wLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHRhcmdldCBub2RlIGFuZCBkaXNwYXRjaCBlbnRlci9sZWF2ZSBldmVudHMuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGRyYWcgc2Nyb2xsIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX3VwZGF0ZURyYWdTY3JvbGwoZXZlbnQpO1xuICAgICAgICAvLyBNb3ZlIHRoZSBkcmFnIGltYWdlIHRvIHRoZSBzcGVjaWZpZWQgY2xpZW50IHBvc2l0aW9uLiBUaGlzIGlzXG4gICAgICAgIC8vIHBlcmZvcm1lZCAqYWZ0ZXIqIGRpc3BhdGNoaW5nIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVmbG93cy5cbiAgICAgICAgdGhpcy5tb3ZlRHJhZ0ltYWdlKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNldXAnYCBldmVudCBmb3IgdGhlIGRyYWcgb2JqZWN0LlxuICAgICAqL1xuICAgIERyYWcucHJvdG90eXBlLl9ldnRNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGlucHV0IGV2ZW50cyBkdXJpbmcgZHJhZy1kcm9wLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbGVmdCBidXR0b24gaXMgbm90IHJlbGVhc2VkLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHRhcmdldCBub2RlIGFuZCBkaXNwYXRjaCBlbnRlci9sZWF2ZSBldmVudHMuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgYSBzdWJ0bGUgaXNzdWUgd2hlcmUgdGhlIERPTSBtdXRhdGVzIHVuZGVyIHRoZVxuICAgICAgICAvLyBjdXJzb3IgYWZ0ZXIgdGhlIGxhc3QgbW92ZSBldmVudCBidXQgYmVmb3JlIHRoZSBkcm9wIGV2ZW50LlxuICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY3VycmVudCB0YXJnZXQsIGZpbmFsaXplIHdpdGggYCdub25lJ2AuXG4gICAgICAgIGlmICghdGhpcy5fY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemUoJ25vbmUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkcm9wIGFjdGlvbiB3YXMgYCdub25lJ2AsIGRpc3BhdGNoIGEgbGVhdmUgZXZlbnRcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgdGFyZ2V0IGFuZCBmaW5hbGl6ZSB0aGUgZHJhZyB3aXRoIGAnbm9uZSdgLlxuICAgICAgICBpZiAodGhpcy5fZHJvcEFjdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBQcml2YXRlLmRpc3BhdGNoRHJhZ0xlYXZlKHRoaXMsIHRoaXMuX2N1cnJlbnRUYXJnZXQsIG51bGwsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplKCdub25lJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGRyb3AgZXZlbnQgYXQgdGhlIGN1cnJlbnQgdGFyZ2V0IGFuZCBmaW5hbGl6ZVxuICAgICAgICAvLyB3aXRoIHRoZSByZXN1bHRpbmcgZHJvcCBhY3Rpb24uXG4gICAgICAgIHZhciBhY3Rpb24gPSBQcml2YXRlLmRpc3BhdGNoRHJvcCh0aGlzLCB0aGlzLl9jdXJyZW50VGFyZ2V0LCBldmVudCk7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplKGFjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAna2V5ZG93bidgIGV2ZW50IGZvciB0aGUgZHJhZyBvYmplY3QuXG4gICAgICovXG4gICAgRHJhZy5wcm90b3R5cGUuX2V2dEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcCBhbGwgaW5wdXQgZXZlbnRzIGR1cmluZyBkcmFnLWRyb3AuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRyYWcgaWYgYEVzY2FwZWAgaXMgcHJlc3NlZC5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBkb2N1bWVudCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBkcmFnIG9iamVjdC5cbiAgICAgKi9cbiAgICBEcmFnLnByb3RvdHlwZS5fYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIGRyYWcgb2JqZWN0LlxuICAgICAqL1xuICAgIERyYWcucHJvdG90eXBlLl9yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZHJhZyBzY3JvbGwgZWxlbWVudCB1bmRlciB0aGUgbW91c2UuXG4gICAgICovXG4gICAgRHJhZy5wcm90b3R5cGUuX3VwZGF0ZURyYWdTY3JvbGwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgc2Nyb2xsIHRhcmdldCB1bmRlciB0aGUgbW91c2UuXG4gICAgICAgIHZhciB0YXJnZXQgPSBQcml2YXRlLmZpbmRTY3JvbGxUYXJnZXQoZXZlbnQpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gc2Nyb2xsLlxuICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbFRhcmdldCAmJiAhdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgdGhlIHNjcm9sbCBsb29wIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fb25TY3JvbGxGcmFtZSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNjcm9sbCB0YXJnZXQuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldCA9IHRhcmdldDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY3VycmVudCB0YXJnZXQgbm9kZSB1c2luZyB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgRHJhZy5wcm90b3R5cGUuX3VwZGF0ZUN1cnJlbnRUYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRmV0Y2ggY29tbW9uIGxvY2FsIHN0YXRlLlxuICAgICAgICB2YXIgcHJldlRhcmdldCA9IHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHZhciBjdXJyVGFyZ2V0ID0gdGhpcy5fY3VycmVudFRhcmdldDtcbiAgICAgICAgdmFyIHByZXZFbGVtID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgIC8vIEZpbmQgdGhlIGN1cnJlbnQgaW5kaWNhdGVkIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICB2YXIgY3VyckVsZW0gPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgZWxlbWVudCByZWZlcmVuY2UuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gY3VyckVsZW07XG4gICAgICAgIC8vIElmIHRoZSBpbmRpY2F0ZWQgZWxlbWVudCBjaGFuZ2VzIGZyb20gdGhlIHByZXZpb3VzIGl0ZXJhdGlvbixcbiAgICAgICAgLy8gYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHRhcmdldCwgZGlzcGF0Y2ggdGhlIGV4aXRcbiAgICAgICAgLy8gZXZlbnQgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgaWYgKGN1cnJFbGVtICE9PSBwcmV2RWxlbSAmJiBjdXJyRWxlbSAhPT0gY3VyclRhcmdldCkge1xuICAgICAgICAgICAgUHJpdmF0ZS5kaXNwYXRjaERyYWdFeGl0KHRoaXMsIGN1cnJUYXJnZXQsIGN1cnJFbGVtLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGluZGljYXRlZCBlbGVtZW50IGNoYW5nZXMgZnJvbSB0aGUgcHJldmlvdXMgaXRlcmF0aW9uLFxuICAgICAgICAvLyBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgdGFyZ2V0LCBkaXNwYXRjaCB0aGUgZW50ZXJcbiAgICAgICAgLy8gZXZlbnQgYW5kIGNvbXB1dGUgdGhlIG5ldyB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgaWYgKGN1cnJFbGVtICE9PSBwcmV2RWxlbSAmJiBjdXJyRWxlbSAhPT0gY3VyclRhcmdldCkge1xuICAgICAgICAgICAgY3VyclRhcmdldCA9IFByaXZhdGUuZGlzcGF0Y2hEcmFnRW50ZXIodGhpcywgY3VyckVsZW0sIGN1cnJUYXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHRhcmdldCByZWZlcmVuY2UgYW5kIGRpc3BhdGNoIHRoZSBsZWF2ZSBldmVudCB0byB0aGUgb2xkIHRhcmdldC5cbiAgICAgICAgaWYgKGN1cnJUYXJnZXQgIT09IHByZXZUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBjdXJyVGFyZ2V0O1xuICAgICAgICAgICAgUHJpdmF0ZS5kaXNwYXRjaERyYWdMZWF2ZSh0aGlzLCBwcmV2VGFyZ2V0LCBjdXJyVGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGRyYWcgb3ZlciBldmVudCBhbmQgdXBkYXRlIHRoZSBkcm9wIGFjdGlvbi5cbiAgICAgICAgdmFyIGFjdGlvbiA9IFByaXZhdGUuZGlzcGF0Y2hEcmFnT3Zlcih0aGlzLCBjdXJyVGFyZ2V0LCBldmVudCk7XG4gICAgICAgIHRoaXMuX3NldERyb3BBY3Rpb24oYWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZHJhZyBpbWFnZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gZHJhZyBpbWFnZSBlbGVtZW50LlxuICAgICAqL1xuICAgIERyYWcucHJvdG90eXBlLl9hdHRhY2hEcmFnSW1hZ2UgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ0ltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnSW1hZ2UuY2xhc3NMaXN0LmFkZCgnbG0tbW9kLWRyYWctaW1hZ2UnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIHRoaXMuZHJhZ0ltYWdlLmNsYXNzTGlzdC5hZGQoJ3AtbW9kLWRyYWctaW1hZ2UnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmRyYWdJbWFnZS5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBzdHlsZS50b3AgPSBjbGllbnRZICsgXCJweFwiO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gY2xpZW50WCArIFwicHhcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdJbWFnZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIGRyYWcgaW1hZ2UgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gZHJhZyBpbWFnZSBlbGVtZW50LlxuICAgICAqL1xuICAgIERyYWcucHJvdG90eXBlLl9kZXRhY2hEcmFnSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnSW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5kcmFnSW1hZ2UucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5kcmFnSW1hZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbnRlcm5hbCBkcm9wIGFjdGlvbiBzdGF0ZSBhbmQgdXBkYXRlIHRoZSBkcmFnIGN1cnNvci5cbiAgICAgKi9cbiAgICBEcmFnLnByb3RvdHlwZS5fc2V0RHJvcEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgYWN0aW9uID0gUHJpdmF0ZS52YWxpZGF0ZUFjdGlvbihhY3Rpb24sIHRoaXMuc3VwcG9ydGVkQWN0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLl9vdmVycmlkZSAmJiB0aGlzLl9kcm9wQWN0aW9uID09PSBhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJvcEFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdmVycmlkZSA9IERyYWcub3ZlcnJpZGVDdXJzb3IoJ25vLWRyb3AnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvcHknOlxuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSBEcmFnLm92ZXJyaWRlQ3Vyc29yKCdjb3B5Jyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wQWN0aW9uID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuX292ZXJyaWRlID0gRHJhZy5vdmVycmlkZUN1cnNvcignYWxpYXMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSBEcmFnLm92ZXJyaWRlQ3Vyc29yKCdtb3ZlJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmFsaXplIHRoZSBkcmFnIG9wZXJhdGlvbiBhbmQgcmVzb2x2ZSB0aGUgZHJhZyBwcm9taXNlLlxuICAgICAqL1xuICAgIERyYWcucHJvdG90eXBlLl9maW5hbGl6ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIHJlc29sdmUgZnVuY3Rpb24gYXMgYSB0ZW1wIHZhcmlhYmxlLlxuICAgICAgICB2YXIgcmVzb2x2ZSA9IHRoaXMuX3Jlc29sdmU7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZG9jdW1lbnQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgLy8gRGV0YWNoIHRoZSBkcmFnIGltYWdlLlxuICAgICAgICB0aGlzLl9kZXRhY2hEcmFnSW1hZ2UoKTtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgY3Vyc29yIG92ZXJyaWRlLlxuICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJyaWRlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0aGUgbWltZSBkYXRhLlxuICAgICAgICB0aGlzLm1pbWVEYXRhLmNsZWFyKCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSByZXN0IG9mIHRoZSBpbnRlcm5hbCBkcmFnIHN0YXRlLlxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Ryb3BBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgLy8gRmluYWxseSwgcmVzb2x2ZSB0aGUgcHJvbWlzZSB0byB0aGUgZ2l2ZW4gZHJvcCBhY3Rpb24uXG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEcmFnO1xufSgpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIGBEcmFnYCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKERyYWcpIHtcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgY3Vyc29yIGljb24gZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3Vyc29yIC0gVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnNvciBzdHlsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZGlzcG9zYWJsZSB3aGljaCB3aWxsIGNsZWFyIHRoZSBvdmVycmlkZSB3aGVuIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBtb3N0IHJlY2VudCBjYWxsIHRvIGBvdmVycmlkZUN1cnNvcmAgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgKiBEaXNwb3NpbmcgYW4gb2xkIG92ZXJyaWRlIGhhcyBubyBlZmZlY3Qgb24gdGhlIGN1cnJlbnQgb3ZlcnJpZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgYERyYWdgIGNsYXNzIHRvIG92ZXJyaWRlIHRoZVxuICAgICAqIG1vdXNlIGN1cnNvciBkdXJpbmcgYSBkcmFnLWRyb3Agb3BlcmF0aW9uLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZFxuICAgICAqIGJ5IG90aGVyIGNsYXNzZXMgdG8gZml4IHRoZSBjdXJzb3IgaWNvbiBkdXJpbmcgbm9ybWFsIG1vdXNlIGRyYWdzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IERyYWcgfSBmcm9tICdAbHVtaW5vL2RyYWdkcm9wJztcbiAgICAgKlxuICAgICAqIC8vIEZvcmNlIHRoZSBjdXJzb3IgdG8gYmUgJ3dhaXQnIGZvciB0aGUgZW50aXJlIGRvY3VtZW50LlxuICAgICAqIGxldCBvdmVycmlkZSA9IERyYWcub3ZlcnJpZGVDdXJzb3IoJ3dhaXQnKTtcbiAgICAgKlxuICAgICAqIC8vIENsZWFyIHRoZSBvdmVycmlkZSBieSBkaXNwb3NpbmcgdGhlIHJldHVybiB2YWx1ZS5cbiAgICAgKiBvdmVycmlkZS5kaXNwb3NlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcnJpZGVDdXJzb3IoY3Vyc29yKSB7XG4gICAgICAgIHZhciBpZCA9ICsrb3ZlcnJpZGVDdXJzb3JJRDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnbG0tbW9kLW92ZXJyaWRlLWN1cnNvcicpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdwLW1vZC1vdmVycmlkZS1jdXJzb3InKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICByZXR1cm4gbmV3IERpc3Bvc2FibGVEZWxlZ2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaWQgPT09IG92ZXJyaWRlQ3Vyc29ySUQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbG0tbW9kLW92ZXJyaWRlLWN1cnNvcicpO1xuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgncC1tb2Qtb3ZlcnJpZGUtY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgRHJhZy5vdmVycmlkZUN1cnNvciA9IG92ZXJyaWRlQ3Vyc29yO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBpZCBmb3IgdGhlIGFjdGl2ZSBjdXJzb3Igb3ZlcnJpZGUuXG4gICAgICovXG4gICAgdmFyIG92ZXJyaWRlQ3Vyc29ySUQgPSAwO1xufSkoRHJhZyB8fCAoRHJhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGU7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiBhIGRyYWcgc2Nyb2xsIGVkZ2UsIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBQcml2YXRlLlNDUk9MTF9FREdFX1NJWkUgPSAyMDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gYWN0aW9uIGlzIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBhY3Rpb24gb3IgYCdub25lJ2AgaWYgdGhlIGFjdGlvbiBpcyB1bnN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFjdGlvbihhY3Rpb24sIHN1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm4gKGFjdGlvblRhYmxlW2FjdGlvbl0gJiBzdXBwb3J0ZWRUYWJsZVtzdXBwb3J0ZWRdKSA/IGFjdGlvbiA6ICdub25lJztcbiAgICB9XG4gICAgUHJpdmF0ZS52YWxpZGF0ZUFjdGlvbiA9IHZhbGlkYXRlQWN0aW9uO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxlZnQgbW91c2UgZXZlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXZlbnQgdHlwZSBmb3IgdGhlIG1vdXNlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsaWVudFggLSBUaGUgY2xpZW50IFggcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50WSAtIFRoZSBjbGllbnQgWSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3bHkgY3JlYXRlZCBhbmQgaW5pdGlhbGl6ZWQgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTW91c2VFdmVudCh0eXBlLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgY2xpZW50WCwgY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlTW91c2VFdmVudCA9IGNyZWF0ZU1vdXNlRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZHJhZyBzY3JvbGwgdGFyZ2V0IHVuZGVyIHRoZSBtb3VzZSwgaWYgYW55LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRTY3JvbGxUYXJnZXQoZXZlbnQpIHtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgY2xpZW50IG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICB2YXIgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IHVuZGVyIHRoZSBtb3VzZS5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGEgc2Nyb2xsYWJsZSB0YXJnZXQgYmFzZWQgb24gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICAvLyBUaGUgbnVsbCBhc3NlcnQgaW4gdGhpcmQgY2xhdXNlIG9mIGZvci1sb29wIGlzIHJlcXVpcmVkIGR1ZSB0bzpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNDE0M1xuICAgICAgICBmb3IgKDsgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVsZW1lbnRzIHdoaWNoIGFyZSBub3QgbWFya2VkIGFzIHNjcm9sbGFibGUuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsYWJsZSA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWxtLWRyYWdzY3JvbGwnKTtcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgc2Nyb2xsYWJsZSA9IHNjcm9sbGFibGUgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcC1kcmFnc2Nyb2xsJyk7XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAoIXNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgY29vcmRpbmF0ZSBvZmZzZXRzIGZvciB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IGJvdW5kcyBpbiB2aWV3cG9ydCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZhciByID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IHIudG9wICsgb2Zmc2V0WTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gci5sZWZ0ICsgb2Zmc2V0WDtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyByLndpZHRoO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRvcF8xICsgci5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBlbGVtZW50IGlmIGl0J3Mgbm90IHVuZGVyIHRoZSBtb3VzZS5cbiAgICAgICAgICAgIGlmICh4IDwgbGVmdCB8fCB4ID49IHJpZ2h0IHx8IHkgPCB0b3BfMSB8fCB5ID49IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8gZWFjaCBlZGdlLlxuICAgICAgICAgICAgdmFyIGRsID0geCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIGR0ID0geSAtIHRvcF8xICsgMTtcbiAgICAgICAgICAgIHZhciBkciA9IHJpZ2h0IC0geDtcbiAgICAgICAgICAgIHZhciBkYiA9IGJvdHRvbSAtIHk7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBvZiB0aGUgZWRnZSBkaXN0YW5jZXMuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1pbihkbCwgZHQsIGRyLCBkYik7XG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBlbGVtZW50IGlmIHRoZSBtb3VzZSBpcyBub3Qgd2l0aGluIGEgc2Nyb2xsIGVkZ2UuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBQcml2YXRlLlNDUk9MTF9FREdFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgZWRnZSByZXN1bHQgdmFyaWFibGUuXG4gICAgICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGVkZ2UgZm9yIHRoZSBjb21wdXRlZCBkaXN0YW5jZS5cbiAgICAgICAgICAgIHN3aXRjaCAoZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGRiOlxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZHQ6XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBkcjpcbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZGw6XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIGhvdyBtdWNoIHRoZSBlbGVtZW50IGNhbiBzY3JvbGwgaW4gd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgICAgIHZhciBkc3cgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHZhciBkc2ggPSBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IHNob3VsZCBiZSBzY3JvbGxlZCBmb3IgdGhlIGVkZ2UuXG4gICAgICAgICAgICB2YXIgc2hvdWxkU2Nyb2xsID0gdm9pZCAwO1xuICAgICAgICAgICAgc3dpdGNoIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gZHNoID4gMCAmJiBlbGVtZW50LnNjcm9sbFRvcCA+IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSBkc3cgPiAwICYmIGVsZW1lbnQuc2Nyb2xsTGVmdCA+IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gZHN3ID4gMCAmJiBlbGVtZW50LnNjcm9sbExlZnQgPCBkc3c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IGRzaCA+IDAgJiYgZWxlbWVudC5zY3JvbGxUb3AgPCBkc2g7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBlbGVtZW50IGlmIGl0IHNob3VsZCBub3QgYmUgc2Nyb2xsZWQuXG4gICAgICAgICAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBkcmFnIHNjcm9sbCB0YXJnZXQuXG4gICAgICAgICAgICByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBlZGdlOiBlZGdlLCBkaXN0YW5jZTogZGlzdGFuY2UgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBkcmFnIHNjcm9sbCB0YXJnZXQgd2FzIGZvdW5kLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgUHJpdmF0ZS5maW5kU2Nyb2xsVGFyZ2V0ID0gZmluZFNjcm9sbFRhcmdldDtcbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGRyYWcgZW50ZXIgZXZlbnQgdG8gdGhlIGluZGljYXRlZCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRyYWcgLSBUaGUgZHJhZyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VyckVsZW0gLSBUaGUgY3VycmVudGx5IGluZGljYXRlZCBlbGVtZW50LCBvciBgbnVsbGAuIFRoaXNcbiAgICAgKiAgIGlzIHRoZSBcImltbWVkaWF0ZSB1c2VyIHNlbGVjdGlvblwiIGZyb20gdGhlIHdoYXR3ZyBzcGVjLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cnJUYXJnZXQgLSBUaGUgY3VycmVudCBkcmFnIHRhcmdldCBlbGVtZW50LCBvciBgbnVsbGAuIFRoaXNcbiAgICAgKiAgIGlzIHRoZSBcImN1cnJlbnQgdGFyZ2V0IGVsZW1lbnRcIiBmcm9tIHRoZSB3aGF0d2cgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBldmVudCByZWxhdGVkIHRvIHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCB0byB1c2UgYXMgdGhlIGN1cnJlbnQgZHJhZyB0YXJnZXQuIFRoaXMgaXMgdGhlXG4gICAgICogICBcImN1cnJlbnQgdGFyZ2V0IGVsZW1lbnRcIiBmcm9tIHRoZSB3aGF0d2cgc3BlYywgYW5kIG1heSBiZSBgbnVsbGAuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBsYXJnZWx5IGltcGxlbWVudHMgdGhlIGRyYWcgZW50ZXIgcG9ydGlvbiBvZiB0aGUgd2hhdHdnIHNwZWM6XG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNkcmFnLWFuZC1kcm9wLXByb2Nlc3NpbmctbW9kZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXNwYXRjaERyYWdFbnRlcihkcmFnLCBjdXJyRWxlbSwgY3VyclRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBudWxsLCByZXR1cm4gbnVsbCBhcyB0aGUgbmV3IHRhcmdldC5cbiAgICAgICAgaWYgKCFjdXJyRWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcGF0Y2ggYSBkcmFnIGVudGVyIGV2ZW50IHRvIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgIHZhciBkcmFnRXZlbnQgPSBjcmVhdGVEcmFnRXZlbnQoJ2xtLWRyYWdlbnRlcicsIGRyYWcsIGV2ZW50LCBjdXJyVGFyZ2V0KTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gIWN1cnJFbGVtLmRpc3BhdGNoRXZlbnQoZHJhZ0V2ZW50KTtcbiAgICAgICAgLy8gSWYgdGhlIGV2ZW50IHdhcyBjYW5jZWxlZCwgdXNlIHRoZSBjdXJyZW50IGVsZW1lbnQgYXMgdGhlIG5ldyB0YXJnZXQuXG4gICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJFbGVtO1xuICAgICAgICB9XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBkcmFnRXZlbnQgPSBjcmVhdGVEcmFnRXZlbnQoJ3AtZHJhZ2VudGVyJywgZHJhZywgZXZlbnQsIGN1cnJUYXJnZXQpO1xuICAgICAgICBjYW5jZWxlZCA9ICFjdXJyRWxlbS5kaXNwYXRjaEV2ZW50KGRyYWdFdmVudCk7XG4gICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJFbGVtO1xuICAgICAgICB9XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyB0aGUgZG9jdW1lbnQgYm9keSwga2VlcCB0aGUgb3JpZ2luYWwgdGFyZ2V0LlxuICAgICAgICBpZiAoY3VyckVsZW0gPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3BhdGNoIGEgZHJhZyBlbnRlciBldmVudCBvbiB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgICAgZHJhZ0V2ZW50ID0gY3JlYXRlRHJhZ0V2ZW50KCdsbS1kcmFnZW50ZXInLCBkcmFnLCBldmVudCwgY3VyclRhcmdldCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuZGlzcGF0Y2hFdmVudChkcmFnRXZlbnQpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgZHJhZ0V2ZW50ID0gY3JlYXRlRHJhZ0V2ZW50KCdwLWRyYWdlbnRlcicsIGRyYWcsIGV2ZW50LCBjdXJyVGFyZ2V0KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5kaXNwYXRjaEV2ZW50KGRyYWdFdmVudCk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBjYW5jZWxsYXRpb24sIGFuZCB1c2UgdGhlIGJvZHkgYXMgdGhlIG5ldyB0YXJnZXQuXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICBQcml2YXRlLmRpc3BhdGNoRHJhZ0VudGVyID0gZGlzcGF0Y2hEcmFnRW50ZXI7XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBkcmFnIGV4aXQgZXZlbnQgdG8gdGhlIGluZGljYXRlZCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRyYWcgLSBUaGUgZHJhZyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJldlRhcmdldCAtIFRoZSBwcmV2aW91cyB0YXJnZXQgZWxlbWVudCwgb3IgYG51bGxgLiBUaGlzXG4gICAgICogICBpcyB0aGUgcHJldmlvdXMgXCJjdXJyZW50IHRhcmdldCBlbGVtZW50XCIgZnJvbSB0aGUgd2hhdHdnIHNwZWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VyclRhcmdldCAtIFRoZSBjdXJyZW50IGRyYWcgdGFyZ2V0IGVsZW1lbnQsIG9yIGBudWxsYC4gVGhpc1xuICAgICAqICAgaXMgdGhlIFwiY3VycmVudCB0YXJnZXQgZWxlbWVudFwiIGZyb20gdGhlIHdoYXR3ZyBzcGVjLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50IHJlbGF0ZWQgdG8gdGhlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxhcmdlbHkgaW1wbGVtZW50cyB0aGUgZHJhZyBleGl0IHBvcnRpb24gb2YgdGhlIHdoYXR3ZyBzcGVjOlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjZHJhZy1hbmQtZHJvcC1wcm9jZXNzaW5nLW1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hEcmFnRXhpdChkcmFnLCBwcmV2VGFyZ2V0LCBjdXJyVGFyZ2V0LCBldmVudCkge1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGFyZ2V0IGlzIG51bGwsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICghcHJldlRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3BhdGNoIHRoZSBkcmFnIGV4aXQgZXZlbnQgdG8gdGhlIHByZXZpb3VzIHRhcmdldC5cbiAgICAgICAgdmFyIGRyYWdFdmVudCA9IGNyZWF0ZURyYWdFdmVudCgnbG0tZHJhZ2V4aXQnLCBkcmFnLCBldmVudCwgY3VyclRhcmdldCk7XG4gICAgICAgIHByZXZUYXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnRXZlbnQpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgZHJhZ0V2ZW50ID0gY3JlYXRlRHJhZ0V2ZW50KCdwLWRyYWdleGl0JywgZHJhZywgZXZlbnQsIGN1cnJUYXJnZXQpO1xuICAgICAgICBwcmV2VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZHJhZ0V2ZW50KTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgIH1cbiAgICBQcml2YXRlLmRpc3BhdGNoRHJhZ0V4aXQgPSBkaXNwYXRjaERyYWdFeGl0O1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZHJhZyBsZWF2ZSBldmVudCB0byB0aGUgaW5kaWNhdGVkIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZHJhZyAtIFRoZSBkcmFnIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmV2VGFyZ2V0IC0gVGhlIHByZXZpb3VzIHRhcmdldCBlbGVtZW50LCBvciBgbnVsbGAuIFRoaXNcbiAgICAgKiAgIGlzIHRoZSBwcmV2aW91cyBcImN1cnJlbnQgdGFyZ2V0IGVsZW1lbnRcIiBmcm9tIHRoZSB3aGF0d2cgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJyVGFyZ2V0IC0gVGhlIGN1cnJlbnQgZHJhZyB0YXJnZXQgZWxlbWVudCwgb3IgYG51bGxgLiBUaGlzXG4gICAgICogICBpcyB0aGUgXCJjdXJyZW50IHRhcmdldCBlbGVtZW50XCIgZnJvbSB0aGUgd2hhdHdnIHNwZWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQgcmVsYXRlZCB0byB0aGUgYWN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbGFyZ2VseSBpbXBsZW1lbnRzIHRoZSBkcmFnIGxlYXZlIHBvcnRpb24gb2YgdGhlIHdoYXR3ZyBzcGVjOlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjZHJhZy1hbmQtZHJvcC1wcm9jZXNzaW5nLW1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hEcmFnTGVhdmUoZHJhZywgcHJldlRhcmdldCwgY3VyclRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHRhcmdldCBpcyBudWxsLCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoIXByZXZUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZHJhZyBsZWF2ZSBldmVudCB0byB0aGUgcHJldmlvdXMgdGFyZ2V0LlxuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gY3JlYXRlRHJhZ0V2ZW50KCdsbS1kcmFnbGVhdmUnLCBkcmFnLCBldmVudCwgY3VyclRhcmdldCk7XG4gICAgICAgIHByZXZUYXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnRXZlbnQpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgZHJhZ0V2ZW50ID0gY3JlYXRlRHJhZ0V2ZW50KCdwLWRyYWdsZWF2ZScsIGRyYWcsIGV2ZW50LCBjdXJyVGFyZ2V0KTtcbiAgICAgICAgcHJldlRhcmdldC5kaXNwYXRjaEV2ZW50KGRyYWdFdmVudCk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICB9XG4gICAgUHJpdmF0ZS5kaXNwYXRjaERyYWdMZWF2ZSA9IGRpc3BhdGNoRHJhZ0xlYXZlO1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZHJhZyBvdmVyIGV2ZW50IHRvIHRoZSBpbmRpY2F0ZWQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFnIC0gVGhlIGRyYWcgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cnJUYXJnZXQgLSBUaGUgY3VycmVudCBkcmFnIHRhcmdldCBlbGVtZW50LCBvciBgbnVsbGAuIFRoaXNcbiAgICAgKiAgIGlzIHRoZSBcImN1cnJlbnQgdGFyZ2V0IGVsZW1lbnRcIiBmcm9tIHRoZSB3aGF0d2cgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBldmVudCByZWxhdGVkIHRvIHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYERyb3BBY3Rpb25gIHJlc3VsdCBvZiB0aGUgZHJhZyBvdmVyIGV2ZW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbGFyZ2VseSBpbXBsZW1lbnRzIHRoZSBkcmFnIG92ZXIgcG9ydGlvbiBvZiB0aGUgd2hhdHdnIHNwZWM6XG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNkcmFnLWFuZC1kcm9wLXByb2Nlc3NpbmctbW9kZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXNwYXRjaERyYWdPdmVyKGRyYWcsIGN1cnJUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgdGFyZ2V0LCB0aGUgZHJvcCBhY3Rpb24gaXMgbm9uZS5cbiAgICAgICAgaWYgKCFjdXJyVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3BhdGNoIHRoZSBkcmFnIG92ZXIgZXZlbnQgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0LlxuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gY3JlYXRlRHJhZ0V2ZW50KCdsbS1kcmFnb3ZlcicsIGRyYWcsIGV2ZW50LCBudWxsKTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gIWN1cnJUYXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnRXZlbnQpO1xuICAgICAgICAvLyBJZiB0aGUgZXZlbnQgd2FzIGNhbmNlbGVkLCByZXR1cm4gdGhlIGRyb3AgYWN0aW9uIHJlc3VsdC5cbiAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZ0V2ZW50LmRyb3BBY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIGRyYWdFdmVudCA9IGNyZWF0ZURyYWdFdmVudCgncC1kcmFnb3ZlcicsIGRyYWcsIGV2ZW50LCBudWxsKTtcbiAgICAgICAgY2FuY2VsZWQgPSAhY3VyclRhcmdldC5kaXNwYXRjaEV2ZW50KGRyYWdFdmVudCk7XG4gICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWdFdmVudC5kcm9wQWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZWZmZWN0aXZlIGRyb3AgYWN0aW9uIGlzIG5vbmUuXG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgfVxuICAgIFByaXZhdGUuZGlzcGF0Y2hEcmFnT3ZlciA9IGRpc3BhdGNoRHJhZ092ZXI7XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBkcm9wIGV2ZW50IHRvIHRoZSBpbmRpY2F0ZWQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFnIC0gVGhlIGRyYWcgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cnJUYXJnZXQgLSBUaGUgY3VycmVudCBkcmFnIHRhcmdldCBlbGVtZW50LCBvciBgbnVsbGAuIFRoaXNcbiAgICAgKiAgIGlzIHRoZSBcImN1cnJlbnQgdGFyZ2V0IGVsZW1lbnRcIiBmcm9tIHRoZSB3aGF0d2cgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBldmVudCByZWxhdGVkIHRvIHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYERyb3BBY3Rpb25gIHJlc3VsdCBvZiB0aGUgZHJvcCBldmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxhcmdlbHkgaW1wbGVtZW50cyB0aGUgZHJhZyBvdmVyIHBvcnRpb24gb2YgdGhlIHdoYXR3ZyBzcGVjOlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjZHJhZy1hbmQtZHJvcC1wcm9jZXNzaW5nLW1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hEcm9wKGRyYWcsIGN1cnJUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgdGFyZ2V0LCB0aGUgZHJvcCBhY3Rpb24gaXMgbm9uZS5cbiAgICAgICAgaWYgKCFjdXJyVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3BhdGNoIHRoZSBkcm9wIGV2ZW50IHRvIHRoZSBjdXJyZW50IHRhcmdldC5cbiAgICAgICAgdmFyIGRyYWdFdmVudCA9IGNyZWF0ZURyYWdFdmVudCgnbG0tZHJvcCcsIGRyYWcsIGV2ZW50LCBudWxsKTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gIWN1cnJUYXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnRXZlbnQpO1xuICAgICAgICAvLyBJZiB0aGUgZXZlbnQgd2FzIGNhbmNlbGVkLCByZXR1cm4gdGhlIGRyb3AgYWN0aW9uIHJlc3VsdC5cbiAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZ0V2ZW50LmRyb3BBY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIGRyYWdFdmVudCA9IGNyZWF0ZURyYWdFdmVudCgncC1kcm9wJywgZHJhZywgZXZlbnQsIG51bGwpO1xuICAgICAgICBjYW5jZWxlZCA9ICFjdXJyVGFyZ2V0LmRpc3BhdGNoRXZlbnQoZHJhZ0V2ZW50KTtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZ0V2ZW50LmRyb3BBY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBlZmZlY3RpdmUgZHJvcCBhY3Rpb24gaXMgbm9uZS5cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG4gICAgUHJpdmF0ZS5kaXNwYXRjaERyb3AgPSBkaXNwYXRjaERyb3A7XG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgdGFibGUgZnJvbSBkcm9wIGFjdGlvbiB0byBiaXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGFjdGlvblRhYmxlID0ge1xuICAgICAgICAnbm9uZSc6IDB4MCxcbiAgICAgICAgJ2NvcHknOiAweDEsXG4gICAgICAgICdsaW5rJzogMHgyLFxuICAgICAgICAnbW92ZSc6IDB4NFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgdGFibGUgZnJvbSBzdXBwb3J0ZWQgYWN0aW9uIHRvIGRyb3AgYWN0aW9uIGJpdCBtYXNrLlxuICAgICAqL1xuICAgIHZhciBzdXBwb3J0ZWRUYWJsZSA9IHtcbiAgICAgICAgJ25vbmUnOiBhY3Rpb25UYWJsZVsnbm9uZSddLFxuICAgICAgICAnY29weSc6IGFjdGlvblRhYmxlWydjb3B5J10sXG4gICAgICAgICdsaW5rJzogYWN0aW9uVGFibGVbJ2xpbmsnXSxcbiAgICAgICAgJ21vdmUnOiBhY3Rpb25UYWJsZVsnbW92ZSddLFxuICAgICAgICAnY29weS1saW5rJzogYWN0aW9uVGFibGVbJ2NvcHknXSB8IGFjdGlvblRhYmxlWydsaW5rJ10sXG4gICAgICAgICdjb3B5LW1vdmUnOiBhY3Rpb25UYWJsZVsnY29weSddIHwgYWN0aW9uVGFibGVbJ21vdmUnXSxcbiAgICAgICAgJ2xpbmstbW92ZSc6IGFjdGlvblRhYmxlWydsaW5rJ10gfCBhY3Rpb25UYWJsZVsnbW92ZSddLFxuICAgICAgICAnYWxsJzogYWN0aW9uVGFibGVbJ2NvcHknXSB8IGFjdGlvblRhYmxlWydsaW5rJ10gfCBhY3Rpb25UYWJsZVsnbW92ZSddXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5pdGlhbGl6ZWQgYElEcmFnRXZlbnRgIGZyb20gdGhlIGdpdmVuIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBldmVudCB0eXBlIGZvciB0aGUgZHJhZyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFnIC0gVGhlIGRyYWcgb2JqZWN0IHRvIHVzZSBmb3Igc2VlZGluZyB0aGUgZHJhZyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50IHRvIHVzZSBmb3Igc2VlZGluZyB0aGUgbW91c2UgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGVkIC0gVGhlIHJlbGF0ZWQgdGFyZ2V0IGZvciB0aGUgZXZlbnQsIG9yIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIGBJRHJhZ0V2ZW50YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFnRXZlbnQodHlwZSwgZHJhZywgZXZlbnQsIHJlbGF0ZWQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1vdXNlIGV2ZW50IHRvIHVzZSBhcyB0aGUgZHJhZyBldmVudC4gQ3VycmVudGx5LFxuICAgICAgICAvLyBKUyBlbmdpbmVzIGRvIG5vdyBhbGxvdyB1c2VyLWRlZmluZWQgRXZlbnQgc3ViY2xhc3Nlcy5cbiAgICAgICAgdmFyIGRyYWdFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1vdXNlIGV2ZW50IGRhdGEuXG4gICAgICAgIGRyYWdFdmVudC5pbml0TW91c2VFdmVudCh0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIGV2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblksIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFksIGV2ZW50LmN0cmxLZXksIGV2ZW50LmFsdEtleSwgZXZlbnQuc2hpZnRLZXksIGV2ZW50Lm1ldGFLZXksIGV2ZW50LmJ1dHRvbiwgcmVsYXRlZCk7XG4gICAgICAgIC8vIEZvcmNlZnVsbHkgYWRkIHRoZSBjdXN0b20gZHJhZyBldmVudCBwcm9wZXJ0aWVzLlxuICAgICAgICBkcmFnRXZlbnQuZHJvcEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgZHJhZ0V2ZW50Lm1pbWVEYXRhID0gZHJhZy5taW1lRGF0YTtcbiAgICAgICAgZHJhZ0V2ZW50LnByb3Bvc2VkQWN0aW9uID0gZHJhZy5wcm9wb3NlZEFjdGlvbjtcbiAgICAgICAgZHJhZ0V2ZW50LnN1cHBvcnRlZEFjdGlvbnMgPSBkcmFnLnN1cHBvcnRlZEFjdGlvbnM7XG4gICAgICAgIGRyYWdFdmVudC5zb3VyY2UgPSBkcmFnLnNvdXJjZTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBmdWxseSBpbml0aWFsaXplZCBkcmFnIGV2ZW50LlxuICAgICAgICByZXR1cm4gZHJhZ0V2ZW50O1xuICAgIH1cbn0pKFByaXZhdGUgfHwgKFByaXZhdGUgPSB7fSkpO1xuXG5leHBvcnQgeyBEcmFnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/dragdrop/dist/index.es6.js\n")},"./node_modules/@lumino/keyboard/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EN_US\": () => (/* binding */ EN_US),\n/* harmony export */   \"KeycodeLayout\": () => (/* binding */ KeycodeLayout),\n/* harmony export */   \"getKeyboardLayout\": () => (/* binding */ getKeyboardLayout),\n/* harmony export */   \"setKeyboardLayout\": () => (/* binding */ setKeyboardLayout)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Get the global application keyboard layout instance.\n *\n * @returns The keyboard layout for use by the application.\n *\n * #### Notes\n * The default keyboard layout is US-English.\n */\nfunction getKeyboardLayout() {\n    return Private.keyboardLayout;\n}\n/**\n * Set the global application keyboard layout instance.\n *\n * @param - The keyboard layout for use by the application.\n *\n * #### Notes\n * The keyboard layout should typically be set on application startup\n * to a layout which is appropriate for the user's system.\n */\nfunction setKeyboardLayout(layout) {\n    Private.keyboardLayout = layout;\n}\n/**\n * A concrete implementation of [[IKeyboardLayout]] based on keycodes.\n *\n * The `keyCode` property of a `'keydown'` event is a browser and OS\n * specific representation of the physical key (not character) which\n * was pressed on a keyboard. While not the most convenient API, it\n * is currently the only one which works reliably on all browsers.\n *\n * This class accepts a user-defined mapping of keycode to key, which\n * allows for reliable shortcuts tailored to the user's system.\n */\nvar KeycodeLayout = /** @class */ (function () {\n    /**\n     * Construct a new keycode layout.\n     *\n     * @param name - The human readable name for the layout.\n     *\n     * @param codes - A mapping of keycode to key value.\n     */\n    function KeycodeLayout(name, codes) {\n        this.name = name;\n        this._codes = codes;\n        this._keys = KeycodeLayout.extractKeys(codes);\n    }\n    /**\n     * Get an array of the key values supported by the layout.\n     *\n     * @returns A new array of the supported key values.\n     */\n    KeycodeLayout.prototype.keys = function () {\n        return Object.keys(this._keys);\n    };\n    /**\n     * Test whether the given key is a valid value for the layout.\n     *\n     * @param key - The user provided key to test for validity.\n     *\n     * @returns `true` if the key is valid, `false` otherwise.\n     */\n    KeycodeLayout.prototype.isValidKey = function (key) {\n        return key in this._keys;\n    };\n    /**\n     * Get the key for a `'keydown'` event.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     *\n     * @returns The associated key value, or an empty string if\n     *   the event does not represent a valid primary key.\n     */\n    KeycodeLayout.prototype.keyForKeydownEvent = function (event) {\n        return this._codes[event.keyCode] || '';\n    };\n    return KeycodeLayout;\n}());\n/**\n * The namespace for the `KeycodeLayout` class statics.\n */\n(function (KeycodeLayout) {\n    /**\n     * Extract the set of keys from a code map.\n     *\n     * @param code - The code map of interest.\n     *\n     * @returns A set of the keys in the code map.\n     */\n    function extractKeys(codes) {\n        var keys = Object.create(null);\n        for (var c in codes) {\n            keys[codes[c]] = true;\n        }\n        return keys;\n    }\n    KeycodeLayout.extractKeys = extractKeys;\n})(KeycodeLayout || (KeycodeLayout = {}));\n/**\n * A keycode-based keyboard layout for US English keyboards.\n *\n * This layout is valid for the following OS/Browser combinations.\n *\n * - Windows\n *   - Chrome\n *   - Firefox\n *   - IE\n *\n * - OSX\n *   - Chrome\n *   - Firefox\n *   - Safari\n *\n * - Linux\n *   - Chrome\n *   - Firefox\n *\n * Other combinations may also work, but are untested.\n */\nvar EN_US = new KeycodeLayout('en-us', {\n    8: 'Backspace',\n    9: 'Tab',\n    13: 'Enter',\n    19: 'Pause',\n    27: 'Escape',\n    32: 'Space',\n    33: 'PageUp',\n    34: 'PageDown',\n    35: 'End',\n    36: 'Home',\n    37: 'ArrowLeft',\n    38: 'ArrowUp',\n    39: 'ArrowRight',\n    40: 'ArrowDown',\n    45: 'Insert',\n    46: 'Delete',\n    48: '0',\n    49: '1',\n    50: '2',\n    51: '3',\n    52: '4',\n    53: '5',\n    54: '6',\n    55: '7',\n    56: '8',\n    57: '9',\n    59: ';',\n    61: '=',\n    65: 'A',\n    66: 'B',\n    67: 'C',\n    68: 'D',\n    69: 'E',\n    70: 'F',\n    71: 'G',\n    72: 'H',\n    73: 'I',\n    74: 'J',\n    75: 'K',\n    76: 'L',\n    77: 'M',\n    78: 'N',\n    79: 'O',\n    80: 'P',\n    81: 'Q',\n    82: 'R',\n    83: 'S',\n    84: 'T',\n    85: 'U',\n    86: 'V',\n    87: 'W',\n    88: 'X',\n    89: 'Y',\n    90: 'Z',\n    93: 'ContextMenu',\n    96: '0',\n    97: '1',\n    98: '2',\n    99: '3',\n    100: '4',\n    101: '5',\n    102: '6',\n    103: '7',\n    104: '8',\n    105: '9',\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    112: 'F1',\n    113: 'F2',\n    114: 'F3',\n    115: 'F4',\n    116: 'F5',\n    117: 'F6',\n    118: 'F7',\n    119: 'F8',\n    120: 'F9',\n    121: 'F10',\n    122: 'F11',\n    123: 'F12',\n    173: '-',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n});\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The global keyboard layout instance.\n     */\n    Private.keyboardLayout = EN_US;\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9rZXlib2FyZC9kaXN0L2luZGV4LmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUyQztBQUN0RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhZnNoaW4vbGlmZS8uL25vZGVfbW9kdWxlcy9AbHVtaW5vL2tleWJvYXJkL2Rpc3QvaW5kZXguZXM2LmpzPzAxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgUGhvc3Bob3JKUyBDb250cmlidXRvcnNcbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBMSUNFTlNFLCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEdldCB0aGUgZ2xvYmFsIGFwcGxpY2F0aW9uIGtleWJvYXJkIGxheW91dCBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUga2V5Ym9hcmQgbGF5b3V0IGZvciB1c2UgYnkgdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoZSBkZWZhdWx0IGtleWJvYXJkIGxheW91dCBpcyBVUy1FbmdsaXNoLlxuICovXG5mdW5jdGlvbiBnZXRLZXlib2FyZExheW91dCgpIHtcbiAgICByZXR1cm4gUHJpdmF0ZS5rZXlib2FyZExheW91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBnbG9iYWwgYXBwbGljYXRpb24ga2V5Ym9hcmQgbGF5b3V0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAtIFRoZSBrZXlib2FyZCBsYXlvdXQgZm9yIHVzZSBieSB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhlIGtleWJvYXJkIGxheW91dCBzaG91bGQgdHlwaWNhbGx5IGJlIHNldCBvbiBhcHBsaWNhdGlvbiBzdGFydHVwXG4gKiB0byBhIGxheW91dCB3aGljaCBpcyBhcHByb3ByaWF0ZSBmb3IgdGhlIHVzZXIncyBzeXN0ZW0uXG4gKi9cbmZ1bmN0aW9uIHNldEtleWJvYXJkTGF5b3V0KGxheW91dCkge1xuICAgIFByaXZhdGUua2V5Ym9hcmRMYXlvdXQgPSBsYXlvdXQ7XG59XG4vKipcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgW1tJS2V5Ym9hcmRMYXlvdXRdXSBiYXNlZCBvbiBrZXljb2Rlcy5cbiAqXG4gKiBUaGUgYGtleUNvZGVgIHByb3BlcnR5IG9mIGEgYCdrZXlkb3duJ2AgZXZlbnQgaXMgYSBicm93c2VyIGFuZCBPU1xuICogc3BlY2lmaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBoeXNpY2FsIGtleSAobm90IGNoYXJhY3Rlcikgd2hpY2hcbiAqIHdhcyBwcmVzc2VkIG9uIGEga2V5Ym9hcmQuIFdoaWxlIG5vdCB0aGUgbW9zdCBjb252ZW5pZW50IEFQSSwgaXRcbiAqIGlzIGN1cnJlbnRseSB0aGUgb25seSBvbmUgd2hpY2ggd29ya3MgcmVsaWFibHkgb24gYWxsIGJyb3dzZXJzLlxuICpcbiAqIFRoaXMgY2xhc3MgYWNjZXB0cyBhIHVzZXItZGVmaW5lZCBtYXBwaW5nIG9mIGtleWNvZGUgdG8ga2V5LCB3aGljaFxuICogYWxsb3dzIGZvciByZWxpYWJsZSBzaG9ydGN1dHMgdGFpbG9yZWQgdG8gdGhlIHVzZXIncyBzeXN0ZW0uXG4gKi9cbnZhciBLZXljb2RlTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBrZXljb2RlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXMgLSBBIG1hcHBpbmcgb2Yga2V5Y29kZSB0byBrZXkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gS2V5Y29kZUxheW91dChuYW1lLCBjb2Rlcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9jb2RlcyA9IGNvZGVzO1xuICAgICAgICB0aGlzLl9rZXlzID0gS2V5Y29kZUxheW91dC5leHRyYWN0S2V5cyhjb2Rlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhcnJheSBvZiB0aGUga2V5IHZhbHVlcyBzdXBwb3J0ZWQgYnkgdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIHRoZSBzdXBwb3J0ZWQga2V5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBLZXljb2RlTGF5b3V0LnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fa2V5cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBhIHZhbGlkIHZhbHVlIGZvciB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSB1c2VyIHByb3ZpZGVkIGtleSB0byB0ZXN0IGZvciB2YWxpZGl0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUga2V5IGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBLZXljb2RlTGF5b3V0LnByb3RvdHlwZS5pc1ZhbGlkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHRoaXMuX2tleXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGtleSBmb3IgYSBgJ2tleWRvd24nYCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgZm9yIGEgYCdrZXlkb3duJ2AgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYXNzb2NpYXRlZCBrZXkgdmFsdWUsIG9yIGFuIGVtcHR5IHN0cmluZyBpZlxuICAgICAqICAgdGhlIGV2ZW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbGlkIHByaW1hcnkga2V5LlxuICAgICAqL1xuICAgIEtleWNvZGVMYXlvdXQucHJvdG90eXBlLmtleUZvcktleWRvd25FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29kZXNbZXZlbnQua2V5Q29kZV0gfHwgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5Y29kZUxheW91dDtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgS2V5Y29kZUxheW91dGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChLZXljb2RlTGF5b3V0KSB7XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgc2V0IG9mIGtleXMgZnJvbSBhIGNvZGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSBtYXAgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHNldCBvZiB0aGUga2V5cyBpbiB0aGUgY29kZSBtYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0cmFjdEtleXMoY29kZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKHZhciBjIGluIGNvZGVzKSB7XG4gICAgICAgICAgICBrZXlzW2NvZGVzW2NdXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIEtleWNvZGVMYXlvdXQuZXh0cmFjdEtleXMgPSBleHRyYWN0S2V5cztcbn0pKEtleWNvZGVMYXlvdXQgfHwgKEtleWNvZGVMYXlvdXQgPSB7fSkpO1xuLyoqXG4gKiBBIGtleWNvZGUtYmFzZWQga2V5Ym9hcmQgbGF5b3V0IGZvciBVUyBFbmdsaXNoIGtleWJvYXJkcy5cbiAqXG4gKiBUaGlzIGxheW91dCBpcyB2YWxpZCBmb3IgdGhlIGZvbGxvd2luZyBPUy9Ccm93c2VyIGNvbWJpbmF0aW9ucy5cbiAqXG4gKiAtIFdpbmRvd3NcbiAqICAgLSBDaHJvbWVcbiAqICAgLSBGaXJlZm94XG4gKiAgIC0gSUVcbiAqXG4gKiAtIE9TWFxuICogICAtIENocm9tZVxuICogICAtIEZpcmVmb3hcbiAqICAgLSBTYWZhcmlcbiAqXG4gKiAtIExpbnV4XG4gKiAgIC0gQ2hyb21lXG4gKiAgIC0gRmlyZWZveFxuICpcbiAqIE90aGVyIGNvbWJpbmF0aW9ucyBtYXkgYWxzbyB3b3JrLCBidXQgYXJlIHVudGVzdGVkLlxuICovXG52YXIgRU5fVVMgPSBuZXcgS2V5Y29kZUxheW91dCgnZW4tdXMnLCB7XG4gICAgODogJ0JhY2tzcGFjZScsXG4gICAgOTogJ1RhYicsXG4gICAgMTM6ICdFbnRlcicsXG4gICAgMTk6ICdQYXVzZScsXG4gICAgMjc6ICdFc2NhcGUnLFxuICAgIDMyOiAnU3BhY2UnLFxuICAgIDMzOiAnUGFnZVVwJyxcbiAgICAzNDogJ1BhZ2VEb3duJyxcbiAgICAzNTogJ0VuZCcsXG4gICAgMzY6ICdIb21lJyxcbiAgICAzNzogJ0Fycm93TGVmdCcsXG4gICAgMzg6ICdBcnJvd1VwJyxcbiAgICAzOTogJ0Fycm93UmlnaHQnLFxuICAgIDQwOiAnQXJyb3dEb3duJyxcbiAgICA0NTogJ0luc2VydCcsXG4gICAgNDY6ICdEZWxldGUnLFxuICAgIDQ4OiAnMCcsXG4gICAgNDk6ICcxJyxcbiAgICA1MDogJzInLFxuICAgIDUxOiAnMycsXG4gICAgNTI6ICc0JyxcbiAgICA1MzogJzUnLFxuICAgIDU0OiAnNicsXG4gICAgNTU6ICc3JyxcbiAgICA1NjogJzgnLFxuICAgIDU3OiAnOScsXG4gICAgNTk6ICc7JyxcbiAgICA2MTogJz0nLFxuICAgIDY1OiAnQScsXG4gICAgNjY6ICdCJyxcbiAgICA2NzogJ0MnLFxuICAgIDY4OiAnRCcsXG4gICAgNjk6ICdFJyxcbiAgICA3MDogJ0YnLFxuICAgIDcxOiAnRycsXG4gICAgNzI6ICdIJyxcbiAgICA3MzogJ0knLFxuICAgIDc0OiAnSicsXG4gICAgNzU6ICdLJyxcbiAgICA3NjogJ0wnLFxuICAgIDc3OiAnTScsXG4gICAgNzg6ICdOJyxcbiAgICA3OTogJ08nLFxuICAgIDgwOiAnUCcsXG4gICAgODE6ICdRJyxcbiAgICA4MjogJ1InLFxuICAgIDgzOiAnUycsXG4gICAgODQ6ICdUJyxcbiAgICA4NTogJ1UnLFxuICAgIDg2OiAnVicsXG4gICAgODc6ICdXJyxcbiAgICA4ODogJ1gnLFxuICAgIDg5OiAnWScsXG4gICAgOTA6ICdaJyxcbiAgICA5MzogJ0NvbnRleHRNZW51JyxcbiAgICA5NjogJzAnLFxuICAgIDk3OiAnMScsXG4gICAgOTg6ICcyJyxcbiAgICA5OTogJzMnLFxuICAgIDEwMDogJzQnLFxuICAgIDEwMTogJzUnLFxuICAgIDEwMjogJzYnLFxuICAgIDEwMzogJzcnLFxuICAgIDEwNDogJzgnLFxuICAgIDEwNTogJzknLFxuICAgIDEwNjogJyonLFxuICAgIDEwNzogJysnLFxuICAgIDEwOTogJy0nLFxuICAgIDExMDogJy4nLFxuICAgIDExMTogJy8nLFxuICAgIDExMjogJ0YxJyxcbiAgICAxMTM6ICdGMicsXG4gICAgMTE0OiAnRjMnLFxuICAgIDExNTogJ0Y0JyxcbiAgICAxMTY6ICdGNScsXG4gICAgMTE3OiAnRjYnLFxuICAgIDExODogJ0Y3JyxcbiAgICAxMTk6ICdGOCcsXG4gICAgMTIwOiAnRjknLFxuICAgIDEyMTogJ0YxMCcsXG4gICAgMTIyOiAnRjExJyxcbiAgICAxMjM6ICdGMTInLFxuICAgIDE3MzogJy0nLFxuICAgIDE4NjogJzsnLFxuICAgIDE4NzogJz0nLFxuICAgIDE4ODogJywnLFxuICAgIDE4OTogJy0nLFxuICAgIDE5MDogJy4nLFxuICAgIDE5MTogJy8nLFxuICAgIDE5MjogJ2AnLFxuICAgIDIxOTogJ1snLFxuICAgIDIyMDogJ1xcXFwnLFxuICAgIDIyMTogJ10nLFxuICAgIDIyMjogJ1xcJydcbn0pO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBrZXlib2FyZCBsYXlvdXQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgUHJpdmF0ZS5rZXlib2FyZExheW91dCA9IEVOX1VTO1xufSkoUHJpdmF0ZSB8fCAoUHJpdmF0ZSA9IHt9KSk7XG5cbmV4cG9ydCB7IEVOX1VTLCBLZXljb2RlTGF5b3V0LCBnZXRLZXlib2FyZExheW91dCwgc2V0S2V5Ym9hcmRMYXlvdXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lumino/keyboard/dist/index.es6.js\n")},"./node_modules/@lumino/messaging/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ConflatableMessage": () => (/* binding */ ConflatableMessage),\n/* harmony export */   "Message": () => (/* binding */ Message),\n/* harmony export */   "MessageLoop": () => (/* binding */ MessageLoop)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@lumino/algorithm/dist/index.es6.js");\n/* harmony import */ var _lumino_collections__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@lumino/collections/dist/index.es6.js");\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nvar Message = /** @class */ (function () {\n    /**\n     * Construct a new message.\n     *\n     * @param type - The type of the message.\n     */\n    function Message(type) {\n        this.type = type;\n    }\n    Object.defineProperty(Message.prototype, "isConflatable", {\n        /**\n         * Test whether the message is conflatable.\n         *\n         * #### Notes\n         * Message conflation is an advanced topic. Most message types will\n         * not make use of this feature.\n         *\n         * If a conflatable message is posted to a handler while another\n         * conflatable message of the same `type` has already been posted\n         * to the handler, the `conflate()` method of the existing message\n         * will be invoked. If that method returns `true`, the new message\n         * will not be enqueued. This allows messages to be compressed, so\n         * that only a single instance of the message type is processed per\n         * cycle, no matter how many times messages of that type are posted.\n         *\n         * Custom message types may reimplement this property.\n         *\n         * The default implementation is always `false`.\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Conflate this message with another message of the same `type`.\n     *\n     * @param other - A conflatable message of the same `type`.\n     *\n     * @returns `true` if the message was successfully conflated, or\n     *   `false` otherwise.\n     *\n     * #### Notes\n     * Message conflation is an advanced topic. Most message types will\n     * not make use of this feature.\n     *\n     * This method is called automatically by the message loop when the\n     * given message is posted to the handler paired with this message.\n     * This message will already be enqueued and conflatable, and the\n     * given message will have the same `type` and also be conflatable.\n     *\n     * This method should merge the state of the other message into this\n     * message as needed so that when this message is finally delivered\n     * to the handler, it receives the most up-to-date information.\n     *\n     * If this method returns `true`, it signals that the other message\n     * was successfully conflated and that message will not be enqueued.\n     *\n     * If this method returns `false`, the other message will be enqueued\n     * for normal delivery.\n     *\n     * Custom message types may reimplement this method.\n     *\n     * The default implementation always returns `false`.\n     */\n    Message.prototype.conflate = function (other) {\n        return false;\n    };\n    return Message;\n}());\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nvar ConflatableMessage = /** @class */ (function (_super) {\n    __extends(ConflatableMessage, _super);\n    function ConflatableMessage() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ConflatableMessage.prototype, "isConflatable", {\n        /**\n         * Test whether the message is conflatable.\n         *\n         * #### Notes\n         * This property is always `true`.\n         */\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Conflate this message with another message of the same `type`.\n     *\n     * #### Notes\n     * This method always returns `true`.\n     */\n    ConflatableMessage.prototype.conflate = function (other) {\n        return true;\n    };\n    return ConflatableMessage;\n}(Message));\n/**\n * The namespace for the global singleton message loop.\n */\nvar MessageLoop;\n(function (MessageLoop) {\n    /**\n     * Send a message to a message handler to process immediately.\n     *\n     * @param handler - The handler which should process the message.\n     *\n     * @param msg - The message to deliver to the handler.\n     *\n     * #### Notes\n     * The message will first be sent through any installed message hooks\n     * for the handler. If the message passes all hooks, it will then be\n     * delivered to the `processMessage` method of the handler.\n     *\n     * The message will not be conflated with pending posted messages.\n     *\n     * Exceptions in hooks and handlers will be caught and logged.\n     */\n    function sendMessage(handler, msg) {\n        // Lookup the message hooks for the handler.\n        var hooks = messageHooks.get(handler);\n        // Handle the common case of no installed hooks.\n        if (!hooks || hooks.length === 0) {\n            invokeHandler(handler, msg);\n            return;\n        }\n        // Invoke the message hooks starting with the newest first.\n        var passed = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.every)((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.retro)(hooks), function (hook) {\n            return hook ? invokeHook(hook, handler, msg) : true;\n        });\n        // Invoke the handler if the message passes all hooks.\n        if (passed) {\n            invokeHandler(handler, msg);\n        }\n    }\n    MessageLoop.sendMessage = sendMessage;\n    /**\n     * Post a message to a message handler to process in the future.\n     *\n     * @param handler - The handler which should process the message.\n     *\n     * @param msg - The message to post to the handler.\n     *\n     * #### Notes\n     * The message will be conflated with the pending posted messages for\n     * the handler, if possible. If the message is not conflated, it will\n     * be queued for normal delivery on the next cycle of the event loop.\n     *\n     * Exceptions in hooks and handlers will be caught and logged.\n     */\n    function postMessage(handler, msg) {\n        // Handle the common case of a non-conflatable message.\n        if (!msg.isConflatable) {\n            enqueueMessage(handler, msg);\n            return;\n        }\n        // Conflate the message with an existing message if possible.\n        var conflated = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.some)(messageQueue, function (posted) {\n            if (posted.handler !== handler) {\n                return false;\n            }\n            if (!posted.msg) {\n                return false;\n            }\n            if (posted.msg.type !== msg.type) {\n                return false;\n            }\n            if (!posted.msg.isConflatable) {\n                return false;\n            }\n            return posted.msg.conflate(msg);\n        });\n        // Enqueue the message if it was not conflated.\n        if (!conflated) {\n            enqueueMessage(handler, msg);\n        }\n    }\n    MessageLoop.postMessage = postMessage;\n    /**\n     * Install a message hook for a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * @param hook - The message hook to install.\n     *\n     * #### Notes\n     * A message hook is invoked before a message is delivered to the\n     * handler. If the hook returns `false`, no other hooks will be\n     * invoked and the message will not be delivered to the handler.\n     *\n     * The most recently installed message hook is executed first.\n     *\n     * If the hook is already installed, this is a no-op.\n     */\n    function installMessageHook(handler, hook) {\n        // Lookup the hooks for the handler.\n        var hooks = messageHooks.get(handler);\n        // Bail early if the hook is already installed.\n        if (hooks && hooks.indexOf(hook) !== -1) {\n            return;\n        }\n        // Add the hook to the end, so it will be the first to execute.\n        if (!hooks) {\n            messageHooks.set(handler, [hook]);\n        }\n        else {\n            hooks.push(hook);\n        }\n    }\n    MessageLoop.installMessageHook = installMessageHook;\n    /**\n     * Remove an installed message hook for a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * @param hook - The message hook to remove.\n     *\n     * #### Notes\n     * It is safe to call this function while the hook is executing.\n     *\n     * If the hook is not installed, this is a no-op.\n     */\n    function removeMessageHook(handler, hook) {\n        // Lookup the hooks for the handler.\n        var hooks = messageHooks.get(handler);\n        // Bail early if the hooks do not exist.\n        if (!hooks) {\n            return;\n        }\n        // Lookup the index of the hook and bail if not found.\n        var i = hooks.indexOf(hook);\n        if (i === -1) {\n            return;\n        }\n        // Clear the hook and schedule a cleanup of the array.\n        hooks[i] = null;\n        scheduleCleanup(hooks);\n    }\n    MessageLoop.removeMessageHook = removeMessageHook;\n    /**\n     * Clear all message data associated with a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * #### Notes\n     * This will clear all posted messages and hooks for the handler.\n     */\n    function clearData(handler) {\n        // Lookup the hooks for the handler.\n        var hooks = messageHooks.get(handler);\n        // Clear all messsage hooks for the handler.\n        if (hooks && hooks.length > 0) {\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.fill(hooks, null);\n            scheduleCleanup(hooks);\n        }\n        // Clear all posted messages for the handler.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(messageQueue, function (posted) {\n            if (posted.handler === handler) {\n                posted.handler = null;\n                posted.msg = null;\n            }\n        });\n    }\n    MessageLoop.clearData = clearData;\n    /**\n     * Process the pending posted messages in the queue immediately.\n     *\n     * #### Notes\n     * This function is useful when posted messages must be processed\n     * immediately, instead of on the next animation frame.\n     *\n     * This function should normally not be needed, but it may be\n     * required to work around certain browser idiosyncrasies.\n     *\n     * Recursing into this function is a no-op.\n     */\n    function flush() {\n        // Bail if recursion is detected or if there is no pending task.\n        if (flushGuard || loopTaskID === 0) {\n            return;\n        }\n        // Unschedule the pending loop task.\n        unschedule(loopTaskID);\n        // Run the message loop within the recursion guard.\n        flushGuard = true;\n        runMessageLoop();\n        flushGuard = false;\n    }\n    MessageLoop.flush = flush;\n    /**\n     * Get the message loop exception handler.\n     *\n     * @returns The current exception handler.\n     *\n     * #### Notes\n     * The default exception handler is `console.error`.\n     */\n    function getExceptionHandler() {\n        return exceptionHandler;\n    }\n    MessageLoop.getExceptionHandler = getExceptionHandler;\n    /**\n     * Set the message loop exception handler.\n     *\n     * @param handler - The function to use as the exception handler.\n     *\n     * @returns The old exception handler.\n     *\n     * #### Notes\n     * The exception handler is invoked when a message handler or a\n     * message hook throws an exception.\n     */\n    function setExceptionHandler(handler) {\n        var old = exceptionHandler;\n        exceptionHandler = handler;\n        return old;\n    }\n    MessageLoop.setExceptionHandler = setExceptionHandler;\n    /**\n     * The queue of posted message pairs.\n     */\n    var messageQueue = new _lumino_collections__WEBPACK_IMPORTED_MODULE_1__.LinkedList();\n    /**\n     * A mapping of handler to array of installed message hooks.\n     */\n    var messageHooks = new WeakMap();\n    /**\n     * A set of message hook arrays which are pending cleanup.\n     */\n    var dirtySet = new Set();\n    /**\n     * The message loop exception handler.\n     */\n    var exceptionHandler = function (err) {\n        console.error(err);\n    };\n    /**\n     * The id of the pending loop task animation frame.\n     */\n    var loopTaskID = 0;\n    /**\n     * A guard flag to prevent flush recursion.\n     */\n    var flushGuard = false;\n    /**\n     * A function to schedule an event loop callback.\n     */\n    var schedule = (function () {\n        var ok = typeof requestAnimationFrame === \'function\';\n        return ok ? requestAnimationFrame : setImmediate;\n    })();\n    /**\n     * A function to unschedule an event loop callback.\n     */\n    var unschedule = (function () {\n        var ok = typeof cancelAnimationFrame === \'function\';\n        return ok ? cancelAnimationFrame : clearImmediate;\n    })();\n    /**\n     * Invoke a message hook with the specified handler and message.\n     *\n     * Returns the result of the hook, or `true` if the hook throws.\n     *\n     * Exceptions in the hook will be caught and logged.\n     */\n    function invokeHook(hook, handler, msg) {\n        var result = true;\n        try {\n            if (typeof hook === \'function\') {\n                result = hook(handler, msg);\n            }\n            else {\n                result = hook.messageHook(handler, msg);\n            }\n        }\n        catch (err) {\n            exceptionHandler(err);\n        }\n        return result;\n    }\n    /**\n     * Invoke a message handler with the specified message.\n     *\n     * Exceptions in the handler will be caught and logged.\n     */\n    function invokeHandler(handler, msg) {\n        try {\n            handler.processMessage(msg);\n        }\n        catch (err) {\n            exceptionHandler(err);\n        }\n    }\n    /**\n     * Add a message to the end of the message queue.\n     *\n     * This will automatically schedule a run of the message loop.\n     */\n    function enqueueMessage(handler, msg) {\n        // Add the posted message to the queue.\n        messageQueue.addLast({ handler: handler, msg: msg });\n        // Bail if a loop task is already pending.\n        if (loopTaskID !== 0) {\n            return;\n        }\n        // Schedule a run of the message loop.\n        loopTaskID = schedule(runMessageLoop);\n    }\n    /**\n     * Run an iteration of the message loop.\n     *\n     * This will process all pending messages in the queue. If a message\n     * is added to the queue while the message loop is running, it will\n     * be processed on the next cycle of the loop.\n     */\n    function runMessageLoop() {\n        // Clear the task ID so the next loop can be scheduled.\n        loopTaskID = 0;\n        // If the message queue is empty, there is nothing else to do.\n        if (messageQueue.isEmpty) {\n            return;\n        }\n        // Add a sentinel value to the end of the queue. The queue will\n        // only be processed up to the sentinel. Messages posted during\n        // this cycle will execute on the next cycle.\n        var sentinel = { handler: null, msg: null };\n        messageQueue.addLast(sentinel);\n        // Enter the message loop.\n        while (true) {\n            // Remove the first posted message in the queue.\n            var posted = messageQueue.removeFirst();\n            // If the value is the sentinel, exit the loop.\n            if (posted === sentinel) {\n                return;\n            }\n            // Dispatch the message if it has not been cleared.\n            if (posted.handler && posted.msg) {\n                sendMessage(posted.handler, posted.msg);\n            }\n        }\n    }\n    /**\n     * Schedule a cleanup of a message hooks array.\n     *\n     * This will add the array to the dirty set and schedule a deferred\n     * cleanup of the array contents. On cleanup, any `null` hook will\n     * be removed from the array.\n     */\n    function scheduleCleanup(hooks) {\n        if (dirtySet.size === 0) {\n            schedule(cleanupDirtySet);\n        }\n        dirtySet.add(hooks);\n    }\n    /**\n     * Cleanup the message hook arrays in the dirty set.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupDirtySet() {\n        dirtySet.forEach(cleanupHooks);\n        dirtySet.clear();\n    }\n    /**\n     * Cleanup the dirty hooks in a message hooks array.\n     *\n     * This will remove any `null` hook from the array.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupHooks(hooks) {\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAllWhere(hooks, isNull);\n    }\n    /**\n     * Test whether a value is `null`.\n     */\n    function isNull(value) {\n        return value === null;\n    }\n})(MessageLoop || (MessageLoop = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9tZXNzYWdpbmcvZGlzdC9pbmRleC5lczYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUU7QUFDdEI7O0FBRWpEO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQUssQ0FBQyx3REFBSztBQUNoQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDOztBQUVpQjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BhZnNoaW4vbGlmZS8uL25vZGVfbW9kdWxlcy9AbHVtaW5vL21lc3NhZ2luZy9kaXN0L2luZGV4LmVzNi5qcz9mZDlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV2ZXJ5LCByZXRybywgc29tZSwgQXJyYXlFeHQsIGVhY2ggfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG5pbXBvcnQgeyBMaW5rZWRMaXN0IH0gZnJvbSAnQGx1bWluby9jb2xsZWN0aW9ucyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBBIG1lc3NhZ2Ugd2hpY2ggY2FuIGJlIGRlbGl2ZXJlZCB0byBhIG1lc3NhZ2UgaGFuZGxlci5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGNsYXNzIG1heSBiZSBzdWJjbGFzc2VkIHRvIGNyZWF0ZSBjb21wbGV4IG1lc3NhZ2UgdHlwZXMuXG4gKi9cbnZhciBNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlKHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UucHJvdG90eXBlLCBcImlzQ29uZmxhdGFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGNvbmZsYXRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIE1lc3NhZ2UgY29uZmxhdGlvbiBpcyBhbiBhZHZhbmNlZCB0b3BpYy4gTW9zdCBtZXNzYWdlIHR5cGVzIHdpbGxcbiAgICAgICAgICogbm90IG1ha2UgdXNlIG9mIHRoaXMgZmVhdHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBjb25mbGF0YWJsZSBtZXNzYWdlIGlzIHBvc3RlZCB0byBhIGhhbmRsZXIgd2hpbGUgYW5vdGhlclxuICAgICAgICAgKiBjb25mbGF0YWJsZSBtZXNzYWdlIG9mIHRoZSBzYW1lIGB0eXBlYCBoYXMgYWxyZWFkeSBiZWVuIHBvc3RlZFxuICAgICAgICAgKiB0byB0aGUgaGFuZGxlciwgdGhlIGBjb25mbGF0ZSgpYCBtZXRob2Qgb2YgdGhlIGV4aXN0aW5nIG1lc3NhZ2VcbiAgICAgICAgICogd2lsbCBiZSBpbnZva2VkLiBJZiB0aGF0IG1ldGhvZCByZXR1cm5zIGB0cnVlYCwgdGhlIG5ldyBtZXNzYWdlXG4gICAgICAgICAqIHdpbGwgbm90IGJlIGVucXVldWVkLiBUaGlzIGFsbG93cyBtZXNzYWdlcyB0byBiZSBjb21wcmVzc2VkLCBzb1xuICAgICAgICAgKiB0aGF0IG9ubHkgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhlIG1lc3NhZ2UgdHlwZSBpcyBwcm9jZXNzZWQgcGVyXG4gICAgICAgICAqIGN5Y2xlLCBubyBtYXR0ZXIgaG93IG1hbnkgdGltZXMgbWVzc2FnZXMgb2YgdGhhdCB0eXBlIGFyZSBwb3N0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEN1c3RvbSBtZXNzYWdlIHR5cGVzIG1heSByZWltcGxlbWVudCB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBhbHdheXMgYGZhbHNlYC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb25mbGF0ZSB0aGlzIG1lc3NhZ2Ugd2l0aCBhbm90aGVyIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgYHR5cGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gQSBjb25mbGF0YWJsZSBtZXNzYWdlIG9mIHRoZSBzYW1lIGB0eXBlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWVzc2FnZSB3YXMgc3VjY2Vzc2Z1bGx5IGNvbmZsYXRlZCwgb3JcbiAgICAgKiAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIE1lc3NhZ2UgY29uZmxhdGlvbiBpcyBhbiBhZHZhbmNlZCB0b3BpYy4gTW9zdCBtZXNzYWdlIHR5cGVzIHdpbGxcbiAgICAgKiBub3QgbWFrZSB1c2Ugb2YgdGhpcyBmZWF0dXJlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIG1lc3NhZ2UgbG9vcCB3aGVuIHRoZVxuICAgICAqIGdpdmVuIG1lc3NhZ2UgaXMgcG9zdGVkIHRvIHRoZSBoYW5kbGVyIHBhaXJlZCB3aXRoIHRoaXMgbWVzc2FnZS5cbiAgICAgKiBUaGlzIG1lc3NhZ2Ugd2lsbCBhbHJlYWR5IGJlIGVucXVldWVkIGFuZCBjb25mbGF0YWJsZSwgYW5kIHRoZVxuICAgICAqIGdpdmVuIG1lc3NhZ2Ugd2lsbCBoYXZlIHRoZSBzYW1lIGB0eXBlYCBhbmQgYWxzbyBiZSBjb25mbGF0YWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBtZXJnZSB0aGUgc3RhdGUgb2YgdGhlIG90aGVyIG1lc3NhZ2UgaW50byB0aGlzXG4gICAgICogbWVzc2FnZSBhcyBuZWVkZWQgc28gdGhhdCB3aGVuIHRoaXMgbWVzc2FnZSBpcyBmaW5hbGx5IGRlbGl2ZXJlZFxuICAgICAqIHRvIHRoZSBoYW5kbGVyLCBpdCByZWNlaXZlcyB0aGUgbW9zdCB1cC10by1kYXRlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAsIGl0IHNpZ25hbHMgdGhhdCB0aGUgb3RoZXIgbWVzc2FnZVxuICAgICAqIHdhcyBzdWNjZXNzZnVsbHkgY29uZmxhdGVkIGFuZCB0aGF0IG1lc3NhZ2Ugd2lsbCBub3QgYmUgZW5xdWV1ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAsIHRoZSBvdGhlciBtZXNzYWdlIHdpbGwgYmUgZW5xdWV1ZWRcbiAgICAgKiBmb3Igbm9ybWFsIGRlbGl2ZXJ5LlxuICAgICAqXG4gICAgICogQ3VzdG9tIG1lc3NhZ2UgdHlwZXMgbWF5IHJlaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBNZXNzYWdlLnByb3RvdHlwZS5jb25mbGF0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZTtcbn0oKSk7XG4vKipcbiAqIEEgY29udmVuaWVuY2UgbWVzc2FnZSBjbGFzcyB3aGljaCBjb25mbGF0ZXMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBNZXNzYWdlIGNvbmZsYXRpb24gaXMgYW4gYWR2YW5jZWQgdG9waWMuIE1vc3QgdXNlciBjb2RlIHdpbGwgbm90XG4gKiBtYWtlIHVzZSBvZiB0aGlzIGNsYXNzLlxuICpcbiAqIFRoaXMgbWVzc2FnZSBjbGFzcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIG1lc3NhZ2UgaW5zdGFuY2VzIHdoaWNoXG4gKiBzaG91bGQgYmUgY29uZmxhdGVkLCBidXQgd2hpY2ggaGF2ZSBubyBzdGF0ZSBvdGhlciB0aGFuIGB0eXBlYC5cbiAqXG4gKiBJZiBjb25mbGF0aW9uIG9mIHN0YXRlZnVsIG1lc3NhZ2VzIGlzIHJlcXVpcmVkLCBhIGN1c3RvbSBgTWVzc2FnZWBcbiAqIHN1YmNsYXNzIHNob3VsZCBiZSBjcmVhdGVkLlxuICovXG52YXIgQ29uZmxhdGFibGVNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25mbGF0YWJsZU1lc3NhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uZmxhdGFibGVNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25mbGF0YWJsZU1lc3NhZ2UucHJvdG90eXBlLCBcImlzQ29uZmxhdGFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGNvbmZsYXRhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgYWx3YXlzIGB0cnVlYC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENvbmZsYXRlIHRoaXMgbWVzc2FnZSB3aXRoIGFub3RoZXIgbWVzc2FnZSBvZiB0aGUgc2FtZSBgdHlwZWAuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgYWx3YXlzIHJldHVybnMgYHRydWVgLlxuICAgICAqL1xuICAgIENvbmZsYXRhYmxlTWVzc2FnZS5wcm90b3R5cGUuY29uZmxhdGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZmxhdGFibGVNZXNzYWdlO1xufShNZXNzYWdlKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBnbG9iYWwgc2luZ2xldG9uIG1lc3NhZ2UgbG9vcC5cbiAqL1xudmFyIE1lc3NhZ2VMb29wO1xuKGZ1bmN0aW9uIChNZXNzYWdlTG9vcCkge1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIGEgbWVzc2FnZSBoYW5kbGVyIHRvIHByb2Nlc3MgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBoYW5kbGVyIHdoaWNoIHNob3VsZCBwcm9jZXNzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHRvIGRlbGl2ZXIgdG8gdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBmaXJzdCBiZSBzZW50IHRocm91Z2ggYW55IGluc3RhbGxlZCBtZXNzYWdlIGhvb2tzXG4gICAgICogZm9yIHRoZSBoYW5kbGVyLiBJZiB0aGUgbWVzc2FnZSBwYXNzZXMgYWxsIGhvb2tzLCBpdCB3aWxsIHRoZW4gYmVcbiAgICAgKiBkZWxpdmVyZWQgdG8gdGhlIGBwcm9jZXNzTWVzc2FnZWAgbWV0aG9kIG9mIHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBub3QgYmUgY29uZmxhdGVkIHdpdGggcGVuZGluZyBwb3N0ZWQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBFeGNlcHRpb25zIGluIGhvb2tzIGFuZCBoYW5kbGVycyB3aWxsIGJlIGNhdWdodCBhbmQgbG9nZ2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRNZXNzYWdlKGhhbmRsZXIsIG1zZykge1xuICAgICAgICAvLyBMb29rdXAgdGhlIG1lc3NhZ2UgaG9va3MgZm9yIHRoZSBoYW5kbGVyLlxuICAgICAgICB2YXIgaG9va3MgPSBtZXNzYWdlSG9va3MuZ2V0KGhhbmRsZXIpO1xuICAgICAgICAvLyBIYW5kbGUgdGhlIGNvbW1vbiBjYXNlIG9mIG5vIGluc3RhbGxlZCBob29rcy5cbiAgICAgICAgaWYgKCFob29rcyB8fCBob29rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGludm9rZUhhbmRsZXIoaGFuZGxlciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnZva2UgdGhlIG1lc3NhZ2UgaG9va3Mgc3RhcnRpbmcgd2l0aCB0aGUgbmV3ZXN0IGZpcnN0LlxuICAgICAgICB2YXIgcGFzc2VkID0gZXZlcnkocmV0cm8oaG9va3MpLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2sgPyBpbnZva2VIb29rKGhvb2ssIGhhbmRsZXIsIG1zZykgOiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBoYW5kbGVyIGlmIHRoZSBtZXNzYWdlIHBhc3NlcyBhbGwgaG9va3MuXG4gICAgICAgIGlmIChwYXNzZWQpIHtcbiAgICAgICAgICAgIGludm9rZUhhbmRsZXIoaGFuZGxlciwgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIFBvc3QgYSBtZXNzYWdlIHRvIGEgbWVzc2FnZSBoYW5kbGVyIHRvIHByb2Nlc3MgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGhhbmRsZXIgd2hpY2ggc2hvdWxkIHByb2Nlc3MgdGhlIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gcG9zdCB0byB0aGUgaGFuZGxlci5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIGNvbmZsYXRlZCB3aXRoIHRoZSBwZW5kaW5nIHBvc3RlZCBtZXNzYWdlcyBmb3JcbiAgICAgKiB0aGUgaGFuZGxlciwgaWYgcG9zc2libGUuIElmIHRoZSBtZXNzYWdlIGlzIG5vdCBjb25mbGF0ZWQsIGl0IHdpbGxcbiAgICAgKiBiZSBxdWV1ZWQgZm9yIG5vcm1hbCBkZWxpdmVyeSBvbiB0aGUgbmV4dCBjeWNsZSBvZiB0aGUgZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqIEV4Y2VwdGlvbnMgaW4gaG9va3MgYW5kIGhhbmRsZXJzIHdpbGwgYmUgY2F1Z2h0IGFuZCBsb2dnZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoaGFuZGxlciwgbXNnKSB7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY29tbW9uIGNhc2Ugb2YgYSBub24tY29uZmxhdGFibGUgbWVzc2FnZS5cbiAgICAgICAgaWYgKCFtc2cuaXNDb25mbGF0YWJsZSkge1xuICAgICAgICAgICAgZW5xdWV1ZU1lc3NhZ2UoaGFuZGxlciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25mbGF0ZSB0aGUgbWVzc2FnZSB3aXRoIGFuIGV4aXN0aW5nIG1lc3NhZ2UgaWYgcG9zc2libGUuXG4gICAgICAgIHZhciBjb25mbGF0ZWQgPSBzb21lKG1lc3NhZ2VRdWV1ZSwgZnVuY3Rpb24gKHBvc3RlZCkge1xuICAgICAgICAgICAgaWYgKHBvc3RlZC5oYW5kbGVyICE9PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwb3N0ZWQubXNnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc3RlZC5tc2cudHlwZSAhPT0gbXNnLnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBvc3RlZC5tc2cuaXNDb25mbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb3N0ZWQubXNnLmNvbmZsYXRlKG1zZyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFbnF1ZXVlIHRoZSBtZXNzYWdlIGlmIGl0IHdhcyBub3QgY29uZmxhdGVkLlxuICAgICAgICBpZiAoIWNvbmZsYXRlZCkge1xuICAgICAgICAgICAgZW5xdWV1ZU1lc3NhZ2UoaGFuZGxlciwgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSA9IHBvc3RNZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIEluc3RhbGwgYSBtZXNzYWdlIGhvb2sgZm9yIGEgbWVzc2FnZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgbWVzc2FnZSBoYW5kbGVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGhvb2sgLSBUaGUgbWVzc2FnZSBob29rIHRvIGluc3RhbGwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogQSBtZXNzYWdlIGhvb2sgaXMgaW52b2tlZCBiZWZvcmUgYSBtZXNzYWdlIGlzIGRlbGl2ZXJlZCB0byB0aGVcbiAgICAgKiBoYW5kbGVyLiBJZiB0aGUgaG9vayByZXR1cm5zIGBmYWxzZWAsIG5vIG90aGVyIGhvb2tzIHdpbGwgYmVcbiAgICAgKiBpbnZva2VkIGFuZCB0aGUgbWVzc2FnZSB3aWxsIG5vdCBiZSBkZWxpdmVyZWQgdG8gdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGUgbW9zdCByZWNlbnRseSBpbnN0YWxsZWQgbWVzc2FnZSBob29rIGlzIGV4ZWN1dGVkIGZpcnN0LlxuICAgICAqXG4gICAgICogSWYgdGhlIGhvb2sgaXMgYWxyZWFkeSBpbnN0YWxsZWQsIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUhvb2soaGFuZGxlciwgaG9vaykge1xuICAgICAgICAvLyBMb29rdXAgdGhlIGhvb2tzIGZvciB0aGUgaGFuZGxlci5cbiAgICAgICAgdmFyIGhvb2tzID0gbWVzc2FnZUhvb2tzLmdldChoYW5kbGVyKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgaG9vayBpcyBhbHJlYWR5IGluc3RhbGxlZC5cbiAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLmluZGV4T2YoaG9vaykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBob29rIHRvIHRoZSBlbmQsIHNvIGl0IHdpbGwgYmUgdGhlIGZpcnN0IHRvIGV4ZWN1dGUuXG4gICAgICAgIGlmICghaG9va3MpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VIb29rcy5zZXQoaGFuZGxlciwgW2hvb2tdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLnB1c2goaG9vayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTWVzc2FnZUxvb3AuaW5zdGFsbE1lc3NhZ2VIb29rID0gaW5zdGFsbE1lc3NhZ2VIb29rO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBpbnN0YWxsZWQgbWVzc2FnZSBob29rIGZvciBhIG1lc3NhZ2UgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIG1lc3NhZ2UgaGFuZGxlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBob29rIC0gVGhlIG1lc3NhZ2UgaG9vayB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2hpbGUgdGhlIGhvb2sgaXMgZXhlY3V0aW5nLlxuICAgICAqXG4gICAgICogSWYgdGhlIGhvb2sgaXMgbm90IGluc3RhbGxlZCwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VIb29rKGhhbmRsZXIsIGhvb2spIHtcbiAgICAgICAgLy8gTG9va3VwIHRoZSBob29rcyBmb3IgdGhlIGhhbmRsZXIuXG4gICAgICAgIHZhciBob29rcyA9IG1lc3NhZ2VIb29rcy5nZXQoaGFuZGxlcik7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGhvb2tzIGRvIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCFob29rcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2t1cCB0aGUgaW5kZXggb2YgdGhlIGhvb2sgYW5kIGJhaWwgaWYgbm90IGZvdW5kLlxuICAgICAgICB2YXIgaSA9IGhvb2tzLmluZGV4T2YoaG9vayk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSBob29rIGFuZCBzY2hlZHVsZSBhIGNsZWFudXAgb2YgdGhlIGFycmF5LlxuICAgICAgICBob29rc1tpXSA9IG51bGw7XG4gICAgICAgIHNjaGVkdWxlQ2xlYW51cChob29rcyk7XG4gICAgfVxuICAgIE1lc3NhZ2VMb29wLnJlbW92ZU1lc3NhZ2VIb29rID0gcmVtb3ZlTWVzc2FnZUhvb2s7XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIG1lc3NhZ2UgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBtZXNzYWdlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBtZXNzYWdlIGhhbmRsZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIGNsZWFyIGFsbCBwb3N0ZWQgbWVzc2FnZXMgYW5kIGhvb2tzIGZvciB0aGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhckRhdGEoaGFuZGxlcikge1xuICAgICAgICAvLyBMb29rdXAgdGhlIGhvb2tzIGZvciB0aGUgaGFuZGxlci5cbiAgICAgICAgdmFyIGhvb2tzID0gbWVzc2FnZUhvb2tzLmdldChoYW5kbGVyKTtcbiAgICAgICAgLy8gQ2xlYXIgYWxsIG1lc3NzYWdlIGhvb2tzIGZvciB0aGUgaGFuZGxlci5cbiAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIEFycmF5RXh0LmZpbGwoaG9va3MsIG51bGwpO1xuICAgICAgICAgICAgc2NoZWR1bGVDbGVhbnVwKGhvb2tzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhbGwgcG9zdGVkIG1lc3NhZ2VzIGZvciB0aGUgaGFuZGxlci5cbiAgICAgICAgZWFjaChtZXNzYWdlUXVldWUsIGZ1bmN0aW9uIChwb3N0ZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3N0ZWQuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHBvc3RlZC5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3N0ZWQubXNnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE1lc3NhZ2VMb29wLmNsZWFyRGF0YSA9IGNsZWFyRGF0YTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBwZW5kaW5nIHBvc3RlZCBtZXNzYWdlcyBpbiB0aGUgcXVldWUgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiBwb3N0ZWQgbWVzc2FnZXMgbXVzdCBiZSBwcm9jZXNzZWRcbiAgICAgKiBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3JtYWxseSBub3QgYmUgbmVlZGVkLCBidXQgaXQgbWF5IGJlXG4gICAgICogcmVxdWlyZWQgdG8gd29yayBhcm91bmQgY2VydGFpbiBicm93c2VyIGlkaW9zeW5jcmFzaWVzLlxuICAgICAqXG4gICAgICogUmVjdXJzaW5nIGludG8gdGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAvLyBCYWlsIGlmIHJlY3Vyc2lvbiBpcyBkZXRlY3RlZCBvciBpZiB0aGVyZSBpcyBubyBwZW5kaW5nIHRhc2suXG4gICAgICAgIGlmIChmbHVzaEd1YXJkIHx8IGxvb3BUYXNrSUQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbnNjaGVkdWxlIHRoZSBwZW5kaW5nIGxvb3AgdGFzay5cbiAgICAgICAgdW5zY2hlZHVsZShsb29wVGFza0lEKTtcbiAgICAgICAgLy8gUnVuIHRoZSBtZXNzYWdlIGxvb3Agd2l0aGluIHRoZSByZWN1cnNpb24gZ3VhcmQuXG4gICAgICAgIGZsdXNoR3VhcmQgPSB0cnVlO1xuICAgICAgICBydW5NZXNzYWdlTG9vcCgpO1xuICAgICAgICBmbHVzaEd1YXJkID0gZmFsc2U7XG4gICAgfVxuICAgIE1lc3NhZ2VMb29wLmZsdXNoID0gZmx1c2g7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtZXNzYWdlIGxvb3AgZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBleGNlcHRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBleGNlcHRpb24gaGFuZGxlciBpcyBgY29uc29sZS5lcnJvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RXhjZXB0aW9uSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvbkhhbmRsZXI7XG4gICAgfVxuICAgIE1lc3NhZ2VMb29wLmdldEV4Y2VwdGlvbkhhbmRsZXIgPSBnZXRFeGNlcHRpb25IYW5kbGVyO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWVzc2FnZSBsb29wIGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgZnVuY3Rpb24gdG8gdXNlIGFzIHRoZSBleGNlcHRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvbGQgZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGV4Y2VwdGlvbiBoYW5kbGVyIGlzIGludm9rZWQgd2hlbiBhIG1lc3NhZ2UgaGFuZGxlciBvciBhXG4gICAgICogbWVzc2FnZSBob29rIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RXhjZXB0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHZhciBvbGQgPSBleGNlcHRpb25IYW5kbGVyO1xuICAgICAgICBleGNlcHRpb25IYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICB9XG4gICAgTWVzc2FnZUxvb3Auc2V0RXhjZXB0aW9uSGFuZGxlciA9IHNldEV4Y2VwdGlvbkhhbmRsZXI7XG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXVlIG9mIHBvc3RlZCBtZXNzYWdlIHBhaXJzLlxuICAgICAqL1xuICAgIHZhciBtZXNzYWdlUXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIC8qKlxuICAgICAqIEEgbWFwcGluZyBvZiBoYW5kbGVyIHRvIGFycmF5IG9mIGluc3RhbGxlZCBtZXNzYWdlIGhvb2tzLlxuICAgICAqL1xuICAgIHZhciBtZXNzYWdlSG9va3MgPSBuZXcgV2Vha01hcCgpO1xuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIG1lc3NhZ2UgaG9vayBhcnJheXMgd2hpY2ggYXJlIHBlbmRpbmcgY2xlYW51cC5cbiAgICAgKi9cbiAgICB2YXIgZGlydHlTZXQgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lc3NhZ2UgbG9vcCBleGNlcHRpb24gaGFuZGxlci5cbiAgICAgKi9cbiAgICB2YXIgZXhjZXB0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGlkIG9mIHRoZSBwZW5kaW5nIGxvb3AgdGFzayBhbmltYXRpb24gZnJhbWUuXG4gICAgICovXG4gICAgdmFyIGxvb3BUYXNrSUQgPSAwO1xuICAgIC8qKlxuICAgICAqIEEgZ3VhcmQgZmxhZyB0byBwcmV2ZW50IGZsdXNoIHJlY3Vyc2lvbi5cbiAgICAgKi9cbiAgICB2YXIgZmx1c2hHdWFyZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYW4gZXZlbnQgbG9vcCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICB2YXIgc2NoZWR1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2sgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gb2sgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRJbW1lZGlhdGU7XG4gICAgfSkoKTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIHVuc2NoZWR1bGUgYW4gZXZlbnQgbG9vcCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICB2YXIgdW5zY2hlZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvayA9IHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG9rID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhckltbWVkaWF0ZTtcbiAgICB9KSgpO1xuICAgIC8qKlxuICAgICAqIEludm9rZSBhIG1lc3NhZ2UgaG9vayB3aXRoIHRoZSBzcGVjaWZpZWQgaGFuZGxlciBhbmQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaG9vaywgb3IgYHRydWVgIGlmIHRoZSBob29rIHRocm93cy5cbiAgICAgKlxuICAgICAqIEV4Y2VwdGlvbnMgaW4gdGhlIGhvb2sgd2lsbCBiZSBjYXVnaHQgYW5kIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2VIb29rKGhvb2ssIGhhbmRsZXIsIG1zZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG9vayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGhvb2soaGFuZGxlciwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGhvb2subWVzc2FnZUhvb2soaGFuZGxlciwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlIGEgbWVzc2FnZSBoYW5kbGVyIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRXhjZXB0aW9ucyBpbiB0aGUgaGFuZGxlciB3aWxsIGJlIGNhdWdodCBhbmQgbG9nZ2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZUhhbmRsZXIoaGFuZGxlciwgbXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyLnByb2Nlc3NNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1lc3NhZ2UgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IHNjaGVkdWxlIGEgcnVuIG9mIHRoZSBtZXNzYWdlIGxvb3AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5xdWV1ZU1lc3NhZ2UoaGFuZGxlciwgbXNnKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgcG9zdGVkIG1lc3NhZ2UgdG8gdGhlIHF1ZXVlLlxuICAgICAgICBtZXNzYWdlUXVldWUuYWRkTGFzdCh7IGhhbmRsZXI6IGhhbmRsZXIsIG1zZzogbXNnIH0pO1xuICAgICAgICAvLyBCYWlsIGlmIGEgbG9vcCB0YXNrIGlzIGFscmVhZHkgcGVuZGluZy5cbiAgICAgICAgaWYgKGxvb3BUYXNrSUQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTY2hlZHVsZSBhIHJ1biBvZiB0aGUgbWVzc2FnZSBsb29wLlxuICAgICAgICBsb29wVGFza0lEID0gc2NoZWR1bGUocnVuTWVzc2FnZUxvb3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gYW4gaXRlcmF0aW9uIG9mIHRoZSBtZXNzYWdlIGxvb3AuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcHJvY2VzcyBhbGwgcGVuZGluZyBtZXNzYWdlcyBpbiB0aGUgcXVldWUuIElmIGEgbWVzc2FnZVxuICAgICAqIGlzIGFkZGVkIHRvIHRoZSBxdWV1ZSB3aGlsZSB0aGUgbWVzc2FnZSBsb29wIGlzIHJ1bm5pbmcsIGl0IHdpbGxcbiAgICAgKiBiZSBwcm9jZXNzZWQgb24gdGhlIG5leHQgY3ljbGUgb2YgdGhlIGxvb3AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcnVuTWVzc2FnZUxvb3AoKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSB0YXNrIElEIHNvIHRoZSBuZXh0IGxvb3AgY2FuIGJlIHNjaGVkdWxlZC5cbiAgICAgICAgbG9vcFRhc2tJRCA9IDA7XG4gICAgICAgIC8vIElmIHRoZSBtZXNzYWdlIHF1ZXVlIGlzIGVtcHR5LCB0aGVyZSBpcyBub3RoaW5nIGVsc2UgdG8gZG8uXG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIHNlbnRpbmVsIHZhbHVlIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiBUaGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBvbmx5IGJlIHByb2Nlc3NlZCB1cCB0byB0aGUgc2VudGluZWwuIE1lc3NhZ2VzIHBvc3RlZCBkdXJpbmdcbiAgICAgICAgLy8gdGhpcyBjeWNsZSB3aWxsIGV4ZWN1dGUgb24gdGhlIG5leHQgY3ljbGUuXG4gICAgICAgIHZhciBzZW50aW5lbCA9IHsgaGFuZGxlcjogbnVsbCwgbXNnOiBudWxsIH07XG4gICAgICAgIG1lc3NhZ2VRdWV1ZS5hZGRMYXN0KHNlbnRpbmVsKTtcbiAgICAgICAgLy8gRW50ZXIgdGhlIG1lc3NhZ2UgbG9vcC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgcG9zdGVkIG1lc3NhZ2UgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgdmFyIHBvc3RlZCA9IG1lc3NhZ2VRdWV1ZS5yZW1vdmVGaXJzdCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHRoZSBzZW50aW5lbCwgZXhpdCB0aGUgbG9vcC5cbiAgICAgICAgICAgIGlmIChwb3N0ZWQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIG1lc3NhZ2UgaWYgaXQgaGFzIG5vdCBiZWVuIGNsZWFyZWQuXG4gICAgICAgICAgICBpZiAocG9zdGVkLmhhbmRsZXIgJiYgcG9zdGVkLm1zZykge1xuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKHBvc3RlZC5oYW5kbGVyLCBwb3N0ZWQubXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhIGNsZWFudXAgb2YgYSBtZXNzYWdlIGhvb2tzIGFycmF5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFkZCB0aGUgYXJyYXkgdG8gdGhlIGRpcnR5IHNldCBhbmQgc2NoZWR1bGUgYSBkZWZlcnJlZFxuICAgICAqIGNsZWFudXAgb2YgdGhlIGFycmF5IGNvbnRlbnRzLiBPbiBjbGVhbnVwLCBhbnkgYG51bGxgIGhvb2sgd2lsbFxuICAgICAqIGJlIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVDbGVhbnVwKGhvb2tzKSB7XG4gICAgICAgIGlmIChkaXJ0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShjbGVhbnVwRGlydHlTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGRpcnR5U2V0LmFkZChob29rcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFudXAgdGhlIG1lc3NhZ2UgaG9vayBhcnJheXMgaW4gdGhlIGRpcnR5IHNldC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgaW52b2tlZCBhc3luY2hyb25vdXNseSwgd2hlbiB0aGVcbiAgICAgKiBzdGFjayBmcmFtZSBpcyBndWFyYW50ZWVkIHRvIG5vdCBiZSBvbiB0aGUgcGF0aCBvZiB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYW51cERpcnR5U2V0KCkge1xuICAgICAgICBkaXJ0eVNldC5mb3JFYWNoKGNsZWFudXBIb29rcyk7XG4gICAgICAgIGRpcnR5U2V0LmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFudXAgdGhlIGRpcnR5IGhvb2tzIGluIGEgbWVzc2FnZSBob29rcyBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgYW55IGBudWxsYCBob29rIGZyb20gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBpbnZva2VkIGFzeW5jaHJvbm91c2x5LCB3aGVuIHRoZVxuICAgICAqIHN0YWNrIGZyYW1lIGlzIGd1YXJhbnRlZWQgdG8gbm90IGJlIG9uIHRoZSBwYXRoIG9mIHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhbnVwSG9va3MoaG9va3MpIHtcbiAgICAgICAgQXJyYXlFeHQucmVtb3ZlQWxsV2hlcmUoaG9va3MsIGlzTnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIGBudWxsYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cbn0pKE1lc3NhZ2VMb29wIHx8IChNZXNzYWdlTG9vcCA9IHt9KSk7XG5cbmV4cG9ydCB7IENvbmZsYXRhYmxlTWVzc2FnZSwgTWVzc2FnZSwgTWVzc2FnZUxvb3AgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lumino/messaging/dist/index.es6.js\n')},"./node_modules/@lumino/polling/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Debouncer\": () => (/* binding */ Debouncer),\n/* harmony export */   \"Poll\": () => (/* binding */ Poll),\n/* harmony export */   \"RateLimiter\": () => (/* binding */ RateLimiter),\n/* harmony export */   \"Throttler\": () => (/* binding */ Throttler)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/coreutils/dist/index.es6.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/@lumino/signaling/dist/index.es6.js\");\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A function to defer an action immediately.\n */\nvar defer = typeof requestAnimationFrame === 'function'\n    ? requestAnimationFrame\n    : setImmediate;\n/**\n * A function to cancel a deferred action.\n */\nvar cancel = typeof cancelAnimationFrame === 'function'\n    ? cancelAnimationFrame\n    : clearImmediate;\n/**\n * A class that wraps an asynchronous function to poll at a regular interval\n * with exponential increases to the interval length if the poll fails.\n *\n * @typeparam T - The resolved type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam U - The rejected type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam V - An optional type to extend the phases supported by a poll.\n * Defaults to `standby`, which already exists in the `Phase` type.\n */\nvar Poll = /** @class */ (function () {\n    /**\n     * Instantiate a new poll with exponential backoff in case of failure.\n     *\n     * @param options - The poll instantiation options.\n     */\n    function Poll(options) {\n        var _this = this;\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._tick = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        this._ticked = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);\n        this._timeout = -1;\n        this._factory = options.factory;\n        this._standby = options.standby || Private.DEFAULT_STANDBY;\n        this._state = __assign(__assign({}, Private.DEFAULT_STATE), { timestamp: new Date().getTime() });\n        // Normalize poll frequency `max` to be the greater of\n        // default `max`, `options.frequency.max`, or `options.frequency.interval`.\n        var frequency = options.frequency || {};\n        var max = Math.max(frequency.interval || 0, frequency.max || 0, Private.DEFAULT_FREQUENCY.max);\n        this.frequency = __assign(__assign(__assign({}, Private.DEFAULT_FREQUENCY), frequency), { max: max });\n        this.name = options.name || Private.DEFAULT_NAME;\n        if ('auto' in options ? options.auto : true) {\n            defer(function () { return void _this.start(); });\n        }\n    }\n    Object.defineProperty(Poll.prototype, \"disposed\", {\n        /**\n         * A signal emitted when the poll is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"frequency\", {\n        /**\n         * The polling frequency parameters.\n         */\n        get: function () {\n            return this._frequency;\n        },\n        set: function (frequency) {\n            if (this.isDisposed || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(frequency, this.frequency || {})) {\n                return;\n            }\n            var backoff = frequency.backoff, interval = frequency.interval, max = frequency.max;\n            interval = Math.round(interval);\n            max = Math.round(max);\n            if (typeof backoff === 'number' && backoff < 1) {\n                throw new Error('Poll backoff growth factor must be at least 1');\n            }\n            if ((interval < 0 || interval > max) && interval !== Poll.NEVER) {\n                throw new Error('Poll interval must be between 0 and max');\n            }\n            if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) {\n                throw new Error(\"Max interval must be less than \" + Poll.MAX_INTERVAL);\n            }\n            this._frequency = { backoff: backoff, interval: interval, max: max };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"isDisposed\", {\n        /**\n         * Whether the poll is disposed.\n         */\n        get: function () {\n            return this.state.phase === 'disposed';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"standby\", {\n        /**\n         * Indicates when the poll switches to standby.\n         */\n        get: function () {\n            return this._standby;\n        },\n        set: function (standby) {\n            if (this.isDisposed || this.standby === standby) {\n                return;\n            }\n            this._standby = standby;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"state\", {\n        /**\n         * The poll state, which is the content of the current poll tick.\n         */\n        get: function () {\n            return this._state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"tick\", {\n        /**\n         * A promise that resolves when the poll next ticks.\n         */\n        get: function () {\n            return this._tick.promise;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Poll.prototype, \"ticked\", {\n        /**\n         * A signal emitted when the poll ticks and fires off a new request.\n         */\n        get: function () {\n            return this._ticked;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose the poll.\n     */\n    Poll.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this._state = __assign(__assign({}, Private.DISPOSED_STATE), { timestamp: new Date().getTime() });\n        this._tick.promise.catch(function (_) { return undefined; });\n        this._tick.reject(new Error(\"Poll (\" + this.name + \") is disposed.\"));\n        this._disposed.emit(undefined);\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);\n    };\n    /**\n     * Refreshes the poll. Schedules `refreshed` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     *\n     * #### Notes\n     * The returned promise resolves after the tick is scheduled, but before\n     * the polling action is run. To wait until after the poll action executes,\n     * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`\n     */\n    Poll.prototype.refresh = function () {\n        return this.schedule({\n            cancel: function (_a) {\n                var phase = _a.phase;\n                return phase === 'refreshed';\n            },\n            interval: Poll.IMMEDIATE,\n            phase: 'refreshed'\n        });\n    };\n    /**\n     * Schedule the next poll tick.\n     *\n     * @param next - The next poll state data to schedule. Defaults to standby.\n     *\n     * @param next.cancel - Cancels state transition if function returns `true`.\n     *\n     * @returns A promise that resolves when the next poll state is active.\n     *\n     * #### Notes\n     * This method is not meant to be invoked by user code typically. It is public\n     * to allow poll instances to be composed into classes that schedule ticks.\n     */\n    Poll.prototype.schedule = function (next) {\n        if (next === void 0) { next = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var last, pending, scheduled, state, execute;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.isDisposed) {\n                            return [2 /*return*/];\n                        }\n                        // Check if the phase transition should be canceled.\n                        if (next.cancel && next.cancel(this.state)) {\n                            return [2 /*return*/];\n                        }\n                        last = this.state;\n                        pending = this._tick;\n                        scheduled = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n                        state = __assign({ interval: this.frequency.interval, payload: null, phase: 'standby', timestamp: new Date().getTime() }, next);\n                        this._state = state;\n                        this._tick = scheduled;\n                        // Clear the schedule if possible.\n                        if (last.interval === Poll.IMMEDIATE) {\n                            cancel(this._timeout);\n                        }\n                        else {\n                            clearTimeout(this._timeout);\n                        }\n                        // Emit ticked signal, resolve pending promise, and await its settlement.\n                        this._ticked.emit(this.state);\n                        pending.resolve(this);\n                        return [4 /*yield*/, pending.promise];\n                    case 1:\n                        _a.sent();\n                        execute = function () {\n                            if (_this.isDisposed || _this.tick !== scheduled.promise) {\n                                return;\n                            }\n                            _this._execute();\n                        };\n                        this._timeout =\n                            state.interval === Poll.IMMEDIATE\n                                ? defer(execute)\n                                : state.interval === Poll.NEVER\n                                    ? -1\n                                    : setTimeout(execute, state.interval);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Starts the poll. Schedules `started` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    Poll.prototype.start = function () {\n        return this.schedule({\n            cancel: function (_a) {\n                var phase = _a.phase;\n                return phase !== 'constructed' && phase !== 'standby' && phase !== 'stopped';\n            },\n            interval: Poll.IMMEDIATE,\n            phase: 'started'\n        });\n    };\n    /**\n     * Stops the poll. Schedules `stopped` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    Poll.prototype.stop = function () {\n        return this.schedule({\n            cancel: function (_a) {\n                var phase = _a.phase;\n                return phase === 'stopped';\n            },\n            interval: Poll.NEVER,\n            phase: 'stopped'\n        });\n    };\n    /**\n     * Execute a new poll factory promise or stand by if necessary.\n     */\n    Poll.prototype._execute = function () {\n        var _this = this;\n        var standby = typeof this.standby === 'function' ? this.standby() : this.standby;\n        standby =\n            standby === 'never'\n                ? false\n                : standby === 'when-hidden'\n                    ? !!(typeof document !== 'undefined' && document && document.hidden)\n                    : standby;\n        // If in standby mode schedule next tick without calling the factory.\n        if (standby) {\n            void this.schedule();\n            return;\n        }\n        var pending = this.tick;\n        this._factory(this.state)\n            .then(function (resolved) {\n            if (_this.isDisposed || _this.tick !== pending) {\n                return;\n            }\n            void _this.schedule({\n                payload: resolved,\n                phase: _this.state.phase === 'rejected' ? 'reconnected' : 'resolved'\n            });\n        })\n            .catch(function (rejected) {\n            if (_this.isDisposed || _this.tick !== pending) {\n                return;\n            }\n            void _this.schedule({\n                interval: Private.sleep(_this.frequency, _this.state),\n                payload: rejected,\n                phase: 'rejected'\n            });\n        });\n    };\n    return Poll;\n}());\n/**\n * A namespace for `Poll` types, interfaces, and statics.\n */\n(function (Poll) {\n    /**\n     * An interval value that indicates the poll should tick immediately.\n     */\n    Poll.IMMEDIATE = 0;\n    /**\n     * Delays are 32-bit integers in many browsers so intervals need to be capped.\n     *\n     * #### Notes\n     * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\n     */\n    Poll.MAX_INTERVAL = 2147483647;\n    /**\n     * An interval value that indicates the poll should never tick.\n     */\n    Poll.NEVER = Infinity;\n})(Poll || (Poll = {}));\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default backoff growth rate if `backoff` is `true`.\n     */\n    Private.DEFAULT_BACKOFF = 3;\n    /**\n     * The default polling frequency.\n     */\n    Private.DEFAULT_FREQUENCY = {\n        backoff: true,\n        interval: 1000,\n        max: 30 * 1000\n    };\n    /**\n     * The default poll name.\n     */\n    Private.DEFAULT_NAME = 'unknown';\n    /**\n     * The default poll standby behavior.\n     */\n    Private.DEFAULT_STANDBY = 'when-hidden';\n    /**\n     * The first poll tick state's default values superseded in constructor.\n     */\n    Private.DEFAULT_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'constructed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * The disposed tick state values.\n     */\n    Private.DISPOSED_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'disposed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * Get a random integer between min and max, inclusive of both.\n     *\n     * #### Notes\n     * From\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive\n     *\n     * From the MDN page: It might be tempting to use Math.round() to accomplish\n     * that, but doing so would cause your random numbers to follow a non-uniform\n     * distribution, which may not be acceptable for your needs.\n     */\n    function getRandomIntInclusive(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    /**\n     * Returns the number of milliseconds to sleep before the next tick.\n     *\n     * @param frequency - The poll's base frequency.\n     * @param last - The poll's last tick.\n     */\n    function sleep(frequency, last) {\n        var backoff = frequency.backoff, interval = frequency.interval, max = frequency.max;\n        if (interval === Poll.NEVER) {\n            return interval;\n        }\n        var growth = backoff === true ? Private.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;\n        var random = getRandomIntInclusive(interval, last.interval * growth);\n        return Math.min(max, random);\n    }\n    Private.sleep = sleep;\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A base class to implement rate limiters with different invocation strategies.\n *\n * @typeparam T - The resolved type of the underlying function.\n *\n * @typeparam U - The rejected type of the underlying function.\n */\nvar RateLimiter = /** @class */ (function () {\n    /**\n     * Instantiate a rate limiter.\n     *\n     * @param fn - The function to rate limit.\n     *\n     * @param limit - The rate limit; defaults to 500ms.\n     */\n    function RateLimiter(fn, limit) {\n        var _this = this;\n        if (limit === void 0) { limit = 500; }\n        /**\n         * A promise that resolves on each successful invocation.\n         */\n        this.payload = null;\n        this.limit = limit;\n        this.poll = new Poll({\n            auto: false,\n            factory: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, fn()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            }); }); },\n            frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },\n            standby: 'never'\n        });\n        this.payload = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        this.poll.ticked.connect(function (_, state) {\n            var payload = _this.payload;\n            if (state.phase === 'resolved') {\n                _this.payload = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n                payload.resolve(state.payload);\n                return;\n            }\n            if (state.phase === 'rejected' || state.phase === 'stopped') {\n                _this.payload = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n                payload.promise.catch(function (_) { return undefined; });\n                payload.reject(state.payload);\n                return;\n            }\n        }, this);\n    }\n    Object.defineProperty(RateLimiter.prototype, \"isDisposed\", {\n        /**\n         * Whether the rate limiter is disposed.\n         */\n        get: function () {\n            return this.payload === null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Disposes the rate limiter.\n     */\n    RateLimiter.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        this.payload = null;\n        this.poll.dispose();\n    };\n    /**\n     * Stop the function if it is mid-flight.\n     */\n    RateLimiter.prototype.stop = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.poll.stop()];\n            });\n        });\n    };\n    return RateLimiter;\n}());\n/**\n * Wraps and debounces a function that can be called multiple times and only\n * executes the underlying function one `interval` after the last invocation.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n */\nvar Debouncer = /** @class */ (function (_super) {\n    __extends(Debouncer, _super);\n    function Debouncer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Invokes the function and only executes after rate limit has elapsed.\n     * Each invocation resets the timer.\n     */\n    Debouncer.prototype.invoke = function () {\n        void this.poll.schedule({ interval: this.limit, phase: 'invoked' });\n        return this.payload.promise;\n    };\n    return Debouncer;\n}(RateLimiter));\n/**\n * Wraps and throttles a function that can be called multiple times and only\n * executes the underlying function once per `interval`.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n */\nvar Throttler = /** @class */ (function (_super) {\n    __extends(Throttler, _super);\n    /**\n     * Instantiate a throttler.\n     *\n     * @param fn - The function being throttled.\n     *\n     * @param options - Throttling configuration or throttling limit in ms.\n     *\n     * #### Notes\n     * The `edge` defaults to `leading`; the `limit` defaults to `500`.\n     */\n    function Throttler(fn, options) {\n        var _this = _super.call(this, fn, typeof options === 'number' ? options : options && options.limit) || this;\n        var edge = 'leading';\n        if (typeof options !== 'number') {\n            options = options || {};\n            edge = 'edge' in options ? options.edge : edge;\n        }\n        _this._interval = edge === 'trailing' ? _this.limit : Poll.IMMEDIATE;\n        return _this;\n    }\n    /**\n     * Throttles function invocations if one is currently in flight.\n     */\n    Throttler.prototype.invoke = function () {\n        if (this.poll.state.phase !== 'invoked') {\n            void this.poll.schedule({ interval: this._interval, phase: 'invoked' });\n        }\n        return this.payload.promise;\n    };\n    return Throttler;\n}(RateLimiter));\n/**\n * A namespace for `Throttler` interfaces.\n */\n(function (Throttler) {\n})(Throttler || (Throttler = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9wb2xsaW5nL2Rpc3QvaW5kZXguZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUNsQjs7QUFFM0M7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQyxpRUFBaUUsd0JBQXdCO0FBQ3pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMseUJBQXlCLDhEQUFlO0FBQ3hDLDJCQUEyQixxREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCLGlDQUFpQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0Q0FBNEMsVUFBVTtBQUM1RztBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLGdFQUFpQixnQ0FBZ0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QixpQ0FBaUM7QUFDeEcsZ0RBQWdELG1CQUFtQjtBQUNuRTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhEQUFlO0FBQ3ZELDJDQUEyQyxxR0FBcUc7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0RBQXNEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLElBQUk7QUFDckIseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBLFNBQVM7QUFDVCwyQkFBMkIsOERBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25ELHFEQUFxRCxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQXdDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRW9CO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vcG9sbGluZy9kaXN0L2luZGV4LmVzNi5qcz9hYzhmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEpTT05FeHQsIFByb21pc2VEZWxlZ2F0ZSB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBkZWZlciBhbiBhY3Rpb24gaW1tZWRpYXRlbHkuXG4gKi9cbnZhciBkZWZlciA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbidcbiAgICA/IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIDogc2V0SW1tZWRpYXRlO1xuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbmNlbCBhIGRlZmVycmVkIGFjdGlvbi5cbiAqL1xudmFyIGNhbmNlbCA9IHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgICA6IGNsZWFySW1tZWRpYXRlO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgd3JhcHMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRvIHBvbGwgYXQgYSByZWd1bGFyIGludGVydmFsXG4gKiB3aXRoIGV4cG9uZW50aWFsIGluY3JlYXNlcyB0byB0aGUgaW50ZXJ2YWwgbGVuZ3RoIGlmIHRoZSBwb2xsIGZhaWxzLlxuICpcbiAqIEB0eXBlcGFyYW0gVCAtIFRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSBmYWN0b3J5J3MgcHJvbWlzZXMuXG4gKiBEZWZhdWx0cyB0byBgYW55YC5cbiAqXG4gKiBAdHlwZXBhcmFtIFUgLSBUaGUgcmVqZWN0ZWQgdHlwZSBvZiB0aGUgZmFjdG9yeSdzIHByb21pc2VzLlxuICogRGVmYXVsdHMgdG8gYGFueWAuXG4gKlxuICogQHR5cGVwYXJhbSBWIC0gQW4gb3B0aW9uYWwgdHlwZSB0byBleHRlbmQgdGhlIHBoYXNlcyBzdXBwb3J0ZWQgYnkgYSBwb2xsLlxuICogRGVmYXVsdHMgdG8gYHN0YW5kYnlgLCB3aGljaCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYFBoYXNlYCB0eXBlLlxuICovXG52YXIgUG9sbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBwb2xsIHdpdGggZXhwb25lbnRpYWwgYmFja29mZiBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwb2xsIGluc3RhbnRpYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb2xsKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrID0gbmV3IFByb21pc2VEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl90aWNrZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBvcHRpb25zLmZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX3N0YW5kYnkgPSBvcHRpb25zLnN0YW5kYnkgfHwgUHJpdmF0ZS5ERUZBVUxUX1NUQU5EQlk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIFByaXZhdGUuREVGQVVMVF9TVEFURSksIHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSB9KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHBvbGwgZnJlcXVlbmN5IGBtYXhgIHRvIGJlIHRoZSBncmVhdGVyIG9mXG4gICAgICAgIC8vIGRlZmF1bHQgYG1heGAsIGBvcHRpb25zLmZyZXF1ZW5jeS5tYXhgLCBvciBgb3B0aW9ucy5mcmVxdWVuY3kuaW50ZXJ2YWxgLlxuICAgICAgICB2YXIgZnJlcXVlbmN5ID0gb3B0aW9ucy5mcmVxdWVuY3kgfHwge307XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChmcmVxdWVuY3kuaW50ZXJ2YWwgfHwgMCwgZnJlcXVlbmN5Lm1heCB8fCAwLCBQcml2YXRlLkRFRkFVTFRfRlJFUVVFTkNZLm1heCk7XG4gICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIFByaXZhdGUuREVGQVVMVF9GUkVRVUVOQ1kpLCBmcmVxdWVuY3kpLCB7IG1heDogbWF4IH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgUHJpdmF0ZS5ERUZBVUxUX05BTUU7XG4gICAgICAgIGlmICgnYXV0bycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuYXV0byA6IHRydWUpIHtcbiAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgX3RoaXMuc3RhcnQoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbGwucHJvdG90eXBlLCBcImRpc3Bvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgcG9sbCBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9sbC5wcm90b3R5cGUsIFwiZnJlcXVlbmN5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb2xsaW5nIGZyZXF1ZW5jeSBwYXJhbWV0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJlcXVlbmN5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmcmVxdWVuY3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQgfHwgSlNPTkV4dC5kZWVwRXF1YWwoZnJlcXVlbmN5LCB0aGlzLmZyZXF1ZW5jeSB8fCB7fSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmFja29mZiA9IGZyZXF1ZW5jeS5iYWNrb2ZmLCBpbnRlcnZhbCA9IGZyZXF1ZW5jeS5pbnRlcnZhbCwgbWF4ID0gZnJlcXVlbmN5Lm1heDtcbiAgICAgICAgICAgIGludGVydmFsID0gTWF0aC5yb3VuZChpbnRlcnZhbCk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLnJvdW5kKG1heCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJhY2tvZmYgPT09ICdudW1iZXInICYmIGJhY2tvZmYgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2xsIGJhY2tvZmYgZ3Jvd3RoIGZhY3RvciBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaW50ZXJ2YWwgPCAwIHx8IGludGVydmFsID4gbWF4KSAmJiBpbnRlcnZhbCAhPT0gUG9sbC5ORVZFUikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9sbCBpbnRlcnZhbCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4ID4gUG9sbC5NQVhfSU5URVJWQUwgJiYgbWF4ICE9PSBQb2xsLk5FVkVSKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWF4IGludGVydmFsIG11c3QgYmUgbGVzcyB0aGFuIFwiICsgUG9sbC5NQVhfSU5URVJWQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZnJlcXVlbmN5ID0geyBiYWNrb2ZmOiBiYWNrb2ZmLCBpbnRlcnZhbDogaW50ZXJ2YWwsIG1heDogbWF4IH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2xsLnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHBvbGwgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBoYXNlID09PSAnZGlzcG9zZWQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9sbC5wcm90b3R5cGUsIFwic3RhbmRieVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hlbiB0aGUgcG9sbCBzd2l0Y2hlcyB0byBzdGFuZGJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhbmRieTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3RhbmRieSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCB8fCB0aGlzLnN0YW5kYnkgPT09IHN0YW5kYnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGFuZGJ5ID0gc3RhbmRieTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbGwucHJvdG90eXBlLCBcInN0YXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb2xsIHN0YXRlLCB3aGljaCBpcyB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudCBwb2xsIHRpY2suXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbGwucHJvdG90eXBlLCBcInRpY2tcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcG9sbCBuZXh0IHRpY2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGljay5wcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9sbC5wcm90b3R5cGUsIFwidGlja2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgcG9sbCB0aWNrcyBhbmQgZmlyZXMgb2ZmIGEgbmV3IHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIHBvbGwuXG4gICAgICovXG4gICAgUG9sbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIFByaXZhdGUuRElTUE9TRURfU1RBVEUpLCB7IHRpbWVzdGFtcDogbmV3IERhdGUoKS5nZXRUaW1lKCkgfSk7XG4gICAgICAgIHRoaXMuX3RpY2sucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoXykgeyByZXR1cm4gdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgdGhpcy5fdGljay5yZWplY3QobmV3IEVycm9yKFwiUG9sbCAoXCIgKyB0aGlzLm5hbWUgKyBcIikgaXMgZGlzcG9zZWQuXCIpKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQuZW1pdCh1bmRlZmluZWQpO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBwb2xsLiBTY2hlZHVsZXMgYHJlZnJlc2hlZGAgdGljayBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aWNrIGlzIHNjaGVkdWxlZCBhbmQgbmV2ZXIgcmVqZWN0cy5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyBhZnRlciB0aGUgdGljayBpcyBzY2hlZHVsZWQsIGJ1dCBiZWZvcmVcbiAgICAgKiB0aGUgcG9sbGluZyBhY3Rpb24gaXMgcnVuLiBUbyB3YWl0IHVudGlsIGFmdGVyIHRoZSBwb2xsIGFjdGlvbiBleGVjdXRlcyxcbiAgICAgKiBhd2FpdCB0aGUgYHBvbGwudGlja2AgcHJvbWlzZTogYGF3YWl0IHBvbGwucmVmcmVzaCgpOyBhd2FpdCBwb2xsLnRpY2s7YFxuICAgICAqL1xuICAgIFBvbGwucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKHtcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBoYXNlID0gX2EucGhhc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBoYXNlID09PSAncmVmcmVzaGVkJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlcnZhbDogUG9sbC5JTU1FRElBVEUsXG4gICAgICAgICAgICBwaGFzZTogJ3JlZnJlc2hlZCdcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSB0aGUgbmV4dCBwb2xsIHRpY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV4dCAtIFRoZSBuZXh0IHBvbGwgc3RhdGUgZGF0YSB0byBzY2hlZHVsZS4gRGVmYXVsdHMgdG8gc3RhbmRieS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXh0LmNhbmNlbCAtIENhbmNlbHMgc3RhdGUgdHJhbnNpdGlvbiBpZiBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG5leHQgcG9sbCBzdGF0ZSBpcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IG1lYW50IHRvIGJlIGludm9rZWQgYnkgdXNlciBjb2RlIHR5cGljYWxseS4gSXQgaXMgcHVibGljXG4gICAgICogdG8gYWxsb3cgcG9sbCBpbnN0YW5jZXMgdG8gYmUgY29tcG9zZWQgaW50byBjbGFzc2VzIHRoYXQgc2NoZWR1bGUgdGlja3MuXG4gICAgICovXG4gICAgUG9sbC5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBpZiAobmV4dCA9PT0gdm9pZCAwKSB7IG5leHQgPSB7fTsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCwgcGVuZGluZywgc2NoZWR1bGVkLCBzdGF0ZSwgZXhlY3V0ZTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBoYXNlIHRyYW5zaXRpb24gc2hvdWxkIGJlIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuY2FuY2VsICYmIG5leHQuY2FuY2VsKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gdGhpcy5fdGljaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IG5ldyBQcm9taXNlRGVsZWdhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gX19hc3NpZ24oeyBpbnRlcnZhbDogdGhpcy5mcmVxdWVuY3kuaW50ZXJ2YWwsIHBheWxvYWQ6IG51bGwsIHBoYXNlOiAnc3RhbmRieScsIHRpbWVzdGFtcDogbmV3IERhdGUoKS5nZXRUaW1lKCkgfSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGljayA9IHNjaGVkdWxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBzY2hlZHVsZSBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0LmludGVydmFsID09PSBQb2xsLklNTUVESUFURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdGlja2VkIHNpZ25hbCwgcmVzb2x2ZSBwZW5kaW5nIHByb21pc2UsIGFuZCBhd2FpdCBpdHMgc2V0dGxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tlZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5yZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcGVuZGluZy5wcm9taXNlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNEaXNwb3NlZCB8fCBfdGhpcy50aWNrICE9PSBzY2hlZHVsZWQucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWwgPT09IFBvbGwuSU1NRURJQVRFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGVmZXIoZXhlY3V0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGF0ZS5pbnRlcnZhbCA9PT0gUG9sbC5ORVZFUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXRUaW1lb3V0KGV4ZWN1dGUsIHN0YXRlLmludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHBvbGwuIFNjaGVkdWxlcyBgc3RhcnRlZGAgdGljayBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aWNrIGlzIHNjaGVkdWxlZCBhbmQgbmV2ZXIgcmVqZWN0cy5cbiAgICAgKi9cbiAgICBQb2xsLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUoe1xuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGhhc2UgPSBfYS5waGFzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGhhc2UgIT09ICdjb25zdHJ1Y3RlZCcgJiYgcGhhc2UgIT09ICdzdGFuZGJ5JyAmJiBwaGFzZSAhPT0gJ3N0b3BwZWQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludGVydmFsOiBQb2xsLklNTUVESUFURSxcbiAgICAgICAgICAgIHBoYXNlOiAnc3RhcnRlZCdcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgcG9sbC4gU2NoZWR1bGVzIGBzdG9wcGVkYCB0aWNrIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRpY2sgaXMgc2NoZWR1bGVkIGFuZCBuZXZlciByZWplY3RzLlxuICAgICAqL1xuICAgIFBvbGwucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKHtcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBoYXNlID0gX2EucGhhc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBoYXNlID09PSAnc3RvcHBlZCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IFBvbGwuTkVWRVIsXG4gICAgICAgICAgICBwaGFzZTogJ3N0b3BwZWQnXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIG5ldyBwb2xsIGZhY3RvcnkgcHJvbWlzZSBvciBzdGFuZCBieSBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgUG9sbC5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFuZGJ5ID0gdHlwZW9mIHRoaXMuc3RhbmRieSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc3RhbmRieSgpIDogdGhpcy5zdGFuZGJ5O1xuICAgICAgICBzdGFuZGJ5ID1cbiAgICAgICAgICAgIHN0YW5kYnkgPT09ICduZXZlcidcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBzdGFuZGJ5ID09PSAnd2hlbi1oaWRkZW4nXG4gICAgICAgICAgICAgICAgICAgID8gISEodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5oaWRkZW4pXG4gICAgICAgICAgICAgICAgICAgIDogc3RhbmRieTtcbiAgICAgICAgLy8gSWYgaW4gc3RhbmRieSBtb2RlIHNjaGVkdWxlIG5leHQgdGljayB3aXRob3V0IGNhbGxpbmcgdGhlIGZhY3RvcnkuXG4gICAgICAgIGlmIChzdGFuZGJ5KSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGVuZGluZyA9IHRoaXMudGljaztcbiAgICAgICAgdGhpcy5fZmFjdG9yeSh0aGlzLnN0YXRlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEaXNwb3NlZCB8fCBfdGhpcy50aWNrICE9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCBfdGhpcy5zY2hlZHVsZSh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgcGhhc2U6IF90aGlzLnN0YXRlLnBoYXNlID09PSAncmVqZWN0ZWQnID8gJ3JlY29ubmVjdGVkJyA6ICdyZXNvbHZlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRGlzcG9zZWQgfHwgX3RoaXMudGljayAhPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgX3RoaXMuc2NoZWR1bGUoe1xuICAgICAgICAgICAgICAgIGludGVydmFsOiBQcml2YXRlLnNsZWVwKF90aGlzLmZyZXF1ZW5jeSwgX3RoaXMuc3RhdGUpLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHJlamVjdGVkLFxuICAgICAgICAgICAgICAgIHBoYXNlOiAncmVqZWN0ZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9sbDtcbn0oKSk7XG4vKipcbiAqIEEgbmFtZXNwYWNlIGZvciBgUG9sbGAgdHlwZXMsIGludGVyZmFjZXMsIGFuZCBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKFBvbGwpIHtcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcnZhbCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgcG9sbCBzaG91bGQgdGljayBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBQb2xsLklNTUVESUFURSA9IDA7XG4gICAgLyoqXG4gICAgICogRGVsYXlzIGFyZSAzMi1iaXQgaW50ZWdlcnMgaW4gbWFueSBicm93c2VycyBzbyBpbnRlcnZhbHMgbmVlZCB0byBiZSBjYXBwZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvc2V0VGltZW91dCNNYXhpbXVtX2RlbGF5X3ZhbHVlXG4gICAgICovXG4gICAgUG9sbC5NQVhfSU5URVJWQUwgPSAyMTQ3NDgzNjQ3O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVydmFsIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBwb2xsIHNob3VsZCBuZXZlciB0aWNrLlxuICAgICAqL1xuICAgIFBvbGwuTkVWRVIgPSBJbmZpbml0eTtcbn0pKFBvbGwgfHwgKFBvbGwgPSB7fSkpO1xuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgcHJpdmF0ZSBtb2R1bGUgZGF0YS5cbiAqL1xudmFyIFByaXZhdGU7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBiYWNrb2ZmIGdyb3d0aCByYXRlIGlmIGBiYWNrb2ZmYCBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgUHJpdmF0ZS5ERUZBVUxUX0JBQ0tPRkYgPSAzO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHBvbGxpbmcgZnJlcXVlbmN5LlxuICAgICAqL1xuICAgIFByaXZhdGUuREVGQVVMVF9GUkVRVUVOQ1kgPSB7XG4gICAgICAgIGJhY2tvZmY6IHRydWUsXG4gICAgICAgIGludGVydmFsOiAxMDAwLFxuICAgICAgICBtYXg6IDMwICogMTAwMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcG9sbCBuYW1lLlxuICAgICAqL1xuICAgIFByaXZhdGUuREVGQVVMVF9OQU1FID0gJ3Vua25vd24nO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHBvbGwgc3RhbmRieSBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBQcml2YXRlLkRFRkFVTFRfU1RBTkRCWSA9ICd3aGVuLWhpZGRlbic7XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IHBvbGwgdGljayBzdGF0ZSdzIGRlZmF1bHQgdmFsdWVzIHN1cGVyc2VkZWQgaW4gY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgUHJpdmF0ZS5ERUZBVUxUX1NUQVRFID0ge1xuICAgICAgICBpbnRlcnZhbDogUG9sbC5ORVZFUixcbiAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgcGhhc2U6ICdjb25zdHJ1Y3RlZCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoMCkuZ2V0VGltZSgpXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlzcG9zZWQgdGljayBzdGF0ZSB2YWx1ZXMuXG4gICAgICovXG4gICAgUHJpdmF0ZS5ESVNQT1NFRF9TVEFURSA9IHtcbiAgICAgICAgaW50ZXJ2YWw6IFBvbGwuTkVWRVIsXG4gICAgICAgIHBheWxvYWQ6IG51bGwsXG4gICAgICAgIHBoYXNlOiAnZGlzcG9zZWQnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKDApLmdldFRpbWUoKVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCwgaW5jbHVzaXZlIG9mIGJvdGguXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogRnJvbVxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcmFuZG9tI0dldHRpbmdfYV9yYW5kb21faW50ZWdlcl9iZXR3ZWVuX3R3b192YWx1ZXNfaW5jbHVzaXZlXG4gICAgICpcbiAgICAgKiBGcm9tIHRoZSBNRE4gcGFnZTogSXQgbWlnaHQgYmUgdGVtcHRpbmcgdG8gdXNlIE1hdGgucm91bmQoKSB0byBhY2NvbXBsaXNoXG4gICAgICogdGhhdCwgYnV0IGRvaW5nIHNvIHdvdWxkIGNhdXNlIHlvdXIgcmFuZG9tIG51bWJlcnMgdG8gZm9sbG93IGEgbm9uLXVuaWZvcm1cbiAgICAgKiBkaXN0cmlidXRpb24sIHdoaWNoIG1heSBub3QgYmUgYWNjZXB0YWJsZSBmb3IgeW91ciBuZWVkcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYW5kb21JbnRJbmNsdXNpdmUobWluLCBtYXgpIHtcbiAgICAgICAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gICAgICAgIG1heCA9IE1hdGguZmxvb3IobWF4KTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gc2xlZXAgYmVmb3JlIHRoZSBuZXh0IHRpY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJlcXVlbmN5IC0gVGhlIHBvbGwncyBiYXNlIGZyZXF1ZW5jeS5cbiAgICAgKiBAcGFyYW0gbGFzdCAtIFRoZSBwb2xsJ3MgbGFzdCB0aWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsZWVwKGZyZXF1ZW5jeSwgbGFzdCkge1xuICAgICAgICB2YXIgYmFja29mZiA9IGZyZXF1ZW5jeS5iYWNrb2ZmLCBpbnRlcnZhbCA9IGZyZXF1ZW5jeS5pbnRlcnZhbCwgbWF4ID0gZnJlcXVlbmN5Lm1heDtcbiAgICAgICAgaWYgKGludGVydmFsID09PSBQb2xsLk5FVkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3d0aCA9IGJhY2tvZmYgPT09IHRydWUgPyBQcml2YXRlLkRFRkFVTFRfQkFDS09GRiA6IGJhY2tvZmYgPT09IGZhbHNlID8gMSA6IGJhY2tvZmY7XG4gICAgICAgIHZhciByYW5kb20gPSBnZXRSYW5kb21JbnRJbmNsdXNpdmUoaW50ZXJ2YWwsIGxhc3QuaW50ZXJ2YWwgKiBncm93dGgpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4LCByYW5kb20pO1xuICAgIH1cbiAgICBQcml2YXRlLnNsZWVwID0gc2xlZXA7XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEEgYmFzZSBjbGFzcyB0byBpbXBsZW1lbnQgcmF0ZSBsaW1pdGVycyB3aXRoIGRpZmZlcmVudCBpbnZvY2F0aW9uIHN0cmF0ZWdpZXMuXG4gKlxuICogQHR5cGVwYXJhbSBUIC0gVGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24uXG4gKlxuICogQHR5cGVwYXJhbSBVIC0gVGhlIHJlamVjdGVkIHR5cGUgb2YgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24uXG4gKi9cbnZhciBSYXRlTGltaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIHJhdGUgbGltaXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byByYXRlIGxpbWl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0IC0gVGhlIHJhdGUgbGltaXQ7IGRlZmF1bHRzIHRvIDUwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJhdGVMaW1pdGVyKGZuLCBsaW1pdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGltaXQgPT09IHZvaWQgMCkgeyBsaW1pdCA9IDUwMDsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb24gZWFjaCBzdWNjZXNzZnVsIGludm9jYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMucG9sbCA9IG5ldyBQb2xsKHtcbiAgICAgICAgICAgIGF1dG86IGZhbHNlLFxuICAgICAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZuKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyB9KTsgfSxcbiAgICAgICAgICAgIGZyZXF1ZW5jeTogeyBiYWNrb2ZmOiBmYWxzZSwgaW50ZXJ2YWw6IFBvbGwuTkVWRVIsIG1heDogUG9sbC5ORVZFUiB9LFxuICAgICAgICAgICAgc3RhbmRieTogJ25ldmVyJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gbmV3IFByb21pc2VEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLnBvbGwudGlja2VkLmNvbm5lY3QoZnVuY3Rpb24gKF8sIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IF90aGlzLnBheWxvYWQ7XG4gICAgICAgICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdyZXNvbHZlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXlsb2FkID0gbmV3IFByb21pc2VEZWxlZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQucmVzb2x2ZShzdGF0ZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdyZWplY3RlZCcgfHwgc3RhdGUucGhhc2UgPT09ICdzdG9wcGVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnBheWxvYWQgPSBuZXcgUHJvbWlzZURlbGVnYXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChfKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pO1xuICAgICAgICAgICAgICAgIHBheWxvYWQucmVqZWN0KHN0YXRlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSYXRlTGltaXRlci5wcm90b3R5cGUsIFwiaXNEaXNwb3NlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByYXRlIGxpbWl0ZXIgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBheWxvYWQgPT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSByYXRlIGxpbWl0ZXIuXG4gICAgICovXG4gICAgUmF0ZUxpbWl0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBheWxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvbGwuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgZnVuY3Rpb24gaWYgaXQgaXMgbWlkLWZsaWdodC5cbiAgICAgKi9cbiAgICBSYXRlTGltaXRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnBvbGwuc3RvcCgpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSYXRlTGltaXRlcjtcbn0oKSk7XG4vKipcbiAqIFdyYXBzIGFuZCBkZWJvdW5jZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYW5kIG9ubHlcbiAqIGV4ZWN1dGVzIHRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uIG9uZSBgaW50ZXJ2YWxgIGFmdGVyIHRoZSBsYXN0IGludm9jYXRpb24uXG4gKlxuICogQHR5cGVwYXJhbSBUIC0gVGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24uIERlZmF1bHRzIHRvIGFueS5cbiAqXG4gKiBAdHlwZXBhcmFtIFUgLSBUaGUgcmVqZWN0ZWQgdHlwZSBvZiB0aGUgdW5kZXJseWluZyBmdW5jdGlvbi4gRGVmYXVsdHMgdG8gYW55LlxuICovXG52YXIgRGVib3VuY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWJvdW5jZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGZ1bmN0aW9uIGFuZCBvbmx5IGV4ZWN1dGVzIGFmdGVyIHJhdGUgbGltaXQgaGFzIGVsYXBzZWQuXG4gICAgICogRWFjaCBpbnZvY2F0aW9uIHJlc2V0cyB0aGUgdGltZXIuXG4gICAgICovXG4gICAgRGVib3VuY2VyLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZvaWQgdGhpcy5wb2xsLnNjaGVkdWxlKHsgaW50ZXJ2YWw6IHRoaXMubGltaXQsIHBoYXNlOiAnaW52b2tlZCcgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBheWxvYWQucHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZXI7XG59KFJhdGVMaW1pdGVyKSk7XG4vKipcbiAqIFdyYXBzIGFuZCB0aHJvdHRsZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYW5kIG9ubHlcbiAqIGV4ZWN1dGVzIHRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uIG9uY2UgcGVyIGBpbnRlcnZhbGAuXG4gKlxuICogQHR5cGVwYXJhbSBUIC0gVGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24uIERlZmF1bHRzIHRvIGFueS5cbiAqXG4gKiBAdHlwZXBhcmFtIFUgLSBUaGUgcmVqZWN0ZWQgdHlwZSBvZiB0aGUgdW5kZXJseWluZyBmdW5jdGlvbi4gRGVmYXVsdHMgdG8gYW55LlxuICovXG52YXIgVGhyb3R0bGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvdHRsZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSB0aHJvdHRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gYmVpbmcgdGhyb3R0bGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaHJvdHRsaW5nIGNvbmZpZ3VyYXRpb24gb3IgdGhyb3R0bGluZyBsaW1pdCBpbiBtcy5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgYGVkZ2VgIGRlZmF1bHRzIHRvIGBsZWFkaW5nYDsgdGhlIGBsaW1pdGAgZGVmYXVsdHMgdG8gYDUwMGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGhyb3R0bGVyKGZuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZuLCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgPyBvcHRpb25zIDogb3B0aW9ucyAmJiBvcHRpb25zLmxpbWl0KSB8fCB0aGlzO1xuICAgICAgICB2YXIgZWRnZSA9ICdsZWFkaW5nJztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBlZGdlID0gJ2VkZ2UnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVkZ2UgOiBlZGdlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9pbnRlcnZhbCA9IGVkZ2UgPT09ICd0cmFpbGluZycgPyBfdGhpcy5saW1pdCA6IFBvbGwuSU1NRURJQVRFO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRocm90dGxlcyBmdW5jdGlvbiBpbnZvY2F0aW9ucyBpZiBvbmUgaXMgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICAgKi9cbiAgICBUaHJvdHRsZXIucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9sbC5zdGF0ZS5waGFzZSAhPT0gJ2ludm9rZWQnKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMucG9sbC5zY2hlZHVsZSh7IGludGVydmFsOiB0aGlzLl9pbnRlcnZhbCwgcGhhc2U6ICdpbnZva2VkJyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXlsb2FkLnByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVyO1xufShSYXRlTGltaXRlcikpO1xuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgYFRocm90dGxlcmAgaW50ZXJmYWNlcy5cbiAqL1xuKGZ1bmN0aW9uIChUaHJvdHRsZXIpIHtcbn0pKFRocm90dGxlciB8fCAoVGhyb3R0bGVyID0ge30pKTtcblxuZXhwb3J0IHsgRGVib3VuY2VyLCBQb2xsLCBSYXRlTGltaXRlciwgVGhyb3R0bGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/polling/dist/index.es6.js\n")},"./node_modules/@lumino/properties/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "AttachedProperty": () => (/* binding */ AttachedProperty)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A class which attaches a value to an external object.\n *\n * #### Notes\n * Attached properties are used to extend the state of an object with\n * semantic data from an unrelated class. They also encapsulate value\n * creation, coercion, and notification.\n *\n * Because attached property values are stored in a hash table, which\n * in turn is stored in a WeakMap keyed on the owner object, there is\n * non-trivial storage overhead involved in their use. The pattern is\n * therefore best used for the storage of rare data.\n */\nvar AttachedProperty = /** @class */ (function () {\n    /**\n     * Construct a new attached property.\n     *\n     * @param options - The options for initializing the property.\n     */\n    function AttachedProperty(options) {\n        this._pid = Private.nextPID();\n        this.name = options.name;\n        this._create = options.create;\n        this._coerce = options.coerce || null;\n        this._compare = options.compare || null;\n        this._changed = options.changed || null;\n    }\n    /**\n     * Get the current value of the property for a given owner.\n     *\n     * @param owner - The property owner of interest.\n     *\n     * @returns The current value of the property.\n     *\n     * #### Notes\n     * If the value has not yet been set, the default value will be\n     * computed and assigned as the current value of the property.\n     */\n    AttachedProperty.prototype.get = function (owner) {\n        var value;\n        var map = Private.ensureMap(owner);\n        if (this._pid in map) {\n            value = map[this._pid];\n        }\n        else {\n            value = map[this._pid] = this._createValue(owner);\n        }\n        return value;\n    };\n    /**\n     * Set the current value of the property for a given owner.\n     *\n     * @param owner - The property owner of interest.\n     *\n     * @param value - The value for the property.\n     *\n     * #### Notes\n     * If the value has not yet been set, the default value will be\n     * computed and used as the previous value for the comparison.\n     */\n    AttachedProperty.prototype.set = function (owner, value) {\n        var oldValue;\n        var map = Private.ensureMap(owner);\n        if (this._pid in map) {\n            oldValue = map[this._pid];\n        }\n        else {\n            oldValue = map[this._pid] = this._createValue(owner);\n        }\n        var newValue = this._coerceValue(owner, value);\n        this._maybeNotify(owner, oldValue, map[this._pid] = newValue);\n    };\n    /**\n     * Explicitly coerce the current property value for a given owner.\n     *\n     * @param owner - The property owner of interest.\n     *\n     * #### Notes\n     * If the value has not yet been set, the default value will be\n     * computed and used as the previous value for the comparison.\n     */\n    AttachedProperty.prototype.coerce = function (owner) {\n        var oldValue;\n        var map = Private.ensureMap(owner);\n        if (this._pid in map) {\n            oldValue = map[this._pid];\n        }\n        else {\n            oldValue = map[this._pid] = this._createValue(owner);\n        }\n        var newValue = this._coerceValue(owner, oldValue);\n        this._maybeNotify(owner, oldValue, map[this._pid] = newValue);\n    };\n    /**\n     * Get or create the default value for the given owner.\n     */\n    AttachedProperty.prototype._createValue = function (owner) {\n        var create = this._create;\n        return create(owner);\n    };\n    /**\n     * Coerce the value for the given owner.\n     */\n    AttachedProperty.prototype._coerceValue = function (owner, value) {\n        var coerce = this._coerce;\n        return coerce ? coerce(owner, value) : value;\n    };\n    /**\n     * Compare the old value and new value for equality.\n     */\n    AttachedProperty.prototype._compareValue = function (oldValue, newValue) {\n        var compare = this._compare;\n        return compare ? compare(oldValue, newValue) : oldValue === newValue;\n    };\n    /**\n     * Run the change notification if the given values are different.\n     */\n    AttachedProperty.prototype._maybeNotify = function (owner, oldValue, newValue) {\n        var changed = this._changed;\n        if (changed && !this._compareValue(oldValue, newValue)) {\n            changed(owner, oldValue, newValue);\n        }\n    };\n    return AttachedProperty;\n}());\n/**\n * The namespace for the `AttachedProperty` class statics.\n */\n(function (AttachedProperty) {\n    /**\n     * Clear the stored property data for the given owner.\n     *\n     * @param owner - The property owner of interest.\n     *\n     * #### Notes\n     * This will clear all property values for the owner, but it will\n     * **not** run the change notification for any of the properties.\n     */\n    function clearData(owner) {\n        Private.ownerData.delete(owner);\n    }\n    AttachedProperty.clearData = clearData;\n})(AttachedProperty || (AttachedProperty = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A weak mapping of property owner to property map.\n     */\n    Private.ownerData = new WeakMap();\n    /**\n     * A function which computes successive unique property ids.\n     */\n    Private.nextPID = (function () {\n        var id = 0;\n        return function () {\n            var rand = Math.random();\n            var stem = ("" + rand).slice(2);\n            return "pid-" + stem + "-" + id++;\n        };\n    })();\n    /**\n     * Lookup the data map for the property owner.\n     *\n     * This will create the map if one does not already exist.\n     */\n    function ensureMap(owner) {\n        var map = Private.ownerData.get(owner);\n        if (map) {\n            return map;\n        }\n        map = Object.create(null);\n        Private.ownerData.set(owner, map);\n        return map;\n    }\n    Private.ensureMap = ensureMap;\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9wcm9wZXJ0aWVzL2Rpc3QvaW5kZXguZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRUM7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWZzaGluL2xpZmUvLi9ub2RlX21vZHVsZXMvQGx1bWluby9wcm9wZXJ0aWVzL2Rpc3QvaW5kZXguZXM2LmpzPzI3YzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgUGhvc3Bob3JKUyBDb250cmlidXRvcnNcbnxcbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbnxcbnwgVGhlIGZ1bGwgbGljZW5zZSBpcyBpbiB0aGUgZmlsZSBMSUNFTlNFLCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc29mdHdhcmUuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggYXR0YWNoZXMgYSB2YWx1ZSB0byBhbiBleHRlcm5hbCBvYmplY3QuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogQXR0YWNoZWQgcHJvcGVydGllcyBhcmUgdXNlZCB0byBleHRlbmQgdGhlIHN0YXRlIG9mIGFuIG9iamVjdCB3aXRoXG4gKiBzZW1hbnRpYyBkYXRhIGZyb20gYW4gdW5yZWxhdGVkIGNsYXNzLiBUaGV5IGFsc28gZW5jYXBzdWxhdGUgdmFsdWVcbiAqIGNyZWF0aW9uLCBjb2VyY2lvbiwgYW5kIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiBCZWNhdXNlIGF0dGFjaGVkIHByb3BlcnR5IHZhbHVlcyBhcmUgc3RvcmVkIGluIGEgaGFzaCB0YWJsZSwgd2hpY2hcbiAqIGluIHR1cm4gaXMgc3RvcmVkIGluIGEgV2Vha01hcCBrZXllZCBvbiB0aGUgb3duZXIgb2JqZWN0LCB0aGVyZSBpc1xuICogbm9uLXRyaXZpYWwgc3RvcmFnZSBvdmVyaGVhZCBpbnZvbHZlZCBpbiB0aGVpciB1c2UuIFRoZSBwYXR0ZXJuIGlzXG4gKiB0aGVyZWZvcmUgYmVzdCB1c2VkIGZvciB0aGUgc3RvcmFnZSBvZiByYXJlIGRhdGEuXG4gKi9cbnZhciBBdHRhY2hlZFByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBhdHRhY2hlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXR0YWNoZWRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3BpZCA9IFByaXZhdGUubmV4dFBJRCgpO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgIHRoaXMuX2NyZWF0ZSA9IG9wdGlvbnMuY3JlYXRlO1xuICAgICAgICB0aGlzLl9jb2VyY2UgPSBvcHRpb25zLmNvZXJjZSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9jb21wYXJlID0gb3B0aW9ucy5jb21wYXJlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQgPSBvcHRpb25zLmNoYW5nZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBvd25lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvd25lciAtIFRoZSBwcm9wZXJ0eSBvd25lciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiB0aGUgdmFsdWUgaGFzIG5vdCB5ZXQgYmVlbiBzZXQsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmVcbiAgICAgKiBjb21wdXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIEF0dGFjaGVkUHJvcGVydHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhciBtYXAgPSBQcml2YXRlLmVuc3VyZU1hcChvd25lcik7XG4gICAgICAgIGlmICh0aGlzLl9waWQgaW4gbWFwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hcFt0aGlzLl9waWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXBbdGhpcy5fcGlkXSA9IHRoaXMuX2NyZWF0ZVZhbHVlKG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciBhIGdpdmVuIG93bmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG93bmVyIC0gVGhlIHByb3BlcnR5IG93bmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHZhbHVlIGhhcyBub3QgeWV0IGJlZW4gc2V0LCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlXG4gICAgICogY29tcHV0ZWQgYW5kIHVzZWQgYXMgdGhlIHByZXZpb3VzIHZhbHVlIGZvciB0aGUgY29tcGFyaXNvbi5cbiAgICAgKi9cbiAgICBBdHRhY2hlZFByb3BlcnR5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3duZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZTtcbiAgICAgICAgdmFyIG1hcCA9IFByaXZhdGUuZW5zdXJlTWFwKG93bmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX3BpZCBpbiBtYXApIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gbWFwW3RoaXMuX3BpZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IG1hcFt0aGlzLl9waWRdID0gdGhpcy5fY3JlYXRlVmFsdWUob3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuX2NvZXJjZVZhbHVlKG93bmVyLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX21heWJlTm90aWZ5KG93bmVyLCBvbGRWYWx1ZSwgbWFwW3RoaXMuX3BpZF0gPSBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHBsaWNpdGx5IGNvZXJjZSB0aGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBvd25lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvd25lciAtIFRoZSBwcm9wZXJ0eSBvd25lciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiB0aGUgdmFsdWUgaGFzIG5vdCB5ZXQgYmVlbiBzZXQsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmVcbiAgICAgKiBjb21wdXRlZCBhbmQgdXNlZCBhcyB0aGUgcHJldmlvdXMgdmFsdWUgZm9yIHRoZSBjb21wYXJpc29uLlxuICAgICAqL1xuICAgIEF0dGFjaGVkUHJvcGVydHkucHJvdG90eXBlLmNvZXJjZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgICB2YXIgb2xkVmFsdWU7XG4gICAgICAgIHZhciBtYXAgPSBQcml2YXRlLmVuc3VyZU1hcChvd25lcik7XG4gICAgICAgIGlmICh0aGlzLl9waWQgaW4gbWFwKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IG1hcFt0aGlzLl9waWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSBtYXBbdGhpcy5fcGlkXSA9IHRoaXMuX2NyZWF0ZVZhbHVlKG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLl9jb2VyY2VWYWx1ZShvd25lciwgb2xkVmFsdWUpO1xuICAgICAgICB0aGlzLl9tYXliZU5vdGlmeShvd25lciwgb2xkVmFsdWUsIG1hcFt0aGlzLl9waWRdID0gbmV3VmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IG9yIGNyZWF0ZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIG93bmVyLlxuICAgICAqL1xuICAgIEF0dGFjaGVkUHJvcGVydHkucHJvdG90eXBlLl9jcmVhdGVWYWx1ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgICB2YXIgY3JlYXRlID0gdGhpcy5fY3JlYXRlO1xuICAgICAgICByZXR1cm4gY3JlYXRlKG93bmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvZXJjZSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvd25lci5cbiAgICAgKi9cbiAgICBBdHRhY2hlZFByb3BlcnR5LnByb3RvdHlwZS5fY29lcmNlVmFsdWUgPSBmdW5jdGlvbiAob3duZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjb2VyY2UgPSB0aGlzLl9jb2VyY2U7XG4gICAgICAgIHJldHVybiBjb2VyY2UgPyBjb2VyY2Uob3duZXIsIHZhbHVlKSA6IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGUgb2xkIHZhbHVlIGFuZCBuZXcgdmFsdWUgZm9yIGVxdWFsaXR5LlxuICAgICAqL1xuICAgIEF0dGFjaGVkUHJvcGVydHkucHJvdG90eXBlLl9jb21wYXJlVmFsdWUgPSBmdW5jdGlvbiAob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyZTtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUgPyBjb21wYXJlKG9sZFZhbHVlLCBuZXdWYWx1ZSkgOiBvbGRWYWx1ZSA9PT0gbmV3VmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIGdpdmVuIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICAgICAqL1xuICAgIEF0dGFjaGVkUHJvcGVydHkucHJvdG90eXBlLl9tYXliZU5vdGlmeSA9IGZ1bmN0aW9uIChvd25lciwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fY2hhbmdlZDtcbiAgICAgICAgaWYgKGNoYW5nZWQgJiYgIXRoaXMuX2NvbXBhcmVWYWx1ZShvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBjaGFuZ2VkKG93bmVyLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXR0YWNoZWRQcm9wZXJ0eTtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgQXR0YWNoZWRQcm9wZXJ0eWAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChBdHRhY2hlZFByb3BlcnR5KSB7XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHN0b3JlZCBwcm9wZXJ0eSBkYXRhIGZvciB0aGUgZ2l2ZW4gb3duZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3duZXIgLSBUaGUgcHJvcGVydHkgb3duZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIGNsZWFyIGFsbCBwcm9wZXJ0eSB2YWx1ZXMgZm9yIHRoZSBvd25lciwgYnV0IGl0IHdpbGxcbiAgICAgKiAqKm5vdCoqIHJ1biB0aGUgY2hhbmdlIG5vdGlmaWNhdGlvbiBmb3IgYW55IG9mIHRoZSBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyRGF0YShvd25lcikge1xuICAgICAgICBQcml2YXRlLm93bmVyRGF0YS5kZWxldGUob3duZXIpO1xuICAgIH1cbiAgICBBdHRhY2hlZFByb3BlcnR5LmNsZWFyRGF0YSA9IGNsZWFyRGF0YTtcbn0pKEF0dGFjaGVkUHJvcGVydHkgfHwgKEF0dGFjaGVkUHJvcGVydHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQSB3ZWFrIG1hcHBpbmcgb2YgcHJvcGVydHkgb3duZXIgdG8gcHJvcGVydHkgbWFwLlxuICAgICAqL1xuICAgIFByaXZhdGUub3duZXJEYXRhID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGNvbXB1dGVzIHN1Y2Nlc3NpdmUgdW5pcXVlIHByb3BlcnR5IGlkcy5cbiAgICAgKi9cbiAgICBQcml2YXRlLm5leHRQSUQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgdmFyIHN0ZW0gPSAoXCJcIiArIHJhbmQpLnNsaWNlKDIpO1xuICAgICAgICAgICAgcmV0dXJuIFwicGlkLVwiICsgc3RlbSArIFwiLVwiICsgaWQrKztcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIC8qKlxuICAgICAqIExvb2t1cCB0aGUgZGF0YSBtYXAgZm9yIHRoZSBwcm9wZXJ0eSBvd25lci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBjcmVhdGUgdGhlIG1hcCBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbnN1cmVNYXAob3duZXIpIHtcbiAgICAgICAgdmFyIG1hcCA9IFByaXZhdGUub3duZXJEYXRhLmdldChvd25lcik7XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgUHJpdmF0ZS5vd25lckRhdGEuc2V0KG93bmVyLCBtYXApO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBQcml2YXRlLmVuc3VyZU1hcCA9IGVuc3VyZU1hcDtcbn0pKFByaXZhdGUgfHwgKFByaXZhdGUgPSB7fSkpO1xuXG5leHBvcnQgeyBBdHRhY2hlZFByb3BlcnR5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/properties/dist/index.es6.js\n')},"./node_modules/@lumino/signaling/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Signal\": () => (/* binding */ Signal)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/algorithm/dist/index.es6.js\");\n\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A concrete implementation of `ISignal`.\n *\n * #### Example\n * ```typescript\n * import { ISignal, Signal } from '@lumino/signaling';\n *\n * class SomeClass {\n *\n *   constructor(name: string) {\n *     this.name = name;\n *   }\n *\n *   readonly name: string;\n *\n *   get valueChanged: ISignal<this, number> {\n *     return this._valueChanged;\n *   }\n *\n *   get value(): number {\n *     return this._value;\n *   }\n *\n *   set value(value: number) {\n *     if (value === this._value) {\n *       return;\n *     }\n *     this._value = value;\n *     this._valueChanged.emit(value);\n *   }\n *\n *   private _value = 0;\n *   private _valueChanged = new Signal<this, number>(this);\n * }\n *\n * function logger(sender: SomeClass, value: number): void {\n *   console.log(sender.name, value);\n * }\n *\n * let m1 = new SomeClass('foo');\n * let m2 = new SomeClass('bar');\n *\n * m1.valueChanged.connect(logger);\n * m2.valueChanged.connect(logger);\n *\n * m1.value = 42;  // logs: foo 42\n * m2.value = 17;  // logs: bar 17\n * ```\n */\nvar Signal = /** @class */ (function () {\n    /**\n     * Construct a new signal.\n     *\n     * @param sender - The sender which owns the signal.\n     */\n    function Signal(sender) {\n        this.sender = sender;\n    }\n    /**\n     * Connect a slot to the signal.\n     *\n     * @param slot - The slot to invoke when the signal is emitted.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection succeeds, `false` otherwise.\n     */\n    Signal.prototype.connect = function (slot, thisArg) {\n        return Private.connect(this, slot, thisArg);\n    };\n    /**\n     * Disconnect a slot from the signal.\n     *\n     * @param slot - The slot to disconnect from the signal.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection is removed, `false` otherwise.\n     */\n    Signal.prototype.disconnect = function (slot, thisArg) {\n        return Private.disconnect(this, slot, thisArg);\n    };\n    /**\n     * Emit the signal and invoke the connected slots.\n     *\n     * @param args - The args to pass to the connected slots.\n     *\n     * #### Notes\n     * Slots are invoked synchronously in connection order.\n     *\n     * Exceptions thrown by connected slots will be caught and logged.\n     */\n    Signal.prototype.emit = function (args) {\n        Private.emit(this, args);\n    };\n    return Signal;\n}());\n/**\n * The namespace for the `Signal` class statics.\n */\n(function (Signal) {\n    /**\n     * Remove all connections between a sender and receiver.\n     *\n     * @param sender - The sender object of interest.\n     *\n     * @param receiver - The receiver object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectBetween(sender, receiver) {\n        Private.disconnectBetween(sender, receiver);\n    }\n    Signal.disconnectBetween = disconnectBetween;\n    /**\n     * Remove all connections where the given object is the sender.\n     *\n     * @param sender - The sender object of interest.\n     */\n    function disconnectSender(sender) {\n        Private.disconnectSender(sender);\n    }\n    Signal.disconnectSender = disconnectSender;\n    /**\n     * Remove all connections where the given object is the receiver.\n     *\n     * @param receiver - The receiver object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectReceiver(receiver) {\n        Private.disconnectReceiver(receiver);\n    }\n    Signal.disconnectReceiver = disconnectReceiver;\n    /**\n     * Remove all connections where an object is the sender or receiver.\n     *\n     * @param object - The object of interest.\n     *\n     * #### Notes\n     * If a `thisArg` is provided when connecting a signal, that object\n     * is considered the receiver. Otherwise, the `slot` is considered\n     * the receiver.\n     */\n    function disconnectAll(object) {\n        Private.disconnectAll(object);\n    }\n    Signal.disconnectAll = disconnectAll;\n    /**\n     * Clear all signal data associated with the given object.\n     *\n     * @param object - The object for which the data should be cleared.\n     *\n     * #### Notes\n     * This removes all signal connections and any other signal data\n     * associated with the object.\n     */\n    function clearData(object) {\n        Private.disconnectAll(object);\n    }\n    Signal.clearData = clearData;\n    /**\n     * Get the signal exception handler.\n     *\n     * @returns The current exception handler.\n     *\n     * #### Notes\n     * The default exception handler is `console.error`.\n     */\n    function getExceptionHandler() {\n        return Private.exceptionHandler;\n    }\n    Signal.getExceptionHandler = getExceptionHandler;\n    /**\n     * Set the signal exception handler.\n     *\n     * @param handler - The function to use as the exception handler.\n     *\n     * @returns The old exception handler.\n     *\n     * #### Notes\n     * The exception handler is invoked when a slot throws an exception.\n     */\n    function setExceptionHandler(handler) {\n        var old = Private.exceptionHandler;\n        Private.exceptionHandler = handler;\n        return old;\n    }\n    Signal.setExceptionHandler = setExceptionHandler;\n})(Signal || (Signal = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The signal exception handler function.\n     */\n    Private.exceptionHandler = function (err) {\n        console.error(err);\n    };\n    /**\n     * Connect a slot to a signal.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param slot - The slot to invoke when the signal is emitted.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection succeeds, `false` otherwise.\n     */\n    function connect(signal, slot, thisArg) {\n        // Coerce a `null` `thisArg` to `undefined`.\n        thisArg = thisArg || undefined;\n        // Ensure the sender's array of receivers is created.\n        var receivers = receiversForSender.get(signal.sender);\n        if (!receivers) {\n            receivers = [];\n            receiversForSender.set(signal.sender, receivers);\n        }\n        // Bail if a matching connection already exists.\n        if (findConnection(receivers, signal, slot, thisArg)) {\n            return false;\n        }\n        // Choose the best object for the receiver.\n        var receiver = thisArg || slot;\n        // Ensure the receiver's array of senders is created.\n        var senders = sendersForReceiver.get(receiver);\n        if (!senders) {\n            senders = [];\n            sendersForReceiver.set(receiver, senders);\n        }\n        // Create a new connection and add it to the end of each array.\n        var connection = { signal: signal, slot: slot, thisArg: thisArg };\n        receivers.push(connection);\n        senders.push(connection);\n        // Indicate a successful connection.\n        return true;\n    }\n    Private.connect = connect;\n    /**\n     * Disconnect a slot from a signal.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param slot - The slot to disconnect from the signal.\n     *\n     * @param thisArg - The `this` context for the slot. If provided,\n     *   this must be a non-primitive object.\n     *\n     * @returns `true` if the connection is removed, `false` otherwise.\n     */\n    function disconnect(signal, slot, thisArg) {\n        // Coerce a `null` `thisArg` to `undefined`.\n        thisArg = thisArg || undefined;\n        // Lookup the list of receivers, and bail if none exist.\n        var receivers = receiversForSender.get(signal.sender);\n        if (!receivers || receivers.length === 0) {\n            return false;\n        }\n        // Bail if no matching connection exits.\n        var connection = findConnection(receivers, signal, slot, thisArg);\n        if (!connection) {\n            return false;\n        }\n        // Choose the best object for the receiver.\n        var receiver = thisArg || slot;\n        // Lookup the array of senders, which is now known to exist.\n        var senders = sendersForReceiver.get(receiver);\n        // Clear the connection and schedule cleanup of the arrays.\n        connection.signal = null;\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n        // Indicate a successful disconnection.\n        return true;\n    }\n    Private.disconnect = disconnect;\n    /**\n     * Remove all connections between a sender and receiver.\n     *\n     * @param sender - The sender object of interest.\n     *\n     * @param receiver - The receiver object of interest.\n     */\n    function disconnectBetween(sender, receiver) {\n        // If there are no receivers, there is nothing to do.\n        var receivers = receiversForSender.get(sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // If there are no senders, there is nothing to do.\n        var senders = sendersForReceiver.get(receiver);\n        if (!senders || senders.length === 0) {\n            return;\n        }\n        // Clear each connection between the sender and receiver.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(senders, function (connection) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                return;\n            }\n            // Clear the connection if it matches the sender.\n            if (connection.signal.sender === sender) {\n                connection.signal = null;\n            }\n        });\n        // Schedule a cleanup of the senders and receivers.\n        scheduleCleanup(receivers);\n        scheduleCleanup(senders);\n    }\n    Private.disconnectBetween = disconnectBetween;\n    /**\n     * Remove all connections where the given object is the sender.\n     *\n     * @param sender - The sender object of interest.\n     */\n    function disconnectSender(sender) {\n        // If there are no receivers, there is nothing to do.\n        var receivers = receiversForSender.get(sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // Clear each receiver connection.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(receivers, function (connection) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                return;\n            }\n            // Choose the best object for the receiver.\n            var receiver = connection.thisArg || connection.slot;\n            // Clear the connection.\n            connection.signal = null;\n            // Cleanup the array of senders, which is now known to exist.\n            scheduleCleanup(sendersForReceiver.get(receiver));\n        });\n        // Schedule a cleanup of the receivers.\n        scheduleCleanup(receivers);\n    }\n    Private.disconnectSender = disconnectSender;\n    /**\n     * Remove all connections where the given object is the receiver.\n     *\n     * @param receiver - The receiver object of interest.\n     */\n    function disconnectReceiver(receiver) {\n        // If there are no senders, there is nothing to do.\n        var senders = sendersForReceiver.get(receiver);\n        if (!senders || senders.length === 0) {\n            return;\n        }\n        // Clear each sender connection.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(senders, function (connection) {\n            // Skip connections which have already been cleared.\n            if (!connection.signal) {\n                return;\n            }\n            // Lookup the sender for the connection.\n            var sender = connection.signal.sender;\n            // Clear the connection.\n            connection.signal = null;\n            // Cleanup the array of receivers, which is now known to exist.\n            scheduleCleanup(receiversForSender.get(sender));\n        });\n        // Schedule a cleanup of the list of senders.\n        scheduleCleanup(senders);\n    }\n    Private.disconnectReceiver = disconnectReceiver;\n    /**\n     * Remove all connections where an object is the sender or receiver.\n     *\n     * @param object - The object of interest.\n     */\n    function disconnectAll(object) {\n        // Remove all connections where the given object is the sender.\n        disconnectSender(object);\n        // Remove all connections where the given object is the receiver.\n        disconnectReceiver(object);\n    }\n    Private.disconnectAll = disconnectAll;\n    /**\n     * Emit a signal and invoke its connected slots.\n     *\n     * @param signal - The signal of interest.\n     *\n     * @param args - The args to pass to the connected slots.\n     *\n     * #### Notes\n     * Slots are invoked synchronously in connection order.\n     *\n     * Exceptions thrown by connected slots will be caught and logged.\n     */\n    function emit(signal, args) {\n        // If there are no receivers, there is nothing to do.\n        var receivers = receiversForSender.get(signal.sender);\n        if (!receivers || receivers.length === 0) {\n            return;\n        }\n        // Invoke the slots for connections with a matching signal.\n        // Any connections added during emission are not invoked.\n        for (var i = 0, n = receivers.length; i < n; ++i) {\n            var connection = receivers[i];\n            if (connection.signal === signal) {\n                invokeSlot(connection, args);\n            }\n        }\n    }\n    Private.emit = emit;\n    /**\n     * A weak mapping of sender to array of receiver connections.\n     */\n    var receiversForSender = new WeakMap();\n    /**\n     * A weak mapping of receiver to array of sender connections.\n     */\n    var sendersForReceiver = new WeakMap();\n    /**\n     * A set of connection arrays which are pending cleanup.\n     */\n    var dirtySet = new Set();\n    /**\n     * A function to schedule an event loop callback.\n     */\n    var schedule = (function () {\n        var ok = typeof requestAnimationFrame === 'function';\n        // @ts-ignore\n        return ok ? requestAnimationFrame : setImmediate;\n    })();\n    /**\n     * Find a connection which matches the given parameters.\n     */\n    function findConnection(connections, signal, slot, thisArg) {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(connections, function (connection) { return (connection.signal === signal &&\n            connection.slot === slot &&\n            connection.thisArg === thisArg); });\n    }\n    /**\n     * Invoke a slot with the given parameters.\n     *\n     * The connection is assumed to be valid.\n     *\n     * Exceptions in the slot will be caught and logged.\n     */\n    function invokeSlot(connection, args) {\n        var signal = connection.signal, slot = connection.slot, thisArg = connection.thisArg;\n        try {\n            slot.call(thisArg, signal.sender, args);\n        }\n        catch (err) {\n            Private.exceptionHandler(err);\n        }\n    }\n    /**\n     * Schedule a cleanup of a connection array.\n     *\n     * This will add the array to the dirty set and schedule a deferred\n     * cleanup of the array contents. On cleanup, any connection with a\n     * `null` signal will be removed from the array.\n     */\n    function scheduleCleanup(array) {\n        if (dirtySet.size === 0) {\n            schedule(cleanupDirtySet);\n        }\n        dirtySet.add(array);\n    }\n    /**\n     * Cleanup the connection lists in the dirty set.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupDirtySet() {\n        dirtySet.forEach(cleanupConnections);\n        dirtySet.clear();\n    }\n    /**\n     * Cleanup the dirty connections in a connections array.\n     *\n     * This will remove any connection with a `null` signal.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupConnections(connections) {\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAllWhere(connections, isDeadConnection);\n    }\n    /**\n     * Test whether a connection is dead.\n     *\n     * A dead connection has a `null` signal.\n     */\n    function isDeadConnection(connection) {\n        return connection.signal === null;\n    }\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby9zaWduYWxpbmcvZGlzdC9pbmRleC5lczYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUksc0NBQXNDO0FBQ3pEO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRVQ7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWZzaGluL2xpZmUvLi9ub2RlX21vZHVsZXMvQGx1bWluby9zaWduYWxpbmcvZGlzdC9pbmRleC5lczYuanM/MjQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kLCBlYWNoLCBBcnJheUV4dCB9IGZyb20gJ0BsdW1pbm8vYWxnb3JpdGhtJztcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYElTaWduYWxgLlxuICpcbiAqICMjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgSVNpZ25hbCwgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuICpcbiAqIGNsYXNzIFNvbWVDbGFzcyB7XG4gKlxuICogICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcpIHtcbiAqICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICogICB9XG4gKlxuICogICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gKlxuICogICBnZXQgdmFsdWVDaGFuZ2VkOiBJU2lnbmFsPHRoaXMsIG51bWJlcj4ge1xuICogICAgIHJldHVybiB0aGlzLl92YWx1ZUNoYW5nZWQ7XG4gKiAgIH1cbiAqXG4gKiAgIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICogICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAqICAgfVxuICpcbiAqICAgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAqICAgICBpZiAodmFsdWUgPT09IHRoaXMuX3ZhbHVlKSB7XG4gKiAgICAgICByZXR1cm47XG4gKiAgICAgfVxuICogICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gKiAgICAgdGhpcy5fdmFsdWVDaGFuZ2VkLmVtaXQodmFsdWUpO1xuICogICB9XG4gKlxuICogICBwcml2YXRlIF92YWx1ZSA9IDA7XG4gKiAgIHByaXZhdGUgX3ZhbHVlQ2hhbmdlZCA9IG5ldyBTaWduYWw8dGhpcywgbnVtYmVyPih0aGlzKTtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBsb2dnZXIoc2VuZGVyOiBTb21lQ2xhc3MsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAqICAgY29uc29sZS5sb2coc2VuZGVyLm5hbWUsIHZhbHVlKTtcbiAqIH1cbiAqXG4gKiBsZXQgbTEgPSBuZXcgU29tZUNsYXNzKCdmb28nKTtcbiAqIGxldCBtMiA9IG5ldyBTb21lQ2xhc3MoJ2JhcicpO1xuICpcbiAqIG0xLnZhbHVlQ2hhbmdlZC5jb25uZWN0KGxvZ2dlcik7XG4gKiBtMi52YWx1ZUNoYW5nZWQuY29ubmVjdChsb2dnZXIpO1xuICpcbiAqIG0xLnZhbHVlID0gNDI7ICAvLyBsb2dzOiBmb28gNDJcbiAqIG0yLnZhbHVlID0gMTc7ICAvLyBsb2dzOiBiYXIgMTdcbiAqIGBgYFxuICovXG52YXIgU2lnbmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBzaWduYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VuZGVyIC0gVGhlIHNlbmRlciB3aGljaCBvd25zIHRoZSBzaWduYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmFsKHNlbmRlcikge1xuICAgICAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCBhIHNsb3QgdG8gdGhlIHNpZ25hbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbG90IC0gVGhlIHNsb3QgdG8gaW52b2tlIHdoZW4gdGhlIHNpZ25hbCBpcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBUaGUgYHRoaXNgIGNvbnRleHQgZm9yIHRoZSBzbG90LiBJZiBwcm92aWRlZCxcbiAgICAgKiAgIHRoaXMgbXVzdCBiZSBhIG5vbi1wcmltaXRpdmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIHN1Y2NlZWRzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBTaWduYWwucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoc2xvdCwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5jb25uZWN0KHRoaXMsIHNsb3QsIHRoaXNBcmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBhIHNsb3QgZnJvbSB0aGUgc2lnbmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNsb3QgLSBUaGUgc2xvdCB0byBkaXNjb25uZWN0IGZyb20gdGhlIHNpZ25hbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVGhlIGB0aGlzYCBjb250ZXh0IGZvciB0aGUgc2xvdC4gSWYgcHJvdmlkZWQsXG4gICAgICogICB0aGlzIG11c3QgYmUgYSBub24tcHJpbWl0aXZlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBTaWduYWwucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoc2xvdCwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZS5kaXNjb25uZWN0KHRoaXMsIHNsb3QsIHRoaXNBcmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgc2lnbmFsIGFuZCBpbnZva2UgdGhlIGNvbm5lY3RlZCBzbG90cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3MgdG8gcGFzcyB0byB0aGUgY29ubmVjdGVkIHNsb3RzLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFNsb3RzIGFyZSBpbnZva2VkIHN5bmNocm9ub3VzbHkgaW4gY29ubmVjdGlvbiBvcmRlci5cbiAgICAgKlxuICAgICAqIEV4Y2VwdGlvbnMgdGhyb3duIGJ5IGNvbm5lY3RlZCBzbG90cyB3aWxsIGJlIGNhdWdodCBhbmQgbG9nZ2VkLlxuICAgICAqL1xuICAgIFNpZ25hbC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIFByaXZhdGUuZW1pdCh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBTaWduYWw7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYFNpZ25hbGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChTaWduYWwpIHtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGNvbm5lY3Rpb25zIGJldHdlZW4gYSBzZW5kZXIgYW5kIHJlY2VpdmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbmRlciAtIFRoZSBzZW5kZXIgb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIC0gVGhlIHJlY2VpdmVyIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiBhIGB0aGlzQXJnYCBpcyBwcm92aWRlZCB3aGVuIGNvbm5lY3RpbmcgYSBzaWduYWwsIHRoYXQgb2JqZWN0XG4gICAgICogaXMgY29uc2lkZXJlZCB0aGUgcmVjZWl2ZXIuIE90aGVyd2lzZSwgdGhlIGBzbG90YCBpcyBjb25zaWRlcmVkXG4gICAgICogdGhlIHJlY2VpdmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RCZXR3ZWVuKHNlbmRlciwgcmVjZWl2ZXIpIHtcbiAgICAgICAgUHJpdmF0ZS5kaXNjb25uZWN0QmV0d2VlbihzZW5kZXIsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgU2lnbmFsLmRpc2Nvbm5lY3RCZXR3ZWVuID0gZGlzY29ubmVjdEJldHdlZW47XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb25uZWN0aW9ucyB3aGVyZSB0aGUgZ2l2ZW4gb2JqZWN0IGlzIHRoZSBzZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VuZGVyIC0gVGhlIHNlbmRlciBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzY29ubmVjdFNlbmRlcihzZW5kZXIpIHtcbiAgICAgICAgUHJpdmF0ZS5kaXNjb25uZWN0U2VuZGVyKHNlbmRlcik7XG4gICAgfVxuICAgIFNpZ25hbC5kaXNjb25uZWN0U2VuZGVyID0gZGlzY29ubmVjdFNlbmRlcjtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGNvbm5lY3Rpb25zIHdoZXJlIHRoZSBnaXZlbiBvYmplY3QgaXMgdGhlIHJlY2VpdmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIC0gVGhlIHJlY2VpdmVyIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiBhIGB0aGlzQXJnYCBpcyBwcm92aWRlZCB3aGVuIGNvbm5lY3RpbmcgYSBzaWduYWwsIHRoYXQgb2JqZWN0XG4gICAgICogaXMgY29uc2lkZXJlZCB0aGUgcmVjZWl2ZXIuIE90aGVyd2lzZSwgdGhlIGBzbG90YCBpcyBjb25zaWRlcmVkXG4gICAgICogdGhlIHJlY2VpdmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RSZWNlaXZlcihyZWNlaXZlcikge1xuICAgICAgICBQcml2YXRlLmRpc2Nvbm5lY3RSZWNlaXZlcihyZWNlaXZlcik7XG4gICAgfVxuICAgIFNpZ25hbC5kaXNjb25uZWN0UmVjZWl2ZXIgPSBkaXNjb25uZWN0UmVjZWl2ZXI7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb25uZWN0aW9ucyB3aGVyZSBhbiBvYmplY3QgaXMgdGhlIHNlbmRlciBvciByZWNlaXZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIGEgYHRoaXNBcmdgIGlzIHByb3ZpZGVkIHdoZW4gY29ubmVjdGluZyBhIHNpZ25hbCwgdGhhdCBvYmplY3RcbiAgICAgKiBpcyBjb25zaWRlcmVkIHRoZSByZWNlaXZlci4gT3RoZXJ3aXNlLCB0aGUgYHNsb3RgIGlzIGNvbnNpZGVyZWRcbiAgICAgKiB0aGUgcmVjZWl2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzY29ubmVjdEFsbChvYmplY3QpIHtcbiAgICAgICAgUHJpdmF0ZS5kaXNjb25uZWN0QWxsKG9iamVjdCk7XG4gICAgfVxuICAgIFNpZ25hbC5kaXNjb25uZWN0QWxsID0gZGlzY29ubmVjdEFsbDtcbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgc2lnbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCBmb3Igd2hpY2ggdGhlIGRhdGEgc2hvdWxkIGJlIGNsZWFyZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyByZW1vdmVzIGFsbCBzaWduYWwgY29ubmVjdGlvbnMgYW5kIGFueSBvdGhlciBzaWduYWwgZGF0YVxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyRGF0YShvYmplY3QpIHtcbiAgICAgICAgUHJpdmF0ZS5kaXNjb25uZWN0QWxsKG9iamVjdCk7XG4gICAgfVxuICAgIFNpZ25hbC5jbGVhckRhdGEgPSBjbGVhckRhdGE7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaWduYWwgZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBleGNlcHRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBleGNlcHRpb24gaGFuZGxlciBpcyBgY29uc29sZS5lcnJvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RXhjZXB0aW9uSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIFByaXZhdGUuZXhjZXB0aW9uSGFuZGxlcjtcbiAgICB9XG4gICAgU2lnbmFsLmdldEV4Y2VwdGlvbkhhbmRsZXIgPSBnZXRFeGNlcHRpb25IYW5kbGVyO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2lnbmFsIGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgZnVuY3Rpb24gdG8gdXNlIGFzIHRoZSBleGNlcHRpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvbGQgZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGV4Y2VwdGlvbiBoYW5kbGVyIGlzIGludm9rZWQgd2hlbiBhIHNsb3QgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRFeGNlcHRpb25IYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIG9sZCA9IFByaXZhdGUuZXhjZXB0aW9uSGFuZGxlcjtcbiAgICAgICAgUHJpdmF0ZS5leGNlcHRpb25IYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICB9XG4gICAgU2lnbmFsLnNldEV4Y2VwdGlvbkhhbmRsZXIgPSBzZXRFeGNlcHRpb25IYW5kbGVyO1xufSkoU2lnbmFsIHx8IChTaWduYWwgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHNpZ25hbCBleGNlcHRpb24gaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBQcml2YXRlLmV4Y2VwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYSBzbG90IHRvIGEgc2lnbmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hbCAtIFRoZSBzaWduYWwgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2xvdCAtIFRoZSBzbG90IHRvIGludm9rZSB3aGVuIHRoZSBzaWduYWwgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVGhlIGB0aGlzYCBjb250ZXh0IGZvciB0aGUgc2xvdC4gSWYgcHJvdmlkZWQsXG4gICAgICogICB0aGlzIG11c3QgYmUgYSBub24tcHJpbWl0aXZlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBzdWNjZWVkcywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29ubmVjdChzaWduYWwsIHNsb3QsIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gQ29lcmNlIGEgYG51bGxgIGB0aGlzQXJnYCB0byBgdW5kZWZpbmVkYC5cbiAgICAgICAgdGhpc0FyZyA9IHRoaXNBcmcgfHwgdW5kZWZpbmVkO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHNlbmRlcidzIGFycmF5IG9mIHJlY2VpdmVycyBpcyBjcmVhdGVkLlxuICAgICAgICB2YXIgcmVjZWl2ZXJzID0gcmVjZWl2ZXJzRm9yU2VuZGVyLmdldChzaWduYWwuc2VuZGVyKTtcbiAgICAgICAgaWYgKCFyZWNlaXZlcnMpIHtcbiAgICAgICAgICAgIHJlY2VpdmVycyA9IFtdO1xuICAgICAgICAgICAgcmVjZWl2ZXJzRm9yU2VuZGVyLnNldChzaWduYWwuc2VuZGVyLCByZWNlaXZlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgaWYgYSBtYXRjaGluZyBjb25uZWN0aW9uIGFscmVhZHkgZXhpc3RzLlxuICAgICAgICBpZiAoZmluZENvbm5lY3Rpb24ocmVjZWl2ZXJzLCBzaWduYWwsIHNsb3QsIHRoaXNBcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hvb3NlIHRoZSBiZXN0IG9iamVjdCBmb3IgdGhlIHJlY2VpdmVyLlxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzQXJnIHx8IHNsb3Q7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcmVjZWl2ZXIncyBhcnJheSBvZiBzZW5kZXJzIGlzIGNyZWF0ZWQuXG4gICAgICAgIHZhciBzZW5kZXJzID0gc2VuZGVyc0ZvclJlY2VpdmVyLmdldChyZWNlaXZlcik7XG4gICAgICAgIGlmICghc2VuZGVycykge1xuICAgICAgICAgICAgc2VuZGVycyA9IFtdO1xuICAgICAgICAgICAgc2VuZGVyc0ZvclJlY2VpdmVyLnNldChyZWNlaXZlciwgc2VuZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gYW5kIGFkZCBpdCB0byB0aGUgZW5kIG9mIGVhY2ggYXJyYXkuXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0geyBzaWduYWw6IHNpZ25hbCwgc2xvdDogc2xvdCwgdGhpc0FyZzogdGhpc0FyZyB9O1xuICAgICAgICByZWNlaXZlcnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgc2VuZGVycy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICAvLyBJbmRpY2F0ZSBhIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFByaXZhdGUuY29ubmVjdCA9IGNvbm5lY3Q7XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBhIHNsb3QgZnJvbSBhIHNpZ25hbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgc2lnbmFsIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNsb3QgLSBUaGUgc2xvdCB0byBkaXNjb25uZWN0IGZyb20gdGhlIHNpZ25hbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGlzQXJnIC0gVGhlIGB0aGlzYCBjb250ZXh0IGZvciB0aGUgc2xvdC4gSWYgcHJvdmlkZWQsXG4gICAgICogICB0aGlzIG11c3QgYmUgYSBub24tcHJpbWl0aXZlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0KHNpZ25hbCwgc2xvdCwgdGhpc0FyZykge1xuICAgICAgICAvLyBDb2VyY2UgYSBgbnVsbGAgYHRoaXNBcmdgIHRvIGB1bmRlZmluZWRgLlxuICAgICAgICB0aGlzQXJnID0gdGhpc0FyZyB8fCB1bmRlZmluZWQ7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgbGlzdCBvZiByZWNlaXZlcnMsIGFuZCBiYWlsIGlmIG5vbmUgZXhpc3QuXG4gICAgICAgIHZhciByZWNlaXZlcnMgPSByZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHNpZ25hbC5zZW5kZXIpO1xuICAgICAgICBpZiAoIXJlY2VpdmVycyB8fCByZWNlaXZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBpZiBubyBtYXRjaGluZyBjb25uZWN0aW9uIGV4aXRzLlxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGZpbmRDb25uZWN0aW9uKHJlY2VpdmVycywgc2lnbmFsLCBzbG90LCB0aGlzQXJnKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hvb3NlIHRoZSBiZXN0IG9iamVjdCBmb3IgdGhlIHJlY2VpdmVyLlxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzQXJnIHx8IHNsb3Q7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgYXJyYXkgb2Ygc2VuZGVycywgd2hpY2ggaXMgbm93IGtub3duIHRvIGV4aXN0LlxuICAgICAgICB2YXIgc2VuZGVycyA9IHNlbmRlcnNGb3JSZWNlaXZlci5nZXQocmVjZWl2ZXIpO1xuICAgICAgICAvLyBDbGVhciB0aGUgY29ubmVjdGlvbiBhbmQgc2NoZWR1bGUgY2xlYW51cCBvZiB0aGUgYXJyYXlzLlxuICAgICAgICBjb25uZWN0aW9uLnNpZ25hbCA9IG51bGw7XG4gICAgICAgIHNjaGVkdWxlQ2xlYW51cChyZWNlaXZlcnMpO1xuICAgICAgICBzY2hlZHVsZUNsZWFudXAoc2VuZGVycyk7XG4gICAgICAgIC8vIEluZGljYXRlIGEgc3VjY2Vzc2Z1bCBkaXNjb25uZWN0aW9uLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgUHJpdmF0ZS5kaXNjb25uZWN0ID0gZGlzY29ubmVjdDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGNvbm5lY3Rpb25zIGJldHdlZW4gYSBzZW5kZXIgYW5kIHJlY2VpdmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbmRlciAtIFRoZSBzZW5kZXIgb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIC0gVGhlIHJlY2VpdmVyIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0QmV0d2VlbihzZW5kZXIsIHJlY2VpdmVyKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyByZWNlaXZlcnMsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIHZhciByZWNlaXZlcnMgPSByZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHNlbmRlcik7XG4gICAgICAgIGlmICghcmVjZWl2ZXJzIHx8IHJlY2VpdmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc2VuZGVycywgdGhlcmUgaXMgbm90aGluZyB0byBkby5cbiAgICAgICAgdmFyIHNlbmRlcnMgPSBzZW5kZXJzRm9yUmVjZWl2ZXIuZ2V0KHJlY2VpdmVyKTtcbiAgICAgICAgaWYgKCFzZW5kZXJzIHx8IHNlbmRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgZWFjaCBjb25uZWN0aW9uIGJldHdlZW4gdGhlIHNlbmRlciBhbmQgcmVjZWl2ZXIuXG4gICAgICAgIGVhY2goc2VuZGVycywgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNraXAgY29ubmVjdGlvbnMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gY2xlYXJlZC5cbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbi5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgY29ubmVjdGlvbiBpZiBpdCBtYXRjaGVzIHRoZSBzZW5kZXIuXG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zaWduYWwuc2VuZGVyID09PSBzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNpZ25hbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTY2hlZHVsZSBhIGNsZWFudXAgb2YgdGhlIHNlbmRlcnMgYW5kIHJlY2VpdmVycy5cbiAgICAgICAgc2NoZWR1bGVDbGVhbnVwKHJlY2VpdmVycyk7XG4gICAgICAgIHNjaGVkdWxlQ2xlYW51cChzZW5kZXJzKTtcbiAgICB9XG4gICAgUHJpdmF0ZS5kaXNjb25uZWN0QmV0d2VlbiA9IGRpc2Nvbm5lY3RCZXR3ZWVuO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgY29ubmVjdGlvbnMgd2hlcmUgdGhlIGdpdmVuIG9iamVjdCBpcyB0aGUgc2VuZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbmRlciAtIFRoZSBzZW5kZXIgb2JqZWN0IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RTZW5kZXIoc2VuZGVyKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyByZWNlaXZlcnMsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIHZhciByZWNlaXZlcnMgPSByZWNlaXZlcnNGb3JTZW5kZXIuZ2V0KHNlbmRlcik7XG4gICAgICAgIGlmICghcmVjZWl2ZXJzIHx8IHJlY2VpdmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBlYWNoIHJlY2VpdmVyIGNvbm5lY3Rpb24uXG4gICAgICAgIGVhY2gocmVjZWl2ZXJzLCBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gU2tpcCBjb25uZWN0aW9ucyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBjbGVhcmVkLlxuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uLnNpZ25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENob29zZSB0aGUgYmVzdCBvYmplY3QgZm9yIHRoZSByZWNlaXZlci5cbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IGNvbm5lY3Rpb24udGhpc0FyZyB8fCBjb25uZWN0aW9uLnNsb3Q7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2lnbmFsID0gbnVsbDtcbiAgICAgICAgICAgIC8vIENsZWFudXAgdGhlIGFycmF5IG9mIHNlbmRlcnMsIHdoaWNoIGlzIG5vdyBrbm93biB0byBleGlzdC5cbiAgICAgICAgICAgIHNjaGVkdWxlQ2xlYW51cChzZW5kZXJzRm9yUmVjZWl2ZXIuZ2V0KHJlY2VpdmVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTY2hlZHVsZSBhIGNsZWFudXAgb2YgdGhlIHJlY2VpdmVycy5cbiAgICAgICAgc2NoZWR1bGVDbGVhbnVwKHJlY2VpdmVycyk7XG4gICAgfVxuICAgIFByaXZhdGUuZGlzY29ubmVjdFNlbmRlciA9IGRpc2Nvbm5lY3RTZW5kZXI7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb25uZWN0aW9ucyB3aGVyZSB0aGUgZ2l2ZW4gb2JqZWN0IGlzIHRoZSByZWNlaXZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWNlaXZlciAtIFRoZSByZWNlaXZlciBvYmplY3Qgb2YgaW50ZXJlc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzY29ubmVjdFJlY2VpdmVyKHJlY2VpdmVyKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBzZW5kZXJzLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLlxuICAgICAgICB2YXIgc2VuZGVycyA9IHNlbmRlcnNGb3JSZWNlaXZlci5nZXQocmVjZWl2ZXIpO1xuICAgICAgICBpZiAoIXNlbmRlcnMgfHwgc2VuZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBlYWNoIHNlbmRlciBjb25uZWN0aW9uLlxuICAgICAgICBlYWNoKHNlbmRlcnMsIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGNvbm5lY3Rpb25zIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGNsZWFyZWQuXG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24uc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSBzZW5kZXIgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgdmFyIHNlbmRlciA9IGNvbm5lY3Rpb24uc2lnbmFsLnNlbmRlcjtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgY29ubmVjdGlvbi5zaWduYWwgPSBudWxsO1xuICAgICAgICAgICAgLy8gQ2xlYW51cCB0aGUgYXJyYXkgb2YgcmVjZWl2ZXJzLCB3aGljaCBpcyBub3cga25vd24gdG8gZXhpc3QuXG4gICAgICAgICAgICBzY2hlZHVsZUNsZWFudXAocmVjZWl2ZXJzRm9yU2VuZGVyLmdldChzZW5kZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGEgY2xlYW51cCBvZiB0aGUgbGlzdCBvZiBzZW5kZXJzLlxuICAgICAgICBzY2hlZHVsZUNsZWFudXAoc2VuZGVycyk7XG4gICAgfVxuICAgIFByaXZhdGUuZGlzY29ubmVjdFJlY2VpdmVyID0gZGlzY29ubmVjdFJlY2VpdmVyO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgY29ubmVjdGlvbnMgd2hlcmUgYW4gb2JqZWN0IGlzIHRoZSBzZW5kZXIgb3IgcmVjZWl2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0QWxsKG9iamVjdCkge1xuICAgICAgICAvLyBSZW1vdmUgYWxsIGNvbm5lY3Rpb25zIHdoZXJlIHRoZSBnaXZlbiBvYmplY3QgaXMgdGhlIHNlbmRlci5cbiAgICAgICAgZGlzY29ubmVjdFNlbmRlcihvYmplY3QpO1xuICAgICAgICAvLyBSZW1vdmUgYWxsIGNvbm5lY3Rpb25zIHdoZXJlIHRoZSBnaXZlbiBvYmplY3QgaXMgdGhlIHJlY2VpdmVyLlxuICAgICAgICBkaXNjb25uZWN0UmVjZWl2ZXIob2JqZWN0KTtcbiAgICB9XG4gICAgUHJpdmF0ZS5kaXNjb25uZWN0QWxsID0gZGlzY29ubmVjdEFsbDtcbiAgICAvKipcbiAgICAgKiBFbWl0IGEgc2lnbmFsIGFuZCBpbnZva2UgaXRzIGNvbm5lY3RlZCBzbG90cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYWwgLSBUaGUgc2lnbmFsIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJncyB0byBwYXNzIHRvIHRoZSBjb25uZWN0ZWQgc2xvdHMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogU2xvdHMgYXJlIGludm9rZWQgc3luY2hyb25vdXNseSBpbiBjb25uZWN0aW9uIG9yZGVyLlxuICAgICAqXG4gICAgICogRXhjZXB0aW9ucyB0aHJvd24gYnkgY29ubmVjdGVkIHNsb3RzIHdpbGwgYmUgY2F1Z2h0IGFuZCBsb2dnZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1pdChzaWduYWwsIGFyZ3MpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHJlY2VpdmVycywgdGhlcmUgaXMgbm90aGluZyB0byBkby5cbiAgICAgICAgdmFyIHJlY2VpdmVycyA9IHJlY2VpdmVyc0ZvclNlbmRlci5nZXQoc2lnbmFsLnNlbmRlcik7XG4gICAgICAgIGlmICghcmVjZWl2ZXJzIHx8IHJlY2VpdmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnZva2UgdGhlIHNsb3RzIGZvciBjb25uZWN0aW9ucyB3aXRoIGEgbWF0Y2hpbmcgc2lnbmFsLlxuICAgICAgICAvLyBBbnkgY29ubmVjdGlvbnMgYWRkZWQgZHVyaW5nIGVtaXNzaW9uIGFyZSBub3QgaW52b2tlZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByZWNlaXZlcnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHJlY2VpdmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnNpZ25hbCA9PT0gc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlU2xvdChjb25uZWN0aW9uLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBQcml2YXRlLmVtaXQgPSBlbWl0O1xuICAgIC8qKlxuICAgICAqIEEgd2VhayBtYXBwaW5nIG9mIHNlbmRlciB0byBhcnJheSBvZiByZWNlaXZlciBjb25uZWN0aW9ucy5cbiAgICAgKi9cbiAgICB2YXIgcmVjZWl2ZXJzRm9yU2VuZGVyID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKipcbiAgICAgKiBBIHdlYWsgbWFwcGluZyBvZiByZWNlaXZlciB0byBhcnJheSBvZiBzZW5kZXIgY29ubmVjdGlvbnMuXG4gICAgICovXG4gICAgdmFyIHNlbmRlcnNGb3JSZWNlaXZlciA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgY29ubmVjdGlvbiBhcnJheXMgd2hpY2ggYXJlIHBlbmRpbmcgY2xlYW51cC5cbiAgICAgKi9cbiAgICB2YXIgZGlydHlTZXQgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byBzY2hlZHVsZSBhbiBldmVudCBsb29wIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHZhciBzY2hlZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvayA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG9rID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0SW1tZWRpYXRlO1xuICAgIH0pKCk7XG4gICAgLyoqXG4gICAgICogRmluZCBhIGNvbm5lY3Rpb24gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQ29ubmVjdGlvbihjb25uZWN0aW9ucywgc2lnbmFsLCBzbG90LCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiBmaW5kKGNvbm5lY3Rpb25zLCBmdW5jdGlvbiAoY29ubmVjdGlvbikgeyByZXR1cm4gKGNvbm5lY3Rpb24uc2lnbmFsID09PSBzaWduYWwgJiZcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2xvdCA9PT0gc2xvdCAmJlxuICAgICAgICAgICAgY29ubmVjdGlvbi50aGlzQXJnID09PSB0aGlzQXJnKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBhIHNsb3Qgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgdmFsaWQuXG4gICAgICpcbiAgICAgKiBFeGNlcHRpb25zIGluIHRoZSBzbG90IHdpbGwgYmUgY2F1Z2h0IGFuZCBsb2dnZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlU2xvdChjb25uZWN0aW9uLCBhcmdzKSB7XG4gICAgICAgIHZhciBzaWduYWwgPSBjb25uZWN0aW9uLnNpZ25hbCwgc2xvdCA9IGNvbm5lY3Rpb24uc2xvdCwgdGhpc0FyZyA9IGNvbm5lY3Rpb24udGhpc0FyZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNsb3QuY2FsbCh0aGlzQXJnLCBzaWduYWwuc2VuZGVyLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBQcml2YXRlLmV4Y2VwdGlvbkhhbmRsZXIoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhIGNsZWFudXAgb2YgYSBjb25uZWN0aW9uIGFycmF5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFkZCB0aGUgYXJyYXkgdG8gdGhlIGRpcnR5IHNldCBhbmQgc2NoZWR1bGUgYSBkZWZlcnJlZFxuICAgICAqIGNsZWFudXAgb2YgdGhlIGFycmF5IGNvbnRlbnRzLiBPbiBjbGVhbnVwLCBhbnkgY29ubmVjdGlvbiB3aXRoIGFcbiAgICAgKiBgbnVsbGAgc2lnbmFsIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNsZWFudXAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGRpcnR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNsZWFudXBEaXJ0eVNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlydHlTZXQuYWRkKGFycmF5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW51cCB0aGUgY29ubmVjdGlvbiBsaXN0cyBpbiB0aGUgZGlydHkgc2V0LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBpbnZva2VkIGFzeW5jaHJvbm91c2x5LCB3aGVuIHRoZVxuICAgICAqIHN0YWNrIGZyYW1lIGlzIGd1YXJhbnRlZWQgdG8gbm90IGJlIG9uIHRoZSBwYXRoIG9mIHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhbnVwRGlydHlTZXQoKSB7XG4gICAgICAgIGRpcnR5U2V0LmZvckVhY2goY2xlYW51cENvbm5lY3Rpb25zKTtcbiAgICAgICAgZGlydHlTZXQuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW51cCB0aGUgZGlydHkgY29ubmVjdGlvbnMgaW4gYSBjb25uZWN0aW9ucyBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgYW55IGNvbm5lY3Rpb24gd2l0aCBhIGBudWxsYCBzaWduYWwuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGludm9rZWQgYXN5bmNocm9ub3VzbHksIHdoZW4gdGhlXG4gICAgICogc3RhY2sgZnJhbWUgaXMgZ3VhcmFudGVlZCB0byBub3QgYmUgb24gdGhlIHBhdGggb2YgdXNlciBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFudXBDb25uZWN0aW9ucyhjb25uZWN0aW9ucykge1xuICAgICAgICBBcnJheUV4dC5yZW1vdmVBbGxXaGVyZShjb25uZWN0aW9ucywgaXNEZWFkQ29ubmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIGNvbm5lY3Rpb24gaXMgZGVhZC5cbiAgICAgKlxuICAgICAqIEEgZGVhZCBjb25uZWN0aW9uIGhhcyBhIGBudWxsYCBzaWduYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZWFkQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNpZ25hbCA9PT0gbnVsbDtcbiAgICB9XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcblxuZXhwb3J0IHsgU2lnbmFsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/signaling/dist/index.es6.js\n")},"./node_modules/@lumino/virtualdom/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VirtualDOM\": () => (/* binding */ VirtualDOM),\n/* harmony export */   \"VirtualElement\": () => (/* binding */ VirtualElement),\n/* harmony export */   \"VirtualElementPass\": () => (/* binding */ VirtualElementPass),\n/* harmony export */   \"VirtualText\": () => (/* binding */ VirtualText),\n/* harmony export */   \"h\": () => (/* binding */ h),\n/* harmony export */   \"hpass\": () => (/* binding */ hpass)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/algorithm/dist/index.es6.js\");\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * A virtual node which represents plain text content.\n *\n * #### Notes\n * User code will not typically create a `VirtualText` node directly.\n * Instead, the `h()` function will be used to create an element tree.\n */\nvar VirtualText = /** @class */ (function () {\n    /**\n     * Construct a new virtual text node.\n     *\n     * @param content - The text content for the node.\n     */\n    function VirtualText(content) {\n        /**\n         * The type of the node.\n         *\n         * This value can be used as a type guard for discriminating the\n         * `VirtualNode` union type.\n         */\n        this.type = 'text';\n        this.content = content;\n    }\n    return VirtualText;\n}());\n/**\n * A virtual node which represents an HTML element.\n *\n * #### Notes\n * User code will not typically create a `VirtualElement` node directly.\n * Instead, the `h()` function will be used to create an element tree.\n */\nvar VirtualElement = /** @class */ (function () {\n    /**\n     * Construct a new virtual element node.\n     *\n     * @param tag - The element tag name.\n     *\n     * @param attrs - The element attributes.\n     *\n     * @param children - The element children.\n     *\n     * @param renderer - An optional custom renderer for the element.\n     */\n    function VirtualElement(tag, attrs, children, renderer) {\n        /**\n         * The type of the node.\n         *\n         * This value can be used as a type guard for discriminating the\n         * `VirtualNode` union type.\n         */\n        this.type = 'element';\n        this.tag = tag;\n        this.attrs = attrs;\n        this.children = children;\n        this.renderer = renderer;\n    }\n    return VirtualElement;\n}());\n/**\n * DEPRECATED - use VirtualElement with a defined renderer param instead.\n * This class is provided as a backwards compatibility shim\n *\n * A \"pass thru\" virtual node whose children are managed by a render and an\n * unrender callback. The intent of this flavor of virtual node is to make\n * it easy to blend other kinds of virtualdom (eg React) into Phosphor's\n * virtualdom.\n *\n * #### Notes\n * User code will not typically create a `VirtualElementPass` node directly.\n * Instead, the `hpass()` function will be used to create an element tree.\n */\nvar VirtualElementPass = /** @class */ (function (_super) {\n    __extends(VirtualElementPass, _super);\n    /**\n     * DEPRECATED - use VirtualElement with a defined renderer param instead\n     *\n     * Construct a new virtual element pass thru node.\n     *\n     * @param tag - the tag of the parent element of this node. Once the parent\n     * element is rendered, it will be passed as an argument to\n     * renderer.render\n     *\n     * @param attrs - attributes that will assigned to the\n     * parent element\n     *\n     * @param renderer - an object with render and unrender\n     * functions, each of which should take a single argument of type\n     * HTMLElement and return nothing. If null, the parent element\n     * will be rendered barren without any children.\n     */\n    function VirtualElementPass(tag, attrs, renderer) {\n        return _super.call(this, tag, attrs, [], renderer || undefined) || this;\n    }\n    return VirtualElementPass;\n}(VirtualElement));\nfunction h(tag) {\n    var attrs = {};\n    var renderer;\n    var children = [];\n    for (var i = 1, n = arguments.length; i < n; ++i) {\n        var arg = arguments[i];\n        if (typeof arg === 'string') {\n            children.push(new VirtualText(arg));\n        }\n        else if (arg instanceof VirtualText) {\n            children.push(arg);\n        }\n        else if (arg instanceof VirtualElement) {\n            children.push(arg);\n        }\n        else if (arg instanceof Array) {\n            extend(children, arg);\n        }\n        else if ((i === 1 || i === 2) && arg && typeof arg === 'object') {\n            if (\"render\" in arg) {\n                renderer = arg;\n            }\n            else {\n                attrs = arg;\n            }\n        }\n    }\n    return new VirtualElement(tag, attrs, children, renderer);\n    function extend(array, values) {\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var child = values_1[_i];\n            if (typeof child === 'string') {\n                array.push(new VirtualText(child));\n            }\n            else if (child instanceof VirtualText) {\n                array.push(child);\n            }\n            else if (child instanceof VirtualElement) {\n                array.push(child);\n            }\n        }\n    }\n}\n/**\n * The namespace for the `h` function statics.\n */\n(function (h) {\n    h.a = h.bind(undefined, 'a');\n    h.abbr = h.bind(undefined, 'abbr');\n    h.address = h.bind(undefined, 'address');\n    h.area = h.bind(undefined, 'area');\n    h.article = h.bind(undefined, 'article');\n    h.aside = h.bind(undefined, 'aside');\n    h.audio = h.bind(undefined, 'audio');\n    h.b = h.bind(undefined, 'b');\n    h.bdi = h.bind(undefined, 'bdi');\n    h.bdo = h.bind(undefined, 'bdo');\n    h.blockquote = h.bind(undefined, 'blockquote');\n    h.br = h.bind(undefined, 'br');\n    h.button = h.bind(undefined, 'button');\n    h.canvas = h.bind(undefined, 'canvas');\n    h.caption = h.bind(undefined, 'caption');\n    h.cite = h.bind(undefined, 'cite');\n    h.code = h.bind(undefined, 'code');\n    h.col = h.bind(undefined, 'col');\n    h.colgroup = h.bind(undefined, 'colgroup');\n    h.data = h.bind(undefined, 'data');\n    h.datalist = h.bind(undefined, 'datalist');\n    h.dd = h.bind(undefined, 'dd');\n    h.del = h.bind(undefined, 'del');\n    h.dfn = h.bind(undefined, 'dfn');\n    h.div = h.bind(undefined, 'div');\n    h.dl = h.bind(undefined, 'dl');\n    h.dt = h.bind(undefined, 'dt');\n    h.em = h.bind(undefined, 'em');\n    h.embed = h.bind(undefined, 'embed');\n    h.fieldset = h.bind(undefined, 'fieldset');\n    h.figcaption = h.bind(undefined, 'figcaption');\n    h.figure = h.bind(undefined, 'figure');\n    h.footer = h.bind(undefined, 'footer');\n    h.form = h.bind(undefined, 'form');\n    h.h1 = h.bind(undefined, 'h1');\n    h.h2 = h.bind(undefined, 'h2');\n    h.h3 = h.bind(undefined, 'h3');\n    h.h4 = h.bind(undefined, 'h4');\n    h.h5 = h.bind(undefined, 'h5');\n    h.h6 = h.bind(undefined, 'h6');\n    h.header = h.bind(undefined, 'header');\n    h.hr = h.bind(undefined, 'hr');\n    h.i = h.bind(undefined, 'i');\n    h.iframe = h.bind(undefined, 'iframe');\n    h.img = h.bind(undefined, 'img');\n    h.input = h.bind(undefined, 'input');\n    h.ins = h.bind(undefined, 'ins');\n    h.kbd = h.bind(undefined, 'kbd');\n    h.label = h.bind(undefined, 'label');\n    h.legend = h.bind(undefined, 'legend');\n    h.li = h.bind(undefined, 'li');\n    h.main = h.bind(undefined, 'main');\n    h.map = h.bind(undefined, 'map');\n    h.mark = h.bind(undefined, 'mark');\n    h.meter = h.bind(undefined, 'meter');\n    h.nav = h.bind(undefined, 'nav');\n    h.noscript = h.bind(undefined, 'noscript');\n    h.object = h.bind(undefined, 'object');\n    h.ol = h.bind(undefined, 'ol');\n    h.optgroup = h.bind(undefined, 'optgroup');\n    h.option = h.bind(undefined, 'option');\n    h.output = h.bind(undefined, 'output');\n    h.p = h.bind(undefined, 'p');\n    h.param = h.bind(undefined, 'param');\n    h.pre = h.bind(undefined, 'pre');\n    h.progress = h.bind(undefined, 'progress');\n    h.q = h.bind(undefined, 'q');\n    h.rp = h.bind(undefined, 'rp');\n    h.rt = h.bind(undefined, 'rt');\n    h.ruby = h.bind(undefined, 'ruby');\n    h.s = h.bind(undefined, 's');\n    h.samp = h.bind(undefined, 'samp');\n    h.section = h.bind(undefined, 'section');\n    h.select = h.bind(undefined, 'select');\n    h.small = h.bind(undefined, 'small');\n    h.source = h.bind(undefined, 'source');\n    h.span = h.bind(undefined, 'span');\n    h.strong = h.bind(undefined, 'strong');\n    h.sub = h.bind(undefined, 'sub');\n    h.summary = h.bind(undefined, 'summary');\n    h.sup = h.bind(undefined, 'sup');\n    h.table = h.bind(undefined, 'table');\n    h.tbody = h.bind(undefined, 'tbody');\n    h.td = h.bind(undefined, 'td');\n    h.textarea = h.bind(undefined, 'textarea');\n    h.tfoot = h.bind(undefined, 'tfoot');\n    h.th = h.bind(undefined, 'th');\n    h.thead = h.bind(undefined, 'thead');\n    h.time = h.bind(undefined, 'time');\n    h.title = h.bind(undefined, 'title');\n    h.tr = h.bind(undefined, 'tr');\n    h.track = h.bind(undefined, 'track');\n    h.u = h.bind(undefined, 'u');\n    h.ul = h.bind(undefined, 'ul');\n    h.var_ = h.bind(undefined, 'var');\n    h.video = h.bind(undefined, 'video');\n    h.wbr = h.bind(undefined, 'wbr');\n})(h || (h = {}));\nfunction hpass(tag) {\n    var attrs = {};\n    var renderer = null;\n    if (arguments.length === 2) {\n        var arg = arguments[1];\n        if (\"render\" in arg) {\n            renderer = arg;\n        }\n        else {\n            attrs = arg;\n        }\n    }\n    else if (arguments.length === 3) {\n        attrs = arguments[1];\n        renderer = arguments[2];\n    }\n    else if (arguments.length > 3) {\n        throw new Error(\"hpass() should be called with 1, 2, or 3 arguments\");\n    }\n    return new VirtualElementPass(tag, attrs, renderer);\n}\n/**\n * The namespace for the virtual DOM rendering functions.\n */\nvar VirtualDOM;\n(function (VirtualDOM) {\n    function realize(node) {\n        return Private.createDOMNode(node);\n    }\n    VirtualDOM.realize = realize;\n    /**\n     * Render virtual DOM content into a host element.\n     *\n     * @param content - The virtual DOM content to render.\n     *\n     * @param host - The host element for the rendered content.\n     *\n     * #### Notes\n     * This renders the delta from the previous rendering. It assumes that\n     * the content of the host element is not manipulated by external code.\n     *\n     * Providing `null` content will clear the rendering.\n     *\n     * Externally modifying the provided content or the host element will\n     * result in undefined rendering behavior.\n     */\n    function render(content, host) {\n        var oldContent = Private.hostMap.get(host) || [];\n        var newContent = Private.asContentArray(content);\n        Private.hostMap.set(host, newContent);\n        Private.updateContent(host, oldContent, newContent);\n    }\n    VirtualDOM.render = render;\n})(VirtualDOM || (VirtualDOM = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A weak mapping of host element to virtual DOM content.\n     */\n    Private.hostMap = new WeakMap();\n    /**\n     * Cast a content value to a content array.\n     */\n    function asContentArray(value) {\n        if (!value) {\n            return [];\n        }\n        if (value instanceof Array) {\n            return value;\n        }\n        return [value];\n    }\n    Private.asContentArray = asContentArray;\n    function createDOMNode(node) {\n        var host = arguments[1] || null;\n        var before = arguments[2] || null;\n        if (host) {\n            host.insertBefore(createDOMNode(node), before);\n        }\n        else {\n            // Create a text node for a virtual text node.\n            if (node.type === 'text') {\n                return document.createTextNode(node.content);\n            }\n            // Create the HTML element with the specified tag.\n            host = document.createElement(node.tag);\n            // Add the attributes for the new element.\n            addAttrs(host, node.attrs);\n            if (node.renderer) {\n                node.renderer.render(host, { attrs: node.attrs, children: node.children });\n                return host;\n            }\n            // Recursively populate the element with child content.\n            for (var i = 0, n = node.children.length; i < n; ++i) {\n                createDOMNode(node.children[i], host);\n            }\n        }\n        return host;\n    }\n    Private.createDOMNode = createDOMNode;\n    /**\n     * Update a host element with the delta of the virtual content.\n     *\n     * This is the core \"diff\" algorithm. There is no explicit \"patch\"\n     * phase. The host is patched at each step as the diff progresses.\n     */\n    function updateContent(host, oldContent, newContent) {\n        // Bail early if the content is identical.\n        if (oldContent === newContent) {\n            return;\n        }\n        // Collect the old keyed elems into a mapping.\n        var oldKeyed = collectKeys(host, oldContent);\n        // Create a copy of the old content which can be modified in-place.\n        var oldCopy = oldContent.slice();\n        // Update the host with the new content. The diff always proceeds\n        // forward and never modifies a previously visited index. The old\n        // copy array is modified in-place to reflect the changes made to\n        // the host children. This causes the stale nodes to be pushed to\n        // the end of the host node and removed at the end of the loop.\n        var currElem = host.firstChild;\n        var newCount = newContent.length;\n        for (var i = 0; i < newCount; ++i) {\n            // If the old content is exhausted, create a new node.\n            if (i >= oldCopy.length) {\n                createDOMNode(newContent[i], host);\n                continue;\n            }\n            // Lookup the old and new virtual nodes.\n            var oldVNode = oldCopy[i];\n            var newVNode = newContent[i];\n            // If both elements are identical, there is nothing to do.\n            if (oldVNode === newVNode) {\n                currElem = currElem.nextSibling;\n                continue;\n            }\n            // Handle the simplest case of in-place text update first.\n            if (oldVNode.type === 'text' && newVNode.type === 'text') {\n                currElem.textContent = newVNode.content;\n                currElem = currElem.nextSibling;\n                continue;\n            }\n            // If the old or new node is a text node, the other node is now\n            // known to be an element node, so create and insert a new node.\n            if (oldVNode.type === 'text' || newVNode.type === 'text') {\n                _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // If the old XOR new node has a custom renderer,\n            // create and insert a new node.\n            if (!(oldVNode.renderer) != !(newVNode.renderer)) {\n                _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // At this point, both nodes are known to be element nodes.\n            // If the new elem is keyed, move an old keyed elem to the proper\n            // location before proceeding with the diff. The search can start\n            // at the current index, since the unmatched old keyed elems are\n            // pushed forward in the old copy array.\n            var newKey = newVNode.attrs.key;\n            if (newKey && newKey in oldKeyed) {\n                var pair = oldKeyed[newKey];\n                if (pair.vNode !== oldVNode) {\n                    _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(oldCopy, oldCopy.indexOf(pair.vNode, i + 1), i);\n                    host.insertBefore(pair.element, currElem);\n                    oldVNode = pair.vNode;\n                    currElem = pair.element;\n                }\n            }\n            // If both elements are identical, there is nothing to do.\n            if (oldVNode === newVNode) {\n                currElem = currElem.nextSibling;\n                continue;\n            }\n            // If the old elem is keyed and does not match the new elem key,\n            // create a new node. This is necessary since the old keyed elem\n            // may be matched at a later point in the diff.\n            var oldKey = oldVNode.attrs.key;\n            if (oldKey && oldKey !== newKey) {\n                _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // If the tags are different, create a new node.\n            if (oldVNode.tag !== newVNode.tag) {\n                _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(oldCopy, i, newVNode);\n                createDOMNode(newVNode, host, currElem);\n                continue;\n            }\n            // At this point, the element can be updated in-place.\n            // Update the element attributes.\n            updateAttrs(currElem, oldVNode.attrs, newVNode.attrs);\n            // Update the element content.\n            if (newVNode.renderer) {\n                newVNode.renderer.render(currElem, { attrs: newVNode.attrs, children: newVNode.children });\n            }\n            else {\n                updateContent(currElem, oldVNode.children, newVNode.children);\n            }\n            // Step to the next sibling element.\n            currElem = currElem.nextSibling;\n        }\n        // Cleanup stale DOM\n        removeContent(host, oldCopy, newCount, true);\n    }\n    Private.updateContent = updateContent;\n    /**\n     * Handle cleanup of stale vdom and its associated DOM. The host node is\n     * traversed recursively (in depth-first order), and any explicit cleanup\n     * required by a child node is carried out when it is visited (eg if a node\n     * has a custom renderer, the renderer.unrender function will be called).\n     * Once the subtree beneath each child of host has been completely visited,\n     * that child will be removed via a call to host.removeChild.\n     */\n    function removeContent(host, oldContent, newCount, _sentinel) {\n        // Dispose of the old nodes pushed to the end of the host.\n        for (var i = oldContent.length - 1; i >= newCount; --i) {\n            var oldNode = oldContent[i];\n            var child = (_sentinel ? host.lastChild : host.childNodes[i]);\n            // recursively clean up host children\n            if (oldNode.type === 'text') ;\n            else if (oldNode.renderer && oldNode.renderer.unrender) {\n                oldNode.renderer.unrender(child, { attrs: oldNode.attrs, children: oldNode.children });\n            }\n            else {\n                removeContent(child, oldNode.children, 0, false);\n            }\n            if (_sentinel) {\n                host.removeChild(child);\n            }\n        }\n    }\n    /**\n     * A set of special-cased attribute names.\n     */\n    var specialAttrs = {\n        'key': true,\n        'className': true,\n        'htmlFor': true,\n        'dataset': true,\n        'style': true,\n    };\n    /**\n     * Add element attributes to a newly created HTML element.\n     */\n    function addAttrs(element, attrs) {\n        // Add the inline event listeners and node attributes.\n        for (var name_1 in attrs) {\n            if (name_1 in specialAttrs) {\n                continue;\n            }\n            if (name_1.substr(0, 2) === 'on') {\n                element[name_1] = attrs[name_1];\n            }\n            else {\n                element.setAttribute(name_1, attrs[name_1]);\n            }\n        }\n        // Add the element `class` attribute.\n        if (attrs.className !== undefined) {\n            element.setAttribute('class', attrs.className);\n        }\n        // Add the element `for` attribute.\n        if (attrs.htmlFor !== undefined) {\n            element.setAttribute('for', attrs.htmlFor);\n        }\n        // Add the dataset values.\n        if (attrs.dataset) {\n            addDataset(element, attrs.dataset);\n        }\n        // Add the inline styles.\n        if (attrs.style) {\n            addStyle(element, attrs.style);\n        }\n    }\n    /**\n     * Update the element attributes of an HTML element.\n     */\n    function updateAttrs(element, oldAttrs, newAttrs) {\n        // Do nothing if the attrs are the same object.\n        if (oldAttrs === newAttrs) {\n            return;\n        }\n        // Setup the strongly typed loop variable.\n        var name;\n        // Remove attributes and listeners which no longer exist.\n        for (name in oldAttrs) {\n            if (name in specialAttrs || name in newAttrs) {\n                continue;\n            }\n            if (name.substr(0, 2) === 'on') {\n                element[name] = null;\n            }\n            else {\n                element.removeAttribute(name);\n            }\n        }\n        // Add and update new and existing attributes and listeners.\n        for (name in newAttrs) {\n            if (name in specialAttrs || oldAttrs[name] === newAttrs[name]) {\n                continue;\n            }\n            if (name.substr(0, 2) === 'on') {\n                element[name] = newAttrs[name];\n            }\n            else {\n                element.setAttribute(name, newAttrs[name]);\n            }\n        }\n        // Update the element `class` attribute.\n        if (oldAttrs.className !== newAttrs.className) {\n            if (newAttrs.className !== undefined) {\n                element.setAttribute('class', newAttrs.className);\n            }\n            else {\n                element.removeAttribute('class');\n            }\n        }\n        // Add the element `for` attribute.\n        if (oldAttrs.htmlFor !== newAttrs.htmlFor) {\n            if (newAttrs.htmlFor !== undefined) {\n                element.setAttribute('for', newAttrs.htmlFor);\n            }\n            else {\n                element.removeAttribute('for');\n            }\n        }\n        // Update the dataset values.\n        if (oldAttrs.dataset !== newAttrs.dataset) {\n            updateDataset(element, oldAttrs.dataset || {}, newAttrs.dataset || {});\n        }\n        // Update the inline styles.\n        if (oldAttrs.style !== newAttrs.style) {\n            updateStyle(element, oldAttrs.style || {}, newAttrs.style || {});\n        }\n    }\n    /**\n     * Add dataset values to a newly created HTML element.\n     */\n    function addDataset(element, dataset) {\n        for (var name_2 in dataset) {\n            element.setAttribute(\"data-\" + name_2, dataset[name_2]);\n        }\n    }\n    /**\n     * Update the dataset values of an HTML element.\n     */\n    function updateDataset(element, oldDataset, newDataset) {\n        for (var name_3 in oldDataset) {\n            if (!(name_3 in newDataset)) {\n                element.removeAttribute(\"data-\" + name_3);\n            }\n        }\n        for (var name_4 in newDataset) {\n            if (oldDataset[name_4] !== newDataset[name_4]) {\n                element.setAttribute(\"data-\" + name_4, newDataset[name_4]);\n            }\n        }\n    }\n    /**\n     * Add inline style values to a newly created HTML element.\n     */\n    function addStyle(element, style) {\n        var elemStyle = element.style;\n        var name;\n        for (name in style) {\n            elemStyle[name] = style[name];\n        }\n    }\n    /**\n     * Update the inline style values of an HTML element.\n     */\n    function updateStyle(element, oldStyle, newStyle) {\n        var elemStyle = element.style;\n        var name;\n        for (name in oldStyle) {\n            if (!(name in newStyle)) {\n                elemStyle[name] = '';\n            }\n        }\n        for (name in newStyle) {\n            if (oldStyle[name] !== newStyle[name]) {\n                elemStyle[name] = newStyle[name];\n            }\n        }\n    }\n    /**\n     * Collect a mapping of keyed elements for the host content.\n     */\n    function collectKeys(host, content) {\n        var node = host.firstChild;\n        var keyMap = Object.create(null);\n        for (var _i = 0, content_1 = content; _i < content_1.length; _i++) {\n            var vNode = content_1[_i];\n            if (vNode.type === 'element' && vNode.attrs.key) {\n                keyMap[vNode.attrs.key] = { vNode: vNode, element: node };\n            }\n            node = node.nextSibling;\n        }\n        return keyMap;\n    }\n})(Private || (Private = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby92aXJ0dWFsZG9tL2Rpc3QvaW5kZXguZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkM7O0FBRTdDO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0RBQW9EO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0RBQWtEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjs7QUFFc0Q7QUFDakYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYWZzaGluL2xpZmUvLi9ub2RlX21vZHVsZXMvQGx1bWluby92aXJ0dWFsZG9tL2Rpc3QvaW5kZXguZXM2LmpzP2E5NjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBBIHZpcnR1YWwgbm9kZSB3aGljaCByZXByZXNlbnRzIHBsYWluIHRleHQgY29udGVudC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBVc2VyIGNvZGUgd2lsbCBub3QgdHlwaWNhbGx5IGNyZWF0ZSBhIGBWaXJ0dWFsVGV4dGAgbm9kZSBkaXJlY3RseS5cbiAqIEluc3RlYWQsIHRoZSBgaCgpYCBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGVsZW1lbnQgdHJlZS5cbiAqL1xudmFyIFZpcnR1YWxUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB2aXJ0dWFsIHRleHQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZW50IC0gVGhlIHRleHQgY29udGVudCBmb3IgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlydHVhbFRleHQoY29udGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYSB0eXBlIGd1YXJkIGZvciBkaXNjcmltaW5hdGluZyB0aGVcbiAgICAgICAgICogYFZpcnR1YWxOb2RlYCB1bmlvbiB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gVmlydHVhbFRleHQ7XG59KCkpO1xuLyoqXG4gKiBBIHZpcnR1YWwgbm9kZSB3aGljaCByZXByZXNlbnRzIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBVc2VyIGNvZGUgd2lsbCBub3QgdHlwaWNhbGx5IGNyZWF0ZSBhIGBWaXJ0dWFsRWxlbWVudGAgbm9kZSBkaXJlY3RseS5cbiAqIEluc3RlYWQsIHRoZSBgaCgpYCBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGVsZW1lbnQgdHJlZS5cbiAqL1xudmFyIFZpcnR1YWxFbGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB2aXJ0dWFsIGVsZW1lbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YWcgLSBUaGUgZWxlbWVudCB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRycyAtIFRoZSBlbGVtZW50IGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gLSBUaGUgZWxlbWVudCBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW5kZXJlciAtIEFuIG9wdGlvbmFsIGN1c3RvbSByZW5kZXJlciBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlydHVhbEVsZW1lbnQodGFnLCBhdHRycywgY2hpbGRyZW4sIHJlbmRlcmVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhIHR5cGUgZ3VhcmQgZm9yIGRpc2NyaW1pbmF0aW5nIHRoZVxuICAgICAgICAgKiBgVmlydHVhbE5vZGVgIHVuaW9uIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnZWxlbWVudCc7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cbiAgICByZXR1cm4gVmlydHVhbEVsZW1lbnQ7XG59KCkpO1xuLyoqXG4gKiBERVBSRUNBVEVEIC0gdXNlIFZpcnR1YWxFbGVtZW50IHdpdGggYSBkZWZpbmVkIHJlbmRlcmVyIHBhcmFtIGluc3RlYWQuXG4gKiBUaGlzIGNsYXNzIGlzIHByb3ZpZGVkIGFzIGEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgc2hpbVxuICpcbiAqIEEgXCJwYXNzIHRocnVcIiB2aXJ0dWFsIG5vZGUgd2hvc2UgY2hpbGRyZW4gYXJlIG1hbmFnZWQgYnkgYSByZW5kZXIgYW5kIGFuXG4gKiB1bnJlbmRlciBjYWxsYmFjay4gVGhlIGludGVudCBvZiB0aGlzIGZsYXZvciBvZiB2aXJ0dWFsIG5vZGUgaXMgdG8gbWFrZVxuICogaXQgZWFzeSB0byBibGVuZCBvdGhlciBraW5kcyBvZiB2aXJ0dWFsZG9tIChlZyBSZWFjdCkgaW50byBQaG9zcGhvcidzXG4gKiB2aXJ0dWFsZG9tLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFVzZXIgY29kZSB3aWxsIG5vdCB0eXBpY2FsbHkgY3JlYXRlIGEgYFZpcnR1YWxFbGVtZW50UGFzc2Agbm9kZSBkaXJlY3RseS5cbiAqIEluc3RlYWQsIHRoZSBgaHBhc3MoKWAgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhbiBlbGVtZW50IHRyZWUuXG4gKi9cbnZhciBWaXJ0dWFsRWxlbWVudFBhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpcnR1YWxFbGVtZW50UGFzcywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVEIC0gdXNlIFZpcnR1YWxFbGVtZW50IHdpdGggYSBkZWZpbmVkIHJlbmRlcmVyIHBhcmFtIGluc3RlYWRcbiAgICAgKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB2aXJ0dWFsIGVsZW1lbnQgcGFzcyB0aHJ1IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFnIC0gdGhlIHRhZyBvZiB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhpcyBub2RlLiBPbmNlIHRoZSBwYXJlbnRcbiAgICAgKiBlbGVtZW50IGlzIHJlbmRlcmVkLCBpdCB3aWxsIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0b1xuICAgICAqIHJlbmRlcmVyLnJlbmRlclxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHJzIC0gYXR0cmlidXRlcyB0aGF0IHdpbGwgYXNzaWduZWQgdG8gdGhlXG4gICAgICogcGFyZW50IGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW5kZXJlciAtIGFuIG9iamVjdCB3aXRoIHJlbmRlciBhbmQgdW5yZW5kZXJcbiAgICAgKiBmdW5jdGlvbnMsIGVhY2ggb2Ygd2hpY2ggc2hvdWxkIHRha2UgYSBzaW5nbGUgYXJndW1lbnQgb2YgdHlwZVxuICAgICAqIEhUTUxFbGVtZW50IGFuZCByZXR1cm4gbm90aGluZy4gSWYgbnVsbCwgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICogd2lsbCBiZSByZW5kZXJlZCBiYXJyZW4gd2l0aG91dCBhbnkgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlydHVhbEVsZW1lbnRQYXNzKHRhZywgYXR0cnMsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0YWcsIGF0dHJzLCBbXSwgcmVuZGVyZXIgfHwgdW5kZWZpbmVkKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVmlydHVhbEVsZW1lbnRQYXNzO1xufShWaXJ0dWFsRWxlbWVudCkpO1xuZnVuY3Rpb24gaCh0YWcpIHtcbiAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICB2YXIgcmVuZGVyZXI7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVmlydHVhbFRleHQoYXJnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgVmlydHVhbFRleHQpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBWaXJ0dWFsRWxlbWVudCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBleHRlbmQoY2hpbGRyZW4sIGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGkgPT09IDEgfHwgaSA9PT0gMikgJiYgYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoXCJyZW5kZXJcIiBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJzID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVmlydHVhbEVsZW1lbnQodGFnLCBhdHRycywgY2hpbGRyZW4sIHJlbmRlcmVyKTtcbiAgICBmdW5jdGlvbiBleHRlbmQoYXJyYXksIHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlc18xID0gdmFsdWVzOyBfaSA8IHZhbHVlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdmFsdWVzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKG5ldyBWaXJ0dWFsVGV4dChjaGlsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBWaXJ0dWFsVGV4dCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBWaXJ0dWFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYGhgIGZ1bmN0aW9uIHN0YXRpY3MuXG4gKi9cbihmdW5jdGlvbiAoaCkge1xuICAgIGguYSA9IGguYmluZCh1bmRlZmluZWQsICdhJyk7XG4gICAgaC5hYmJyID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2FiYnInKTtcbiAgICBoLmFkZHJlc3MgPSBoLmJpbmQodW5kZWZpbmVkLCAnYWRkcmVzcycpO1xuICAgIGguYXJlYSA9IGguYmluZCh1bmRlZmluZWQsICdhcmVhJyk7XG4gICAgaC5hcnRpY2xlID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2FydGljbGUnKTtcbiAgICBoLmFzaWRlID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2FzaWRlJyk7XG4gICAgaC5hdWRpbyA9IGguYmluZCh1bmRlZmluZWQsICdhdWRpbycpO1xuICAgIGguYiA9IGguYmluZCh1bmRlZmluZWQsICdiJyk7XG4gICAgaC5iZGkgPSBoLmJpbmQodW5kZWZpbmVkLCAnYmRpJyk7XG4gICAgaC5iZG8gPSBoLmJpbmQodW5kZWZpbmVkLCAnYmRvJyk7XG4gICAgaC5ibG9ja3F1b3RlID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2Jsb2NrcXVvdGUnKTtcbiAgICBoLmJyID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2JyJyk7XG4gICAgaC5idXR0b24gPSBoLmJpbmQodW5kZWZpbmVkLCAnYnV0dG9uJyk7XG4gICAgaC5jYW52YXMgPSBoLmJpbmQodW5kZWZpbmVkLCAnY2FudmFzJyk7XG4gICAgaC5jYXB0aW9uID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2NhcHRpb24nKTtcbiAgICBoLmNpdGUgPSBoLmJpbmQodW5kZWZpbmVkLCAnY2l0ZScpO1xuICAgIGguY29kZSA9IGguYmluZCh1bmRlZmluZWQsICdjb2RlJyk7XG4gICAgaC5jb2wgPSBoLmJpbmQodW5kZWZpbmVkLCAnY29sJyk7XG4gICAgaC5jb2xncm91cCA9IGguYmluZCh1bmRlZmluZWQsICdjb2xncm91cCcpO1xuICAgIGguZGF0YSA9IGguYmluZCh1bmRlZmluZWQsICdkYXRhJyk7XG4gICAgaC5kYXRhbGlzdCA9IGguYmluZCh1bmRlZmluZWQsICdkYXRhbGlzdCcpO1xuICAgIGguZGQgPSBoLmJpbmQodW5kZWZpbmVkLCAnZGQnKTtcbiAgICBoLmRlbCA9IGguYmluZCh1bmRlZmluZWQsICdkZWwnKTtcbiAgICBoLmRmbiA9IGguYmluZCh1bmRlZmluZWQsICdkZm4nKTtcbiAgICBoLmRpdiA9IGguYmluZCh1bmRlZmluZWQsICdkaXYnKTtcbiAgICBoLmRsID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2RsJyk7XG4gICAgaC5kdCA9IGguYmluZCh1bmRlZmluZWQsICdkdCcpO1xuICAgIGguZW0gPSBoLmJpbmQodW5kZWZpbmVkLCAnZW0nKTtcbiAgICBoLmVtYmVkID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2VtYmVkJyk7XG4gICAgaC5maWVsZHNldCA9IGguYmluZCh1bmRlZmluZWQsICdmaWVsZHNldCcpO1xuICAgIGguZmlnY2FwdGlvbiA9IGguYmluZCh1bmRlZmluZWQsICdmaWdjYXB0aW9uJyk7XG4gICAgaC5maWd1cmUgPSBoLmJpbmQodW5kZWZpbmVkLCAnZmlndXJlJyk7XG4gICAgaC5mb290ZXIgPSBoLmJpbmQodW5kZWZpbmVkLCAnZm9vdGVyJyk7XG4gICAgaC5mb3JtID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2Zvcm0nKTtcbiAgICBoLmgxID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2gxJyk7XG4gICAgaC5oMiA9IGguYmluZCh1bmRlZmluZWQsICdoMicpO1xuICAgIGguaDMgPSBoLmJpbmQodW5kZWZpbmVkLCAnaDMnKTtcbiAgICBoLmg0ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2g0Jyk7XG4gICAgaC5oNSA9IGguYmluZCh1bmRlZmluZWQsICdoNScpO1xuICAgIGguaDYgPSBoLmJpbmQodW5kZWZpbmVkLCAnaDYnKTtcbiAgICBoLmhlYWRlciA9IGguYmluZCh1bmRlZmluZWQsICdoZWFkZXInKTtcbiAgICBoLmhyID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2hyJyk7XG4gICAgaC5pID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2knKTtcbiAgICBoLmlmcmFtZSA9IGguYmluZCh1bmRlZmluZWQsICdpZnJhbWUnKTtcbiAgICBoLmltZyA9IGguYmluZCh1bmRlZmluZWQsICdpbWcnKTtcbiAgICBoLmlucHV0ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2lucHV0Jyk7XG4gICAgaC5pbnMgPSBoLmJpbmQodW5kZWZpbmVkLCAnaW5zJyk7XG4gICAgaC5rYmQgPSBoLmJpbmQodW5kZWZpbmVkLCAna2JkJyk7XG4gICAgaC5sYWJlbCA9IGguYmluZCh1bmRlZmluZWQsICdsYWJlbCcpO1xuICAgIGgubGVnZW5kID0gaC5iaW5kKHVuZGVmaW5lZCwgJ2xlZ2VuZCcpO1xuICAgIGgubGkgPSBoLmJpbmQodW5kZWZpbmVkLCAnbGknKTtcbiAgICBoLm1haW4gPSBoLmJpbmQodW5kZWZpbmVkLCAnbWFpbicpO1xuICAgIGgubWFwID0gaC5iaW5kKHVuZGVmaW5lZCwgJ21hcCcpO1xuICAgIGgubWFyayA9IGguYmluZCh1bmRlZmluZWQsICdtYXJrJyk7XG4gICAgaC5tZXRlciA9IGguYmluZCh1bmRlZmluZWQsICdtZXRlcicpO1xuICAgIGgubmF2ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ25hdicpO1xuICAgIGgubm9zY3JpcHQgPSBoLmJpbmQodW5kZWZpbmVkLCAnbm9zY3JpcHQnKTtcbiAgICBoLm9iamVjdCA9IGguYmluZCh1bmRlZmluZWQsICdvYmplY3QnKTtcbiAgICBoLm9sID0gaC5iaW5kKHVuZGVmaW5lZCwgJ29sJyk7XG4gICAgaC5vcHRncm91cCA9IGguYmluZCh1bmRlZmluZWQsICdvcHRncm91cCcpO1xuICAgIGgub3B0aW9uID0gaC5iaW5kKHVuZGVmaW5lZCwgJ29wdGlvbicpO1xuICAgIGgub3V0cHV0ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ291dHB1dCcpO1xuICAgIGgucCA9IGguYmluZCh1bmRlZmluZWQsICdwJyk7XG4gICAgaC5wYXJhbSA9IGguYmluZCh1bmRlZmluZWQsICdwYXJhbScpO1xuICAgIGgucHJlID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3ByZScpO1xuICAgIGgucHJvZ3Jlc3MgPSBoLmJpbmQodW5kZWZpbmVkLCAncHJvZ3Jlc3MnKTtcbiAgICBoLnEgPSBoLmJpbmQodW5kZWZpbmVkLCAncScpO1xuICAgIGgucnAgPSBoLmJpbmQodW5kZWZpbmVkLCAncnAnKTtcbiAgICBoLnJ0ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3J0Jyk7XG4gICAgaC5ydWJ5ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3J1YnknKTtcbiAgICBoLnMgPSBoLmJpbmQodW5kZWZpbmVkLCAncycpO1xuICAgIGguc2FtcCA9IGguYmluZCh1bmRlZmluZWQsICdzYW1wJyk7XG4gICAgaC5zZWN0aW9uID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3NlY3Rpb24nKTtcbiAgICBoLnNlbGVjdCA9IGguYmluZCh1bmRlZmluZWQsICdzZWxlY3QnKTtcbiAgICBoLnNtYWxsID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3NtYWxsJyk7XG4gICAgaC5zb3VyY2UgPSBoLmJpbmQodW5kZWZpbmVkLCAnc291cmNlJyk7XG4gICAgaC5zcGFuID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3NwYW4nKTtcbiAgICBoLnN0cm9uZyA9IGguYmluZCh1bmRlZmluZWQsICdzdHJvbmcnKTtcbiAgICBoLnN1YiA9IGguYmluZCh1bmRlZmluZWQsICdzdWInKTtcbiAgICBoLnN1bW1hcnkgPSBoLmJpbmQodW5kZWZpbmVkLCAnc3VtbWFyeScpO1xuICAgIGguc3VwID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3N1cCcpO1xuICAgIGgudGFibGUgPSBoLmJpbmQodW5kZWZpbmVkLCAndGFibGUnKTtcbiAgICBoLnRib2R5ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3Rib2R5Jyk7XG4gICAgaC50ZCA9IGguYmluZCh1bmRlZmluZWQsICd0ZCcpO1xuICAgIGgudGV4dGFyZWEgPSBoLmJpbmQodW5kZWZpbmVkLCAndGV4dGFyZWEnKTtcbiAgICBoLnRmb290ID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3Rmb290Jyk7XG4gICAgaC50aCA9IGguYmluZCh1bmRlZmluZWQsICd0aCcpO1xuICAgIGgudGhlYWQgPSBoLmJpbmQodW5kZWZpbmVkLCAndGhlYWQnKTtcbiAgICBoLnRpbWUgPSBoLmJpbmQodW5kZWZpbmVkLCAndGltZScpO1xuICAgIGgudGl0bGUgPSBoLmJpbmQodW5kZWZpbmVkLCAndGl0bGUnKTtcbiAgICBoLnRyID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3RyJyk7XG4gICAgaC50cmFjayA9IGguYmluZCh1bmRlZmluZWQsICd0cmFjaycpO1xuICAgIGgudSA9IGguYmluZCh1bmRlZmluZWQsICd1Jyk7XG4gICAgaC51bCA9IGguYmluZCh1bmRlZmluZWQsICd1bCcpO1xuICAgIGgudmFyXyA9IGguYmluZCh1bmRlZmluZWQsICd2YXInKTtcbiAgICBoLnZpZGVvID0gaC5iaW5kKHVuZGVmaW5lZCwgJ3ZpZGVvJyk7XG4gICAgaC53YnIgPSBoLmJpbmQodW5kZWZpbmVkLCAnd2JyJyk7XG59KShoIHx8IChoID0ge30pKTtcbmZ1bmN0aW9uIGhwYXNzKHRhZykge1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIHZhciByZW5kZXJlciA9IG51bGw7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKFwicmVuZGVyXCIgaW4gYXJnKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IGFyZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJzID0gYXJnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgYXR0cnMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHJlbmRlcmVyID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJocGFzcygpIHNob3VsZCBiZSBjYWxsZWQgd2l0aCAxLCAyLCBvciAzIGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWaXJ0dWFsRWxlbWVudFBhc3ModGFnLCBhdHRycywgcmVuZGVyZXIpO1xufVxuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgdmlydHVhbCBET00gcmVuZGVyaW5nIGZ1bmN0aW9ucy5cbiAqL1xudmFyIFZpcnR1YWxET007XG4oZnVuY3Rpb24gKFZpcnR1YWxET00pIHtcbiAgICBmdW5jdGlvbiByZWFsaXplKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFByaXZhdGUuY3JlYXRlRE9NTm9kZShub2RlKTtcbiAgICB9XG4gICAgVmlydHVhbERPTS5yZWFsaXplID0gcmVhbGl6ZTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdmlydHVhbCBET00gY29udGVudCBpbnRvIGEgaG9zdCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgdmlydHVhbCBET00gY29udGVudCB0byByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdCAtIFRoZSBob3N0IGVsZW1lbnQgZm9yIHRoZSByZW5kZXJlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgcmVuZGVycyB0aGUgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgcmVuZGVyaW5nLiBJdCBhc3N1bWVzIHRoYXRcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgaG9zdCBlbGVtZW50IGlzIG5vdCBtYW5pcHVsYXRlZCBieSBleHRlcm5hbCBjb2RlLlxuICAgICAqXG4gICAgICogUHJvdmlkaW5nIGBudWxsYCBjb250ZW50IHdpbGwgY2xlYXIgdGhlIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEV4dGVybmFsbHkgbW9kaWZ5aW5nIHRoZSBwcm92aWRlZCBjb250ZW50IG9yIHRoZSBob3N0IGVsZW1lbnQgd2lsbFxuICAgICAqIHJlc3VsdCBpbiB1bmRlZmluZWQgcmVuZGVyaW5nIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlcihjb250ZW50LCBob3N0KSB7XG4gICAgICAgIHZhciBvbGRDb250ZW50ID0gUHJpdmF0ZS5ob3N0TWFwLmdldChob3N0KSB8fCBbXTtcbiAgICAgICAgdmFyIG5ld0NvbnRlbnQgPSBQcml2YXRlLmFzQ29udGVudEFycmF5KGNvbnRlbnQpO1xuICAgICAgICBQcml2YXRlLmhvc3RNYXAuc2V0KGhvc3QsIG5ld0NvbnRlbnQpO1xuICAgICAgICBQcml2YXRlLnVwZGF0ZUNvbnRlbnQoaG9zdCwgb2xkQ29udGVudCwgbmV3Q29udGVudCk7XG4gICAgfVxuICAgIFZpcnR1YWxET00ucmVuZGVyID0gcmVuZGVyO1xufSkoVmlydHVhbERPTSB8fCAoVmlydHVhbERPTSA9IHt9KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGU7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBBIHdlYWsgbWFwcGluZyBvZiBob3N0IGVsZW1lbnQgdG8gdmlydHVhbCBET00gY29udGVudC5cbiAgICAgKi9cbiAgICBQcml2YXRlLmhvc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIC8qKlxuICAgICAqIENhc3QgYSBjb250ZW50IHZhbHVlIHRvIGEgY29udGVudCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc0NvbnRlbnRBcnJheSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gICAgUHJpdmF0ZS5hc0NvbnRlbnRBcnJheSA9IGFzQ29udGVudEFycmF5O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURPTU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaG9zdCA9IGFyZ3VtZW50c1sxXSB8fCBudWxsO1xuICAgICAgICB2YXIgYmVmb3JlID0gYXJndW1lbnRzWzJdIHx8IG51bGw7XG4gICAgICAgIGlmIChob3N0KSB7XG4gICAgICAgICAgICBob3N0Lmluc2VydEJlZm9yZShjcmVhdGVET01Ob2RlKG5vZGUpLCBiZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGV4dCBub2RlIGZvciBhIHZpcnR1YWwgdGV4dCBub2RlLlxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgdGFnLlxuICAgICAgICAgICAgaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZS50YWcpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgbmV3IGVsZW1lbnQuXG4gICAgICAgICAgICBhZGRBdHRycyhob3N0LCBub2RlLmF0dHJzKTtcbiAgICAgICAgICAgIGlmIChub2RlLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW5kZXJlci5yZW5kZXIoaG9zdCwgeyBhdHRyczogbm9kZS5hdHRycywgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSB0aGUgZWxlbWVudCB3aXRoIGNoaWxkIGNvbnRlbnQuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlRE9NTm9kZShub2RlLmNoaWxkcmVuW2ldLCBob3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVET01Ob2RlID0gY3JlYXRlRE9NTm9kZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBob3N0IGVsZW1lbnQgd2l0aCB0aGUgZGVsdGEgb2YgdGhlIHZpcnR1YWwgY29udGVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgXCJkaWZmXCIgYWxnb3JpdGhtLiBUaGVyZSBpcyBubyBleHBsaWNpdCBcInBhdGNoXCJcbiAgICAgKiBwaGFzZS4gVGhlIGhvc3QgaXMgcGF0Y2hlZCBhdCBlYWNoIHN0ZXAgYXMgdGhlIGRpZmYgcHJvZ3Jlc3Nlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGhvc3QsIG9sZENvbnRlbnQsIG5ld0NvbnRlbnQpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgY29udGVudCBpcyBpZGVudGljYWwuXG4gICAgICAgIGlmIChvbGRDb250ZW50ID09PSBuZXdDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29sbGVjdCB0aGUgb2xkIGtleWVkIGVsZW1zIGludG8gYSBtYXBwaW5nLlxuICAgICAgICB2YXIgb2xkS2V5ZWQgPSBjb2xsZWN0S2V5cyhob3N0LCBvbGRDb250ZW50KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgb2xkIGNvbnRlbnQgd2hpY2ggY2FuIGJlIG1vZGlmaWVkIGluLXBsYWNlLlxuICAgICAgICB2YXIgb2xkQ29weSA9IG9sZENvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBob3N0IHdpdGggdGhlIG5ldyBjb250ZW50LiBUaGUgZGlmZiBhbHdheXMgcHJvY2VlZHNcbiAgICAgICAgLy8gZm9yd2FyZCBhbmQgbmV2ZXIgbW9kaWZpZXMgYSBwcmV2aW91c2x5IHZpc2l0ZWQgaW5kZXguIFRoZSBvbGRcbiAgICAgICAgLy8gY29weSBhcnJheSBpcyBtb2RpZmllZCBpbi1wbGFjZSB0byByZWZsZWN0IHRoZSBjaGFuZ2VzIG1hZGUgdG9cbiAgICAgICAgLy8gdGhlIGhvc3QgY2hpbGRyZW4uIFRoaXMgY2F1c2VzIHRoZSBzdGFsZSBub2RlcyB0byBiZSBwdXNoZWQgdG9cbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgaG9zdCBub2RlIGFuZCByZW1vdmVkIGF0IHRoZSBlbmQgb2YgdGhlIGxvb3AuXG4gICAgICAgIHZhciBjdXJyRWxlbSA9IGhvc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG5ld0NvdW50ID0gbmV3Q29udGVudC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9sZCBjb250ZW50IGlzIGV4aGF1c3RlZCwgY3JlYXRlIGEgbmV3IG5vZGUuXG4gICAgICAgICAgICBpZiAoaSA+PSBvbGRDb3B5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZURPTU5vZGUobmV3Q29udGVudFtpXSwgaG9zdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb29rdXAgdGhlIG9sZCBhbmQgbmV3IHZpcnR1YWwgbm9kZXMuXG4gICAgICAgICAgICB2YXIgb2xkVk5vZGUgPSBvbGRDb3B5W2ldO1xuICAgICAgICAgICAgdmFyIG5ld1ZOb2RlID0gbmV3Q29udGVudFtpXTtcbiAgICAgICAgICAgIC8vIElmIGJvdGggZWxlbWVudHMgYXJlIGlkZW50aWNhbCwgdGhlcmUgaXMgbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIGlmIChvbGRWTm9kZSA9PT0gbmV3Vk5vZGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyRWxlbSA9IGN1cnJFbGVtLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzaW1wbGVzdCBjYXNlIG9mIGluLXBsYWNlIHRleHQgdXBkYXRlIGZpcnN0LlxuICAgICAgICAgICAgaWYgKG9sZFZOb2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBuZXdWTm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyRWxlbS50ZXh0Q29udGVudCA9IG5ld1ZOb2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY3VyckVsZW0gPSBjdXJyRWxlbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBvbGQgb3IgbmV3IG5vZGUgaXMgYSB0ZXh0IG5vZGUsIHRoZSBvdGhlciBub2RlIGlzIG5vd1xuICAgICAgICAgICAgLy8ga25vd24gdG8gYmUgYW4gZWxlbWVudCBub2RlLCBzbyBjcmVhdGUgYW5kIGluc2VydCBhIG5ldyBub2RlLlxuICAgICAgICAgICAgaWYgKG9sZFZOb2RlLnR5cGUgPT09ICd0ZXh0JyB8fCBuZXdWTm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQob2xkQ29weSwgaSwgbmV3Vk5vZGUpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZURPTU5vZGUobmV3Vk5vZGUsIGhvc3QsIGN1cnJFbGVtKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBvbGQgWE9SIG5ldyBub2RlIGhhcyBhIGN1c3RvbSByZW5kZXJlcixcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbmQgaW5zZXJ0IGEgbmV3IG5vZGUuXG4gICAgICAgICAgICBpZiAoIShvbGRWTm9kZS5yZW5kZXJlcikgIT0gIShuZXdWTm9kZS5yZW5kZXJlcikpIHtcbiAgICAgICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQob2xkQ29weSwgaSwgbmV3Vk5vZGUpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZURPTU5vZGUobmV3Vk5vZGUsIGhvc3QsIGN1cnJFbGVtKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGJvdGggbm9kZXMgYXJlIGtub3duIHRvIGJlIGVsZW1lbnQgbm9kZXMuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV3IGVsZW0gaXMga2V5ZWQsIG1vdmUgYW4gb2xkIGtleWVkIGVsZW0gdG8gdGhlIHByb3BlclxuICAgICAgICAgICAgLy8gbG9jYXRpb24gYmVmb3JlIHByb2NlZWRpbmcgd2l0aCB0aGUgZGlmZi4gVGhlIHNlYXJjaCBjYW4gc3RhcnRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBjdXJyZW50IGluZGV4LCBzaW5jZSB0aGUgdW5tYXRjaGVkIG9sZCBrZXllZCBlbGVtcyBhcmVcbiAgICAgICAgICAgIC8vIHB1c2hlZCBmb3J3YXJkIGluIHRoZSBvbGQgY29weSBhcnJheS5cbiAgICAgICAgICAgIHZhciBuZXdLZXkgPSBuZXdWTm9kZS5hdHRycy5rZXk7XG4gICAgICAgICAgICBpZiAobmV3S2V5ICYmIG5ld0tleSBpbiBvbGRLZXllZCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gb2xkS2V5ZWRbbmV3S2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocGFpci52Tm9kZSAhPT0gb2xkVk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXlFeHQubW92ZShvbGRDb3B5LCBvbGRDb3B5LmluZGV4T2YocGFpci52Tm9kZSwgaSArIDEpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaG9zdC5pbnNlcnRCZWZvcmUocGFpci5lbGVtZW50LCBjdXJyRWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlID0gcGFpci52Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckVsZW0gPSBwYWlyLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYm90aCBlbGVtZW50cyBhcmUgaWRlbnRpY2FsLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgaWYgKG9sZFZOb2RlID09PSBuZXdWTm9kZSkge1xuICAgICAgICAgICAgICAgIGN1cnJFbGVtID0gY3VyckVsZW0ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgb2xkIGVsZW0gaXMga2V5ZWQgYW5kIGRvZXMgbm90IG1hdGNoIHRoZSBuZXcgZWxlbSBrZXksXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbm9kZS4gVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIG9sZCBrZXllZCBlbGVtXG4gICAgICAgICAgICAvLyBtYXkgYmUgbWF0Y2hlZCBhdCBhIGxhdGVyIHBvaW50IGluIHRoZSBkaWZmLlxuICAgICAgICAgICAgdmFyIG9sZEtleSA9IG9sZFZOb2RlLmF0dHJzLmtleTtcbiAgICAgICAgICAgIGlmIChvbGRLZXkgJiYgb2xkS2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQob2xkQ29weSwgaSwgbmV3Vk5vZGUpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZURPTU5vZGUobmV3Vk5vZGUsIGhvc3QsIGN1cnJFbGVtKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0YWdzIGFyZSBkaWZmZXJlbnQsIGNyZWF0ZSBhIG5ldyBub2RlLlxuICAgICAgICAgICAgaWYgKG9sZFZOb2RlLnRhZyAhPT0gbmV3Vk5vZGUudGFnKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KG9sZENvcHksIGksIG5ld1ZOb2RlKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVET01Ob2RlKG5ld1ZOb2RlLCBob3N0LCBjdXJyRWxlbSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgZWxlbWVudCBjYW4gYmUgdXBkYXRlZCBpbi1wbGFjZS5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgdXBkYXRlQXR0cnMoY3VyckVsZW0sIG9sZFZOb2RlLmF0dHJzLCBuZXdWTm9kZS5hdHRycyk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVsZW1lbnQgY29udGVudC5cbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIG5ld1ZOb2RlLnJlbmRlcmVyLnJlbmRlcihjdXJyRWxlbSwgeyBhdHRyczogbmV3Vk5vZGUuYXR0cnMsIGNoaWxkcmVuOiBuZXdWTm9kZS5jaGlsZHJlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRlbnQoY3VyckVsZW0sIG9sZFZOb2RlLmNoaWxkcmVuLCBuZXdWTm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIHRvIHRoZSBuZXh0IHNpYmxpbmcgZWxlbWVudC5cbiAgICAgICAgICAgIGN1cnJFbGVtID0gY3VyckVsZW0ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW51cCBzdGFsZSBET01cbiAgICAgICAgcmVtb3ZlQ29udGVudChob3N0LCBvbGRDb3B5LCBuZXdDb3VudCwgdHJ1ZSk7XG4gICAgfVxuICAgIFByaXZhdGUudXBkYXRlQ29udGVudCA9IHVwZGF0ZUNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNsZWFudXAgb2Ygc3RhbGUgdmRvbSBhbmQgaXRzIGFzc29jaWF0ZWQgRE9NLiBUaGUgaG9zdCBub2RlIGlzXG4gICAgICogdHJhdmVyc2VkIHJlY3Vyc2l2ZWx5IChpbiBkZXB0aC1maXJzdCBvcmRlciksIGFuZCBhbnkgZXhwbGljaXQgY2xlYW51cFxuICAgICAqIHJlcXVpcmVkIGJ5IGEgY2hpbGQgbm9kZSBpcyBjYXJyaWVkIG91dCB3aGVuIGl0IGlzIHZpc2l0ZWQgKGVnIGlmIGEgbm9kZVxuICAgICAqIGhhcyBhIGN1c3RvbSByZW5kZXJlciwgdGhlIHJlbmRlcmVyLnVucmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkKS5cbiAgICAgKiBPbmNlIHRoZSBzdWJ0cmVlIGJlbmVhdGggZWFjaCBjaGlsZCBvZiBob3N0IGhhcyBiZWVuIGNvbXBsZXRlbHkgdmlzaXRlZCxcbiAgICAgKiB0aGF0IGNoaWxkIHdpbGwgYmUgcmVtb3ZlZCB2aWEgYSBjYWxsIHRvIGhvc3QucmVtb3ZlQ2hpbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ29udGVudChob3N0LCBvbGRDb250ZW50LCBuZXdDb3VudCwgX3NlbnRpbmVsKSB7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIG9sZCBub2RlcyBwdXNoZWQgdG8gdGhlIGVuZCBvZiB0aGUgaG9zdC5cbiAgICAgICAgZm9yICh2YXIgaSA9IG9sZENvbnRlbnQubGVuZ3RoIC0gMTsgaSA+PSBuZXdDb3VudDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgb2xkTm9kZSA9IG9sZENvbnRlbnRbaV07XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSAoX3NlbnRpbmVsID8gaG9zdC5sYXN0Q2hpbGQgOiBob3N0LmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgY2xlYW4gdXAgaG9zdCBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKG9sZE5vZGUudHlwZSA9PT0gJ3RleHQnKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChvbGROb2RlLnJlbmRlcmVyICYmIG9sZE5vZGUucmVuZGVyZXIudW5yZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBvbGROb2RlLnJlbmRlcmVyLnVucmVuZGVyKGNoaWxkLCB7IGF0dHJzOiBvbGROb2RlLmF0dHJzLCBjaGlsZHJlbjogb2xkTm9kZS5jaGlsZHJlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNvbnRlbnQoY2hpbGQsIG9sZE5vZGUuY2hpbGRyZW4sIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBob3N0LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBzcGVjaWFsLWNhc2VkIGF0dHJpYnV0ZSBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc3BlY2lhbEF0dHJzID0ge1xuICAgICAgICAna2V5JzogdHJ1ZSxcbiAgICAgICAgJ2NsYXNzTmFtZSc6IHRydWUsXG4gICAgICAgICdodG1sRm9yJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGFzZXQnOiB0cnVlLFxuICAgICAgICAnc3R5bGUnOiB0cnVlLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGVsZW1lbnQgYXR0cmlidXRlcyB0byBhIG5ld2x5IGNyZWF0ZWQgSFRNTCBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEF0dHJzKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgaW5saW5lIGV2ZW50IGxpc3RlbmVycyBhbmQgbm9kZSBhdHRyaWJ1dGVzLlxuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lXzEgaW4gc3BlY2lhbEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZV8xLnN1YnN0cigwLCAyKSA9PT0gJ29uJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbbmFtZV8xXSA9IGF0dHJzW25hbWVfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lXzEsIGF0dHJzW25hbWVfMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgZWxlbWVudCBgY2xhc3NgIGF0dHJpYnV0ZS5cbiAgICAgICAgaWYgKGF0dHJzLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBhdHRycy5jbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgZWxlbWVudCBgZm9yYCBhdHRyaWJ1dGUuXG4gICAgICAgIGlmIChhdHRycy5odG1sRm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb3InLCBhdHRycy5odG1sRm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGRhdGFzZXQgdmFsdWVzLlxuICAgICAgICBpZiAoYXR0cnMuZGF0YXNldCkge1xuICAgICAgICAgICAgYWRkRGF0YXNldChlbGVtZW50LCBhdHRycy5kYXRhc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGlubGluZSBzdHlsZXMuXG4gICAgICAgIGlmIChhdHRycy5zdHlsZSkge1xuICAgICAgICAgICAgYWRkU3R5bGUoZWxlbWVudCwgYXR0cnMuc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzIG9mIGFuIEhUTUwgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVBdHRycyhlbGVtZW50LCBvbGRBdHRycywgbmV3QXR0cnMpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgYXR0cnMgYXJlIHRoZSBzYW1lIG9iamVjdC5cbiAgICAgICAgaWYgKG9sZEF0dHJzID09PSBuZXdBdHRycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHVwIHRoZSBzdHJvbmdseSB0eXBlZCBsb29wIHZhcmlhYmxlLlxuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgLy8gUmVtb3ZlIGF0dHJpYnV0ZXMgYW5kIGxpc3RlbmVycyB3aGljaCBubyBsb25nZXIgZXhpc3QuXG4gICAgICAgIGZvciAobmFtZSBpbiBvbGRBdHRycykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gc3BlY2lhbEF0dHJzIHx8IG5hbWUgaW4gbmV3QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lLnN1YnN0cigwLCAyKSA9PT0gJ29uJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFuZCB1cGRhdGUgbmV3IGFuZCBleGlzdGluZyBhdHRyaWJ1dGVzIGFuZCBsaXN0ZW5lcnMuXG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdBdHRycykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gc3BlY2lhbEF0dHJzIHx8IG9sZEF0dHJzW25hbWVdID09PSBuZXdBdHRyc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKDAsIDIpID09PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtuYW1lXSA9IG5ld0F0dHJzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3QXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZWxlbWVudCBgY2xhc3NgIGF0dHJpYnV0ZS5cbiAgICAgICAgaWYgKG9sZEF0dHJzLmNsYXNzTmFtZSAhPT0gbmV3QXR0cnMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAobmV3QXR0cnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBuZXdBdHRycy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBlbGVtZW50IGBmb3JgIGF0dHJpYnV0ZS5cbiAgICAgICAgaWYgKG9sZEF0dHJzLmh0bWxGb3IgIT09IG5ld0F0dHJzLmh0bWxGb3IpIHtcbiAgICAgICAgICAgIGlmIChuZXdBdHRycy5odG1sRm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9yJywgbmV3QXR0cnMuaHRtbEZvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBkYXRhc2V0IHZhbHVlcy5cbiAgICAgICAgaWYgKG9sZEF0dHJzLmRhdGFzZXQgIT09IG5ld0F0dHJzLmRhdGFzZXQpIHtcbiAgICAgICAgICAgIHVwZGF0ZURhdGFzZXQoZWxlbWVudCwgb2xkQXR0cnMuZGF0YXNldCB8fCB7fSwgbmV3QXR0cnMuZGF0YXNldCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbmxpbmUgc3R5bGVzLlxuICAgICAgICBpZiAob2xkQXR0cnMuc3R5bGUgIT09IG5ld0F0dHJzLnN0eWxlKSB7XG4gICAgICAgICAgICB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGRBdHRycy5zdHlsZSB8fCB7fSwgbmV3QXR0cnMuc3R5bGUgfHwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhc2V0IHZhbHVlcyB0byBhIG5ld2x5IGNyZWF0ZWQgSFRNTCBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZERhdGFzZXQoZWxlbWVudCwgZGF0YXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gZGF0YXNldCkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZV8yLCBkYXRhc2V0W25hbWVfMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGF0YXNldCB2YWx1ZXMgb2YgYW4gSFRNTCBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGFzZXQoZWxlbWVudCwgb2xkRGF0YXNldCwgbmV3RGF0YXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gb2xkRGF0YXNldCkge1xuICAgICAgICAgICAgaWYgKCEobmFtZV8zIGluIG5ld0RhdGFzZXQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZV8zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBuYW1lXzQgaW4gbmV3RGF0YXNldCkge1xuICAgICAgICAgICAgaWYgKG9sZERhdGFzZXRbbmFtZV80XSAhPT0gbmV3RGF0YXNldFtuYW1lXzRdKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZV80LCBuZXdEYXRhc2V0W25hbWVfNF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBpbmxpbmUgc3R5bGUgdmFsdWVzIHRvIGEgbmV3bHkgY3JlYXRlZCBIVE1MIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkU3R5bGUoZWxlbWVudCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIGVsZW1TdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1TdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW5saW5lIHN0eWxlIHZhbHVlcyBvZiBhbiBIVE1MIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkU3R5bGUsIG5ld1N0eWxlKSB7XG4gICAgICAgIHZhciBlbGVtU3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIG5ld1N0eWxlKSkge1xuICAgICAgICAgICAgICAgIGVsZW1TdHlsZVtuYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgICAgICAgICAgaWYgKG9sZFN0eWxlW25hbWVdICE9PSBuZXdTdHlsZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGVsZW1TdHlsZVtuYW1lXSA9IG5ld1N0eWxlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxlY3QgYSBtYXBwaW5nIG9mIGtleWVkIGVsZW1lbnRzIGZvciB0aGUgaG9zdCBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbGxlY3RLZXlzKGhvc3QsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBob3N0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBrZXlNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnRlbnRfMSA9IGNvbnRlbnQ7IF9pIDwgY29udGVudF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHZOb2RlID0gY29udGVudF8xW19pXTtcbiAgICAgICAgICAgIGlmICh2Tm9kZS50eXBlID09PSAnZWxlbWVudCcgJiYgdk5vZGUuYXR0cnMua2V5KSB7XG4gICAgICAgICAgICAgICAga2V5TWFwW3ZOb2RlLmF0dHJzLmtleV0gPSB7IHZOb2RlOiB2Tm9kZSwgZWxlbWVudDogbm9kZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleU1hcDtcbiAgICB9XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcblxuZXhwb3J0IHsgVmlydHVhbERPTSwgVmlydHVhbEVsZW1lbnQsIFZpcnR1YWxFbGVtZW50UGFzcywgVmlydHVhbFRleHQsIGgsIGhwYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lczYuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lumino/virtualdom/dist/index.es6.js\n")},"./node_modules/@lumino/widgets/dist/index.es6.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AccordionLayout\": () => (/* binding */ AccordionLayout),\n/* harmony export */   \"AccordionPanel\": () => (/* binding */ AccordionPanel),\n/* harmony export */   \"BoxEngine\": () => (/* binding */ BoxEngine),\n/* harmony export */   \"BoxLayout\": () => (/* binding */ BoxLayout),\n/* harmony export */   \"BoxPanel\": () => (/* binding */ BoxPanel),\n/* harmony export */   \"BoxSizer\": () => (/* binding */ BoxSizer),\n/* harmony export */   \"CommandPalette\": () => (/* binding */ CommandPalette),\n/* harmony export */   \"ContextMenu\": () => (/* binding */ ContextMenu),\n/* harmony export */   \"DockLayout\": () => (/* binding */ DockLayout),\n/* harmony export */   \"DockPanel\": () => (/* binding */ DockPanel),\n/* harmony export */   \"FocusTracker\": () => (/* binding */ FocusTracker),\n/* harmony export */   \"GridLayout\": () => (/* binding */ GridLayout),\n/* harmony export */   \"Layout\": () => (/* binding */ Layout),\n/* harmony export */   \"LayoutItem\": () => (/* binding */ LayoutItem),\n/* harmony export */   \"Menu\": () => (/* binding */ Menu),\n/* harmony export */   \"MenuBar\": () => (/* binding */ MenuBar),\n/* harmony export */   \"Panel\": () => (/* binding */ Panel),\n/* harmony export */   \"PanelLayout\": () => (/* binding */ PanelLayout),\n/* harmony export */   \"ScrollBar\": () => (/* binding */ ScrollBar),\n/* harmony export */   \"SingletonLayout\": () => (/* binding */ SingletonLayout),\n/* harmony export */   \"SplitLayout\": () => (/* binding */ SplitLayout),\n/* harmony export */   \"SplitPanel\": () => (/* binding */ SplitPanel),\n/* harmony export */   \"StackedLayout\": () => (/* binding */ StackedLayout),\n/* harmony export */   \"StackedPanel\": () => (/* binding */ StackedPanel),\n/* harmony export */   \"TabBar\": () => (/* binding */ TabBar),\n/* harmony export */   \"TabPanel\": () => (/* binding */ TabPanel),\n/* harmony export */   \"Title\": () => (/* binding */ Title),\n/* harmony export */   \"Widget\": () => (/* binding */ Widget)\n/* harmony export */ });\n/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/@lumino/algorithm/dist/index.es6.js\");\n/* harmony import */ var _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"./node_modules/@lumino/domutils/dist/index.es6.js\");\n/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"./node_modules/@lumino/messaging/dist/index.es6.js\");\n/* harmony import */ var _lumino_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"./node_modules/@lumino/properties/dist/index.es6.js\");\n/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"./node_modules/@lumino/signaling/dist/index.es6.js\");\n/* harmony import */ var _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"./node_modules/@lumino/dragdrop/dist/index.es6.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"./node_modules/@lumino/coreutils/dist/index.es6.js\");\n/* harmony import */ var _lumino_commands__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"./node_modules/@lumino/commands/dist/index.es6.js\");\n/* harmony import */ var _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"./node_modules/@lumino/virtualdom/dist/index.es6.js\");\n/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"./node_modules/@lumino/disposable/dist/index.es6.js\");\n/* harmony import */ var _lumino_keyboard__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"./node_modules/@lumino/keyboard/dist/index.es6.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A sizer object for use with the box engine layout functions.\n *\n * #### Notes\n * A box sizer holds the geometry information for an object along an\n * arbitrary layout orientation.\n *\n * For best performance, this class should be treated as a raw data\n * struct. It should not typically be subclassed.\n */\nvar BoxSizer = /** @class */ (function () {\n    function BoxSizer() {\n        /**\n         * The preferred size for the sizer.\n         *\n         * #### Notes\n         * The sizer will be given this initial size subject to its size\n         * bounds. The sizer will not deviate from this size unless such\n         * deviation is required to fit into the available layout space.\n         *\n         * There is no limit to this value, but it will be clamped to the\n         * bounds defined by [[minSize]] and [[maxSize]].\n         *\n         * The default value is `0`.\n         */\n        this.sizeHint = 0;\n        /**\n         * The minimum size of the sizer.\n         *\n         * #### Notes\n         * The sizer will never be sized less than this value, even if\n         * it means the sizer will overflow the available layout space.\n         *\n         * It is assumed that this value lies in the range `[0, Infinity)`\n         * and that it is `<=` to [[maxSize]]. Failure to adhere to this\n         * constraint will yield undefined results.\n         *\n         * The default value is `0`.\n         */\n        this.minSize = 0;\n        /**\n         * The maximum size of the sizer.\n         *\n         * #### Notes\n         * The sizer will never be sized greater than this value, even if\n         * it means the sizer will underflow the available layout space.\n         *\n         * It is assumed that this value lies in the range `[0, Infinity]`\n         * and that it is `>=` to [[minSize]]. Failure to adhere to this\n         * constraint will yield undefined results.\n         *\n         * The default value is `Infinity`.\n         */\n        this.maxSize = Infinity;\n        /**\n         * The stretch factor for the sizer.\n         *\n         * #### Notes\n         * This controls how much the sizer stretches relative to its sibling\n         * sizers when layout space is distributed. A stretch factor of zero\n         * is special and will cause the sizer to only be resized after all\n         * other sizers with a stretch factor greater than zero have been\n         * resized to their limits.\n         *\n         * It is assumed that this value is an integer that lies in the range\n         * `[0, Infinity)`. Failure to adhere to this constraint will yield\n         * undefined results.\n         *\n         * The default value is `1`.\n         */\n        this.stretch = 1;\n        /**\n         * The computed size of the sizer.\n         *\n         * #### Notes\n         * This value is the output of a call to [[boxCalc]]. It represents\n         * the computed size for the object along the layout orientation,\n         * and will always lie in the range `[minSize, maxSize]`.\n         *\n         * This value is output only.\n         *\n         * Changing this value will have no effect.\n         */\n        this.size = 0;\n        /**\n         * An internal storage property for the layout algorithm.\n         *\n         * #### Notes\n         * This value is used as temporary storage by the layout algorithm.\n         *\n         * Changing this value will have no effect.\n         */\n        this.done = false;\n    }\n    return BoxSizer;\n}());\n/**\n * The namespace for the box engine layout functions.\n */\nvar BoxEngine;\n(function (BoxEngine) {\n    /**\n     * Calculate the optimal layout sizes for a sequence of box sizers.\n     *\n     * This distributes the available layout space among the box sizers\n     * according to the following algorithm:\n     *\n     * 1. Initialize the sizers's size to its size hint and compute the\n     *    sums for each of size hint, min size, and max size.\n     *\n     * 2. If the total size hint equals the available space, return.\n     *\n     * 3. If the available space is less than the total min size, set all\n     *    sizers to their min size and return.\n     *\n     * 4. If the available space is greater than the total max size, set\n     *    all sizers to their max size and return.\n     *\n     * 5. If the layout space is less than the total size hint, distribute\n     *    the negative delta as follows:\n     *\n     *    a. Shrink each sizer with a stretch factor greater than zero by\n     *       an amount proportional to the negative space and the sum of\n     *       stretch factors. If the sizer reaches its min size, remove\n     *       it and its stretch factor from the computation.\n     *\n     *    b. If after adjusting all stretch sizers there remains negative\n     *       space, distribute the space equally among the sizers with a\n     *       stretch factor of zero. If a sizer reaches its min size,\n     *       remove it from the computation.\n     *\n     * 6. If the layout space is greater than the total size hint,\n     *    distribute the positive delta as follows:\n     *\n     *    a. Expand each sizer with a stretch factor greater than zero by\n     *       an amount proportional to the postive space and the sum of\n     *       stretch factors. If the sizer reaches its max size, remove\n     *       it and its stretch factor from the computation.\n     *\n     *    b. If after adjusting all stretch sizers there remains positive\n     *       space, distribute the space equally among the sizers with a\n     *       stretch factor of zero. If a sizer reaches its max size,\n     *       remove it from the computation.\n     *\n     * 7. return\n     *\n     * @param sizers - The sizers for a particular layout line.\n     *\n     * @param space - The available layout space for the sizers.\n     *\n     * @returns The delta between the provided available space and the\n     *   actual consumed space. This value will be zero if the sizers\n     *   can be adjusted to fit, negative if the available space is too\n     *   small, and positive if the available space is too large.\n     *\n     * #### Notes\n     * The [[size]] of each sizer is updated with the computed size.\n     *\n     * This function can be called at any time to recompute the layout for\n     * an existing sequence of sizers. The previously computed results will\n     * have no effect on the new output. It is therefore not necessary to\n     * create new sizer objects on each resize event.\n     */\n    function calc(sizers, space) {\n        // Bail early if there is nothing to do.\n        var count = sizers.length;\n        if (count === 0) {\n            return space;\n        }\n        // Setup the size and stretch counters.\n        var totalMin = 0;\n        var totalMax = 0;\n        var totalSize = 0;\n        var totalStretch = 0;\n        var stretchCount = 0;\n        // Setup the sizers and compute the totals.\n        for (var i = 0; i < count; ++i) {\n            var sizer = sizers[i];\n            var min = sizer.minSize;\n            var max = sizer.maxSize;\n            var hint = sizer.sizeHint;\n            sizer.done = false;\n            sizer.size = Math.max(min, Math.min(hint, max));\n            totalSize += sizer.size;\n            totalMin += min;\n            totalMax += max;\n            if (sizer.stretch > 0) {\n                totalStretch += sizer.stretch;\n                stretchCount++;\n            }\n        }\n        // If the space is equal to the total size, return early.\n        if (space === totalSize) {\n            return 0;\n        }\n        // If the space is less than the total min, minimize each sizer.\n        if (space <= totalMin) {\n            for (var i = 0; i < count; ++i) {\n                var sizer = sizers[i];\n                sizer.size = sizer.minSize;\n            }\n            return space - totalMin;\n        }\n        // If the space is greater than the total max, maximize each sizer.\n        if (space >= totalMax) {\n            for (var i = 0; i < count; ++i) {\n                var sizer = sizers[i];\n                sizer.size = sizer.maxSize;\n            }\n            return space - totalMax;\n        }\n        // The loops below perform sub-pixel precision sizing. A near zero\n        // value is used for compares instead of zero to ensure that the\n        // loop terminates when the subdivided space is reasonably small.\n        var nearZero = 0.01;\n        // A counter which is decremented each time a sizer is resized to\n        // its limit. This ensures the loops terminate even if there is\n        // space remaining to distribute.\n        var notDoneCount = count;\n        // Distribute negative delta space.\n        if (space < totalSize) {\n            // Shrink each stretchable sizer by an amount proportional to its\n            // stretch factor. If a sizer reaches its min size it's marked as\n            // done. The loop progresses in phases where each sizer is given\n            // a chance to consume its fair share for the pass, regardless of\n            // whether a sizer before it reached its limit. This continues\n            // until the stretchable sizers or the free space is exhausted.\n            var freeSpace = totalSize - space;\n            while (stretchCount > 0 && freeSpace > nearZero) {\n                var distSpace = freeSpace;\n                var distStretch = totalStretch;\n                for (var i = 0; i < count; ++i) {\n                    var sizer = sizers[i];\n                    if (sizer.done || sizer.stretch === 0) {\n                        continue;\n                    }\n                    var amt = sizer.stretch * distSpace / distStretch;\n                    if (sizer.size - amt <= sizer.minSize) {\n                        freeSpace -= sizer.size - sizer.minSize;\n                        totalStretch -= sizer.stretch;\n                        sizer.size = sizer.minSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                        stretchCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size -= amt;\n                    }\n                }\n            }\n            // Distribute any remaining space evenly among the non-stretchable\n            // sizers. This progresses in phases in the same manner as above.\n            while (notDoneCount > 0 && freeSpace > nearZero) {\n                var amt = freeSpace / notDoneCount;\n                for (var i = 0; i < count; ++i) {\n                    var sizer = sizers[i];\n                    if (sizer.done) {\n                        continue;\n                    }\n                    if (sizer.size - amt <= sizer.minSize) {\n                        freeSpace -= sizer.size - sizer.minSize;\n                        sizer.size = sizer.minSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size -= amt;\n                    }\n                }\n            }\n        }\n        // Distribute positive delta space.\n        else {\n            // Expand each stretchable sizer by an amount proportional to its\n            // stretch factor. If a sizer reaches its max size it's marked as\n            // done. The loop progresses in phases where each sizer is given\n            // a chance to consume its fair share for the pass, regardless of\n            // whether a sizer before it reached its limit. This continues\n            // until the stretchable sizers or the free space is exhausted.\n            var freeSpace = space - totalSize;\n            while (stretchCount > 0 && freeSpace > nearZero) {\n                var distSpace = freeSpace;\n                var distStretch = totalStretch;\n                for (var i = 0; i < count; ++i) {\n                    var sizer = sizers[i];\n                    if (sizer.done || sizer.stretch === 0) {\n                        continue;\n                    }\n                    var amt = sizer.stretch * distSpace / distStretch;\n                    if (sizer.size + amt >= sizer.maxSize) {\n                        freeSpace -= sizer.maxSize - sizer.size;\n                        totalStretch -= sizer.stretch;\n                        sizer.size = sizer.maxSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                        stretchCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size += amt;\n                    }\n                }\n            }\n            // Distribute any remaining space evenly among the non-stretchable\n            // sizers. This progresses in phases in the same manner as above.\n            while (notDoneCount > 0 && freeSpace > nearZero) {\n                var amt = freeSpace / notDoneCount;\n                for (var i = 0; i < count; ++i) {\n                    var sizer = sizers[i];\n                    if (sizer.done) {\n                        continue;\n                    }\n                    if (sizer.size + amt >= sizer.maxSize) {\n                        freeSpace -= sizer.maxSize - sizer.size;\n                        sizer.size = sizer.maxSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size += amt;\n                    }\n                }\n            }\n        }\n        // Indicate that the consumed space equals the available space.\n        return 0;\n    }\n    BoxEngine.calc = calc;\n    /**\n     * Adjust a sizer by a delta and update its neighbors accordingly.\n     *\n     * @param sizers - The sizers which should be adjusted.\n     *\n     * @param index - The index of the sizer to grow.\n     *\n     * @param delta - The amount to adjust the sizer, positive or negative.\n     *\n     * #### Notes\n     * This will adjust the indicated sizer by the specified amount, along\n     * with the sizes of the appropriate neighbors, subject to the limits\n     * specified by each of the sizers.\n     *\n     * This is useful when implementing box layouts where the boundaries\n     * between the sizers are interactively adjustable by the user.\n     */\n    function adjust(sizers, index, delta) {\n        // Bail early when there is nothing to do.\n        if (sizers.length === 0 || delta === 0) {\n            return;\n        }\n        // Dispatch to the proper implementation.\n        if (delta > 0) {\n            growSizer(sizers, index, delta);\n        }\n        else {\n            shrinkSizer(sizers, index, -delta);\n        }\n    }\n    BoxEngine.adjust = adjust;\n    /**\n     * Grow a sizer by a positive delta and adjust neighbors.\n     */\n    function growSizer(sizers, index, delta) {\n        // Compute how much the items to the left can expand.\n        var growLimit = 0;\n        for (var i = 0; i <= index; ++i) {\n            var sizer = sizers[i];\n            growLimit += sizer.maxSize - sizer.size;\n        }\n        // Compute how much the items to the right can shrink.\n        var shrinkLimit = 0;\n        for (var i = index + 1, n = sizers.length; i < n; ++i) {\n            var sizer = sizers[i];\n            shrinkLimit += sizer.size - sizer.minSize;\n        }\n        // Clamp the delta adjustment to the limits.\n        delta = Math.min(delta, growLimit, shrinkLimit);\n        // Grow the sizers to the left by the delta.\n        var grow = delta;\n        for (var i = index; i >= 0 && grow > 0; --i) {\n            var sizer = sizers[i];\n            var limit = sizer.maxSize - sizer.size;\n            if (limit >= grow) {\n                sizer.sizeHint = sizer.size + grow;\n                grow = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size + limit;\n                grow -= limit;\n            }\n        }\n        // Shrink the sizers to the right by the delta.\n        var shrink = delta;\n        for (var i = index + 1, n = sizers.length; i < n && shrink > 0; ++i) {\n            var sizer = sizers[i];\n            var limit = sizer.size - sizer.minSize;\n            if (limit >= shrink) {\n                sizer.sizeHint = sizer.size - shrink;\n                shrink = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size - limit;\n                shrink -= limit;\n            }\n        }\n    }\n    /**\n     * Shrink a sizer by a positive delta and adjust neighbors.\n     */\n    function shrinkSizer(sizers, index, delta) {\n        // Compute how much the items to the right can expand.\n        var growLimit = 0;\n        for (var i = index + 1, n = sizers.length; i < n; ++i) {\n            var sizer = sizers[i];\n            growLimit += sizer.maxSize - sizer.size;\n        }\n        // Compute how much the items to the left can shrink.\n        var shrinkLimit = 0;\n        for (var i = 0; i <= index; ++i) {\n            var sizer = sizers[i];\n            shrinkLimit += sizer.size - sizer.minSize;\n        }\n        // Clamp the delta adjustment to the limits.\n        delta = Math.min(delta, growLimit, shrinkLimit);\n        // Grow the sizers to the right by the delta.\n        var grow = delta;\n        for (var i = index + 1, n = sizers.length; i < n && grow > 0; ++i) {\n            var sizer = sizers[i];\n            var limit = sizer.maxSize - sizer.size;\n            if (limit >= grow) {\n                sizer.sizeHint = sizer.size + grow;\n                grow = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size + limit;\n                grow -= limit;\n            }\n        }\n        // Shrink the sizers to the left by the delta.\n        var shrink = delta;\n        for (var i = index; i >= 0 && shrink > 0; --i) {\n            var sizer = sizers[i];\n            var limit = sizer.size - sizer.minSize;\n            if (limit >= shrink) {\n                sizer.sizeHint = sizer.size - shrink;\n                shrink = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size - limit;\n                shrink -= limit;\n            }\n        }\n    }\n})(BoxEngine || (BoxEngine = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * An object which holds data related to an object's title.\n *\n * #### Notes\n * A title object is intended to hold the data necessary to display a\n * header for a particular object. A common example is the `TabPanel`,\n * which uses the widget title to populate the tab for a child widget.\n */\nvar Title = /** @class */ (function () {\n    /**\n     * Construct a new title.\n     *\n     * @param options - The options for initializing the title.\n     */\n    function Title(options) {\n        this._label = '';\n        this._caption = '';\n        this._mnemonic = -1;\n        this._iconClass = '';\n        this._iconLabel = '';\n        this._className = '';\n        this._closable = false;\n        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n        this.owner = options.owner;\n        if (options.label !== undefined) {\n            this._label = options.label;\n        }\n        if (options.mnemonic !== undefined) {\n            this._mnemonic = options.mnemonic;\n        }\n        if (options.icon !== undefined) {\n            /* <DEPRECATED> */\n            if (typeof options.icon === \"string\") {\n                // when ._icon is null, the .icon getter will alias .iconClass\n                this._icon = null;\n                this._iconClass = options.icon;\n            }\n            else {\n                /* </DEPRECATED> */\n                this._icon = options.icon;\n                /* <DEPRECATED> */\n            }\n            /* </DEPRECATED> */\n        }\n        /* <DEPRECATED> */\n        else {\n            // if unset, default to aliasing .iconClass\n            this._icon = null;\n        }\n        /* </DEPRECATED> */\n        if (options.iconClass !== undefined) {\n            this._iconClass = options.iconClass;\n        }\n        if (options.iconLabel !== undefined) {\n            this._iconLabel = options.iconLabel;\n        }\n        if (options.iconRenderer !== undefined) {\n            this._icon = options.iconRenderer;\n        }\n        if (options.caption !== undefined) {\n            this._caption = options.caption;\n        }\n        if (options.className !== undefined) {\n            this._className = options.className;\n        }\n        if (options.closable !== undefined) {\n            this._closable = options.closable;\n        }\n        this._dataset = options.dataset || {};\n    }\n    Object.defineProperty(Title.prototype, \"changed\", {\n        /**\n         * A signal emitted when the state of the title changes.\n         */\n        get: function () {\n            return this._changed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"label\", {\n        /**\n         * Get the label for the title.\n         *\n         * #### Notes\n         * The default value is an empty string.\n         */\n        get: function () {\n            return this._label;\n        },\n        /**\n         * Set the label for the title.\n         */\n        set: function (value) {\n            if (this._label === value) {\n                return;\n            }\n            this._label = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"mnemonic\", {\n        /**\n         * Get the mnemonic index for the title.\n         *\n         * #### Notes\n         * The default value is `-1`.\n         */\n        get: function () {\n            return this._mnemonic;\n        },\n        /**\n         * Set the mnemonic index for the title.\n         */\n        set: function (value) {\n            if (this._mnemonic === value) {\n                return;\n            }\n            this._mnemonic = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"icon\", {\n        /**\n         * Get the icon renderer for the title.\n         *\n         * #### Notes\n         * The default value is undefined.\n         *\n         * DEPRECATED: if set to a string value, the .icon field will function as\n         * an alias for the .iconClass field, for backwards compatibility\n         */\n        get: function () {\n            /* <DEPRECATED> */\n            if (this._icon === null) {\n                // only alias .iconClass if ._icon has been explicitly nulled\n                return this.iconClass;\n            }\n            /* </DEPRECATED> */\n            return this._icon;\n        },\n        /**\n         * Set the icon renderer for the title.\n         *\n         * #### Notes\n         * A renderer is an object that supplies a render and unrender function.\n         *\n         * DEPRECATED: if set to a string value, the .icon field will function as\n         * an alias for the .iconClass field, for backwards compatibility\n         */\n        set: function (value /* </DEPRECATED> */) {\n            /* <DEPRECATED> */\n            if (typeof value === \"string\") {\n                // when ._icon is null, the .icon getter will alias .iconClass\n                this._icon = null;\n                this.iconClass = value;\n            }\n            else {\n                /* </DEPRECATED> */\n                if (this._icon === value) {\n                    return;\n                }\n                this._icon = value;\n                this._changed.emit(undefined);\n                /* <DEPRECATED> */\n            }\n            /* </DEPRECATED> */\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"iconClass\", {\n        /**\n         * Get the icon class name for the title.\n         *\n         * #### Notes\n         * The default value is an empty string.\n         */\n        get: function () {\n            return this._iconClass;\n        },\n        /**\n         * Set the icon class name for the title.\n         *\n         * #### Notes\n         * Multiple class names can be separated with whitespace.\n         */\n        set: function (value) {\n            if (this._iconClass === value) {\n                return;\n            }\n            this._iconClass = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"iconLabel\", {\n        /**\n         * Get the icon label for the title.\n         *\n         * #### Notes\n         * The default value is an empty string.\n         */\n        get: function () {\n            return this._iconLabel;\n        },\n        /**\n         * Set the icon label for the title.\n         *\n         * #### Notes\n         * Multiple class names can be separated with whitespace.\n         */\n        set: function (value) {\n            if (this._iconLabel === value) {\n                return;\n            }\n            this._iconLabel = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"iconRenderer\", {\n        /**\n         * @deprecated Use `icon` instead.\n         */\n        get: function () {\n            return this._icon || undefined;\n        },\n        /**\n         * @deprecated Use `icon` instead.\n         */\n        set: function (value) {\n            this.icon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"caption\", {\n        /**\n         * Get the caption for the title.\n         *\n         * #### Notes\n         * The default value is an empty string.\n         */\n        get: function () {\n            return this._caption;\n        },\n        /**\n         * Set the caption for the title.\n         */\n        set: function (value) {\n            if (this._caption === value) {\n                return;\n            }\n            this._caption = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"className\", {\n        /**\n         * Get the extra class name for the title.\n         *\n         * #### Notes\n         * The default value is an empty string.\n         */\n        get: function () {\n            return this._className;\n        },\n        /**\n         * Set the extra class name for the title.\n         *\n         * #### Notes\n         * Multiple class names can be separated with whitespace.\n         */\n        set: function (value) {\n            if (this._className === value) {\n                return;\n            }\n            this._className = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"closable\", {\n        /**\n         * Get the closable state for the title.\n         *\n         * #### Notes\n         * The default value is `false`.\n         */\n        get: function () {\n            return this._closable;\n        },\n        /**\n         * Set the closable state for the title.\n         *\n         * #### Notes\n         * This controls the presence of a close icon when applicable.\n         */\n        set: function (value) {\n            if (this._closable === value) {\n                return;\n            }\n            this._closable = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Title.prototype, \"dataset\", {\n        /**\n         * Get the dataset for the title.\n         *\n         * #### Notes\n         * The default value is an empty dataset.\n         */\n        get: function () {\n            return this._dataset;\n        },\n        /**\n         * Set the dataset for the title.\n         *\n         * #### Notes\n         * This controls the data attributes when applicable.\n         */\n        set: function (value) {\n            if (this._dataset === value) {\n                return;\n            }\n            this._dataset = value;\n            this._changed.emit(undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Title;\n}());\n\n/**\n * The base class of the lumino widget hierarchy.\n *\n * #### Notes\n * This class will typically be subclassed in order to create a useful\n * widget. However, it can be used directly to host externally created\n * content.\n */\nvar Widget = /** @class */ (function () {\n    /**\n     * Construct a new widget.\n     *\n     * @param options - The options for initializing the widget.\n     */\n    function Widget(options) {\n        if (options === void 0) { options = {}; }\n        this._flags = 0;\n        this._layout = null;\n        this._parent = null;\n        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n        this.node = Private.createNode(options);\n        this.addClass('lm-Widget');\n        /* <DEPRECATED> */\n        this.addClass('p-Widget');\n        /* </DEPRECATED> */\n    }\n    /**\n     * Dispose of the widget and its descendant widgets.\n     *\n     * #### Notes\n     * It is unsafe to use the widget after it has been disposed.\n     *\n     * All calls made to this method after the first are a no-op.\n     */\n    Widget.prototype.dispose = function () {\n        // Do nothing if the widget is already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        // Set the disposed flag and emit the disposed signal.\n        this.setFlag(Widget.Flag.IsDisposed);\n        this._disposed.emit(undefined);\n        // Remove or detach the widget if necessary.\n        if (this.parent) {\n            this.parent = null;\n        }\n        else if (this.isAttached) {\n            Widget.detach(this);\n        }\n        // Dispose of the widget layout.\n        if (this._layout) {\n            this._layout.dispose();\n            this._layout = null;\n        }\n        // Clear the extra data associated with the widget.\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal.clearData(this);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.clearData(this);\n        _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty.clearData(this);\n    };\n    Object.defineProperty(Widget.prototype, \"disposed\", {\n        /**\n         * A signal emitted when the widget is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"isDisposed\", {\n        /**\n         * Test whether the widget has been disposed.\n         */\n        get: function () {\n            return this.testFlag(Widget.Flag.IsDisposed);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"isAttached\", {\n        /**\n         * Test whether the widget's node is attached to the DOM.\n         */\n        get: function () {\n            return this.testFlag(Widget.Flag.IsAttached);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"isHidden\", {\n        /**\n         * Test whether the widget is explicitly hidden.\n         */\n        get: function () {\n            return this.testFlag(Widget.Flag.IsHidden);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"isVisible\", {\n        /**\n         * Test whether the widget is visible.\n         *\n         * #### Notes\n         * A widget is visible when it is attached to the DOM, is not\n         * explicitly hidden, and has no explicitly hidden ancestors.\n         */\n        get: function () {\n            return this.testFlag(Widget.Flag.IsVisible);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"title\", {\n        /**\n         * The title object for the widget.\n         *\n         * #### Notes\n         * The title object is used by some container widgets when displaying\n         * the widget alongside some title, such as a tab panel or side bar.\n         *\n         * Since not all widgets will use the title, it is created on demand.\n         *\n         * The `owner` property of the title is set to this widget.\n         */\n        get: function () {\n            return Private.titleProperty.get(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"id\", {\n        /**\n         * Get the id of the widget's DOM node.\n         */\n        get: function () {\n            return this.node.id;\n        },\n        /**\n         * Set the id of the widget's DOM node.\n         */\n        set: function (value) {\n            this.node.id = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"dataset\", {\n        /**\n         * The dataset for the widget's DOM node.\n         */\n        get: function () {\n            return this.node.dataset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"parent\", {\n        /**\n         * Get the parent of the widget.\n         */\n        get: function () {\n            return this._parent;\n        },\n        /**\n         * Set the parent of the widget.\n         *\n         * #### Notes\n         * Children are typically added to a widget by using a layout, which\n         * means user code will not normally set the parent widget directly.\n         *\n         * The widget will be automatically removed from its old parent.\n         *\n         * This is a no-op if there is no effective parent change.\n         */\n        set: function (value) {\n            if (this._parent === value) {\n                return;\n            }\n            if (value && this.contains(value)) {\n                throw new Error('Invalid parent widget.');\n            }\n            if (this._parent && !this._parent.isDisposed) {\n                var msg = new Widget.ChildMessage('child-removed', this);\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this._parent, msg);\n            }\n            this._parent = value;\n            if (this._parent && !this._parent.isDisposed) {\n                var msg = new Widget.ChildMessage('child-added', this);\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this._parent, msg);\n            }\n            if (!this.isDisposed) {\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.ParentChanged);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"layout\", {\n        /**\n         * Get the layout for the widget.\n         */\n        get: function () {\n            return this._layout;\n        },\n        /**\n         * Set the layout for the widget.\n         *\n         * #### Notes\n         * The layout is single-use only. It cannot be changed after the\n         * first assignment.\n         *\n         * The layout is disposed automatically when the widget is disposed.\n         */\n        set: function (value) {\n            if (this._layout === value) {\n                return;\n            }\n            if (this.testFlag(Widget.Flag.DisallowLayout)) {\n                throw new Error('Cannot set widget layout.');\n            }\n            if (this._layout) {\n                throw new Error('Cannot change widget layout.');\n            }\n            if (value.parent) {\n                throw new Error('Cannot change layout parent.');\n            }\n            this._layout = value;\n            value.parent = this;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over the widget's children.\n     *\n     * @returns A new iterator over the children of the widget.\n     *\n     * #### Notes\n     * The widget must have a populated layout in order to have children.\n     *\n     * If a layout is not installed, the returned iterator will be empty.\n     */\n    Widget.prototype.children = function () {\n        return this._layout ? this._layout.iter() : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Test whether a widget is a descendant of this widget.\n     *\n     * @param widget - The descendant widget of interest.\n     *\n     * @returns `true` if the widget is a descendant, `false` otherwise.\n     */\n    Widget.prototype.contains = function (widget) {\n        for (var value = widget; value; value = value._parent) {\n            if (value === this) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Test whether the widget's DOM node has the given class name.\n     *\n     * @param name - The class name of interest.\n     *\n     * @returns `true` if the node has the class, `false` otherwise.\n     */\n    Widget.prototype.hasClass = function (name) {\n        return this.node.classList.contains(name);\n    };\n    /**\n     * Add a class name to the widget's DOM node.\n     *\n     * @param name - The class name to add to the node.\n     *\n     * #### Notes\n     * If the class name is already added to the node, this is a no-op.\n     *\n     * The class name must not contain whitespace.\n     */\n    Widget.prototype.addClass = function (name) {\n        this.node.classList.add(name);\n    };\n    /**\n     * Remove a class name from the widget's DOM node.\n     *\n     * @param name - The class name to remove from the node.\n     *\n     * #### Notes\n     * If the class name is not yet added to the node, this is a no-op.\n     *\n     * The class name must not contain whitespace.\n     */\n    Widget.prototype.removeClass = function (name) {\n        this.node.classList.remove(name);\n    };\n    /**\n     * Toggle a class name on the widget's DOM node.\n     *\n     * @param name - The class name to toggle on the node.\n     *\n     * @param force - Whether to force add the class (`true`) or force\n     *   remove the class (`false`). If not provided, the presence of\n     *   the class will be toggled from its current state.\n     *\n     * @returns `true` if the class is now present, `false` otherwise.\n     *\n     * #### Notes\n     * The class name must not contain whitespace.\n     */\n    Widget.prototype.toggleClass = function (name, force) {\n        if (force === true) {\n            this.node.classList.add(name);\n            return true;\n        }\n        if (force === false) {\n            this.node.classList.remove(name);\n            return false;\n        }\n        return this.node.classList.toggle(name);\n    };\n    /**\n     * Post an `'update-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for posting the message.\n     */\n    Widget.prototype.update = function () {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Widget.Msg.UpdateRequest);\n    };\n    /**\n     * Post a `'fit-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for posting the message.\n     */\n    Widget.prototype.fit = function () {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Widget.Msg.FitRequest);\n    };\n    /**\n     * Post an `'activate-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for posting the message.\n     */\n    Widget.prototype.activate = function () {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Widget.Msg.ActivateRequest);\n    };\n    /**\n     * Send a `'close-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for sending the message.\n     */\n    Widget.prototype.close = function () {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.CloseRequest);\n    };\n    /**\n     * Show the widget and make it visible to its parent widget.\n     *\n     * #### Notes\n     * This causes the [[isHidden]] property to be `false`.\n     *\n     * If the widget is not explicitly hidden, this is a no-op.\n     */\n    Widget.prototype.show = function () {\n        if (!this.testFlag(Widget.Flag.IsHidden)) {\n            return;\n        }\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.BeforeShow);\n        }\n        this.clearFlag(Widget.Flag.IsHidden);\n        this.removeClass('lm-mod-hidden');\n        /* <DEPRECATED> */\n        this.removeClass('p-mod-hidden');\n        /* </DEPRECATED> */\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.AfterShow);\n        }\n        if (this.parent) {\n            var msg = new Widget.ChildMessage('child-shown', this);\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, msg);\n        }\n    };\n    /**\n     * Hide the widget and make it hidden to its parent widget.\n     *\n     * #### Notes\n     * This causes the [[isHidden]] property to be `true`.\n     *\n     * If the widget is explicitly hidden, this is a no-op.\n     */\n    Widget.prototype.hide = function () {\n        if (this.testFlag(Widget.Flag.IsHidden)) {\n            return;\n        }\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.BeforeHide);\n        }\n        this.setFlag(Widget.Flag.IsHidden);\n        this.addClass('lm-mod-hidden');\n        /* <DEPRECATED> */\n        this.addClass('p-mod-hidden');\n        /* </DEPRECATED> */\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.AfterHide);\n        }\n        if (this.parent) {\n            var msg = new Widget.ChildMessage('child-hidden', this);\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, msg);\n        }\n    };\n    /**\n     * Show or hide the widget according to a boolean value.\n     *\n     * @param hidden - `true` to hide the widget, or `false` to show it.\n     *\n     * #### Notes\n     * This is a convenience method for `hide()` and `show()`.\n     */\n    Widget.prototype.setHidden = function (hidden) {\n        if (hidden) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    };\n    /**\n     * Test whether the given widget flag is set.\n     *\n     * #### Notes\n     * This will not typically be called directly by user code.\n     */\n    Widget.prototype.testFlag = function (flag) {\n        return (this._flags & flag) !== 0;\n    };\n    /**\n     * Set the given widget flag.\n     *\n     * #### Notes\n     * This will not typically be called directly by user code.\n     */\n    Widget.prototype.setFlag = function (flag) {\n        this._flags |= flag;\n    };\n    /**\n     * Clear the given widget flag.\n     *\n     * #### Notes\n     * This will not typically be called directly by user code.\n     */\n    Widget.prototype.clearFlag = function (flag) {\n        this._flags &= ~flag;\n    };\n    /**\n     * Process a message sent to the widget.\n     *\n     * @param msg - The message sent to the widget.\n     *\n     * #### Notes\n     * Subclasses may reimplement this method as needed.\n     */\n    Widget.prototype.processMessage = function (msg) {\n        switch (msg.type) {\n            case 'resize':\n                this.notifyLayout(msg);\n                this.onResize(msg);\n                break;\n            case 'update-request':\n                this.notifyLayout(msg);\n                this.onUpdateRequest(msg);\n                break;\n            case 'fit-request':\n                this.notifyLayout(msg);\n                this.onFitRequest(msg);\n                break;\n            case 'before-show':\n                this.notifyLayout(msg);\n                this.onBeforeShow(msg);\n                break;\n            case 'after-show':\n                this.setFlag(Widget.Flag.IsVisible);\n                this.notifyLayout(msg);\n                this.onAfterShow(msg);\n                break;\n            case 'before-hide':\n                this.notifyLayout(msg);\n                this.onBeforeHide(msg);\n                break;\n            case 'after-hide':\n                this.clearFlag(Widget.Flag.IsVisible);\n                this.notifyLayout(msg);\n                this.onAfterHide(msg);\n                break;\n            case 'before-attach':\n                this.notifyLayout(msg);\n                this.onBeforeAttach(msg);\n                break;\n            case 'after-attach':\n                if (!this.isHidden && (!this.parent || this.parent.isVisible)) {\n                    this.setFlag(Widget.Flag.IsVisible);\n                }\n                this.setFlag(Widget.Flag.IsAttached);\n                this.notifyLayout(msg);\n                this.onAfterAttach(msg);\n                break;\n            case 'before-detach':\n                this.notifyLayout(msg);\n                this.onBeforeDetach(msg);\n                break;\n            case 'after-detach':\n                this.clearFlag(Widget.Flag.IsVisible);\n                this.clearFlag(Widget.Flag.IsAttached);\n                this.notifyLayout(msg);\n                this.onAfterDetach(msg);\n                break;\n            case 'activate-request':\n                this.notifyLayout(msg);\n                this.onActivateRequest(msg);\n                break;\n            case 'close-request':\n                this.notifyLayout(msg);\n                this.onCloseRequest(msg);\n                break;\n            case 'child-added':\n                this.notifyLayout(msg);\n                this.onChildAdded(msg);\n                break;\n            case 'child-removed':\n                this.notifyLayout(msg);\n                this.onChildRemoved(msg);\n                break;\n            default:\n                this.notifyLayout(msg);\n                break;\n        }\n    };\n    /**\n     * Invoke the message processing routine of the widget's layout.\n     *\n     * @param msg - The message to dispatch to the layout.\n     *\n     * #### Notes\n     * This is a no-op if the widget does not have a layout.\n     *\n     * This will not typically be called directly by user code.\n     */\n    Widget.prototype.notifyLayout = function (msg) {\n        if (this._layout) {\n            this._layout.processParentMessage(msg);\n        }\n    };\n    /**\n     * A message handler invoked on a `'close-request'` message.\n     *\n     * #### Notes\n     * The default implementation unparents or detaches the widget.\n     */\n    Widget.prototype.onCloseRequest = function (msg) {\n        if (this.parent) {\n            this.parent = null;\n        }\n        else if (this.isAttached) {\n            Widget.detach(this);\n        }\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onResize = function (msg) { };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onUpdateRequest = function (msg) { };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onFitRequest = function (msg) { };\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onActivateRequest = function (msg) { };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onBeforeShow = function (msg) { };\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onAfterShow = function (msg) { };\n    /**\n     * A message handler invoked on a `'before-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onBeforeHide = function (msg) { };\n    /**\n     * A message handler invoked on an `'after-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onAfterHide = function (msg) { };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onBeforeAttach = function (msg) { };\n    /**\n     * A message handler invoked on an `'after-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onAfterAttach = function (msg) { };\n    /**\n     * A message handler invoked on a `'before-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onBeforeDetach = function (msg) { };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onAfterDetach = function (msg) { };\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onChildAdded = function (msg) { };\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Widget.prototype.onChildRemoved = function (msg) { };\n    return Widget;\n}());\n/**\n * The namespace for the `Widget` class statics.\n */\n(function (Widget) {\n    /**\n     * An enum of widget bit flags.\n     */\n    var Flag;\n    (function (Flag) {\n        /**\n         * The widget has been disposed.\n         */\n        Flag[Flag[\"IsDisposed\"] = 1] = \"IsDisposed\";\n        /**\n         * The widget is attached to the DOM.\n         */\n        Flag[Flag[\"IsAttached\"] = 2] = \"IsAttached\";\n        /**\n         * The widget is hidden.\n         */\n        Flag[Flag[\"IsHidden\"] = 4] = \"IsHidden\";\n        /**\n         * The widget is visible.\n         */\n        Flag[Flag[\"IsVisible\"] = 8] = \"IsVisible\";\n        /**\n         * A layout cannot be set on the widget.\n         */\n        Flag[Flag[\"DisallowLayout\"] = 16] = \"DisallowLayout\";\n    })(Flag = Widget.Flag || (Widget.Flag = {}));\n    /**\n     * A collection of stateless messages related to widgets.\n     */\n    var Msg;\n    (function (Msg) {\n        /**\n         * A singleton `'before-show'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it becomes visible.\n         *\n         * This message is **not** sent when the widget is being attached.\n         */\n        Msg.BeforeShow = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('before-show');\n        /**\n         * A singleton `'after-show'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it becomes visible.\n         *\n         * This message is **not** sent when the widget is being attached.\n         */\n        Msg.AfterShow = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('after-show');\n        /**\n         * A singleton `'before-hide'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it becomes not-visible.\n         *\n         * This message is **not** sent when the widget is being detached.\n         */\n        Msg.BeforeHide = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('before-hide');\n        /**\n         * A singleton `'after-hide'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it becomes not-visible.\n         *\n         * This message is **not** sent when the widget is being detached.\n         */\n        Msg.AfterHide = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('after-hide');\n        /**\n         * A singleton `'before-attach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it is attached.\n         */\n        Msg.BeforeAttach = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('before-attach');\n        /**\n         * A singleton `'after-attach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it is attached.\n         */\n        Msg.AfterAttach = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('after-attach');\n        /**\n         * A singleton `'before-detach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it is detached.\n         */\n        Msg.BeforeDetach = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('before-detach');\n        /**\n         * A singleton `'after-detach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it is detached.\n         */\n        Msg.AfterDetach = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('after-detach');\n        /**\n         * A singleton `'parent-changed'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget when its parent has changed.\n         */\n        Msg.ParentChanged = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message('parent-changed');\n        /**\n         * A singleton conflatable `'update-request'` message.\n         *\n         * #### Notes\n         * This message can be dispatched to supporting widgets in order to\n         * update their content based on the current widget state. Not all\n         * widgets will respond to messages of this type.\n         *\n         * For widgets with a layout, this message will inform the layout to\n         * update the position and size of its child widgets.\n         */\n        Msg.UpdateRequest = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.ConflatableMessage('update-request');\n        /**\n         * A singleton conflatable `'fit-request'` message.\n         *\n         * #### Notes\n         * For widgets with a layout, this message will inform the layout to\n         * recalculate its size constraints to fit the space requirements of\n         * its child widgets, and to update their position and size. Not all\n         * layouts will respond to messages of this type.\n         */\n        Msg.FitRequest = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.ConflatableMessage('fit-request');\n        /**\n         * A singleton conflatable `'activate-request'` message.\n         *\n         * #### Notes\n         * This message should be dispatched to a widget when it should\n         * perform the actions necessary to activate the widget, which\n         * may include focusing its node or descendant node.\n         */\n        Msg.ActivateRequest = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.ConflatableMessage('activate-request');\n        /**\n         * A singleton conflatable `'close-request'` message.\n         *\n         * #### Notes\n         * This message should be dispatched to a widget when it should close\n         * and remove itself from the widget hierarchy.\n         */\n        Msg.CloseRequest = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.ConflatableMessage('close-request');\n    })(Msg = Widget.Msg || (Widget.Msg = {}));\n    /**\n     * A message class for child related messages.\n     */\n    var ChildMessage = /** @class */ (function (_super) {\n        __extends(ChildMessage, _super);\n        /**\n         * Construct a new child message.\n         *\n         * @param type - The message type.\n         *\n         * @param child - The child widget for the message.\n         */\n        function ChildMessage(type, child) {\n            var _this = _super.call(this, type) || this;\n            _this.child = child;\n            return _this;\n        }\n        return ChildMessage;\n    }(_lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message));\n    Widget.ChildMessage = ChildMessage;\n    /**\n     * A message class for `'resize'` messages.\n     */\n    var ResizeMessage = /** @class */ (function (_super) {\n        __extends(ResizeMessage, _super);\n        /**\n         * Construct a new resize message.\n         *\n         * @param width - The **offset width** of the widget, or `-1` if\n         *   the width is not known.\n         *\n         * @param height - The **offset height** of the widget, or `-1` if\n         *   the height is not known.\n         */\n        function ResizeMessage(width, height) {\n            var _this = _super.call(this, 'resize') || this;\n            _this.width = width;\n            _this.height = height;\n            return _this;\n        }\n        return ResizeMessage;\n    }(_lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.Message));\n    Widget.ResizeMessage = ResizeMessage;\n    /**\n     * The namespace for the `ResizeMessage` class statics.\n     */\n    (function (ResizeMessage) {\n        /**\n         * A singleton `'resize'` message with an unknown size.\n         */\n        ResizeMessage.UnknownSize = new ResizeMessage(-1, -1);\n    })(ResizeMessage = Widget.ResizeMessage || (Widget.ResizeMessage = {}));\n    /**\n     * Attach a widget to a host DOM node.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param host - The DOM node to use as the widget's host.\n     *\n     * @param ref - The child of `host` to use as the reference element.\n     *   If this is provided, the widget will be inserted before this\n     *   node in the host. The default is `null`, which will cause the\n     *   widget to be added as the last child of the host.\n     *\n     * #### Notes\n     * This will throw an error if the widget is not a root widget, if\n     * the widget is already attached, or if the host is not attached\n     * to the DOM.\n     */\n    function attach(widget, host, ref) {\n        if (ref === void 0) { ref = null; }\n        if (widget.parent) {\n            throw new Error('Cannot attach a child widget.');\n        }\n        if (widget.isAttached || document.body.contains(widget.node)) {\n            throw new Error('Widget is already attached.');\n        }\n        if (!document.body.contains(host)) {\n            throw new Error('Host is not attached.');\n        }\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        host.insertBefore(widget.node, ref);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n    Widget.attach = attach;\n    /**\n     * Detach the widget from its host DOM node.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * This will throw an error if the widget is not a root widget,\n     * or if the widget is not attached to the DOM.\n     */\n    function detach(widget) {\n        if (widget.parent) {\n            throw new Error('Cannot detach a child widget.');\n        }\n        if (!widget.isAttached || !document.body.contains(widget.node)) {\n            throw new Error('Widget is not attached.');\n        }\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        widget.node.parentNode.removeChild(widget.node);\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n    Widget.detach = detach;\n})(Widget || (Widget = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for the widget title object.\n     */\n    Private.titleProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'title',\n        create: function (owner) { return new Title({ owner: owner }); },\n    });\n    /**\n     * Create a DOM node for the given widget options.\n     */\n    function createNode(options) {\n        return options.node || document.createElement(options.tag || 'div');\n    }\n    Private.createNode = createNode;\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * An abstract base class for creating lumino layouts.\n *\n * #### Notes\n * A layout is used to add widgets to a parent and to arrange those\n * widgets within the parent's DOM node.\n *\n * This class implements the base functionality which is required of\n * nearly all layouts. It must be subclassed in order to be useful.\n *\n * Notably, this class does not define a uniform interface for adding\n * widgets to the layout. A subclass should define that API in a way\n * which is meaningful for its intended use.\n */\nvar Layout = /** @class */ (function () {\n    /**\n     * Construct a new layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    function Layout(options) {\n        if (options === void 0) { options = {}; }\n        this._disposed = false;\n        this._parent = null;\n        this._fitPolicy = options.fitPolicy || 'set-min-size';\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     *\n     * #### Notes\n     * This should be reimplemented to clear and dispose of the widgets.\n     *\n     * All reimplementations should call the superclass method.\n     *\n     * This method is called automatically when the parent is disposed.\n     */\n    Layout.prototype.dispose = function () {\n        this._parent = null;\n        this._disposed = true;\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal.clearData(this);\n        _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty.clearData(this);\n    };\n    Object.defineProperty(Layout.prototype, \"isDisposed\", {\n        /**\n         * Test whether the layout is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Layout.prototype, \"parent\", {\n        /**\n         * Get the parent widget of the layout.\n         */\n        get: function () {\n            return this._parent;\n        },\n        /**\n         * Set the parent widget of the layout.\n         *\n         * #### Notes\n         * This is set automatically when installing the layout on the parent\n         * widget. The parent widget should not be set directly by user code.\n         */\n        set: function (value) {\n            if (this._parent === value) {\n                return;\n            }\n            if (this._parent) {\n                throw new Error('Cannot change parent widget.');\n            }\n            if (value.layout !== this) {\n                throw new Error('Invalid parent widget.');\n            }\n            this._parent = value;\n            this.init();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Layout.prototype, \"fitPolicy\", {\n        /**\n         * Get the fit policy for the layout.\n         *\n         * #### Notes\n         * The fit policy controls the computed size constraints which are\n         * applied to the parent widget by the layout.\n         *\n         * Some layout implementations may ignore the fit policy.\n         */\n        get: function () {\n            return this._fitPolicy;\n        },\n        /**\n         * Set the fit policy for the layout.\n         *\n         * #### Notes\n         * The fit policy controls the computed size constraints which are\n         * applied to the parent widget by the layout.\n         *\n         * Some layout implementations may ignore the fit policy.\n         *\n         * Changing the fit policy will clear the current size constraint\n         * for the parent widget and then re-fit the parent.\n         */\n        set: function (value) {\n            // Bail if the policy does not change\n            if (this._fitPolicy === value) {\n                return;\n            }\n            // Update the internal policy.\n            this._fitPolicy = value;\n            // Clear the size constraints and schedule a fit of the parent.\n            if (this._parent) {\n                var style = this._parent.node.style;\n                style.minWidth = '';\n                style.minHeight = '';\n                style.maxWidth = '';\n                style.maxHeight = '';\n                this._parent.fit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Process a message sent to the parent widget.\n     *\n     * @param msg - The message sent to the parent widget.\n     *\n     * #### Notes\n     * This method is called by the parent widget to process a message.\n     *\n     * Subclasses may reimplement this method as needed.\n     */\n    Layout.prototype.processParentMessage = function (msg) {\n        switch (msg.type) {\n            case 'resize':\n                this.onResize(msg);\n                break;\n            case 'update-request':\n                this.onUpdateRequest(msg);\n                break;\n            case 'fit-request':\n                this.onFitRequest(msg);\n                break;\n            case 'before-show':\n                this.onBeforeShow(msg);\n                break;\n            case 'after-show':\n                this.onAfterShow(msg);\n                break;\n            case 'before-hide':\n                this.onBeforeHide(msg);\n                break;\n            case 'after-hide':\n                this.onAfterHide(msg);\n                break;\n            case 'before-attach':\n                this.onBeforeAttach(msg);\n                break;\n            case 'after-attach':\n                this.onAfterAttach(msg);\n                break;\n            case 'before-detach':\n                this.onBeforeDetach(msg);\n                break;\n            case 'after-detach':\n                this.onAfterDetach(msg);\n                break;\n            case 'child-removed':\n                this.onChildRemoved(msg);\n                break;\n            case 'child-shown':\n                this.onChildShown(msg);\n                break;\n            case 'child-hidden':\n                this.onChildHidden(msg);\n                break;\n        }\n    };\n    /**\n     * Perform layout initialization which requires the parent widget.\n     *\n     * #### Notes\n     * This method is invoked immediately after the layout is installed\n     * on the parent widget.\n     *\n     * The default implementation reparents all of the widgets to the\n     * layout parent widget.\n     *\n     * Subclasses should reimplement this method and attach the child\n     * widget nodes to the parent widget's node.\n     */\n    Layout.prototype.init = function () {\n        var _this = this;\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            widget.parent = _this.parent;\n        });\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     *\n     * #### Notes\n     * The layout should ensure that its widgets are resized according\n     * to the specified layout space, and that they are sent a `'resize'`\n     * message if appropriate.\n     *\n     * The default implementation of this method sends an `UnknownSize`\n     * resize message to all widgets.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onResize = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n        });\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     *\n     * #### Notes\n     * The layout should ensure that its widgets are resized according\n     * to the available layout space, and that they are sent a `'resize'`\n     * message if appropriate.\n     *\n     * The default implementation of this method sends an `UnknownSize`\n     * resize message to all widgets.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onUpdateRequest = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n        });\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onBeforeAttach = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n        });\n    };\n    /**\n     * A message handler invoked on an `'after-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onAfterAttach = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n        });\n    };\n    /**\n     * A message handler invoked on a `'before-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onBeforeDetach = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n        });\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onAfterDetach = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n        });\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onBeforeShow = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            if (!widget.isHidden) {\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n            }\n        });\n    };\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onAfterShow = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            if (!widget.isHidden) {\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n            }\n        });\n    };\n    /**\n     * A message handler invoked on a `'before-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onBeforeHide = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            if (!widget.isHidden) {\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n            }\n        });\n    };\n    /**\n     * A message handler invoked on an `'after-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    Layout.prototype.onAfterHide = function (msg) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) {\n            if (!widget.isHidden) {\n                _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, msg);\n            }\n        });\n    };\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     *\n     * #### Notes\n     * This will remove the child widget from the layout.\n     *\n     * Subclasses should **not** typically reimplement this method.\n     */\n    Layout.prototype.onChildRemoved = function (msg) {\n        this.removeWidget(msg.child);\n    };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Layout.prototype.onFitRequest = function (msg) { };\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Layout.prototype.onChildShown = function (msg) { };\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    Layout.prototype.onChildHidden = function (msg) { };\n    return Layout;\n}());\n/**\n * The namespace for the `Layout` class statics.\n */\n(function (Layout) {\n    /**\n     * Get the horizontal alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The horizontal alignment for the widget.\n     *\n     * #### Notes\n     * If the layout width allocated to a widget is larger than its max\n     * width, the horizontal alignment controls how the widget is placed\n     * within the extra horizontal space.\n     *\n     * If the allocated width is less than the widget's max width, the\n     * horizontal alignment has no effect.\n     *\n     * Some layout implementations may ignore horizontal alignment.\n     */\n    function getHorizontalAlignment(widget) {\n        return Private$1.horizontalAlignmentProperty.get(widget);\n    }\n    Layout.getHorizontalAlignment = getHorizontalAlignment;\n    /**\n     * Set the horizontal alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the horizontal alignment.\n     *\n     * #### Notes\n     * If the layout width allocated to a widget is larger than its max\n     * width, the horizontal alignment controls how the widget is placed\n     * within the extra horizontal space.\n     *\n     * If the allocated width is less than the widget's max width, the\n     * horizontal alignment has no effect.\n     *\n     * Some layout implementations may ignore horizontal alignment.\n     *\n     * Changing the horizontal alignment will post an `update-request`\n     * message to widget's parent, provided the parent has a layout\n     * installed.\n     */\n    function setHorizontalAlignment(widget, value) {\n        Private$1.horizontalAlignmentProperty.set(widget, value);\n    }\n    Layout.setHorizontalAlignment = setHorizontalAlignment;\n    /**\n     * Get the vertical alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The vertical alignment for the widget.\n     *\n     * #### Notes\n     * If the layout height allocated to a widget is larger than its max\n     * height, the vertical alignment controls how the widget is placed\n     * within the extra vertical space.\n     *\n     * If the allocated height is less than the widget's max height, the\n     * vertical alignment has no effect.\n     *\n     * Some layout implementations may ignore vertical alignment.\n     */\n    function getVerticalAlignment(widget) {\n        return Private$1.verticalAlignmentProperty.get(widget);\n    }\n    Layout.getVerticalAlignment = getVerticalAlignment;\n    /**\n     * Set the vertical alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the vertical alignment.\n     *\n     * #### Notes\n     * If the layout height allocated to a widget is larger than its max\n     * height, the vertical alignment controls how the widget is placed\n     * within the extra vertical space.\n     *\n     * If the allocated height is less than the widget's max height, the\n     * vertical alignment has no effect.\n     *\n     * Some layout implementations may ignore vertical alignment.\n     *\n     * Changing the horizontal alignment will post an `update-request`\n     * message to widget's parent, provided the parent has a layout\n     * installed.\n     */\n    function setVerticalAlignment(widget, value) {\n        Private$1.verticalAlignmentProperty.set(widget, value);\n    }\n    Layout.setVerticalAlignment = setVerticalAlignment;\n})(Layout || (Layout = {}));\n/**\n * An object which assists in the absolute layout of widgets.\n *\n * #### Notes\n * This class is useful when implementing a layout which arranges its\n * widgets using absolute positioning.\n *\n * This class is used by nearly all of the built-in lumino layouts.\n */\nvar LayoutItem = /** @class */ (function () {\n    /**\n     * Construct a new layout item.\n     *\n     * @param widget - The widget to be managed by the item.\n     *\n     * #### Notes\n     * The widget will be set to absolute positioning.\n     */\n    function LayoutItem(widget) {\n        this._top = NaN;\n        this._left = NaN;\n        this._width = NaN;\n        this._height = NaN;\n        this._minWidth = 0;\n        this._minHeight = 0;\n        this._maxWidth = Infinity;\n        this._maxHeight = Infinity;\n        this._disposed = false;\n        this.widget = widget;\n        this.widget.node.style.position = 'absolute';\n    }\n    /**\n     * Dispose of the the layout item.\n     *\n     * #### Notes\n     * This will reset the positioning of the widget.\n     */\n    LayoutItem.prototype.dispose = function () {\n        // Do nothing if the item is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        // Mark the item as disposed.\n        this._disposed = true;\n        // Reset the widget style.\n        var style = this.widget.node.style;\n        style.position = '';\n        style.top = '';\n        style.left = '';\n        style.width = '';\n        style.height = '';\n    };\n    Object.defineProperty(LayoutItem.prototype, \"minWidth\", {\n        /**\n         * The computed minimum width of the widget.\n         *\n         * #### Notes\n         * This value can be updated by calling the `fit` method.\n         */\n        get: function () {\n            return this._minWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"minHeight\", {\n        /**\n         * The computed minimum height of the widget.\n         *\n         * #### Notes\n         * This value can be updated by calling the `fit` method.\n         */\n        get: function () {\n            return this._minHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"maxWidth\", {\n        /**\n         * The computed maximum width of the widget.\n         *\n         * #### Notes\n         * This value can be updated by calling the `fit` method.\n         */\n        get: function () {\n            return this._maxWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"maxHeight\", {\n        /**\n         * The computed maximum height of the widget.\n         *\n         * #### Notes\n         * This value can be updated by calling the `fit` method.\n         */\n        get: function () {\n            return this._maxHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"isDisposed\", {\n        /**\n         * Whether the layout item is disposed.\n         */\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"isHidden\", {\n        /**\n         * Whether the managed widget is hidden.\n         */\n        get: function () {\n            return this.widget.isHidden;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"isVisible\", {\n        /**\n         * Whether the managed widget is visible.\n         */\n        get: function () {\n            return this.widget.isVisible;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LayoutItem.prototype, \"isAttached\", {\n        /**\n         * Whether the managed widget is attached.\n         */\n        get: function () {\n            return this.widget.isAttached;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Update the computed size limits of the managed widget.\n     */\n    LayoutItem.prototype.fit = function () {\n        var limits = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.sizeLimits(this.widget.node);\n        this._minWidth = limits.minWidth;\n        this._minHeight = limits.minHeight;\n        this._maxWidth = limits.maxWidth;\n        this._maxHeight = limits.maxHeight;\n    };\n    /**\n     * Update the position and size of the managed widget.\n     *\n     * @param left - The left edge position of the layout box.\n     *\n     * @param top - The top edge position of the layout box.\n     *\n     * @param width - The width of the layout box.\n     *\n     * @param height - The height of the layout box.\n     */\n    LayoutItem.prototype.update = function (left, top, width, height) {\n        // Clamp the size to the computed size limits.\n        var clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));\n        var clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));\n        // Adjust the left edge for the horizontal alignment, if needed.\n        if (clampW < width) {\n            switch (Layout.getHorizontalAlignment(this.widget)) {\n                case 'left':\n                    break;\n                case 'center':\n                    left += (width - clampW) / 2;\n                    break;\n                case 'right':\n                    left += width - clampW;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Adjust the top edge for the vertical alignment, if needed.\n        if (clampH < height) {\n            switch (Layout.getVerticalAlignment(this.widget)) {\n                case 'top':\n                    break;\n                case 'center':\n                    top += (height - clampH) / 2;\n                    break;\n                case 'bottom':\n                    top += height - clampH;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Set up the resize variables.\n        var resized = false;\n        var style = this.widget.node.style;\n        // Update the top edge of the widget if needed.\n        if (this._top !== top) {\n            this._top = top;\n            style.top = top + \"px\";\n        }\n        // Update the left edge of the widget if needed.\n        if (this._left !== left) {\n            this._left = left;\n            style.left = left + \"px\";\n        }\n        // Update the width of the widget if needed.\n        if (this._width !== clampW) {\n            resized = true;\n            this._width = clampW;\n            style.width = clampW + \"px\";\n        }\n        // Update the height of the widget if needed.\n        if (this._height !== clampH) {\n            resized = true;\n            this._height = clampH;\n            style.height = clampH + \"px\";\n        }\n        // Send a resize message to the widget if needed.\n        if (resized) {\n            var msg = new Widget.ResizeMessage(clampW, clampH);\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.widget, msg);\n        }\n    };\n    return LayoutItem;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private$1;\n(function (Private) {\n    /**\n     * The attached property for a widget horizontal alignment.\n     */\n    Private.horizontalAlignmentProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'horizontalAlignment',\n        create: function () { return 'center'; },\n        changed: onAlignmentChanged\n    });\n    /**\n     * The attached property for a widget vertical alignment.\n     */\n    Private.verticalAlignmentProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'verticalAlignment',\n        create: function () { return 'top'; },\n        changed: onAlignmentChanged\n    });\n    /**\n     * The change handler for the attached alignment properties.\n     */\n    function onAlignmentChanged(child) {\n        if (child.parent && child.parent.layout) {\n            child.parent.update();\n        }\n    }\n})(Private$1 || (Private$1 = {}));\n\n/**\n * A concrete layout implementation suitable for many use cases.\n *\n * #### Notes\n * This class is suitable as a base class for implementing a variety of\n * layouts, but can also be used directly with standard CSS to layout a\n * collection of widgets.\n */\nvar PanelLayout = /** @class */ (function (_super) {\n    __extends(PanelLayout, _super);\n    function PanelLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._widgets = [];\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     *\n     * #### Notes\n     * This will clear and dispose all widgets in the layout.\n     *\n     * All reimplementations should call the superclass method.\n     *\n     * This method is called automatically when the parent is disposed.\n     */\n    PanelLayout.prototype.dispose = function () {\n        while (this._widgets.length > 0) {\n            this._widgets.pop().dispose();\n        }\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(PanelLayout.prototype, \"widgets\", {\n        /**\n         * A read-only array of the widgets in the layout.\n         */\n        get: function () {\n            return this._widgets;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over the widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     */\n    PanelLayout.prototype.iter = function () {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.iter)(this._widgets);\n    };\n    /**\n     * Add a widget to the end of the layout.\n     *\n     * @param widget - The widget to add to the layout.\n     *\n     * #### Notes\n     * If the widget is already contained in the layout, it will be moved.\n     */\n    PanelLayout.prototype.addWidget = function (widget) {\n        this.insertWidget(this._widgets.length, widget);\n    };\n    /**\n     * Insert a widget into the layout at the specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into the layout.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the widgets.\n     *\n     * If the widget is already added to the layout, it will be moved.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    PanelLayout.prototype.insertWidget = function (index, widget) {\n        // Remove the widget from its current parent. This is a no-op\n        // if the widget's parent is already the layout parent widget.\n        widget.parent = this.parent;\n        // Look up the current index of the widget.\n        var i = this._widgets.indexOf(widget);\n        // Clamp the insert index to the array bounds.\n        var j = Math.max(0, Math.min(index, this._widgets.length));\n        // If the widget is not in the array, insert it.\n        if (i === -1) {\n            // Insert the widget into the array.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._widgets, j, widget);\n            // If the layout is parented, attach the widget to the DOM.\n            if (this.parent) {\n                this.attachWidget(j, widget);\n            }\n            // There is nothing more to do.\n            return;\n        }\n        // Otherwise, the widget exists in the array and should be moved.\n        // Adjust the index if the location is at the end of the array.\n        if (j === this._widgets.length) {\n            j--;\n        }\n        // Bail if there is no effective move.\n        if (i === j) {\n            return;\n        }\n        // Move the widget to the new location.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._widgets, i, j);\n        // If the layout is parented, move the widget in the DOM.\n        if (this.parent) {\n            this.moveWidget(i, j, widget);\n        }\n    };\n    /**\n     * Remove a widget from the layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    PanelLayout.prototype.removeWidget = function (widget) {\n        this.removeWidgetAt(this._widgets.indexOf(widget));\n    };\n    /**\n     * Remove the widget at a given index from the layout.\n     *\n     * @param index - The index of the widget to remove.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    PanelLayout.prototype.removeWidgetAt = function (index) {\n        // Remove the widget from the array.\n        var widget = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._widgets, index);\n        // If the layout is parented, detach the widget from the DOM.\n        if (widget && this.parent) {\n            this.detachWidget(index, widget);\n        }\n    };\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    PanelLayout.prototype.init = function () {\n        var _this = this;\n        _super.prototype.init.call(this);\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget, index) {\n            _this.attachWidget(index, widget);\n        });\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation adds the widgets's node to the parent's\n     * node at the proper location, and sends the appropriate attach\n     * messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is added to the parent's node.\n     */\n    PanelLayout.prototype.attachWidget = function (index, widget) {\n        // Look up the next sibling reference node.\n        var ref = this.parent.node.children[index];\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Insert the widget's node before the sibling.\n        this.parent.node.insertBefore(widget.node, ref);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    };\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation moves the widget's node to the proper\n     * location in the parent's node and sends the appropriate attach and\n     * detach messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is moved in the parent's node.\n     */\n    PanelLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` and  message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Look up the next sibling reference node.\n        var ref = this.parent.node.children[toIndex];\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Insert the widget's node before the sibling.\n        this.parent.node.insertBefore(widget.node, ref);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation removes the widget's node from the\n     * parent's node, and sends the appropriate detach messages to the\n     * widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is removed from the parent's node.\n     */\n    PanelLayout.prototype.detachWidget = function (index, widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n    };\n    return PanelLayout;\n}(Layout));\n\nvar Utils;\n(function (Utils) {\n    /**\n     * Clamp a dimension value to an integer >= 0.\n     */\n    function clampDimension(value) {\n        return Math.max(0, Math.floor(value));\n    }\n    Utils.clampDimension = clampDimension;\n})(Utils || (Utils = {}));\nvar Utils$1 = Utils;\n\n/**\n * A layout which arranges its widgets into resizable sections.\n */\nvar SplitLayout = /** @class */ (function (_super) {\n    __extends(SplitLayout, _super);\n    /**\n     * Construct a new split layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    function SplitLayout(options) {\n        var _this = _super.call(this) || this;\n        _this.widgetOffset = 0;\n        _this._fixed = 0;\n        _this._spacing = 4;\n        _this._dirty = false;\n        _this._hasNormedSizes = false;\n        _this._sizers = [];\n        _this._items = [];\n        _this._handles = [];\n        _this._box = null;\n        _this._alignment = 'start';\n        _this._orientation = 'horizontal';\n        _this.renderer = options.renderer;\n        if (options.orientation !== undefined) {\n            _this._orientation = options.orientation;\n        }\n        if (options.alignment !== undefined) {\n            _this._alignment = options.alignment;\n        }\n        if (options.spacing !== undefined) {\n            _this._spacing = Utils.clampDimension(options.spacing);\n        }\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    SplitLayout.prototype.dispose = function () {\n        // Dispose of the layout items.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this._items, function (item) {\n            item.dispose();\n        });\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        this._sizers.length = 0;\n        this._handles.length = 0;\n        // Dispose of the rest of the layout.\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(SplitLayout.prototype, \"orientation\", {\n        /**\n         * Get the layout orientation for the split layout.\n         */\n        get: function () {\n            return this._orientation;\n        },\n        /**\n         * Set the layout orientation for the split layout.\n         */\n        set: function (value) {\n            if (this._orientation === value) {\n                return;\n            }\n            this._orientation = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.dataset['orientation'] = value;\n            this.parent.fit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitLayout.prototype, \"alignment\", {\n        /**\n         * Get the content alignment for the split layout.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand  to fill the\n         * entire split layout.\n         */\n        get: function () {\n            return this._alignment;\n        },\n        /**\n         * Set the content alignment for the split layout.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand  to fill the\n         * entire split layout.\n         */\n        set: function (value) {\n            if (this._alignment === value) {\n                return;\n            }\n            this._alignment = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.dataset['alignment'] = value;\n            this.parent.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitLayout.prototype, \"spacing\", {\n        /**\n         * Get the inter-element spacing for the split layout.\n         */\n        get: function () {\n            return this._spacing;\n        },\n        /**\n         * Set the inter-element spacing for the split layout.\n         */\n        set: function (value) {\n            value = Utils.clampDimension(value);\n            if (this._spacing === value) {\n                return;\n            }\n            this._spacing = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.fit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitLayout.prototype, \"handles\", {\n        /**\n         * A read-only array of the split handles in the layout.\n         */\n        get: function () {\n            return this._handles;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the relative sizes of the widgets in the layout.\n     *\n     * @returns A new array of the relative sizes of the widgets.\n     *\n     * #### Notes\n     * The returned sizes reflect the sizes of the widgets normalized\n     * relative to their siblings.\n     *\n     * This method **does not** measure the DOM nodes.\n     */\n    SplitLayout.prototype.relativeSizes = function () {\n        return Private$2.normalize(this._sizers.map(function (sizer) { return sizer.size; }));\n    };\n    /**\n     * Set the relative sizes for the widgets in the layout.\n     *\n     * @param sizes - The relative sizes for the widgets in the panel.\n     *\n     * #### Notes\n     * Extra values are ignored, too few will yield an undefined layout.\n     *\n     * The actual geometry of the DOM nodes is updated asynchronously.\n     */\n    SplitLayout.prototype.setRelativeSizes = function (sizes) {\n        // Copy the sizes and pad with zeros as needed.\n        var n = this._sizers.length;\n        var temp = sizes.slice(0, n);\n        while (temp.length < n) {\n            temp.push(0);\n        }\n        // Normalize the padded sizes.\n        var normed = Private$2.normalize(temp);\n        // Apply the normalized sizes to the sizers.\n        for (var i = 0; i < n; ++i) {\n            var sizer = this._sizers[i];\n            sizer.sizeHint = normed[i];\n            sizer.size = normed[i];\n        }\n        // Set the flag indicating the sizes are normalized.\n        this._hasNormedSizes = true;\n        // Trigger an update of the parent widget.\n        if (this.parent) {\n            this.parent.update();\n        }\n    };\n    /**\n     * Move the offset position of a split handle.\n     *\n     * @param index - The index of the handle of the interest.\n     *\n     * @param position - The desired offset position of the handle.\n     *\n     * #### Notes\n     * The position is relative to the offset parent.\n     *\n     * This will move the handle as close as possible to the desired\n     * position. The sibling widgets will be adjusted as necessary.\n     */\n    SplitLayout.prototype.moveHandle = function (index, position) {\n        // Bail if the index is invalid or the handle is hidden.\n        var handle = this._handles[index];\n        if (!handle || handle.classList.contains('lm-mod-hidden')) {\n            return;\n        }\n        // Compute the desired delta movement for the handle.\n        var delta;\n        if (this._orientation === 'horizontal') {\n            delta = position - handle.offsetLeft;\n        }\n        else {\n            delta = position - handle.offsetTop;\n        }\n        // Bail if there is no handle movement.\n        if (delta === 0) {\n            return;\n        }\n        // Prevent widget resizing unless needed.\n        for (var _i = 0, _a = this._sizers; _i < _a.length; _i++) {\n            var sizer = _a[_i];\n            if (sizer.size > 0) {\n                sizer.sizeHint = sizer.size;\n            }\n        }\n        // Adjust the sizers to reflect the handle movement.\n        BoxEngine.adjust(this._sizers, index, delta);\n        // Update the layout of the widgets.\n        if (this.parent) {\n            this.parent.update();\n        }\n    };\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    SplitLayout.prototype.init = function () {\n        this.parent.dataset['orientation'] = this.orientation;\n        this.parent.dataset['alignment'] = this.alignment;\n        _super.prototype.init.call(this);\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    SplitLayout.prototype.attachWidget = function (index, widget) {\n        // Create the item, handle, and sizer for the new widget.\n        var item = new LayoutItem(widget);\n        var handle = Private$2.createHandle(this.renderer);\n        var average = Private$2.averageSize(this._sizers);\n        var sizer = Private$2.createSizer(average);\n        // Insert the item, handle, and sizer into the internal arrays.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._items, index, item);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._sizers, index, sizer);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._handles, index, handle);\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget and handle nodes to the parent.\n        this.parent.node.appendChild(widget.node);\n        this.parent.node.appendChild(handle);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    SplitLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {\n        // Move the item, sizer, and handle for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._items, fromIndex, toIndex);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._sizers, fromIndex, toIndex);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._handles, fromIndex, toIndex);\n        // Post a fit request to the parent to show/hide last handle.\n        this.parent.fit();\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    SplitLayout.prototype.detachWidget = function (index, widget) {\n        // Remove the item, handle, and sizer for the widget.\n        var item = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._items, index);\n        var handle = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._handles, index);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._sizers, index);\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget and handle nodes from the parent.\n        this.parent.node.removeChild(widget.node);\n        this.parent.node.removeChild(handle);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Dispose of the layout item.\n        item.dispose();\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    SplitLayout.prototype.onBeforeShow = function (msg) {\n        _super.prototype.onBeforeShow.call(this, msg);\n        this.parent.update();\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    SplitLayout.prototype.onBeforeAttach = function (msg) {\n        _super.prototype.onBeforeAttach.call(this, msg);\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    SplitLayout.prototype.onChildShown = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    SplitLayout.prototype.onChildHidden = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    SplitLayout.prototype.onResize = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    SplitLayout.prototype.onUpdateRequest = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    SplitLayout.prototype.onFitRequest = function (msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    };\n    /**\n     * Update the item position.\n     *\n     * @param i Item index\n     * @param isHorizontal Whether the layout is horizontal or not\n     * @param left Left position in pixels\n     * @param top Top position in pixels\n     * @param height Item height\n     * @param width Item width\n     * @param size Item size\n     */\n    SplitLayout.prototype.updateItemPosition = function (i, isHorizontal, left, top, height, width, size) {\n        var item = this._items[i];\n        if (item.isHidden) {\n            return;\n        }\n        // Fetch the style for the handle.\n        var handleStyle = this._handles[i].style;\n        // Update the widget and handle, and advance the relevant edge.\n        if (isHorizontal) {\n            left += this.widgetOffset;\n            item.update(left, top, size, height);\n            left += size;\n            handleStyle.top = top + \"px\";\n            handleStyle.left = left + \"px\";\n            handleStyle.width = this._spacing + \"px\";\n            handleStyle.height = height + \"px\";\n        }\n        else {\n            top += this.widgetOffset;\n            item.update(left, top, width, size);\n            top += size;\n            handleStyle.top = top + \"px\";\n            handleStyle.left = left + \"px\";\n            handleStyle.width = width + \"px\";\n            handleStyle.height = this._spacing + \"px\";\n        }\n    };\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    SplitLayout.prototype._fit = function () {\n        // Update the handles and track the visible widget count.\n        var nVisible = 0;\n        var lastHandleIndex = -1;\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            if (this._items[i].isHidden) {\n                this._handles[i].classList.add('lm-mod-hidden');\n                /* <DEPRECATED> */\n                this._handles[i].classList.add('p-mod-hidden');\n                /* </DEPRECATED> */\n            }\n            else {\n                this._handles[i].classList.remove('lm-mod-hidden');\n                /* <DEPRECATED> */\n                this._handles[i].classList.remove('p-mod-hidden');\n                /* </DEPRECATED> */\n                lastHandleIndex = i;\n                nVisible++;\n            }\n        }\n        // Hide the handle for the last visible widget.\n        if (lastHandleIndex !== -1) {\n            this._handles[lastHandleIndex].classList.add('lm-mod-hidden');\n            /* <DEPRECATED> */\n            this._handles[lastHandleIndex].classList.add('p-mod-hidden');\n            /* </DEPRECATED> */\n        }\n        // Update the fixed space for the visible items.\n        this._fixed =\n            this._spacing * Math.max(0, nVisible - 1) +\n                this.widgetOffset * this._items.length;\n        // Setup the computed minimum size.\n        var horz = this._orientation === 'horizontal';\n        var minW = horz ? this._fixed : 0;\n        var minH = horz ? 0 : this._fixed;\n        // Update the sizers and computed size limits.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item and corresponding box sizer.\n            var item = this._items[i];\n            var sizer = this._sizers[i];\n            // Prevent resizing unless necessary.\n            if (sizer.size > 0) {\n                sizer.sizeHint = sizer.size;\n            }\n            // If the item is hidden, it should consume zero size.\n            if (item.isHidden) {\n                sizer.minSize = 0;\n                sizer.maxSize = 0;\n                continue;\n            }\n            // Update the size limits for the item.\n            item.fit();\n            // Update the stretch factor.\n            sizer.stretch = SplitLayout.getStretch(item.widget);\n            // Update the sizer limits and computed min size.\n            if (horz) {\n                sizer.minSize = item.minWidth;\n                sizer.maxSize = item.maxWidth;\n                minW += item.minWidth;\n                minH = Math.max(minH, item.minHeight);\n            }\n            else {\n                sizer.minSize = item.minHeight;\n                sizer.maxSize = item.maxHeight;\n                minH += item.minHeight;\n                minW = Math.max(minW, item.minWidth);\n            }\n        }\n        // Update the box sizing and add it to the computed min size.\n        var box = (this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node));\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        var style = this.parent.node.style;\n        style.minWidth = minW + \"px\";\n        style.minHeight = minH + \"px\";\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    };\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    SplitLayout.prototype._update = function (offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Compute the visible item count.\n        var nVisible = 0;\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Bail early if there are no visible items to layout.\n        if (nVisible === 0 && this.widgetOffset === 0) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the actual layout bounds adjusted for border and padding.\n        var top = this._box.paddingTop;\n        var left = this._box.paddingLeft;\n        var width = offsetWidth - this._box.horizontalSum;\n        var height = offsetHeight - this._box.verticalSum;\n        // Set up the variables for justification and alignment offset.\n        var extra = 0;\n        var offset = 0;\n        var horz = this._orientation === 'horizontal';\n        if (nVisible > 0) {\n            // Compute the adjusted layout space.\n            var space = void 0;\n            if (horz) {\n                // left += this.widgetOffset;\n                space = Math.max(0, width - this._fixed);\n            }\n            else {\n                // top += this.widgetOffset;\n                space = Math.max(0, height - this._fixed);\n            }\n            // Scale the size hints if they are normalized.\n            if (this._hasNormedSizes) {\n                for (var _i = 0, _a = this._sizers; _i < _a.length; _i++) {\n                    var sizer = _a[_i];\n                    sizer.sizeHint *= space;\n                }\n                this._hasNormedSizes = false;\n            }\n            // Distribute the layout space to the box sizers.\n            var delta = BoxEngine.calc(this._sizers, space);\n            // Account for alignment if there is extra layout space.\n            if (delta > 0) {\n                switch (this._alignment) {\n                    case 'start':\n                        break;\n                    case 'center':\n                        extra = 0;\n                        offset = delta / 2;\n                        break;\n                    case 'end':\n                        extra = 0;\n                        offset = delta;\n                        break;\n                    case 'justify':\n                        extra = delta / nVisible;\n                        offset = 0;\n                        break;\n                    default:\n                        throw 'unreachable';\n                }\n            }\n        }\n        // Layout the items using the computed box sizes.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = this._items[i];\n            // Fetch the computed size for the widget.\n            var size = item.isHidden ? 0 : this._sizers[i].size + extra;\n            this.updateItemPosition(i, horz, horz ? left + offset : left, horz ? top : top + offset, height, width, size);\n            var fullOffset = this.widgetOffset +\n                (this._handles[i].classList.contains('lm-mod-hidden')\n                    ? 0\n                    : this._spacing);\n            if (horz) {\n                left += size + fullOffset;\n            }\n            else {\n                top += size + fullOffset;\n            }\n        }\n    };\n    return SplitLayout;\n}(PanelLayout));\n/**\n * The namespace for the `SplitLayout` class statics.\n */\n(function (SplitLayout) {\n    /**\n     * Get the split layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The split layout stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return Private$2.stretchProperty.get(widget);\n    }\n    SplitLayout.getStretch = getStretch;\n    /**\n     * Set the split layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        Private$2.stretchProperty.set(widget, value);\n    }\n    SplitLayout.setStretch = setStretch;\n})(SplitLayout || (SplitLayout = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$2;\n(function (Private) {\n    /**\n     * The property descriptor for a widget stretch factor.\n     */\n    Private.stretchProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'stretch',\n        create: function () { return 0; },\n        coerce: function (owner, value) { return Math.max(0, Math.floor(value)); },\n        changed: onChildSizingChanged,\n    });\n    /**\n     * Create a new box sizer with the given size hint.\n     */\n    function createSizer(size) {\n        var sizer = new BoxSizer();\n        sizer.sizeHint = Math.floor(size);\n        return sizer;\n    }\n    Private.createSizer = createSizer;\n    /**\n     * Create a new split handle node using the given renderer.\n     */\n    function createHandle(renderer) {\n        var handle = renderer.createHandle();\n        handle.style.position = 'absolute';\n        return handle;\n    }\n    Private.createHandle = createHandle;\n    /**\n     * Compute the average size of an array of box sizers.\n     */\n    function averageSize(sizers) {\n        return sizers.reduce(function (v, s) { return v + s.size; }, 0) / sizers.length || 0;\n    }\n    Private.averageSize = averageSize;\n    /**\n     * Normalize an array of values.\n     */\n    function normalize(values) {\n        var n = values.length;\n        if (n === 0) {\n            return [];\n        }\n        var sum = values.reduce(function (a, b) { return a + Math.abs(b); }, 0);\n        return sum === 0 ? values.map(function (v) { return 1 / n; }) : values.map(function (v) { return v / sum; });\n    }\n    Private.normalize = normalize;\n    /**\n     * The change handler for the attached sizing properties.\n     */\n    function onChildSizingChanged(child) {\n        if (child.parent && child.parent.layout instanceof SplitLayout) {\n            child.parent.fit();\n        }\n    }\n})(Private$2 || (Private$2 = {}));\n\n/**\n * A layout which arranges its widgets into collapsible resizable sections.\n */\nvar AccordionLayout = /** @class */ (function (_super) {\n    __extends(AccordionLayout, _super);\n    /**\n     * Construct a new accordion layout.\n     *\n     * @param options - The options for initializing the layout.\n     *\n     * #### Notes\n     * The default orientation will be vertical.\n     *\n     * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css\n     */\n    function AccordionLayout(options) {\n        var _this = _super.call(this, __assign(__assign({}, options), { orientation: options.orientation || 'vertical' })) || this;\n        _this._titles = [];\n        _this.titleSpace = options.titleSpace || 22;\n        return _this;\n    }\n    Object.defineProperty(AccordionLayout.prototype, \"titleSpace\", {\n        /**\n         * The section title height or width depending on the orientation.\n         */\n        get: function () {\n            return this.widgetOffset;\n        },\n        set: function (value) {\n            value = Utils$1.clampDimension(value);\n            if (this.widgetOffset === value) {\n                return;\n            }\n            this.widgetOffset = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.fit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AccordionLayout.prototype, \"titles\", {\n        /**\n         * A read-only array of the section titles in the panel.\n         */\n        get: function () {\n            return this._titles;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    AccordionLayout.prototype.dispose = function () {\n        if (this.isDisposed) {\n            return;\n        }\n        // Clear the layout state.\n        this._titles.length = 0;\n        // Dispose of the rest of the layout.\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     */\n    AccordionLayout.prototype.attachWidget = function (index, widget) {\n        var title = Private$3.createTitle(this.renderer, widget.title);\n        title.style.position = 'absolute';\n        title.setAttribute('aria-label', widget.title.label + \" Section\");\n        title.setAttribute('aria-expanded', 'true');\n        title.setAttribute('aria-controls', widget.id);\n        title.classList.add('lm-mod-expanded');\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._titles, index, title);\n        // Add the title node to the parent before the widget.\n        this.parent.node.appendChild(title);\n        widget.node.setAttribute('role', 'region');\n        widget.node.setAttribute('aria-labelledby', title.id);\n        _super.prototype.attachWidget.call(this, index, widget);\n    };\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     */\n    AccordionLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._titles, fromIndex, toIndex);\n        _super.prototype.moveWidget.call(this, fromIndex, toIndex, widget);\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    AccordionLayout.prototype.detachWidget = function (index, widget) {\n        var title = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._titles, index);\n        this.parent.node.removeChild(title);\n        _super.prototype.detachWidget.call(this, index, widget);\n    };\n    /**\n     * Update the item position.\n     *\n     * @param i Item index\n     * @param isHorizontal Whether the layout is horizontal or not\n     * @param left Left position in pixels\n     * @param top Top position in pixels\n     * @param height Item height\n     * @param width Item width\n     * @param size Item size\n     */\n    AccordionLayout.prototype.updateItemPosition = function (i, isHorizontal, left, top, height, width, size) {\n        var titleStyle = this._titles[i].style;\n        // Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css\n        titleStyle.top = top + \"px\";\n        titleStyle.left = left + \"px\";\n        titleStyle.height = this.widgetOffset + \"px\";\n        if (isHorizontal) {\n            titleStyle.width = height + \"px\";\n        }\n        else {\n            titleStyle.width = width + \"px\";\n        }\n        _super.prototype.updateItemPosition.call(this, i, isHorizontal, left, top, height, width, size);\n    };\n    return AccordionLayout;\n}(SplitLayout));\nvar Private$3;\n(function (Private) {\n    /**\n     * Create the title HTML element.\n     *\n     * @param renderer Accordion renderer\n     * @param data Widget title\n     * @returns Title HTML element\n     */\n    function createTitle(renderer, data) {\n        return renderer.createSectionTitle(data);\n    }\n    Private.createTitle = createTitle;\n})(Private$3 || (Private$3 = {}));\n\n/**\n * A simple and convenient panel widget class.\n *\n * #### Notes\n * This class is suitable as a base class for implementing a variety of\n * convenience panel widgets, but can also be used directly with CSS to\n * arrange a collection of widgets.\n *\n * This class provides a convenience wrapper around a [[PanelLayout]].\n */\nvar Panel = /** @class */ (function (_super) {\n    __extends(Panel, _super);\n    /**\n     * Construct a new panel.\n     *\n     * @param options - The options for initializing the panel.\n     */\n    function Panel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.addClass('lm-Panel');\n        /* <DEPRECATED> */\n        _this.addClass('p-Panel');\n        /* </DEPRECATED> */\n        _this.layout = Private$4.createLayout(options);\n        return _this;\n    }\n    Object.defineProperty(Panel.prototype, \"widgets\", {\n        /**\n         * A read-only array of the widgets in the panel.\n         */\n        get: function () {\n            return this.layout.widgets;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Add a widget to the end of the panel.\n     *\n     * @param widget - The widget to add to the panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     */\n    Panel.prototype.addWidget = function (widget) {\n        this.layout.addWidget(widget);\n    };\n    /**\n     * Insert a widget at the specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into to the panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     */\n    Panel.prototype.insertWidget = function (index, widget) {\n        this.layout.insertWidget(index, widget);\n    };\n    return Panel;\n}(Widget));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$4;\n(function (Private) {\n    /**\n     * Create a panel layout for the given panel options.\n     */\n    function createLayout(options) {\n        return options.layout || new PanelLayout();\n    }\n    Private.createLayout = createLayout;\n})(Private$4 || (Private$4 = {}));\n\n/**\n * A panel which arranges its widgets into resizable sections.\n *\n * #### Notes\n * This class provides a convenience wrapper around a [[SplitLayout]].\n */\nvar SplitPanel = /** @class */ (function (_super) {\n    __extends(SplitPanel, _super);\n    /**\n     * Construct a new split panel.\n     *\n     * @param options - The options for initializing the split panel.\n     */\n    function SplitPanel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { layout: Private$5.createLayout(options) }) || this;\n        _this._pressData = null;\n        _this.addClass('lm-SplitPanel');\n        /* <DEPRECATED> */\n        _this.addClass('p-SplitPanel');\n        return _this;\n        /* </DEPRECATED> */\n    }\n    /**\n     * Dispose of the resources held by the panel.\n     */\n    SplitPanel.prototype.dispose = function () {\n        this._releaseMouse();\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(SplitPanel.prototype, \"orientation\", {\n        /**\n         * Get the layout orientation for the split panel.\n         */\n        get: function () {\n            return this.layout.orientation;\n        },\n        /**\n         * Set the layout orientation for the split panel.\n         */\n        set: function (value) {\n            this.layout.orientation = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitPanel.prototype, \"alignment\", {\n        /**\n         * Get the content alignment for the split panel.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand to fill the\n         * entire split panel.\n         */\n        get: function () {\n            return this.layout.alignment;\n        },\n        /**\n         * Set the content alignment for the split panel.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand to fill the\n         * entire split panel.\n         */\n        set: function (value) {\n            this.layout.alignment = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitPanel.prototype, \"spacing\", {\n        /**\n         * Get the inter-element spacing for the split panel.\n         */\n        get: function () {\n            return this.layout.spacing;\n        },\n        /**\n         * Set the inter-element spacing for the split panel.\n         */\n        set: function (value) {\n            this.layout.spacing = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitPanel.prototype, \"renderer\", {\n        /**\n         * The renderer used by the split panel.\n         */\n        get: function () {\n            return this.layout.renderer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SplitPanel.prototype, \"handles\", {\n        /**\n         * A read-only array of the split handles in the panel.\n         */\n        get: function () {\n            return this.layout.handles;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the relative sizes of the widgets in the panel.\n     *\n     * @returns A new array of the relative sizes of the widgets.\n     *\n     * #### Notes\n     * The returned sizes reflect the sizes of the widgets normalized\n     * relative to their siblings.\n     *\n     * This method **does not** measure the DOM nodes.\n     */\n    SplitPanel.prototype.relativeSizes = function () {\n        return this.layout.relativeSizes();\n    };\n    /**\n     * Set the relative sizes for the widgets in the panel.\n     *\n     * @param sizes - The relative sizes for the widgets in the panel.\n     *\n     * #### Notes\n     * Extra values are ignored, too few will yield an undefined layout.\n     *\n     * The actual geometry of the DOM nodes is updated asynchronously.\n     */\n    SplitPanel.prototype.setRelativeSizes = function (sizes) {\n        this.layout.setRelativeSizes(sizes);\n    };\n    /**\n     * Handle the DOM events for the split panel.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the panel's DOM node. It should\n     * not be called directly by user code.\n     */\n    SplitPanel.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    SplitPanel.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('mousedown', this);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    SplitPanel.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('mousedown', this);\n        this._releaseMouse();\n    };\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    SplitPanel.prototype.onChildAdded = function (msg) {\n        msg.child.addClass('lm-SplitPanel-child');\n        /* <DEPRECATED> */\n        msg.child.addClass('p-SplitPanel-child');\n        /* </DEPRECATED> */\n        this._releaseMouse();\n    };\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    SplitPanel.prototype.onChildRemoved = function (msg) {\n        msg.child.removeClass('lm-SplitPanel-child');\n        /* <DEPRECATED> */\n        msg.child.removeClass('p-SplitPanel-child');\n        /* </DEPRECATED> */\n        this._releaseMouse();\n    };\n    /**\n     * Handle the `'keydown'` event for the split panel.\n     */\n    SplitPanel.prototype._evtKeyDown = function (event) {\n        // Stop input events during drag.\n        if (this._pressData) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        // Release the mouse if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            this._releaseMouse();\n        }\n    };\n    /**\n     * Handle the `'mousedown'` event for the split panel.\n     */\n    SplitPanel.prototype._evtMouseDown = function (event) {\n        // Do nothing if the left mouse button is not pressed.\n        if (event.button !== 0) {\n            return;\n        }\n        // Find the handle which contains the mouse target, if any.\n        var layout = this.layout;\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(layout.handles, function (handle) {\n            return handle.contains(event.target);\n        });\n        // Bail early if the mouse press was not on a handle.\n        if (index === -1) {\n            return;\n        }\n        // Stop the event when a split handle is pressed.\n        event.preventDefault();\n        event.stopPropagation();\n        // Add the extra document listeners.\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Compute the offset delta for the handle press.\n        var delta;\n        var handle = layout.handles[index];\n        var rect = handle.getBoundingClientRect();\n        if (layout.orientation === 'horizontal') {\n            delta = event.clientX - rect.left;\n        }\n        else {\n            delta = event.clientY - rect.top;\n        }\n        // Override the cursor and store the press data.\n        var style = window.getComputedStyle(handle);\n        var override = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__.Drag.overrideCursor(style.cursor);\n        this._pressData = { index: index, delta: delta, override: override };\n    };\n    /**\n     * Handle the `'mousemove'` event for the split panel.\n     */\n    SplitPanel.prototype._evtMouseMove = function (event) {\n        // Stop the event when dragging a split handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Compute the desired offset position for the handle.\n        var pos;\n        var layout = this.layout;\n        var rect = this.node.getBoundingClientRect();\n        if (layout.orientation === 'horizontal') {\n            pos = event.clientX - rect.left - this._pressData.delta;\n        }\n        else {\n            pos = event.clientY - rect.top - this._pressData.delta;\n        }\n        // Move the handle as close to the desired position as possible.\n        layout.moveHandle(this._pressData.index, pos);\n    };\n    /**\n     * Handle the `'mouseup'` event for the split panel.\n     */\n    SplitPanel.prototype._evtMouseUp = function (event) {\n        // Do nothing if the left mouse button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event when releasing a handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Finalize the mouse release.\n        this._releaseMouse();\n    };\n    /**\n     * Release the mouse grab for the split panel.\n     */\n    SplitPanel.prototype._releaseMouse = function () {\n        // Bail early if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the override cursor.\n        this._pressData.override.dispose();\n        this._pressData = null;\n        // Remove the extra document listeners.\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    };\n    return SplitPanel;\n}(Panel));\n/**\n * The namespace for the `SplitPanel` class statics.\n */\n(function (SplitPanel) {\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    var Renderer = /** @class */ (function () {\n        function Renderer() {\n        }\n        /**\n         * Create a new handle for use with a split panel.\n         *\n         * @returns A new handle element for a split panel.\n         */\n        Renderer.prototype.createHandle = function () {\n            var handle = document.createElement('div');\n            handle.className = 'lm-SplitPanel-handle';\n            /* <DEPRECATED> */\n            handle.classList.add('p-SplitPanel-handle');\n            /* </DEPRECATED> */\n            return handle;\n        };\n        return Renderer;\n    }());\n    SplitPanel.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    SplitPanel.defaultRenderer = new Renderer();\n    /**\n     * Get the split panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The split panel stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return SplitLayout.getStretch(widget);\n    }\n    SplitPanel.getStretch = getStretch;\n    /**\n     * Set the split panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        SplitLayout.setStretch(widget, value);\n    }\n    SplitPanel.setStretch = setStretch;\n})(SplitPanel || (SplitPanel = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$5;\n(function (Private) {\n    /**\n     * Create a split layout for the given panel options.\n     */\n    function createLayout(options) {\n        return (options.layout ||\n            new SplitLayout({\n                renderer: options.renderer || SplitPanel.defaultRenderer,\n                orientation: options.orientation,\n                alignment: options.alignment,\n                spacing: options.spacing,\n            }));\n    }\n    Private.createLayout = createLayout;\n})(Private$5 || (Private$5 = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A panel which arranges its widgets into resizable sections separated by a title widget.\n *\n * #### Notes\n * This class provides a convenience wrapper around [[AccordionLayout]].\n */\nvar AccordionPanel = /** @class */ (function (_super) {\n    __extends(AccordionPanel, _super);\n    /**\n     * Construct a new accordion panel.\n     *\n     * @param options - The options for initializing the accordion panel.\n     */\n    function AccordionPanel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, __assign(__assign({}, options), { layout: Private$6.createLayout(options) })) || this;\n        _this.addClass('lm-AccordionPanel');\n        return _this;\n    }\n    Object.defineProperty(AccordionPanel.prototype, \"renderer\", {\n        /**\n         * The renderer used by the accordion panel.\n         */\n        get: function () {\n            return this.layout.renderer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AccordionPanel.prototype, \"titleSpace\", {\n        /**\n         * The section title space.\n         *\n         * This is the height if the panel is vertical and the width if it is\n         * horizontal.\n         */\n        get: function () {\n            return this.layout.titleSpace;\n        },\n        set: function (value) {\n            this.layout.titleSpace = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AccordionPanel.prototype, \"titles\", {\n        /**\n         * A read-only array of the section titles in the panel.\n         */\n        get: function () {\n            return this.layout.titles;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Handle the DOM events for the accordion panel.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the panel's DOM node. It should\n     * not be called directly by user code.\n     */\n    AccordionPanel.prototype.handleEvent = function (event) {\n        _super.prototype.handleEvent.call(this, event);\n        switch (event.type) {\n            case 'click':\n                this._evtClick(event);\n                break;\n            case 'keydown':\n                this._eventKeyDown(event);\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    AccordionPanel.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('click', this);\n        this.node.addEventListener('keydown', this);\n        _super.prototype.onBeforeAttach.call(this, msg);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    AccordionPanel.prototype.onAfterDetach = function (msg) {\n        _super.prototype.onAfterDetach.call(this, msg);\n        this.node.removeEventListener('click', this);\n        this.node.removeEventListener('keydown', this);\n    };\n    /**\n     * Handle the `'click'` event for the accordion panel\n     */\n    AccordionPanel.prototype._evtClick = function (event) {\n        var target = event.target;\n        if (target) {\n            var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this.titles, function (title) {\n                return title.contains(target);\n            });\n            if (index >= 0) {\n                event.preventDefault();\n                event.stopPropagation();\n                var widget = this.layout.widgets[index];\n                if (widget.isHidden) {\n                    target.classList.add('lm-mod-expanded');\n                    target.setAttribute('aria-expanded', 'true');\n                    widget.show();\n                }\n                else {\n                    target.classList.remove('lm-mod-expanded');\n                    target.setAttribute('aria-expanded', 'false');\n                    widget.hide();\n                }\n            }\n        }\n    };\n    /**\n     * Handle the `'keydown'` event for the accordion panel.\n     */\n    AccordionPanel.prototype._eventKeyDown = function (event) {\n        if (event.defaultPrevented) {\n            return;\n        }\n        var target = event.target;\n        var handled = false;\n        if (target) {\n            var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this.titles, function (title) {\n                return title.contains(target);\n            });\n            if (index >= 0) {\n                var keyCode = event.keyCode.toString();\n                // If Space or Enter is pressed on title, emulate click event\n                if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {\n                    target.click();\n                    handled = true;\n                }\n                else if (this.orientation === 'horizontal'\n                    ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/)\n                    : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {\n                    // If Up or Down (for vertical) / Left or Right (for horizontal) is pressed on title, loop on titles\n                    var direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/)\n                        ? -1\n                        : 1;\n                    var length_1 = this.titles.length;\n                    var newIndex = (index + length_1 + direction) % length_1;\n                    this.titles[newIndex].focus();\n                    handled = true;\n                }\n                else if (event.key === 'End' || keyCode === '35') {\n                    // If End is pressed on title, focus on the last title\n                    this.titles[this.titles.length - 1].focus();\n                    handled = true;\n                }\n                else if (event.key === 'Home' || keyCode === '36') {\n                    // If Home is pressed on title, focus on the first title\n                    this.titles[0].focus();\n                    handled = true;\n                }\n            }\n            if (handled) {\n                event.preventDefault();\n            }\n        }\n    };\n    return AccordionPanel;\n}(SplitPanel));\n/**\n * The namespace for the `AccordionPanel` class statics.\n */\n(function (AccordionPanel) {\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    var Renderer = /** @class */ (function (_super) {\n        __extends(Renderer, _super);\n        function Renderer() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            /**\n             * A selector which matches any title node in the accordion.\n             */\n            _this.titleClassName = 'lm-AccordionPanel-title';\n            _this._titleID = 0;\n            _this._titleKeys = new WeakMap();\n            return _this;\n        }\n        /**\n         * Render the collapse indicator for a section title.\n         *\n         * @param data - The data to use for rendering the section title.\n         *\n         * @returns A element representing the collapse indicator.\n         */\n        Renderer.prototype.createCollapseIcon = function (data) {\n            return document.createElement('span');\n        };\n        /**\n         * Render the element for a section title.\n         *\n         * @param data - The data to use for rendering the section title.\n         *\n         * @returns A element representing the section title.\n         */\n        Renderer.prototype.createSectionTitle = function (data) {\n            var handle = document.createElement('h3');\n            handle.setAttribute('role', 'button');\n            handle.setAttribute('tabindex', '0');\n            handle.id = this.createTitleKey(data);\n            handle.className = this.titleClassName;\n            handle.title = data.caption;\n            for (var aData in data.dataset) {\n                handle.dataset[aData] = data.dataset[aData];\n            }\n            var collapser = handle.appendChild(this.createCollapseIcon(data));\n            collapser.className = 'lm-AccordionPanel-titleCollapser';\n            var label = handle.appendChild(document.createElement('span'));\n            label.className = 'lm-AccordionPanel-titleLabel';\n            label.textContent = data.label;\n            return handle;\n        };\n        /**\n         * Create a unique render key for the title.\n         *\n         * @param data - The data to use for the title.\n         *\n         * @returns The unique render key for the title.\n         *\n         * #### Notes\n         * This method caches the key against the section title the first time\n         * the key is generated.\n         */\n        Renderer.prototype.createTitleKey = function (data) {\n            var key = this._titleKeys.get(data);\n            if (key === undefined) {\n                key = \"title-key-\" + this._titleID++;\n                this._titleKeys.set(data, key);\n            }\n            return key;\n        };\n        return Renderer;\n    }(SplitPanel.Renderer));\n    AccordionPanel.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    AccordionPanel.defaultRenderer = new Renderer();\n})(AccordionPanel || (AccordionPanel = {}));\nvar Private$6;\n(function (Private) {\n    /**\n     * Create an accordion layout for the given panel options.\n     *\n     * @param options Panel options\n     * @returns Panel layout\n     */\n    function createLayout(options) {\n        return (options.layout ||\n            new AccordionLayout({\n                renderer: options.renderer || AccordionPanel.defaultRenderer,\n                orientation: options.orientation,\n                alignment: options.alignment,\n                spacing: options.spacing,\n                titleSpace: options.titleSpace,\n            }));\n    }\n    Private.createLayout = createLayout;\n})(Private$6 || (Private$6 = {}));\n\n/**\n * A layout which arranges its widgets in a single row or column.\n */\nvar BoxLayout = /** @class */ (function (_super) {\n    __extends(BoxLayout, _super);\n    /**\n     * Construct a new box layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    function BoxLayout(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this._fixed = 0;\n        _this._spacing = 4;\n        _this._dirty = false;\n        _this._sizers = [];\n        _this._items = [];\n        _this._box = null;\n        _this._alignment = 'start';\n        _this._direction = 'top-to-bottom';\n        if (options.direction !== undefined) {\n            _this._direction = options.direction;\n        }\n        if (options.alignment !== undefined) {\n            _this._alignment = options.alignment;\n        }\n        if (options.spacing !== undefined) {\n            _this._spacing = Utils$1.clampDimension(options.spacing);\n        }\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    BoxLayout.prototype.dispose = function () {\n        // Dispose of the layout items.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this._items, function (item) { item.dispose(); });\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        this._sizers.length = 0;\n        // Dispose of the rest of the layout.\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(BoxLayout.prototype, \"direction\", {\n        /**\n         * Get the layout direction for the box layout.\n         */\n        get: function () {\n            return this._direction;\n        },\n        /**\n         * Set the layout direction for the box layout.\n         */\n        set: function (value) {\n            if (this._direction === value) {\n                return;\n            }\n            this._direction = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.dataset['direction'] = value;\n            this.parent.fit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoxLayout.prototype, \"alignment\", {\n        /**\n         * Get the content alignment for the box layout.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand to fill the\n         * entire box layout.\n         */\n        get: function () {\n            return this._alignment;\n        },\n        /**\n         * Set the content alignment for the box layout.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand to fill the\n         * entire box layout.\n         */\n        set: function (value) {\n            if (this._alignment === value) {\n                return;\n            }\n            this._alignment = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.dataset['alignment'] = value;\n            this.parent.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoxLayout.prototype, \"spacing\", {\n        /**\n         * Get the inter-element spacing for the box layout.\n         */\n        get: function () {\n            return this._spacing;\n        },\n        /**\n         * Set the inter-element spacing for the box layout.\n         */\n        set: function (value) {\n            value = Utils$1.clampDimension(value);\n            if (this._spacing === value) {\n                return;\n            }\n            this._spacing = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.fit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    BoxLayout.prototype.init = function () {\n        this.parent.dataset['direction'] = this.direction;\n        this.parent.dataset['alignment'] = this.alignment;\n        _super.prototype.init.call(this);\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    BoxLayout.prototype.attachWidget = function (index, widget) {\n        // Create and add a new layout item for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._items, index, new LayoutItem(widget));\n        // Create and add a new sizer for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._sizers, index, new BoxSizer());\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    BoxLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {\n        // Move the layout item for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._items, fromIndex, toIndex);\n        // Move the sizer for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._sizers, fromIndex, toIndex);\n        // Post an update request for the parent widget.\n        this.parent.update();\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    BoxLayout.prototype.detachWidget = function (index, widget) {\n        // Remove the layout item for the widget.\n        var item = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._items, index);\n        // Remove the sizer for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._sizers, index);\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Dispose of the layout item.\n        item.dispose();\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    BoxLayout.prototype.onBeforeShow = function (msg) {\n        _super.prototype.onBeforeShow.call(this, msg);\n        this.parent.update();\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    BoxLayout.prototype.onBeforeAttach = function (msg) {\n        _super.prototype.onBeforeAttach.call(this, msg);\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    BoxLayout.prototype.onChildShown = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    BoxLayout.prototype.onChildHidden = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    BoxLayout.prototype.onResize = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    BoxLayout.prototype.onUpdateRequest = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    BoxLayout.prototype.onFitRequest = function (msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    };\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    BoxLayout.prototype._fit = function () {\n        // Compute the visible item count.\n        var nVisible = 0;\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Update the fixed space for the visible items.\n        this._fixed = this._spacing * Math.max(0, nVisible - 1);\n        // Setup the computed minimum size.\n        var horz = Private$7.isHorizontal(this._direction);\n        var minW = horz ? this._fixed : 0;\n        var minH = horz ? 0 : this._fixed;\n        // Update the sizers and computed minimum size.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item and corresponding box sizer.\n            var item = this._items[i];\n            var sizer = this._sizers[i];\n            // If the item is hidden, it should consume zero size.\n            if (item.isHidden) {\n                sizer.minSize = 0;\n                sizer.maxSize = 0;\n                continue;\n            }\n            // Update the size limits for the item.\n            item.fit();\n            // Update the size basis and stretch factor.\n            sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);\n            sizer.stretch = BoxLayout.getStretch(item.widget);\n            // Update the sizer limits and computed min size.\n            if (horz) {\n                sizer.minSize = item.minWidth;\n                sizer.maxSize = item.maxWidth;\n                minW += item.minWidth;\n                minH = Math.max(minH, item.minHeight);\n            }\n            else {\n                sizer.minSize = item.minHeight;\n                sizer.maxSize = item.maxHeight;\n                minH += item.minHeight;\n                minW = Math.max(minW, item.minWidth);\n            }\n        }\n        // Update the box sizing and add it to the computed min size.\n        var box = this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        var style = this.parent.node.style;\n        style.minWidth = minW + \"px\";\n        style.minHeight = minH + \"px\";\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    };\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    BoxLayout.prototype._update = function (offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Compute the visible item count.\n        var nVisible = 0;\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Bail early if there are no visible items to layout.\n        if (nVisible === 0) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the layout area adjusted for border and padding.\n        var top = this._box.paddingTop;\n        var left = this._box.paddingLeft;\n        var width = offsetWidth - this._box.horizontalSum;\n        var height = offsetHeight - this._box.verticalSum;\n        // Distribute the layout space and adjust the start position.\n        var delta;\n        switch (this._direction) {\n            case 'left-to-right':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));\n                break;\n            case 'top-to-bottom':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));\n                break;\n            case 'right-to-left':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));\n                left += width;\n                break;\n            case 'bottom-to-top':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));\n                top += height;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Setup the variables for justification and alignment offset.\n        var extra = 0;\n        var offset = 0;\n        // Account for alignment if there is extra layout space.\n        if (delta > 0) {\n            switch (this._alignment) {\n                case 'start':\n                    break;\n                case 'center':\n                    extra = 0;\n                    offset = delta / 2;\n                    break;\n                case 'end':\n                    extra = 0;\n                    offset = delta;\n                    break;\n                case 'justify':\n                    extra = delta / nVisible;\n                    offset = 0;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Layout the items using the computed box sizes.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Fetch the computed size for the widget.\n            var size = this._sizers[i].size;\n            // Update the widget geometry and advance the relevant edge.\n            switch (this._direction) {\n                case 'left-to-right':\n                    item.update(left + offset, top, size + extra, height);\n                    left += size + extra + this._spacing;\n                    break;\n                case 'top-to-bottom':\n                    item.update(left, top + offset, width, size + extra);\n                    top += size + extra + this._spacing;\n                    break;\n                case 'right-to-left':\n                    item.update(left - offset - size - extra, top, size + extra, height);\n                    left -= size + extra + this._spacing;\n                    break;\n                case 'bottom-to-top':\n                    item.update(left, top - offset - size - extra, width, size + extra);\n                    top -= size + extra + this._spacing;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n    };\n    return BoxLayout;\n}(PanelLayout));\n/**\n * The namespace for the `BoxLayout` class statics.\n */\n(function (BoxLayout) {\n    /**\n     * Get the box layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box layout stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return Private$7.stretchProperty.get(widget);\n    }\n    BoxLayout.getStretch = getStretch;\n    /**\n     * Set the box layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        Private$7.stretchProperty.set(widget, value);\n    }\n    BoxLayout.setStretch = setStretch;\n    /**\n     * Get the box layout size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box layout size basis for the widget.\n     */\n    function getSizeBasis(widget) {\n        return Private$7.sizeBasisProperty.get(widget);\n    }\n    BoxLayout.getSizeBasis = getSizeBasis;\n    /**\n     * Set the box layout size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the size basis.\n     */\n    function setSizeBasis(widget, value) {\n        Private$7.sizeBasisProperty.set(widget, value);\n    }\n    BoxLayout.setSizeBasis = setSizeBasis;\n})(BoxLayout || (BoxLayout = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$7;\n(function (Private) {\n    /**\n     * The property descriptor for a widget stretch factor.\n     */\n    Private.stretchProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'stretch',\n        create: function () { return 0; },\n        coerce: function (owner, value) { return Math.max(0, Math.floor(value)); },\n        changed: onChildSizingChanged\n    });\n    /**\n     * The property descriptor for a widget size basis.\n     */\n    Private.sizeBasisProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'sizeBasis',\n        create: function () { return 0; },\n        coerce: function (owner, value) { return Math.max(0, Math.floor(value)); },\n        changed: onChildSizingChanged\n    });\n    /**\n     * Test whether a direction has horizontal orientation.\n     */\n    function isHorizontal(dir) {\n        return dir === 'left-to-right' || dir === 'right-to-left';\n    }\n    Private.isHorizontal = isHorizontal;\n    /**\n     * Clamp a spacing value to an integer >= 0.\n     */\n    function clampSpacing(value) {\n        return Math.max(0, Math.floor(value));\n    }\n    Private.clampSpacing = clampSpacing;\n    /**\n     * The change handler for the attached sizing properties.\n     */\n    function onChildSizingChanged(child) {\n        if (child.parent && child.parent.layout instanceof BoxLayout) {\n            child.parent.fit();\n        }\n    }\n})(Private$7 || (Private$7 = {}));\n\n/**\n * A panel which arranges its widgets in a single row or column.\n *\n * #### Notes\n * This class provides a convenience wrapper around a [[BoxLayout]].\n */\nvar BoxPanel = /** @class */ (function (_super) {\n    __extends(BoxPanel, _super);\n    /**\n     * Construct a new box panel.\n     *\n     * @param options - The options for initializing the box panel.\n     */\n    function BoxPanel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { layout: Private$8.createLayout(options) }) || this;\n        _this.addClass('lm-BoxPanel');\n        /* <DEPRECATED> */\n        _this.addClass('p-BoxPanel');\n        return _this;\n        /* </DEPRECATED> */\n    }\n    Object.defineProperty(BoxPanel.prototype, \"direction\", {\n        /**\n         * Get the layout direction for the box panel.\n         */\n        get: function () {\n            return this.layout.direction;\n        },\n        /**\n         * Set the layout direction for the box panel.\n         */\n        set: function (value) {\n            this.layout.direction = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoxPanel.prototype, \"alignment\", {\n        /**\n         * Get the content alignment for the box panel.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand to fill the\n         * entire box layout.\n         */\n        get: function () {\n            return this.layout.alignment;\n        },\n        /**\n         * Set the content alignment for the box panel.\n         *\n         * #### Notes\n         * This is the alignment of the widgets in the layout direction.\n         *\n         * The alignment has no effect if the widgets can expand to fill the\n         * entire box layout.\n         */\n        set: function (value) {\n            this.layout.alignment = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoxPanel.prototype, \"spacing\", {\n        /**\n         * Get the inter-element spacing for the box panel.\n         */\n        get: function () {\n            return this.layout.spacing;\n        },\n        /**\n         * Set the inter-element spacing for the box panel.\n         */\n        set: function (value) {\n            this.layout.spacing = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    BoxPanel.prototype.onChildAdded = function (msg) {\n        msg.child.addClass('lm-BoxPanel-child');\n        /* <DEPRECATED> */\n        msg.child.addClass('p-BoxPanel-child');\n        /* </DEPRECATED> */\n    };\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    BoxPanel.prototype.onChildRemoved = function (msg) {\n        msg.child.removeClass('lm-BoxPanel-child');\n        /* <DEPRECATED> */\n        msg.child.removeClass('p-BoxPanel-child');\n        /* </DEPRECATED> */\n    };\n    return BoxPanel;\n}(Panel));\n/**\n * The namespace for the `BoxPanel` class statics.\n */\n(function (BoxPanel) {\n    /**\n     * Get the box panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box panel stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return BoxLayout.getStretch(widget);\n    }\n    BoxPanel.getStretch = getStretch;\n    /**\n     * Set the box panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        BoxLayout.setStretch(widget, value);\n    }\n    BoxPanel.setStretch = setStretch;\n    /**\n     * Get the box panel size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box panel size basis for the widget.\n     */\n    function getSizeBasis(widget) {\n        return BoxLayout.getSizeBasis(widget);\n    }\n    BoxPanel.getSizeBasis = getSizeBasis;\n    /**\n     * Set the box panel size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the size basis.\n     */\n    function setSizeBasis(widget, value) {\n        BoxLayout.setSizeBasis(widget, value);\n    }\n    BoxPanel.setSizeBasis = setSizeBasis;\n})(BoxPanel || (BoxPanel = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$8;\n(function (Private) {\n    /**\n     * Create a box layout for the given panel options.\n     */\n    function createLayout(options) {\n        return options.layout || new BoxLayout(options);\n    }\n    Private.createLayout = createLayout;\n})(Private$8 || (Private$8 = {}));\n\n/**\n * A widget which displays command items as a searchable palette.\n */\nvar CommandPalette = /** @class */ (function (_super) {\n    __extends(CommandPalette, _super);\n    /**\n     * Construct a new command palette.\n     *\n     * @param options - The options for initializing the palette.\n     */\n    function CommandPalette(options) {\n        var _this = _super.call(this, { node: Private$9.createNode() }) || this;\n        _this._activeIndex = -1;\n        _this._items = [];\n        _this._results = null;\n        _this.addClass('lm-CommandPalette');\n        /* <DEPRECATED> */\n        _this.addClass('p-CommandPalette');\n        /* </DEPRECATED> */\n        _this.setFlag(Widget.Flag.DisallowLayout);\n        _this.commands = options.commands;\n        _this.renderer = options.renderer || CommandPalette.defaultRenderer;\n        _this.commands.commandChanged.connect(_this._onGenericChange, _this);\n        _this.commands.keyBindingChanged.connect(_this._onGenericChange, _this);\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    CommandPalette.prototype.dispose = function () {\n        this._items.length = 0;\n        this._results = null;\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(CommandPalette.prototype, \"searchNode\", {\n        /**\n         * The command palette search node.\n         *\n         * #### Notes\n         * This is the node which contains the search-related elements.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-CommandPalette-search')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandPalette.prototype, \"inputNode\", {\n        /**\n         * The command palette input node.\n         *\n         * #### Notes\n         * This is the actual input node for the search area.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-CommandPalette-input')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandPalette.prototype, \"contentNode\", {\n        /**\n         * The command palette content node.\n         *\n         * #### Notes\n         * This is the node which holds the command item nodes.\n         *\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-CommandPalette-content')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandPalette.prototype, \"items\", {\n        /**\n         * A read-only array of the command items in the palette.\n         */\n        get: function () {\n            return this._items;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Add a command item to the command palette.\n     *\n     * @param options - The options for creating the command item.\n     *\n     * @returns The command item added to the palette.\n     */\n    CommandPalette.prototype.addItem = function (options) {\n        // Create a new command item for the options.\n        var item = Private$9.createItem(this.commands, options);\n        // Add the item to the array.\n        this._items.push(item);\n        // Refresh the search results.\n        this.refresh();\n        // Return the item added to the palette.\n        return item;\n    };\n    /**\n     * Adds command items to the command palette.\n     *\n     * @param items - An array of options for creating each command item.\n     *\n     * @returns The command items added to the palette.\n     */\n    CommandPalette.prototype.addItems = function (items) {\n        var _this = this;\n        var newItems = items.map(function (item) { return Private$9.createItem(_this.commands, item); });\n        newItems.forEach(function (item) { return _this._items.push(item); });\n        this.refresh();\n        return newItems;\n    };\n    /**\n     * Remove an item from the command palette.\n     *\n     * @param item - The item to remove from the palette.\n     *\n     * #### Notes\n     * This is a no-op if the item is not in the palette.\n     */\n    CommandPalette.prototype.removeItem = function (item) {\n        this.removeItemAt(this._items.indexOf(item));\n    };\n    /**\n     * Remove the item at a given index from the command palette.\n     *\n     * @param index - The index of the item to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    CommandPalette.prototype.removeItemAt = function (index) {\n        // Remove the item from the array.\n        var item = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._items, index);\n        // Bail if the index is out of range.\n        if (!item) {\n            return;\n        }\n        // Refresh the search results.\n        this.refresh();\n    };\n    /**\n     * Remove all items from the command palette.\n     */\n    CommandPalette.prototype.clearItems = function () {\n        // Bail if there is nothing to remove.\n        if (this._items.length === 0) {\n            return;\n        }\n        // Clear the array of items.\n        this._items.length = 0;\n        // Refresh the search results.\n        this.refresh();\n    };\n    /**\n     * Clear the search results and schedule an update.\n     *\n     * #### Notes\n     * This should be called whenever the search results of the palette\n     * should be updated.\n     *\n     * This is typically called automatically by the palette as needed,\n     * but can be called manually if the input text is programatically\n     * changed.\n     *\n     * The rendered results are updated asynchronously.\n     */\n    CommandPalette.prototype.refresh = function () {\n        this._results = null;\n        if (this.inputNode.value !== '') {\n            var clear = this.node.getElementsByClassName('lm-close-icon')[0];\n            clear.style.display = 'inherit';\n        }\n        else {\n            var clear = this.node.getElementsByClassName('lm-close-icon')[0];\n            clear.style.display = 'none';\n        }\n        this.update();\n    };\n    /**\n     * Handle the DOM events for the command palette.\n     *\n     * @param event - The DOM event sent to the command palette.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the command palette's DOM node.\n     * It should not be called directly by user code.\n     */\n    CommandPalette.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'click':\n                this._evtClick(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'input':\n                this.refresh();\n                break;\n            case 'focus':\n            case 'blur':\n                this._toggleFocused();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    CommandPalette.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('click', this);\n        this.node.addEventListener('keydown', this);\n        this.node.addEventListener('input', this);\n        this.node.addEventListener('focus', this, true);\n        this.node.addEventListener('blur', this, true);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    CommandPalette.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('click', this);\n        this.node.removeEventListener('keydown', this);\n        this.node.removeEventListener('input', this);\n        this.node.removeEventListener('focus', this, true);\n        this.node.removeEventListener('blur', this, true);\n    };\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    CommandPalette.prototype.onActivateRequest = function (msg) {\n        if (this.isAttached) {\n            var input = this.inputNode;\n            input.focus();\n            input.select();\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    CommandPalette.prototype.onUpdateRequest = function (msg) {\n        // Fetch the current query text and content node.\n        var query = this.inputNode.value;\n        var contentNode = this.contentNode;\n        // Ensure the search results are generated.\n        var results = this._results;\n        if (!results) {\n            // Generate and store the new search results.\n            results = this._results = Private$9.search(this._items, query);\n            // Reset the active index.\n            this._activeIndex = (query ? _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(results, Private$9.canActivate) : -1);\n        }\n        // If there is no query and no results, clear the content.\n        if (!query && results.length === 0) {\n            _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.render(null, contentNode);\n            return;\n        }\n        // If the is a query but no results, render the empty message.\n        if (query && results.length === 0) {\n            var content_1 = this.renderer.renderEmptyMessage({ query: query });\n            _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.render(content_1, contentNode);\n            return;\n        }\n        // Create the render content for the search results.\n        var renderer = this.renderer;\n        var activeIndex = this._activeIndex;\n        var content = new Array(results.length);\n        for (var i = 0, n = results.length; i < n; ++i) {\n            var result = results[i];\n            if (result.type === 'header') {\n                var indices = result.indices;\n                var category = result.category;\n                content[i] = renderer.renderHeader({ category: category, indices: indices });\n            }\n            else {\n                var item = result.item;\n                var indices = result.indices;\n                var active = i === activeIndex;\n                content[i] = renderer.renderItem({ item: item, indices: indices, active: active });\n            }\n        }\n        // Render the search result content.\n        _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.render(content, contentNode);\n        // Adjust the scroll position as needed.\n        if (activeIndex < 0 || activeIndex >= results.length) {\n            contentNode.scrollTop = 0;\n        }\n        else {\n            var element = contentNode.children[activeIndex];\n            _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.scrollIntoViewIfNeeded(contentNode, element);\n        }\n    };\n    /**\n     * Handle the `'click'` event for the command palette.\n     */\n    CommandPalette.prototype._evtClick = function (event) {\n        // Bail if the click is not the left button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Clear input if the target is clear button\n        if (event.target.classList.contains(\"lm-close-icon\")) {\n            this.inputNode.value = '';\n            this.refresh();\n            return;\n        }\n        // Find the index of the item which was clicked.\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this.contentNode.children, function (node) {\n            return node.contains(event.target);\n        });\n        // Bail if the click was not on an item.\n        if (index === -1) {\n            return;\n        }\n        // Kill the event when a content item is clicked.\n        event.preventDefault();\n        event.stopPropagation();\n        // Execute the item if possible.\n        this._execute(index);\n    };\n    /**\n     * Handle the `'keydown'` event for the command palette.\n     */\n    CommandPalette.prototype._evtKeyDown = function (event) {\n        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n            return;\n        }\n        switch (event.keyCode) {\n            case 13: // Enter\n                event.preventDefault();\n                event.stopPropagation();\n                this._execute(this._activeIndex);\n                break;\n            case 38: // Up Arrow\n                event.preventDefault();\n                event.stopPropagation();\n                this._activatePreviousItem();\n                break;\n            case 40: // Down Arrow\n                event.preventDefault();\n                event.stopPropagation();\n                this._activateNextItem();\n                break;\n        }\n    };\n    /**\n     * Activate the next enabled command item.\n     */\n    CommandPalette.prototype._activateNextItem = function () {\n        // Bail if there are no search results.\n        if (!this._results || this._results.length === 0) {\n            return;\n        }\n        // Find the next enabled item index.\n        var ai = this._activeIndex;\n        var n = this._results.length;\n        var start = ai < n - 1 ? ai + 1 : 0;\n        var stop = start === 0 ? n - 1 : start - 1;\n        this._activeIndex = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this._results, Private$9.canActivate, start, stop);\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Activate the previous enabled command item.\n     */\n    CommandPalette.prototype._activatePreviousItem = function () {\n        // Bail if there are no search results.\n        if (!this._results || this._results.length === 0) {\n            return;\n        }\n        // Find the previous enabled item index.\n        var ai = this._activeIndex;\n        var n = this._results.length;\n        var start = ai <= 0 ? n - 1 : ai - 1;\n        var stop = start === n - 1 ? 0 : start + 1;\n        this._activeIndex = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findLastIndex(this._results, Private$9.canActivate, start, stop);\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Execute the command item at the given index, if possible.\n     */\n    CommandPalette.prototype._execute = function (index) {\n        // Bail if there are no search results.\n        if (!this._results) {\n            return;\n        }\n        // Bail if the index is out of range.\n        var part = this._results[index];\n        if (!part) {\n            return;\n        }\n        // Update the search text if the item is a header.\n        if (part.type === 'header') {\n            var input = this.inputNode;\n            input.value = part.category.toLowerCase() + \" \";\n            input.focus();\n            this.refresh();\n            return;\n        }\n        // Bail if item is not enabled.\n        if (!part.item.isEnabled) {\n            return;\n        }\n        // Execute the item.\n        this.commands.execute(part.item.command, part.item.args);\n        // Clear the query text.\n        this.inputNode.value = '';\n        // Refresh the search results.\n        this.refresh();\n    };\n    /**\n     * Toggle the focused modifier based on the input node focus state.\n     */\n    CommandPalette.prototype._toggleFocused = function () {\n        var focused = document.activeElement === this.inputNode;\n        this.toggleClass('lm-mod-focused', focused);\n        /* <DEPRECATED> */\n        this.toggleClass('p-mod-focused', focused);\n        /* </DEPRECATED> */\n    };\n    /**\n     * A signal handler for generic command changes.\n     */\n    CommandPalette.prototype._onGenericChange = function () {\n        this.refresh();\n    };\n    return CommandPalette;\n}(Widget));\n/**\n * The namespace for the `CommandPalette` class statics.\n */\n(function (CommandPalette) {\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    var Renderer = /** @class */ (function () {\n        function Renderer() {\n        }\n        /**\n         * Render the virtual element for a command palette header.\n         *\n         * @param data - The data to use for rendering the header.\n         *\n         * @returns A virtual element representing the header.\n         */\n        Renderer.prototype.renderHeader = function (data) {\n            var content = this.formatHeader(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li({ className: 'lm-CommandPalette-header'\n                    /* <DEPRECATED> */\n                    + ' p-CommandPalette-header'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Render the virtual element for a command palette item.\n         *\n         * @param data - The data to use for rendering the item.\n         *\n         * @returns A virtual element representing the item.\n         */\n        Renderer.prototype.renderItem = function (data) {\n            var className = this.createItemClass(data);\n            var dataset = this.createItemDataset(data);\n            if (data.item.isToggleable) {\n                return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li({\n                    className: className,\n                    dataset: dataset,\n                    role: 'checkbox',\n                    'aria-checked': \"\" + data.item.isToggled\n                }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data)));\n            }\n            return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li({\n                className: className,\n                dataset: dataset\n            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data)));\n        };\n        /**\n         * Render the empty results message for a command palette.\n         *\n         * @param data - The data to use for rendering the message.\n         *\n         * @returns A virtual element representing the message.\n         */\n        Renderer.prototype.renderEmptyMessage = function (data) {\n            var content = this.formatEmptyMessage(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li({\n                className: 'lm-CommandPalette-emptyMessage'\n                    /* <DEPRECATED> */\n                    + ' p-CommandPalette-emptyMessage'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Render the icon for a command palette item.\n         *\n         * @param data - The data to use for rendering the icon.\n         *\n         * @returns A virtual element representing the icon.\n         */\n        Renderer.prototype.renderItemIcon = function (data) {\n            var className = this.createIconClass(data);\n            /* <DEPRECATED> */\n            if (typeof data.item.icon === 'string') {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, data.item.iconLabel);\n            }\n            /* </DEPRECATED> */\n            // if data.item.icon is undefined, it will be ignored\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, data.item.icon, data.item.iconLabel);\n        };\n        /**\n         * Render the content for a command palette item.\n         *\n         * @param data - The data to use for rendering the content.\n         *\n         * @returns A virtual element representing the content.\n         */\n        Renderer.prototype.renderItemContent = function (data) {\n            return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-CommandPalette-itemContent'\n                    /* <DEPRECATED> */\n                    + ' p-CommandPalette-itemContent'\n                /* </DEPRECATED> */\n            }, this.renderItemLabel(data), this.renderItemCaption(data)));\n        };\n        /**\n         * Render the label for a command palette item.\n         *\n         * @param data - The data to use for rendering the label.\n         *\n         * @returns A virtual element representing the label.\n         */\n        Renderer.prototype.renderItemLabel = function (data) {\n            var content = this.formatItemLabel(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-CommandPalette-itemLabel'\n                    /* <DEPRECATED> */\n                    + ' p-CommandPalette-itemLabel'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Render the caption for a command palette item.\n         *\n         * @param data - The data to use for rendering the caption.\n         *\n         * @returns A virtual element representing the caption.\n         */\n        Renderer.prototype.renderItemCaption = function (data) {\n            var content = this.formatItemCaption(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-CommandPalette-itemCaption'\n                    /* <DEPRECATED> */\n                    + ' p-CommandPalette-itemCaption'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Render the shortcut for a command palette item.\n         *\n         * @param data - The data to use for rendering the shortcut.\n         *\n         * @returns A virtual element representing the shortcut.\n         */\n        Renderer.prototype.renderItemShortcut = function (data) {\n            var content = this.formatItemShortcut(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-CommandPalette-itemShortcut'\n                    /* <DEPRECATED> */\n                    + ' p-CommandPalette-itemShortcut'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Create the class name for the command palette item.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the command palette item.\n         */\n        Renderer.prototype.createItemClass = function (data) {\n            // Set up the initial class name.\n            var name = 'lm-CommandPalette-item';\n            /* <DEPRECATED> */\n            name += ' p-CommandPalette-item';\n            /* </DEPRECATED> */\n            // Add the boolean state classes.\n            if (!data.item.isEnabled) {\n                name += ' lm-mod-disabled';\n                /* <DEPRECATED> */\n                name += ' p-mod-disabled';\n                /* </DEPRECATED> */\n            }\n            if (data.item.isToggled) {\n                name += ' lm-mod-toggled';\n                /* <DEPRECATED> */\n                name += ' p-mod-toggled';\n                /* </DEPRECATED> */\n            }\n            if (data.active) {\n                name += ' lm-mod-active';\n                /* <DEPRECATED> */\n                name += ' p-mod-active';\n                /* </DEPRECATED> */\n            }\n            // Add the extra class.\n            var extra = data.item.className;\n            if (extra) {\n                name += \" \" + extra;\n            }\n            // Return the complete class name.\n            return name;\n        };\n        /**\n         * Create the dataset for the command palette item.\n         *\n         * @param data - The data to use for creating the dataset.\n         *\n         * @returns The dataset for the command palette item.\n         */\n        Renderer.prototype.createItemDataset = function (data) {\n            return __assign(__assign({}, data.item.dataset), { command: data.item.command });\n        };\n        /**\n         * Create the class name for the command item icon.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the item icon.\n         */\n        Renderer.prototype.createIconClass = function (data) {\n            var name = 'lm-CommandPalette-itemIcon';\n            /* <DEPRECATED> */\n            name += ' p-CommandPalette-itemIcon';\n            /* </DEPRECATED> */\n            var extra = data.item.iconClass;\n            return extra ? name + \" \" + extra : name;\n        };\n        /**\n         * Create the render content for the header node.\n         *\n         * @param data - The data to use for the header content.\n         *\n         * @returns The content to add to the header node.\n         */\n        Renderer.prototype.formatHeader = function (data) {\n            if (!data.indices || data.indices.length === 0) {\n                return data.category;\n            }\n            return _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.StringExt.highlight(data.category, data.indices, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.mark);\n        };\n        /**\n         * Create the render content for the empty message node.\n         *\n         * @param data - The data to use for the empty message content.\n         *\n         * @returns The content to add to the empty message node.\n         */\n        Renderer.prototype.formatEmptyMessage = function (data) {\n            return \"No commands found that match '\" + data.query + \"'\";\n        };\n        /**\n         * Create the render content for the item shortcut node.\n         *\n         * @param data - The data to use for the shortcut content.\n         *\n         * @returns The content to add to the shortcut node.\n         */\n        Renderer.prototype.formatItemShortcut = function (data) {\n            var kb = data.item.keyBinding;\n            return kb ? kb.keys.map(_lumino_commands__WEBPACK_IMPORTED_MODULE_7__.CommandRegistry.formatKeystroke).join(', ') : null;\n        };\n        /**\n         * Create the render content for the item label node.\n         *\n         * @param data - The data to use for the label content.\n         *\n         * @returns The content to add to the label node.\n         */\n        Renderer.prototype.formatItemLabel = function (data) {\n            if (!data.indices || data.indices.length === 0) {\n                return data.item.label;\n            }\n            return _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.StringExt.highlight(data.item.label, data.indices, _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.mark);\n        };\n        /**\n         * Create the render content for the item caption node.\n         *\n         * @param data - The data to use for the caption content.\n         *\n         * @returns The content to add to the caption node.\n         */\n        Renderer.prototype.formatItemCaption = function (data) {\n            return data.item.caption;\n        };\n        return Renderer;\n    }());\n    CommandPalette.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    CommandPalette.defaultRenderer = new Renderer();\n})(CommandPalette || (CommandPalette = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$9;\n(function (Private) {\n    /**\n     * Create the DOM node for a command palette.\n     */\n    function createNode() {\n        var node = document.createElement('div');\n        var search = document.createElement('div');\n        var wrapper = document.createElement('div');\n        var input = document.createElement('input');\n        var content = document.createElement('ul');\n        var clear = document.createElement('button');\n        search.className = 'lm-CommandPalette-search';\n        wrapper.className = 'lm-CommandPalette-wrapper';\n        input.className = 'lm-CommandPalette-input';\n        clear.className = 'lm-close-icon';\n        content.className = 'lm-CommandPalette-content';\n        /* <DEPRECATED> */\n        search.classList.add('p-CommandPalette-search');\n        wrapper.classList.add('p-CommandPalette-wrapper');\n        input.classList.add('p-CommandPalette-input');\n        content.classList.add('p-CommandPalette-content');\n        /* </DEPRECATED> */\n        input.spellcheck = false;\n        wrapper.appendChild(input);\n        wrapper.appendChild(clear);\n        search.appendChild(wrapper);\n        node.appendChild(search);\n        node.appendChild(content);\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Create a new command item from a command registry and options.\n     */\n    function createItem(commands, options) {\n        return new CommandItem(commands, options);\n    }\n    Private.createItem = createItem;\n    /**\n     * Search an array of command items for fuzzy matches.\n     */\n    function search(items, query) {\n        // Fuzzy match the items for the query.\n        var scores = matchItems(items, query);\n        // Sort the items based on their score.\n        scores.sort(scoreCmp);\n        // Create the results for the search.\n        return createResults(scores);\n    }\n    Private.search = search;\n    /**\n     * Test whether a result item can be activated.\n     */\n    function canActivate(result) {\n        return result.type === 'item' && result.item.isEnabled;\n    }\n    Private.canActivate = canActivate;\n    /**\n     * Normalize a category for a command item.\n     */\n    function normalizeCategory(category) {\n        return category.trim().replace(/\\s+/g, ' ');\n    }\n    /**\n     * Normalize the query text for a fuzzy search.\n     */\n    function normalizeQuery(text) {\n        return text.replace(/\\s+/g, '').toLowerCase();\n    }\n    /**\n     * Perform a fuzzy match on an array of command items.\n     */\n    function matchItems(items, query) {\n        // Normalize the query text to lower case with no whitespace.\n        query = normalizeQuery(query);\n        // Create the array to hold the scores.\n        var scores = [];\n        // Iterate over the items and match against the query.\n        for (var i = 0, n = items.length; i < n; ++i) {\n            // Ignore items which are not visible.\n            var item = items[i];\n            if (!item.isVisible) {\n                continue;\n            }\n            // If the query is empty, all items are matched by default.\n            if (!query) {\n                scores.push({\n                    matchType: 3 /* Default */,\n                    categoryIndices: null,\n                    labelIndices: null,\n                    score: 0, item: item\n                });\n                continue;\n            }\n            // Run the fuzzy search for the item and query.\n            var score = fuzzySearch(item, query);\n            // Ignore the item if it is not a match.\n            if (!score) {\n                continue;\n            }\n            // Penalize disabled items.\n            // TODO - push disabled items all the way down in sort cmp?\n            if (!item.isEnabled) {\n                score.score += 1000;\n            }\n            // Add the score to the results.\n            scores.push(score);\n        }\n        // Return the final array of scores.\n        return scores;\n    }\n    /**\n     * Perform a fuzzy search on a single command item.\n     */\n    function fuzzySearch(item, query) {\n        // Create the source text to be searched.\n        var category = item.category.toLowerCase();\n        var label = item.label.toLowerCase();\n        var source = category + \" \" + label;\n        // Set up the match score and indices array.\n        var score = Infinity;\n        var indices = null;\n        // The regex for search word boundaries\n        var rgx = /\\b\\w/g;\n        // Search the source by word boundary.\n        while (true) {\n            // Find the next word boundary in the source.\n            var rgxMatch = rgx.exec(source);\n            // Break if there is no more source context.\n            if (!rgxMatch) {\n                break;\n            }\n            // Run the string match on the relevant substring.\n            var match = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.StringExt.matchSumOfDeltas(source, query, rgxMatch.index);\n            // Break if there is no match.\n            if (!match) {\n                break;\n            }\n            // Update the match if the score is better.\n            if (match && match.score <= score) {\n                score = match.score;\n                indices = match.indices;\n            }\n        }\n        // Bail if there was no match.\n        if (!indices || score === Infinity) {\n            return null;\n        }\n        // Compute the pivot index between category and label text.\n        var pivot = category.length + 1;\n        // Find the slice index to separate matched indices.\n        var j = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.lowerBound(indices, pivot, function (a, b) { return a - b; });\n        // Extract the matched category and label indices.\n        var categoryIndices = indices.slice(0, j);\n        var labelIndices = indices.slice(j);\n        // Adjust the label indices for the pivot offset.\n        for (var i = 0, n = labelIndices.length; i < n; ++i) {\n            labelIndices[i] -= pivot;\n        }\n        // Handle a pure label match.\n        if (categoryIndices.length === 0) {\n            return {\n                matchType: 0 /* Label */,\n                categoryIndices: null,\n                labelIndices: labelIndices,\n                score: score, item: item\n            };\n        }\n        // Handle a pure category match.\n        if (labelIndices.length === 0) {\n            return {\n                matchType: 1 /* Category */,\n                categoryIndices: categoryIndices,\n                labelIndices: null,\n                score: score, item: item\n            };\n        }\n        // Handle a split match.\n        return {\n            matchType: 2 /* Split */,\n            categoryIndices: categoryIndices,\n            labelIndices: labelIndices,\n            score: score, item: item\n        };\n    }\n    /**\n     * A sort comparison function for a match score.\n     */\n    function scoreCmp(a, b) {\n        // First compare based on the match type\n        var m1 = a.matchType - b.matchType;\n        if (m1 !== 0) {\n            return m1;\n        }\n        // Otherwise, compare based on the match score.\n        var d1 = a.score - b.score;\n        if (d1 !== 0) {\n            return d1;\n        }\n        // Find the match index based on the match type.\n        var i1 = 0;\n        var i2 = 0;\n        switch (a.matchType) {\n            case 0 /* Label */:\n                i1 = a.labelIndices[0];\n                i2 = b.labelIndices[0];\n                break;\n            case 1 /* Category */:\n            case 2 /* Split */:\n                i1 = a.categoryIndices[0];\n                i2 = b.categoryIndices[0];\n                break;\n        }\n        // Compare based on the match index.\n        if (i1 !== i2) {\n            return i1 - i2;\n        }\n        // Otherwise, compare by category.\n        var d2 = a.item.category.localeCompare(b.item.category);\n        if (d2 !== 0) {\n            return d2;\n        }\n        // Otherwise, compare by rank.\n        var r1 = a.item.rank;\n        var r2 = b.item.rank;\n        if (r1 !== r2) {\n            return r1 < r2 ? -1 : 1; // Infinity safe\n        }\n        // Finally, compare by label.\n        return a.item.label.localeCompare(b.item.label);\n    }\n    /**\n     * Create the results from an array of sorted scores.\n     */\n    function createResults(scores) {\n        // Set up an array to track which scores have been visited.\n        var visited = new Array(scores.length);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.fill(visited, false);\n        // Set up the search results array.\n        var results = [];\n        // Iterate over each score in the array.\n        for (var i = 0, n = scores.length; i < n; ++i) {\n            // Ignore a score which has already been processed.\n            if (visited[i]) {\n                continue;\n            }\n            // Extract the current item and indices.\n            var _a = scores[i], item = _a.item, categoryIndices = _a.categoryIndices;\n            // Extract the category for the current item.\n            var category = item.category;\n            // Add the header result for the category.\n            results.push({ type: 'header', category: category, indices: categoryIndices });\n            // Find the rest of the scores with the same category.\n            for (var j = i; j < n; ++j) {\n                // Ignore a score which has already been processed.\n                if (visited[j]) {\n                    continue;\n                }\n                // Extract the data for the current score.\n                var _b = scores[j], item_1 = _b.item, labelIndices = _b.labelIndices;\n                // Ignore an item with a different category.\n                if (item_1.category !== category) {\n                    continue;\n                }\n                // Create the item result for the score.\n                results.push({ type: 'item', item: item_1, indices: labelIndices });\n                // Mark the score as processed.\n                visited[j] = true;\n            }\n        }\n        // Return the final results.\n        return results;\n    }\n    /**\n     * A concrete implementation of `CommandPalette.IItem`.\n     */\n    var CommandItem = /** @class */ (function () {\n        /**\n         * Construct a new command item.\n         */\n        function CommandItem(commands, options) {\n            this._commands = commands;\n            this.category = normalizeCategory(options.category);\n            this.command = options.command;\n            this.args = options.args || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.JSONExt.emptyObject;\n            this.rank = options.rank !== undefined ? options.rank : Infinity;\n        }\n        Object.defineProperty(CommandItem.prototype, \"label\", {\n            /**\n             * The display label for the command item.\n             */\n            get: function () {\n                return this._commands.label(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"icon\", {\n            /**\n             * The icon renderer for the command item.\n             */\n            get: function () {\n                return this._commands.icon(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"iconClass\", {\n            /**\n             * The icon class for the command item.\n             */\n            get: function () {\n                return this._commands.iconClass(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"iconLabel\", {\n            /**\n             * The icon label for the command item.\n             */\n            get: function () {\n                return this._commands.iconLabel(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"caption\", {\n            /**\n             * The display caption for the command item.\n             */\n            get: function () {\n                return this._commands.caption(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"className\", {\n            /**\n             * The extra class name for the command item.\n             */\n            get: function () {\n                return this._commands.className(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"dataset\", {\n            /**\n             * The dataset for the command item.\n             */\n            get: function () {\n                return this._commands.dataset(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"isEnabled\", {\n            /**\n             * Whether the command item is enabled.\n             */\n            get: function () {\n                return this._commands.isEnabled(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"isToggled\", {\n            /**\n             * Whether the command item is toggled.\n             */\n            get: function () {\n                return this._commands.isToggled(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"isToggleable\", {\n            /**\n             * Whether the command item is toggleable.\n             */\n            get: function () {\n                return this._commands.isToggleable(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"isVisible\", {\n            /**\n             * Whether the command item is visible.\n             */\n            get: function () {\n                return this._commands.isVisible(this.command, this.args);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CommandItem.prototype, \"keyBinding\", {\n            /**\n             * The key binding for the command item.\n             */\n            get: function () {\n                var _a = this, command = _a.command, args = _a.args;\n                return _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findLastValue(this._commands.keyBindings, function (kb) {\n                    return kb.command === command && _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.JSONExt.deepEqual(kb.args, args);\n                }) || null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return CommandItem;\n    }());\n})(Private$9 || (Private$9 = {}));\n\n/**\n * A widget which displays items as a canonical menu.\n */\nvar Menu = /** @class */ (function (_super) {\n    __extends(Menu, _super);\n    /**\n     * Construct a new menu.\n     *\n     * @param options - The options for initializing the menu.\n     */\n    function Menu(options) {\n        var _this = _super.call(this, { node: Private$a.createNode() }) || this;\n        _this._childIndex = -1;\n        _this._activeIndex = -1;\n        _this._openTimerID = 0;\n        _this._closeTimerID = 0;\n        _this._items = [];\n        _this._childMenu = null;\n        _this._parentMenu = null;\n        _this._aboutToClose = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._menuRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this.addClass('lm-Menu');\n        /* <DEPRECATED> */\n        _this.addClass('p-Menu');\n        /* </DEPRECATED> */\n        _this.setFlag(Widget.Flag.DisallowLayout);\n        _this.commands = options.commands;\n        _this.renderer = options.renderer || Menu.defaultRenderer;\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the menu.\n     */\n    Menu.prototype.dispose = function () {\n        this.close();\n        this._items.length = 0;\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(Menu.prototype, \"aboutToClose\", {\n        /**\n         * A signal emitted just before the menu is closed.\n         *\n         * #### Notes\n         * This signal is emitted when the menu receives a `'close-request'`\n         * message, just before it removes itself from the DOM.\n         *\n         * This signal is not emitted if the menu is already detached from\n         * the DOM when it receives the `'close-request'` message.\n         */\n        get: function () {\n            return this._aboutToClose;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"menuRequested\", {\n        /**\n         * A signal emitted when a new menu is requested by the user.\n         *\n         * #### Notes\n         * This signal is emitted whenever the user presses the right or left\n         * arrow keys, and a submenu cannot be opened or closed in response.\n         *\n         * This signal is useful when implementing menu bars in order to open\n         * the next or previous menu in response to a user key press.\n         *\n         * This signal is only emitted for the root menu in a hierarchy.\n         */\n        get: function () {\n            return this._menuRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"parentMenu\", {\n        /**\n         * The parent menu of the menu.\n         *\n         * #### Notes\n         * This is `null` unless the menu is an open submenu.\n         */\n        get: function () {\n            return this._parentMenu;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"childMenu\", {\n        /**\n         * The child menu of the menu.\n         *\n         * #### Notes\n         * This is `null` unless the menu has an open submenu.\n         */\n        get: function () {\n            return this._childMenu;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"rootMenu\", {\n        /**\n         * The root menu of the menu hierarchy.\n         */\n        get: function () {\n            var menu = this;\n            while (menu._parentMenu) {\n                menu = menu._parentMenu;\n            }\n            return menu;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"leafMenu\", {\n        /**\n         * The leaf menu of the menu hierarchy.\n         */\n        get: function () {\n            var menu = this;\n            while (menu._childMenu) {\n                menu = menu._childMenu;\n            }\n            return menu;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"contentNode\", {\n        /**\n         * The menu content node.\n         *\n         * #### Notes\n         * This is the node which holds the menu item nodes.\n         *\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-Menu-content')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"activeItem\", {\n        /**\n         * Get the currently active menu item.\n         */\n        get: function () {\n            return this._items[this._activeIndex] || null;\n        },\n        /**\n         * Set the currently active menu item.\n         *\n         * #### Notes\n         * If the item cannot be activated, the item will be set to `null`.\n         */\n        set: function (value) {\n            this.activeIndex = value ? this._items.indexOf(value) : -1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"activeIndex\", {\n        /**\n         * Get the index of the currently active menu item.\n         *\n         * #### Notes\n         * This will be `-1` if no menu item is active.\n         */\n        get: function () {\n            return this._activeIndex;\n        },\n        /**\n         * Set the index of the currently active menu item.\n         *\n         * #### Notes\n         * If the item cannot be activated, the index will be set to `-1`.\n         */\n        set: function (value) {\n            // Adjust the value for an out of range index.\n            if (value < 0 || value >= this._items.length) {\n                value = -1;\n            }\n            // Ensure the item can be activated.\n            if (value !== -1 && !Private$a.canActivate(this._items[value])) {\n                value = -1;\n            }\n            // Bail if the index will not change.\n            if (this._activeIndex === value) {\n                return;\n            }\n            // Update the active index.\n            this._activeIndex = value;\n            // Make active element in focus\n            if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {\n                this.contentNode.childNodes[this._activeIndex].focus();\n            }\n            // schedule an update of the items.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Menu.prototype, \"items\", {\n        /**\n         * A read-only array of the menu items in the menu.\n         */\n        get: function () {\n            return this._items;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Activate the next selectable item in the menu.\n     *\n     * #### Notes\n     * If no item is selectable, the index will be set to `-1`.\n     */\n    Menu.prototype.activateNextItem = function () {\n        var n = this._items.length;\n        var ai = this._activeIndex;\n        var start = ai < n - 1 ? ai + 1 : 0;\n        var stop = start === 0 ? n - 1 : start - 1;\n        this.activeIndex = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this._items, Private$a.canActivate, start, stop);\n    };\n    /**\n     * Activate the previous selectable item in the menu.\n     *\n     * #### Notes\n     * If no item is selectable, the index will be set to `-1`.\n     */\n    Menu.prototype.activatePreviousItem = function () {\n        var n = this._items.length;\n        var ai = this._activeIndex;\n        var start = ai <= 0 ? n - 1 : ai - 1;\n        var stop = start === n - 1 ? 0 : start + 1;\n        this.activeIndex = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findLastIndex(this._items, Private$a.canActivate, start, stop);\n    };\n    /**\n     * Trigger the active menu item.\n     *\n     * #### Notes\n     * If the active item is a submenu, it will be opened and the first\n     * item will be activated.\n     *\n     * If the active item is a command, the command will be executed.\n     *\n     * If the menu is not attached, this is a no-op.\n     *\n     * If there is no active item, this is a no-op.\n     */\n    Menu.prototype.triggerActiveItem = function () {\n        // Bail if the menu is not attached.\n        if (!this.isAttached) {\n            return;\n        }\n        // Bail if there is no active item.\n        var item = this.activeItem;\n        if (!item) {\n            return;\n        }\n        // Cancel the pending timers.\n        this._cancelOpenTimer();\n        this._cancelCloseTimer();\n        // If the item is a submenu, open it.\n        if (item.type === 'submenu') {\n            this._openChildMenu(true);\n            return;\n        }\n        // Close the root menu before executing the command.\n        this.rootMenu.close();\n        // Execute the command for the item.\n        var command = item.command, args = item.args;\n        if (this.commands.isEnabled(command, args)) {\n            this.commands.execute(command, args);\n        }\n        else {\n            console.log(\"Command '\" + command + \"' is disabled.\");\n        }\n    };\n    /**\n     * Add a menu item to the end of the menu.\n     *\n     * @param options - The options for creating the menu item.\n     *\n     * @returns The menu item added to the menu.\n     */\n    Menu.prototype.addItem = function (options) {\n        return this.insertItem(this._items.length, options);\n    };\n    /**\n     * Insert a menu item into the menu at the specified index.\n     *\n     * @param index - The index at which to insert the item.\n     *\n     * @param options - The options for creating the menu item.\n     *\n     * @returns The menu item added to the menu.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the items.\n     */\n    Menu.prototype.insertItem = function (index, options) {\n        // Close the menu if it's attached.\n        if (this.isAttached) {\n            this.close();\n        }\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Clamp the insert index to the array bounds.\n        var i = Math.max(0, Math.min(index, this._items.length));\n        // Create the item for the options.\n        var item = Private$a.createItem(this, options);\n        // Insert the item into the array.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._items, i, item);\n        // Schedule an update of the items.\n        this.update();\n        // Return the item added to the menu.\n        return item;\n    };\n    /**\n     * Remove an item from the menu.\n     *\n     * @param item - The item to remove from the menu.\n     *\n     * #### Notes\n     * This is a no-op if the item is not in the menu.\n     */\n    Menu.prototype.removeItem = function (item) {\n        this.removeItemAt(this._items.indexOf(item));\n    };\n    /**\n     * Remove the item at a given index from the menu.\n     *\n     * @param index - The index of the item to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    Menu.prototype.removeItemAt = function (index) {\n        // Close the menu if it's attached.\n        if (this.isAttached) {\n            this.close();\n        }\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Remove the item from the array.\n        var item = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._items, index);\n        // Bail if the index is out of range.\n        if (!item) {\n            return;\n        }\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Remove all menu items from the menu.\n     */\n    Menu.prototype.clearItems = function () {\n        // Close the menu if it's attached.\n        if (this.isAttached) {\n            this.close();\n        }\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Bail if there is nothing to remove.\n        if (this._items.length === 0) {\n            return;\n        }\n        // Clear the items.\n        this._items.length = 0;\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Open the menu at the specified location.\n     *\n     * @param x - The client X coordinate of the menu location.\n     *\n     * @param y - The client Y coordinate of the menu location.\n     *\n     * @param options - The additional options for opening the menu.\n     *\n     * #### Notes\n     * The menu will be opened at the given location unless it will not\n     * fully fit on the screen. If it will not fit, it will be adjusted\n     * to fit naturally on the screen.\n     *\n     * This is a no-op if the menu is already attached to the DOM.\n     */\n    Menu.prototype.open = function (x, y, options) {\n        if (options === void 0) { options = {}; }\n        // Bail early if the menu is already attached.\n        if (this.isAttached) {\n            return;\n        }\n        // Extract the position options.\n        var forceX = options.forceX || false;\n        var forceY = options.forceY || false;\n        // Open the menu as a root menu.\n        Private$a.openRootMenu(this, x, y, forceX, forceY);\n        // Activate the menu to accept keyboard input.\n        this.activate();\n    };\n    /**\n     * Handle the DOM events for the menu.\n     *\n     * @param event - The DOM event sent to the menu.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the menu's DOM nodes. It should\n     * not be called directly by user code.\n     */\n    Menu.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseenter':\n                this._evtMouseEnter(event);\n                break;\n            case 'mouseleave':\n                this._evtMouseLeave(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    Menu.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('keydown', this);\n        this.node.addEventListener('mouseup', this);\n        this.node.addEventListener('mousemove', this);\n        this.node.addEventListener('mouseenter', this);\n        this.node.addEventListener('mouseleave', this);\n        this.node.addEventListener('contextmenu', this);\n        document.addEventListener('mousedown', this, true);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    Menu.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('keydown', this);\n        this.node.removeEventListener('mouseup', this);\n        this.node.removeEventListener('mousemove', this);\n        this.node.removeEventListener('mouseenter', this);\n        this.node.removeEventListener('mouseleave', this);\n        this.node.removeEventListener('contextmenu', this);\n        document.removeEventListener('mousedown', this, true);\n    };\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    Menu.prototype.onActivateRequest = function (msg) {\n        if (this.isAttached) {\n            this.node.focus();\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    Menu.prototype.onUpdateRequest = function (msg) {\n        var _this = this;\n        var items = this._items;\n        var renderer = this.renderer;\n        var activeIndex = this._activeIndex;\n        var collapsedFlags = Private$a.computeCollapsed(items);\n        var content = new Array(items.length);\n        var _loop_1 = function (i, n) {\n            var item = items[i];\n            var active = i === activeIndex;\n            var collapsed = collapsedFlags[i];\n            content[i] = renderer.renderItem({\n                item: item,\n                active: active,\n                collapsed: collapsed,\n                onfocus: function () {\n                    _this.activeIndex = i;\n                }\n            });\n        };\n        for (var i = 0, n = items.length; i < n; ++i) {\n            _loop_1(i);\n        }\n        _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.render(content, this.contentNode);\n    };\n    /**\n     * A message handler invoked on a `'close-request'` message.\n     */\n    Menu.prototype.onCloseRequest = function (msg) {\n        // Cancel the pending timers.\n        this._cancelOpenTimer();\n        this._cancelCloseTimer();\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Close any open child menu.\n        var childMenu = this._childMenu;\n        if (childMenu) {\n            this._childIndex = -1;\n            this._childMenu = null;\n            childMenu._parentMenu = null;\n            childMenu.close();\n        }\n        // Remove this menu from its parent and activate the parent.\n        var parentMenu = this._parentMenu;\n        if (parentMenu) {\n            this._parentMenu = null;\n            parentMenu._childIndex = -1;\n            parentMenu._childMenu = null;\n            parentMenu.activate();\n        }\n        // Emit the `aboutToClose` signal if the menu is attached.\n        if (this.isAttached) {\n            this._aboutToClose.emit(undefined);\n        }\n        // Finish closing the menu.\n        _super.prototype.onCloseRequest.call(this, msg);\n    };\n    /**\n     * Handle the `'keydown'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    Menu.prototype._evtKeyDown = function (event) {\n        // A menu handles all keydown events.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the key code for the event.\n        var kc = event.keyCode;\n        // Enter\n        if (kc === 13) {\n            this.triggerActiveItem();\n            return;\n        }\n        // Escape\n        if (kc === 27) {\n            this.close();\n            return;\n        }\n        // Left Arrow\n        if (kc === 37) {\n            if (this._parentMenu) {\n                this.close();\n            }\n            else {\n                this._menuRequested.emit('previous');\n            }\n            return;\n        }\n        // Up Arrow\n        if (kc === 38) {\n            this.activatePreviousItem();\n            return;\n        }\n        // Right Arrow\n        if (kc === 39) {\n            var item = this.activeItem;\n            if (item && item.type === 'submenu') {\n                this.triggerActiveItem();\n            }\n            else {\n                this.rootMenu._menuRequested.emit('next');\n            }\n            return;\n        }\n        // Down Arrow\n        if (kc === 40) {\n            this.activateNextItem();\n            return;\n        }\n        // Get the pressed key character.\n        var key = (0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_10__.getKeyboardLayout)().keyForKeydownEvent(event);\n        // Bail if the key is not valid.\n        if (!key) {\n            return;\n        }\n        // Search for the next best matching mnemonic item.\n        var start = this._activeIndex + 1;\n        var result = Private$a.findMnemonic(this._items, key, start);\n        // Handle the requested mnemonic based on the search results.\n        // If exactly one mnemonic is matched, that item is triggered.\n        // Otherwise, the next mnemonic is activated if available,\n        // followed by the auto mnemonic if available.\n        if (result.index !== -1 && !result.multiple) {\n            this.activeIndex = result.index;\n            this.triggerActiveItem();\n        }\n        else if (result.index !== -1) {\n            this.activeIndex = result.index;\n        }\n        else if (result.auto !== -1) {\n            this.activeIndex = result.auto;\n        }\n    };\n    /**\n     * Handle the `'mouseup'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    Menu.prototype._evtMouseUp = function (event) {\n        if (event.button !== 0) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        this.triggerActiveItem();\n    };\n    /**\n     * Handle the `'mousemove'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    Menu.prototype._evtMouseMove = function (event) {\n        // Hit test the item nodes for the item under the mouse.\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this.contentNode.children, function (node) {\n            return _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(node, event.clientX, event.clientY);\n        });\n        // Bail early if the mouse is already over the active index.\n        if (index === this._activeIndex) {\n            return;\n        }\n        // Update and coerce the active index.\n        this.activeIndex = index;\n        index = this.activeIndex;\n        // If the index is the current child index, cancel the timers.\n        if (index === this._childIndex) {\n            this._cancelOpenTimer();\n            this._cancelCloseTimer();\n            return;\n        }\n        // If a child menu is currently open, start the close timer.\n        if (this._childIndex !== -1) {\n            this._startCloseTimer();\n        }\n        // Cancel the open timer to give a full delay for opening.\n        this._cancelOpenTimer();\n        // Bail if the active item is not a valid submenu item.\n        var item = this.activeItem;\n        if (!item || item.type !== 'submenu' || !item.submenu) {\n            return;\n        }\n        // Start the open timer to open the active item submenu.\n        this._startOpenTimer();\n    };\n    /**\n     * Handle the `'mouseenter'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    Menu.prototype._evtMouseEnter = function (event) {\n        // Synchronize the active ancestor items.\n        for (var menu = this._parentMenu; menu; menu = menu._parentMenu) {\n            menu._cancelOpenTimer();\n            menu._cancelCloseTimer();\n            menu.activeIndex = menu._childIndex;\n        }\n    };\n    /**\n     * Handle the `'mouseleave'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    Menu.prototype._evtMouseLeave = function (event) {\n        // Cancel any pending submenu opening.\n        this._cancelOpenTimer();\n        // If there is no open child menu, just reset the active index.\n        if (!this._childMenu) {\n            this.activeIndex = -1;\n            return;\n        }\n        // If the mouse is over the child menu, cancel the close timer.\n        var clientX = event.clientX, clientY = event.clientY;\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {\n            this._cancelCloseTimer();\n            return;\n        }\n        // Otherwise, reset the active index and start the close timer.\n        this.activeIndex = -1;\n        this._startCloseTimer();\n    };\n    /**\n     * Handle the `'mousedown'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the document node.\n     */\n    Menu.prototype._evtMouseDown = function (event) {\n        // Bail if the menu is not a root menu.\n        if (this._parentMenu) {\n            return;\n        }\n        // The mouse button which is pressed is irrelevant. If the press\n        // is not on a menu, the entire hierarchy is closed and the event\n        // is allowed to propagate. This allows other code to act on the\n        // event, such as focusing the clicked element.\n        if (Private$a.hitTestMenus(this, event.clientX, event.clientY)) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else {\n            this.close();\n        }\n    };\n    /**\n     * Open the child menu at the active index immediately.\n     *\n     * If a different child menu is already open, it will be closed,\n     * even if the active item is not a valid submenu.\n     */\n    Menu.prototype._openChildMenu = function (activateFirst) {\n        if (activateFirst === void 0) { activateFirst = false; }\n        // If the item is not a valid submenu, close the child menu.\n        var item = this.activeItem;\n        if (!item || item.type !== 'submenu' || !item.submenu) {\n            this._closeChildMenu();\n            return;\n        }\n        // Do nothing if the child menu will not change.\n        var submenu = item.submenu;\n        if (submenu === this._childMenu) {\n            return;\n        }\n        // Ensure the current child menu is closed.\n        this._closeChildMenu();\n        // Update the private child state.\n        this._childMenu = submenu;\n        this._childIndex = this._activeIndex;\n        // Set the parent menu reference for the child.\n        submenu._parentMenu = this;\n        // Ensure the menu is updated and lookup the item node.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n        var itemNode = this.contentNode.children[this._activeIndex];\n        // Open the submenu at the active node.\n        Private$a.openSubmenu(submenu, itemNode);\n        // Activate the first item if desired.\n        if (activateFirst) {\n            submenu.activeIndex = -1;\n            submenu.activateNextItem();\n        }\n        // Activate the child menu.\n        submenu.activate();\n    };\n    /**\n     * Close the child menu immediately.\n     *\n     * This is a no-op if a child menu is not open.\n     */\n    Menu.prototype._closeChildMenu = function () {\n        if (this._childMenu) {\n            this._childMenu.close();\n        }\n    };\n    /**\n     * Start the open timer, unless it is already pending.\n     */\n    Menu.prototype._startOpenTimer = function () {\n        var _this = this;\n        if (this._openTimerID === 0) {\n            this._openTimerID = window.setTimeout(function () {\n                _this._openTimerID = 0;\n                _this._openChildMenu();\n            }, Private$a.TIMER_DELAY);\n        }\n    };\n    /**\n     * Start the close timer, unless it is already pending.\n     */\n    Menu.prototype._startCloseTimer = function () {\n        var _this = this;\n        if (this._closeTimerID === 0) {\n            this._closeTimerID = window.setTimeout(function () {\n                _this._closeTimerID = 0;\n                _this._closeChildMenu();\n            }, Private$a.TIMER_DELAY);\n        }\n    };\n    /**\n     * Cancel the open timer, if the timer is pending.\n     */\n    Menu.prototype._cancelOpenTimer = function () {\n        if (this._openTimerID !== 0) {\n            clearTimeout(this._openTimerID);\n            this._openTimerID = 0;\n        }\n    };\n    /**\n     * Cancel the close timer, if the timer is pending.\n     */\n    Menu.prototype._cancelCloseTimer = function () {\n        if (this._closeTimerID !== 0) {\n            clearTimeout(this._closeTimerID);\n            this._closeTimerID = 0;\n        }\n    };\n    return Menu;\n}(Widget));\n/**\n * The namespace for the `Menu` class statics.\n */\n(function (Menu) {\n    /**\n     * The default implementation of `IRenderer`.\n     *\n     * #### Notes\n     * Subclasses are free to reimplement rendering methods as needed.\n     */\n    var Renderer = /** @class */ (function () {\n        /**\n         * Construct a new renderer.\n         */\n        function Renderer() {\n        }\n        /**\n         * Render the virtual element for a menu item.\n         *\n         * @param data - The data to use for rendering the item.\n         *\n         * @returns A virtual element representing the item.\n         */\n        Renderer.prototype.renderItem = function (data) {\n            var className = this.createItemClass(data);\n            var dataset = this.createItemDataset(data);\n            var aria = this.createItemARIA(data);\n            return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li(__assign({ className: className,\n                dataset: dataset, tabindex: '0', onfocus: data.onfocus }, aria), this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data)));\n        };\n        /**\n         * Render the icon element for a menu item.\n         *\n         * @param data - The data to use for rendering the icon.\n         *\n         * @returns A virtual element representing the item icon.\n         */\n        Renderer.prototype.renderIcon = function (data) {\n            var className = this.createIconClass(data);\n            /* <DEPRECATED> */\n            if (typeof data.item.icon === 'string') {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, data.item.iconLabel);\n            }\n            /* </DEPRECATED> */\n            // if data.item.icon is undefined, it will be ignored\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, data.item.icon, data.item.iconLabel);\n        };\n        /**\n         * Render the label element for a menu item.\n         *\n         * @param data - The data to use for rendering the label.\n         *\n         * @returns A virtual element representing the item label.\n         */\n        Renderer.prototype.renderLabel = function (data) {\n            var content = this.formatLabel(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-Menu-itemLabel'\n                    /* <DEPRECATED> */\n                    + ' p-Menu-itemLabel'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Render the shortcut element for a menu item.\n         *\n         * @param data - The data to use for rendering the shortcut.\n         *\n         * @returns A virtual element representing the item shortcut.\n         */\n        Renderer.prototype.renderShortcut = function (data) {\n            var content = this.formatShortcut(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-Menu-itemShortcut'\n                    /* <DEPRECATED> */\n                    + ' p-Menu-itemShortcut'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Render the submenu icon element for a menu item.\n         *\n         * @param data - The data to use for rendering the submenu icon.\n         *\n         * @returns A virtual element representing the submenu icon.\n         */\n        Renderer.prototype.renderSubmenu = function (data) {\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-Menu-itemSubmenuIcon'\n                    /* <DEPRECATED> */\n                    + ' p-Menu-itemSubmenuIcon'\n                /* </DEPRECATED> */\n            });\n        };\n        /**\n         * Create the class name for the menu item.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the menu item.\n         */\n        Renderer.prototype.createItemClass = function (data) {\n            // Setup the initial class name.\n            var name = 'lm-Menu-item';\n            /* <DEPRECATED> */\n            name += ' p-Menu-item';\n            /* </DEPRECATED> */\n            // Add the boolean state classes.\n            if (!data.item.isEnabled) {\n                name += ' lm-mod-disabled';\n                /* <DEPRECATED> */\n                name += ' p-mod-disabled';\n                /* </DEPRECATED> */\n            }\n            if (data.item.isToggled) {\n                name += ' lm-mod-toggled';\n                /* <DEPRECATED> */\n                name += ' p-mod-toggled';\n                /* </DEPRECATED> */\n            }\n            if (!data.item.isVisible) {\n                name += ' lm-mod-hidden';\n                /* <DEPRECATED> */\n                name += ' p-mod-hidden';\n                /* </DEPRECATED> */\n            }\n            if (data.active) {\n                name += ' lm-mod-active';\n                /* <DEPRECATED> */\n                name += ' p-mod-active';\n                /* </DEPRECATED> */\n            }\n            if (data.collapsed) {\n                name += ' lm-mod-collapsed';\n                /* <DEPRECATED> */\n                name += ' p-mod-collapsed';\n                /* </DEPRECATED> */\n            }\n            // Add the extra class.\n            var extra = data.item.className;\n            if (extra) {\n                name += \" \" + extra;\n            }\n            // Return the complete class name.\n            return name;\n        };\n        /**\n         * Create the dataset for the menu item.\n         *\n         * @param data - The data to use for creating the dataset.\n         *\n         * @returns The dataset for the menu item.\n         */\n        Renderer.prototype.createItemDataset = function (data) {\n            var result;\n            var _a = data.item, type = _a.type, command = _a.command, dataset = _a.dataset;\n            if (type === 'command') {\n                result = __assign(__assign({}, dataset), { type: type, command: command });\n            }\n            else {\n                result = __assign(__assign({}, dataset), { type: type });\n            }\n            return result;\n        };\n        /**\n         * Create the class name for the menu item icon.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the item icon.\n         */\n        Renderer.prototype.createIconClass = function (data) {\n            var name = 'lm-Menu-itemIcon';\n            /* <DEPRECATED> */\n            name += ' p-Menu-itemIcon';\n            /* </DEPRECATED> */\n            var extra = data.item.iconClass;\n            return extra ? name + \" \" + extra : name;\n        };\n        /**\n         * Create the aria attributes for menu item.\n         *\n         * @param data - The data to use for the aria attributes.\n         *\n         * @returns The aria attributes object for the item.\n         */\n        Renderer.prototype.createItemARIA = function (data) {\n            var aria = {};\n            switch (data.item.type) {\n                case 'separator':\n                    aria.role = 'presentation';\n                    break;\n                case 'submenu':\n                    aria['aria-haspopup'] = 'true';\n                    if (!data.item.isEnabled) {\n                        aria['aria-disabled'] = 'true';\n                    }\n                    break;\n                default:\n                    if (!data.item.isEnabled) {\n                        aria['aria-disabled'] = 'true';\n                    }\n                    aria.role = 'menuitem';\n            }\n            return aria;\n        };\n        /**\n         * Create the render content for the label node.\n         *\n         * @param data - The data to use for the label content.\n         *\n         * @returns The content to add to the label node.\n         */\n        Renderer.prototype.formatLabel = function (data) {\n            // Fetch the label text and mnemonic index.\n            var _a = data.item, label = _a.label, mnemonic = _a.mnemonic;\n            // If the index is out of range, do not modify the label.\n            if (mnemonic < 0 || mnemonic >= label.length) {\n                return label;\n            }\n            // Split the label into parts.\n            var prefix = label.slice(0, mnemonic);\n            var suffix = label.slice(mnemonic + 1);\n            var char = label[mnemonic];\n            // Wrap the mnemonic character in a span.\n            var span = _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({\n                className: 'lm-Menu-itemMnemonic'\n                    /* <DEPRECATED> */\n                    + ' p-Menu-itemMnemonic'\n                /* </DEPRECATED> */\n            }, char);\n            // Return the content parts.\n            return [prefix, span, suffix];\n        };\n        /**\n         * Create the render content for the shortcut node.\n         *\n         * @param data - The data to use for the shortcut content.\n         *\n         * @returns The content to add to the shortcut node.\n         */\n        Renderer.prototype.formatShortcut = function (data) {\n            var kb = data.item.keyBinding;\n            return kb ? kb.keys.map(_lumino_commands__WEBPACK_IMPORTED_MODULE_7__.CommandRegistry.formatKeystroke).join(', ') : null;\n        };\n        return Renderer;\n    }());\n    Menu.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    Menu.defaultRenderer = new Renderer();\n})(Menu || (Menu = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$a;\n(function (Private) {\n    /**\n     * The ms delay for opening and closing a submenu.\n     */\n    Private.TIMER_DELAY = 300;\n    /**\n     * The horizontal pixel overlap for an open submenu.\n     */\n    Private.SUBMENU_OVERLAP = 3;\n    /**\n     * Create the DOM node for a menu.\n     */\n    function createNode() {\n        var node = document.createElement('div');\n        var content = document.createElement('ul');\n        content.className = 'lm-Menu-content';\n        /* <DEPRECATED> */\n        content.classList.add('p-Menu-content');\n        /* </DEPRECATED> */\n        node.appendChild(content);\n        content.setAttribute('role', 'menu');\n        node.tabIndex = 0;\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Test whether a menu item can be activated.\n     */\n    function canActivate(item) {\n        return item.type !== 'separator' && item.isEnabled && item.isVisible;\n    }\n    Private.canActivate = canActivate;\n    /**\n     * Create a new menu item for an owner menu.\n     */\n    function createItem(owner, options) {\n        return new MenuItem(owner.commands, options);\n    }\n    Private.createItem = createItem;\n    /**\n     * Hit test a menu hierarchy starting at the given root.\n     */\n    function hitTestMenus(menu, x, y) {\n        for (var temp = menu; temp; temp = temp.childMenu) {\n            if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(temp.node, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Private.hitTestMenus = hitTestMenus;\n    /**\n     * Compute which extra separator items should be collapsed.\n     */\n    function computeCollapsed(items) {\n        // Allocate the return array and fill it with `false`.\n        var result = new Array(items.length);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.fill(result, false);\n        // Collapse the leading separators.\n        var k1 = 0;\n        var n = items.length;\n        for (; k1 < n; ++k1) {\n            var item = items[k1];\n            if (!item.isVisible) {\n                continue;\n            }\n            if (item.type !== 'separator') {\n                break;\n            }\n            result[k1] = true;\n        }\n        // Hide the trailing separators.\n        var k2 = n - 1;\n        for (; k2 >= 0; --k2) {\n            var item = items[k2];\n            if (!item.isVisible) {\n                continue;\n            }\n            if (item.type !== 'separator') {\n                break;\n            }\n            result[k2] = true;\n        }\n        // Hide the remaining consecutive separators.\n        var hide = false;\n        while (++k1 < k2) {\n            var item = items[k1];\n            if (!item.isVisible) {\n                continue;\n            }\n            if (item.type !== 'separator') {\n                hide = false;\n            }\n            else if (hide) {\n                result[k1] = true;\n            }\n            else {\n                hide = true;\n            }\n        }\n        // Return the resulting flags.\n        return result;\n    }\n    Private.computeCollapsed = computeCollapsed;\n    /**\n     * Open a menu as a root menu at the target location.\n     */\n    function openRootMenu(menu, x, y, forceX, forceY) {\n        // Ensure the menu is updated before attaching and measuring.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(menu, Widget.Msg.UpdateRequest);\n        // Get the current position and size of the main viewport.\n        var px = window.pageXOffset;\n        var py = window.pageYOffset;\n        var cw = document.documentElement.clientWidth;\n        var ch = document.documentElement.clientHeight;\n        // Compute the maximum allowed height for the menu.\n        var maxHeight = ch - (forceY ? y : 0);\n        // Fetch common variables.\n        var node = menu.node;\n        var style = node.style;\n        // Clear the menu geometry and prepare it for measuring.\n        style.top = '';\n        style.left = '';\n        style.width = '';\n        style.height = '';\n        style.visibility = 'hidden';\n        style.maxHeight = maxHeight + \"px\";\n        // Attach the menu to the document.\n        Widget.attach(menu, document.body);\n        // Measure the size of the menu.\n        var _a = node.getBoundingClientRect(), width = _a.width, height = _a.height;\n        // Adjust the X position of the menu to fit on-screen.\n        if (!forceX && (x + width > px + cw)) {\n            x = px + cw - width;\n        }\n        // Adjust the Y position of the menu to fit on-screen.\n        if (!forceY && (y + height > py + ch)) {\n            if (y > py + ch) {\n                y = py + ch - height;\n            }\n            else {\n                y = y - height;\n            }\n        }\n        // Update the position of the menu to the computed position.\n        style.top = Math.max(0, y) + \"px\";\n        style.left = Math.max(0, x) + \"px\";\n        // Finally, make the menu visible on the screen.\n        style.visibility = '';\n    }\n    Private.openRootMenu = openRootMenu;\n    /**\n     * Open a menu as a submenu using an item node for positioning.\n     */\n    function openSubmenu(submenu, itemNode) {\n        // Ensure the menu is updated before opening.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(submenu, Widget.Msg.UpdateRequest);\n        // Get the current position and size of the main viewport.\n        var px = window.pageXOffset;\n        var py = window.pageYOffset;\n        var cw = document.documentElement.clientWidth;\n        var ch = document.documentElement.clientHeight;\n        // Compute the maximum allowed height for the menu.\n        var maxHeight = ch;\n        // Fetch common variables.\n        var node = submenu.node;\n        var style = node.style;\n        // Clear the menu geometry and prepare it for measuring.\n        style.top = '';\n        style.left = '';\n        style.width = '';\n        style.height = '';\n        style.visibility = 'hidden';\n        style.maxHeight = maxHeight + \"px\";\n        // Attach the menu to the document.\n        Widget.attach(submenu, document.body);\n        // Measure the size of the menu.\n        var _a = node.getBoundingClientRect(), width = _a.width, height = _a.height;\n        // Compute the box sizing for the menu.\n        var box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(submenu.node);\n        // Get the bounding rect for the target item node.\n        var itemRect = itemNode.getBoundingClientRect();\n        // Compute the target X position.\n        var x = itemRect.right - Private.SUBMENU_OVERLAP;\n        // Adjust the X position to fit on the screen.\n        if (x + width > px + cw) {\n            x = itemRect.left + Private.SUBMENU_OVERLAP - width;\n        }\n        // Compute the target Y position.\n        var y = itemRect.top - box.borderTop - box.paddingTop;\n        // Adjust the Y position to fit on the screen.\n        if (y + height > py + ch) {\n            y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;\n        }\n        // Update the position of the menu to the computed position.\n        style.top = Math.max(0, y) + \"px\";\n        style.left = Math.max(0, x) + \"px\";\n        // Finally, make the menu visible on the screen.\n        style.visibility = '';\n    }\n    Private.openSubmenu = openSubmenu;\n    /**\n     * Find the best matching mnemonic item.\n     *\n     * The search starts at the given index and wraps around.\n     */\n    function findMnemonic(items, key, start) {\n        // Setup the result variables.\n        var index = -1;\n        var auto = -1;\n        var multiple = false;\n        // Normalize the key to upper case.\n        var upperKey = key.toUpperCase();\n        // Search the items from the given start index.\n        for (var i = 0, n = items.length; i < n; ++i) {\n            // Compute the wrapped index.\n            var k = (i + start) % n;\n            // Lookup the item\n            var item = items[k];\n            // Ignore items which cannot be activated.\n            if (!canActivate(item)) {\n                continue;\n            }\n            // Ignore items with an empty label.\n            var label = item.label;\n            if (label.length === 0) {\n                continue;\n            }\n            // Lookup the mnemonic index for the label.\n            var mn = item.mnemonic;\n            // Handle a valid mnemonic index.\n            if (mn >= 0 && mn < label.length) {\n                if (label[mn].toUpperCase() === upperKey) {\n                    if (index === -1) {\n                        index = k;\n                    }\n                    else {\n                        multiple = true;\n                    }\n                }\n                continue;\n            }\n            // Finally, handle the auto index if possible.\n            if (auto === -1 && label[0].toUpperCase() === upperKey) {\n                auto = k;\n            }\n        }\n        // Return the search results.\n        return { index: index, multiple: multiple, auto: auto };\n    }\n    Private.findMnemonic = findMnemonic;\n    /**\n     * A concrete implementation of `Menu.IItem`.\n     */\n    var MenuItem = /** @class */ (function () {\n        /**\n         * Construct a new menu item.\n         */\n        function MenuItem(commands, options) {\n            this._commands = commands;\n            this.type = options.type || 'command';\n            this.command = options.command || '';\n            this.args = options.args || _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.JSONExt.emptyObject;\n            this.submenu = options.submenu || null;\n        }\n        Object.defineProperty(MenuItem.prototype, \"label\", {\n            /**\n             * The display label for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.label(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.label;\n                }\n                return '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"mnemonic\", {\n            /**\n             * The mnemonic index for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.mnemonic(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.mnemonic;\n                }\n                return -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"icon\", {\n            /**\n             * The icon renderer for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.icon(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.icon;\n                }\n                /* <DEPRECATED> */\n                // alias to icon class if not otherwise defined\n                return this.iconClass;\n                /* </DEPRECATED> */\n                /* <FUTURE>\n                return undefined;\n                </FUTURE> */\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"iconClass\", {\n            /**\n             * The icon class for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.iconClass(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.iconClass;\n                }\n                return '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"iconLabel\", {\n            /**\n             * The icon label for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.iconLabel(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.iconLabel;\n                }\n                return '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"caption\", {\n            /**\n             * The display caption for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.caption(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.caption;\n                }\n                return '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"className\", {\n            /**\n             * The extra class name for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.className(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.className;\n                }\n                return '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"dataset\", {\n            /**\n             * The dataset for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.dataset(this.command, this.args);\n                }\n                if (this.type === 'submenu' && this.submenu) {\n                    return this.submenu.title.dataset;\n                }\n                return {};\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"isEnabled\", {\n            /**\n             * Whether the menu item is enabled.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.isEnabled(this.command, this.args);\n                }\n                if (this.type === 'submenu') {\n                    return this.submenu !== null;\n                }\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"isToggled\", {\n            /**\n             * Whether the menu item is toggled.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.isToggled(this.command, this.args);\n                }\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"isVisible\", {\n            /**\n             * Whether the menu item is visible.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    return this._commands.isVisible(this.command, this.args);\n                }\n                if (this.type === 'submenu') {\n                    return this.submenu !== null;\n                }\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MenuItem.prototype, \"keyBinding\", {\n            /**\n             * The key binding for the menu item.\n             */\n            get: function () {\n                if (this.type === 'command') {\n                    var _a = this, command_1 = _a.command, args_1 = _a.args;\n                    return _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findLastValue(this._commands.keyBindings, function (kb) {\n                        return kb.command === command_1 && _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.JSONExt.deepEqual(kb.args, args_1);\n                    }) || null;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MenuItem;\n    }());\n})(Private$a || (Private$a = {}));\n\n/**\n * An object which implements a universal context menu.\n *\n * #### Notes\n * The items shown in the context menu are determined by CSS selector\n * matching against the DOM hierarchy at the site of the mouse click.\n * This is similar in concept to how keyboard shortcuts are matched\n * in the command registry.\n */\nvar ContextMenu = /** @class */ (function () {\n    /**\n     * Construct a new context menu.\n     *\n     * @param options - The options for initializing the menu.\n     */\n    function ContextMenu(options) {\n        this._groupByTarget = true;\n        this._idTick = 0;\n        this._items = [];\n        this._sortBySelector = true;\n        var groupByTarget = options.groupByTarget, sortBySelector = options.sortBySelector, others = __rest(options, [\"groupByTarget\", \"sortBySelector\"]);\n        this.menu = new Menu(others);\n        this._groupByTarget = groupByTarget !== false;\n        this._sortBySelector = sortBySelector !== false;\n    }\n    /**\n     * Add an item to the context menu.\n     *\n     * @param options - The options for creating the item.\n     *\n     * @returns A disposable which will remove the item from the menu.\n     */\n    ContextMenu.prototype.addItem = function (options) {\n        var _this = this;\n        // Create an item from the given options.\n        var item = Private$b.createItem(options, this._idTick++);\n        // Add the item to the internal array.\n        this._items.push(item);\n        // Return a disposable which will remove the item.\n        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_9__.DisposableDelegate(function () {\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeFirstOf(_this._items, item);\n        });\n    };\n    /**\n     * Open the context menu in response to a `'contextmenu'` event.\n     *\n     * @param event - The `'contextmenu'` event of interest.\n     *\n     * @returns `true` if the menu was opened, or `false` if no items\n     *   matched the event and the menu was not opened.\n     *\n     * #### Notes\n     * This method will populate the context menu with items which match\n     * the propagation path of the event, then open the menu at the mouse\n     * position indicated by the event.\n     */\n    ContextMenu.prototype.open = function (event) {\n        var _this = this;\n        // Clear the current contents of the context menu.\n        this.menu.clearItems();\n        // Bail early if there are no items to match.\n        if (this._items.length === 0) {\n            return false;\n        }\n        // Find the matching items for the event.\n        var items = Private$b.matchItems(this._items, event, this._groupByTarget, this._sortBySelector);\n        // Bail if there are no matching items.\n        if (!items || items.length === 0) {\n            return false;\n        }\n        // Add the filtered items to the menu.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(items, function (item) {\n            _this.menu.addItem(item);\n        });\n        // Open the context menu at the current mouse position.\n        this.menu.open(event.clientX, event.clientY);\n        // Indicate success.\n        return true;\n    };\n    return ContextMenu;\n}());\n/**\n * The namespace for the module implementation details.\n */\nvar Private$b;\n(function (Private) {\n    /**\n     * Create a normalized context menu item from an options object.\n     */\n    function createItem(options, id) {\n        var selector = validateSelector(options.selector);\n        var rank = options.rank !== undefined ? options.rank : Infinity;\n        return __assign(__assign({}, options), { selector: selector, rank: rank, id: id });\n    }\n    Private.createItem = createItem;\n    /**\n     * Find the items which match a context menu event.\n     *\n     * The results are sorted by DOM level, specificity, and rank.\n     */\n    function matchItems(items, event, groupByTarget, sortBySelector) {\n        // Look up the target of the event.\n        var target = event.target;\n        // Bail if there is no target.\n        if (!target) {\n            return null;\n        }\n        // Look up the current target of the event.\n        var currentTarget = event.currentTarget;\n        // Bail if there is no current target.\n        if (!currentTarget) {\n            return null;\n        }\n        // There are some third party libraries that cause the `target` to\n        // be detached from the DOM before lumino can process the event.\n        // If that happens, search for a new target node by point. If that\n        // node is still dangling, bail.\n        if (!currentTarget.contains(target)) {\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            if (!target || !currentTarget.contains(target)) {\n                return null;\n            }\n        }\n        // Set up the result array.\n        var result = [];\n        // Copy the items array to allow in-place modification.\n        var availableItems = items.slice();\n        // Walk up the DOM hierarchy searching for matches.\n        while (target !== null) {\n            // Set up the match array for this DOM level.\n            var matches = [];\n            // Search the remaining items for matches.\n            for (var i = 0, n = availableItems.length; i < n; ++i) {\n                // Fetch the item.\n                var item = availableItems[i];\n                // Skip items which are already consumed.\n                if (!item) {\n                    continue;\n                }\n                // Skip items which do not match the element.\n                if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Selector.matches(target, item.selector)) {\n                    continue;\n                }\n                // Add the matched item to the result for this DOM level.\n                matches.push(item);\n                // Mark the item as consumed.\n                availableItems[i] = null;\n            }\n            // Sort the matches for this level and add them to the results.\n            if (matches.length !== 0) {\n                if (groupByTarget) {\n                    matches.sort(sortBySelector ? itemCmp : itemCmpRank);\n                }\n                result.push.apply(result, matches);\n            }\n            // Stop searching at the limits of the DOM range.\n            if (target === currentTarget) {\n                break;\n            }\n            // Step to the parent DOM level.\n            target = target.parentElement;\n        }\n        if (!groupByTarget) {\n            result.sort(sortBySelector ? itemCmp : itemCmpRank);\n        }\n        // Return the matched and sorted results.\n        return result;\n    }\n    Private.matchItems = matchItems;\n    /**\n     * Validate the selector for a menu item.\n     *\n     * This returns the validated selector, or throws if the selector is\n     * invalid or contains commas.\n     */\n    function validateSelector(selector) {\n        if (selector.indexOf(',') !== -1) {\n            throw new Error(\"Selector cannot contain commas: \" + selector);\n        }\n        if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Selector.isValid(selector)) {\n            throw new Error(\"Invalid selector: \" + selector);\n        }\n        return selector;\n    }\n    /**\n     * A sort comparison function for a context menu item by ranks.\n     */\n    function itemCmpRank(a, b) {\n        // Sort based on rank.\n        var r1 = a.rank;\n        var r2 = b.rank;\n        if (r1 !== r2) {\n            return r1 < r2 ? -1 : 1; // Infinity-safe\n        }\n        // When all else fails, sort by item id.\n        return a.id - b.id;\n    }\n    /**\n     * A sort comparison function for a context menu item by selectors and ranks.\n     */\n    function itemCmp(a, b) {\n        // Sort first based on selector specificity.\n        var s1 = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Selector.calculateSpecificity(a.selector);\n        var s2 = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Selector.calculateSpecificity(b.selector);\n        if (s1 !== s2) {\n            return s2 - s1;\n        }\n        // If specificities are equal\n        return itemCmpRank(a, b);\n    }\n})(Private$b || (Private$b = {}));\n\n/**\n * A widget which displays titles as a single row or column of tabs.\n *\n * #### Notes\n * If CSS transforms are used to rotate nodes for vertically oriented\n * text, then tab dragging will not work correctly. The `tabsMovable`\n * property should be set to `false` when rotating nodes from CSS.\n */\nvar TabBar = /** @class */ (function (_super) {\n    __extends(TabBar, _super);\n    /**\n     * Construct a new tab bar.\n     *\n     * @param options - The options for initializing the tab bar.\n     */\n    function TabBar(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { node: Private$c.createNode() }) || this;\n        _this._currentIndex = -1;\n        _this._titles = [];\n        _this._titlesEditable = false;\n        _this._previousTitle = null;\n        _this._dragData = null;\n        _this._addButtonEnabled = false;\n        _this._tabMoved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._currentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._addRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._tabCloseRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._tabDetachRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._tabActivateRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this.addClass('lm-TabBar');\n        /* <DEPRECATED> */\n        _this.addClass('p-TabBar');\n        /* </DEPRECATED> */\n        _this.contentNode.setAttribute('role', 'tablist');\n        _this.setFlag(Widget.Flag.DisallowLayout);\n        _this.tabsMovable = options.tabsMovable || false;\n        _this.titlesEditable = options.titlesEditable || false;\n        _this.allowDeselect = options.allowDeselect || false;\n        _this.addButtonEnabled = options.addButtonEnabled || false;\n        _this.insertBehavior = options.insertBehavior || 'select-tab-if-needed';\n        _this.name = options.name || '';\n        _this.orientation = options.orientation || 'horizontal';\n        _this.removeBehavior = options.removeBehavior || 'select-tab-after';\n        _this.renderer = options.renderer || TabBar.defaultRenderer;\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    TabBar.prototype.dispose = function () {\n        this._releaseMouse();\n        this._titles.length = 0;\n        this._previousTitle = null;\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(TabBar.prototype, \"currentChanged\", {\n        /**\n         * A signal emitted when the current tab is changed.\n         *\n         * #### Notes\n         * This signal is emitted when the currently selected tab is changed\n         * either through user or programmatic interaction.\n         *\n         * Notably, this signal is not emitted when the index of the current\n         * tab changes due to tabs being inserted, removed, or moved. It is\n         * only emitted when the actual current tab node is changed.\n         */\n        get: function () {\n            return this._currentChanged;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"tabMoved\", {\n        /**\n         * A signal emitted when a tab is moved by the user.\n         *\n         * #### Notes\n         * This signal is emitted when a tab is moved by user interaction.\n         *\n         * This signal is not emitted when a tab is moved programmatically.\n         */\n        get: function () {\n            return this._tabMoved;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"tabActivateRequested\", {\n        /**\n         * A signal emitted when a tab is clicked by the user.\n         *\n         * #### Notes\n         * If the clicked tab is not the current tab, the clicked tab will be\n         * made current and the `currentChanged` signal will be emitted first.\n         *\n         * This signal is emitted even if the clicked tab is the current tab.\n         */\n        get: function () {\n            return this._tabActivateRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"addRequested\", {\n        /**\n         * A signal emitted when the tab bar add button is clicked.\n         */\n        get: function () {\n            return this._addRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"tabCloseRequested\", {\n        /**\n         * A signal emitted when a tab close icon is clicked.\n         *\n         * #### Notes\n         * This signal is not emitted unless the tab title is `closable`.\n         */\n        get: function () {\n            return this._tabCloseRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"tabDetachRequested\", {\n        /**\n         * A signal emitted when a tab is dragged beyond the detach threshold.\n         *\n         * #### Notes\n         * This signal is emitted when the user drags a tab with the mouse,\n         * and mouse is dragged beyond the detach threshold.\n         *\n         * The consumer of the signal should call `releaseMouse` and remove\n         * the tab in order to complete the detach.\n         *\n         * This signal is only emitted once per drag cycle.\n         */\n        get: function () {\n            return this._tabDetachRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"titlesEditable\", {\n        /**\n         * Whether the titles can be user-edited.\n         *\n         */\n        get: function () {\n            return this._titlesEditable;\n        },\n        /**\n         * Set whether titles can be user edited.\n         *\n         */\n        set: function (value) {\n            this._titlesEditable = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"currentTitle\", {\n        /**\n         * Get the currently selected title.\n         *\n         * #### Notes\n         * This will be `null` if no tab is selected.\n         */\n        get: function () {\n            return this._titles[this._currentIndex] || null;\n        },\n        /**\n         * Set the currently selected title.\n         *\n         * #### Notes\n         * If the title does not exist, the title will be set to `null`.\n         */\n        set: function (value) {\n            this.currentIndex = value ? this._titles.indexOf(value) : -1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"currentIndex\", {\n        /**\n         * Get the index of the currently selected tab.\n         *\n         * #### Notes\n         * This will be `-1` if no tab is selected.\n         */\n        get: function () {\n            return this._currentIndex;\n        },\n        /**\n         * Set the index of the currently selected tab.\n         *\n         * #### Notes\n         * If the value is out of range, the index will be set to `-1`.\n         */\n        set: function (value) {\n            // Adjust for an out of range index.\n            if (value < 0 || value >= this._titles.length) {\n                value = -1;\n            }\n            // Bail early if the index will not change.\n            if (this._currentIndex === value) {\n                return;\n            }\n            // Look up the previous index and title.\n            var pi = this._currentIndex;\n            var pt = this._titles[pi] || null;\n            // Look up the current index and title.\n            var ci = value;\n            var ct = this._titles[ci] || null;\n            // Update the current index and previous title.\n            this._currentIndex = ci;\n            this._previousTitle = pt;\n            // Schedule an update of the tabs.\n            this.update();\n            // Emit the current changed signal.\n            this._currentChanged.emit({\n                previousIndex: pi, previousTitle: pt,\n                currentIndex: ci, currentTitle: ct\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"name\", {\n        /**\n         * Get the name of the tab bar.\n         */\n        get: function () {\n            return this._name;\n        },\n        /**\n         * Set the name of the tab bar.\n         */\n        set: function (value) {\n            this._name = value;\n            if (value) {\n                this.contentNode.setAttribute('aria-label', value);\n            }\n            else {\n                this.contentNode.removeAttribute('aria-label');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"orientation\", {\n        /**\n         * Get the orientation of the tab bar.\n         *\n         * #### Notes\n         * This controls whether the tabs are arranged in a row or column.\n         */\n        get: function () {\n            return this._orientation;\n        },\n        /**\n         * Set the orientation of the tab bar.\n         *\n         * #### Notes\n         * This controls whether the tabs are arranged in a row or column.\n         */\n        set: function (value) {\n            // Do nothing if the orientation does not change.\n            if (this._orientation === value) {\n                return;\n            }\n            // Release the mouse before making any changes.\n            this._releaseMouse();\n            // Toggle the orientation values.\n            this._orientation = value;\n            this.dataset['orientation'] = value;\n            this.contentNode.setAttribute('aria-orientation', value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"addButtonEnabled\", {\n        /**\n         * Whether the add button is enabled.\n         */\n        get: function () {\n            return this._addButtonEnabled;\n        },\n        /**\n         * Set whether the add button is enabled.\n         */\n        set: function (value) {\n            // Do nothing if the value does not change.\n            if (this._addButtonEnabled === value) {\n                return;\n            }\n            this._addButtonEnabled = value;\n            if (value) {\n                this.addButtonNode.classList.remove('lm-mod-hidden');\n            }\n            else {\n                this.addButtonNode.classList.add('lm-mod-hidden');\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"titles\", {\n        /**\n         * A read-only array of the titles in the tab bar.\n         */\n        get: function () {\n            return this._titles;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"contentNode\", {\n        /**\n         * The tab bar content node.\n         *\n         * #### Notes\n         * This is the node which holds the tab nodes.\n         *\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-TabBar-content')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabBar.prototype, \"addButtonNode\", {\n        /**\n         * The tab bar add button node.\n         *\n         * #### Notes\n         * This is the node which holds the add button.\n         *\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-TabBar-addButton')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Add a tab to the end of the tab bar.\n     *\n     * @param value - The title which holds the data for the tab,\n     *   or an options object to convert to a title.\n     *\n     * @returns The title object added to the tab bar.\n     *\n     * #### Notes\n     * If the title is already added to the tab bar, it will be moved.\n     */\n    TabBar.prototype.addTab = function (value) {\n        return this.insertTab(this._titles.length, value);\n    };\n    /**\n     * Insert a tab into the tab bar at the specified index.\n     *\n     * @param index - The index at which to insert the tab.\n     *\n     * @param value - The title which holds the data for the tab,\n     *   or an options object to convert to a title.\n     *\n     * @returns The title object added to the tab bar.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the tabs.\n     *\n     * If the title is already added to the tab bar, it will be moved.\n     */\n    TabBar.prototype.insertTab = function (index, value) {\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Coerce the value to a title.\n        var title = Private$c.asTitle(value);\n        // Look up the index of the title.\n        var i = this._titles.indexOf(title);\n        // Clamp the insert index to the array bounds.\n        var j = Math.max(0, Math.min(index, this._titles.length));\n        // If the title is not in the array, insert it.\n        if (i === -1) {\n            // Insert the title into the array.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._titles, j, title);\n            // Connect to the title changed signal.\n            title.changed.connect(this._onTitleChanged, this);\n            // Schedule an update of the tabs.\n            this.update();\n            // Adjust the current index for the insert.\n            this._adjustCurrentForInsert(j, title);\n            // Return the title added to the tab bar.\n            return title;\n        }\n        // Otherwise, the title exists in the array and should be moved.\n        // Adjust the index if the location is at the end of the array.\n        if (j === this._titles.length) {\n            j--;\n        }\n        // Bail if there is no effective move.\n        if (i === j) {\n            return title;\n        }\n        // Move the title to the new location.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._titles, i, j);\n        // Schedule an update of the tabs.\n        this.update();\n        // Adjust the current index for the move.\n        this._adjustCurrentForMove(i, j);\n        // Return the title added to the tab bar.\n        return title;\n    };\n    /**\n     * Remove a tab from the tab bar.\n     *\n     * @param title - The title for the tab to remove.\n     *\n     * #### Notes\n     * This is a no-op if the title is not in the tab bar.\n     */\n    TabBar.prototype.removeTab = function (title) {\n        this.removeTabAt(this._titles.indexOf(title));\n    };\n    /**\n     * Remove the tab at a given index from the tab bar.\n     *\n     * @param index - The index of the tab to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    TabBar.prototype.removeTabAt = function (index) {\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Remove the title from the array.\n        var title = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._titles, index);\n        // Bail if the index is out of range.\n        if (!title) {\n            return;\n        }\n        // Disconnect from the title changed signal.\n        title.changed.disconnect(this._onTitleChanged, this);\n        // Clear the previous title if it's being removed.\n        if (title === this._previousTitle) {\n            this._previousTitle = null;\n        }\n        // Schedule an update of the tabs.\n        this.update();\n        // Adjust the current index for the remove.\n        this._adjustCurrentForRemove(index, title);\n    };\n    /**\n     * Remove all tabs from the tab bar.\n     */\n    TabBar.prototype.clearTabs = function () {\n        // Bail if there is nothing to remove.\n        if (this._titles.length === 0) {\n            return;\n        }\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Disconnect from the title changed signals.\n        for (var _i = 0, _a = this._titles; _i < _a.length; _i++) {\n            var title = _a[_i];\n            title.changed.disconnect(this._onTitleChanged, this);\n        }\n        // Get the current index and title.\n        var pi = this.currentIndex;\n        var pt = this.currentTitle;\n        // Reset the current index and previous title.\n        this._currentIndex = -1;\n        this._previousTitle = null;\n        // Clear the title array.\n        this._titles.length = 0;\n        // Schedule an update of the tabs.\n        this.update();\n        // If no tab was selected, there's nothing else to do.\n        if (pi === -1) {\n            return;\n        }\n        // Emit the current changed signal.\n        this._currentChanged.emit({\n            previousIndex: pi, previousTitle: pt,\n            currentIndex: -1, currentTitle: null\n        });\n    };\n    /**\n     * Release the mouse and restore the non-dragged tab positions.\n     *\n     * #### Notes\n     * This will cause the tab bar to stop handling mouse events and to\n     * restore the tabs to their non-dragged positions.\n     */\n    TabBar.prototype.releaseMouse = function () {\n        this._releaseMouse();\n    };\n    /**\n     * Handle the DOM events for the tab bar.\n     *\n     * @param event - The DOM event sent to the tab bar.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the tab bar's DOM node.\n     *\n     * This should not be called directly by user code.\n     */\n    TabBar.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    TabBar.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('mousedown', this);\n        this.node.addEventListener('dblclick', this);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    TabBar.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('mousedown', this);\n        this.node.removeEventListener('dblclick', this);\n        this._releaseMouse();\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    TabBar.prototype.onUpdateRequest = function (msg) {\n        var titles = this._titles;\n        var renderer = this.renderer;\n        var currentTitle = this.currentTitle;\n        var content = new Array(titles.length);\n        for (var i = 0, n = titles.length; i < n; ++i) {\n            var title = titles[i];\n            var current = title === currentTitle;\n            var zIndex = current ? n : n - i - 1;\n            content[i] = renderer.renderTab({ title: title, current: current, zIndex: zIndex });\n        }\n        _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.render(content, this.contentNode);\n    };\n    /**\n     * Handle the `'dblclick'` event for the tab bar.\n     */\n    TabBar.prototype._evtDblClick = function (event) {\n        // Do nothing if titles are not editable\n        if (!this.titlesEditable) {\n            return;\n        }\n        var tabs = this.contentNode.children;\n        // Find the index of the released tab.\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(tabs, function (tab) {\n            return _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(tab, event.clientX, event.clientY);\n        });\n        // Do nothing if the press is not on a tab.\n        if (index === -1) {\n            return;\n        }\n        var title = this.titles[index];\n        var label = tabs[index].querySelector('.lm-TabBar-tabLabel');\n        if (label && label.contains(event.target)) {\n            var value = title.label || '';\n            // Clear the label element\n            var oldValue_1 = label.innerHTML;\n            label.innerHTML = \"\";\n            var input_1 = document.createElement('input');\n            input_1.classList.add('lm-TabBar-tabInput');\n            input_1.value = value;\n            label.appendChild(input_1);\n            var onblur_1 = function () {\n                input_1.removeEventListener('blur', onblur_1);\n                label.innerHTML = oldValue_1;\n            };\n            input_1.addEventListener('dblclick', function (event) { return event.stopPropagation(); });\n            input_1.addEventListener('blur', onblur_1);\n            input_1.addEventListener('keydown', function (event) {\n                if (event.key === 'Enter') {\n                    if (input_1.value !== '') {\n                        title.label = title.caption = input_1.value;\n                    }\n                    onblur_1();\n                }\n                else if (event.key === 'Escape') {\n                    onblur_1();\n                }\n            });\n            input_1.select();\n            input_1.focus();\n            if (label.children.length > 0) {\n                label.children[0].focus();\n            }\n        }\n    };\n    /**\n     * Handle the `'keydown'` event for the tab bar.\n     */\n    TabBar.prototype._evtKeyDown = function (event) {\n        // Stop all input events during drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Release the mouse if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            this._releaseMouse();\n        }\n    };\n    /**\n     * Handle the `'mousedown'` event for the tab bar.\n     */\n    TabBar.prototype._evtMouseDown = function (event) {\n        // Do nothing if it's not a left or middle mouse press.\n        if (event.button !== 0 && event.button !== 1) {\n            return;\n        }\n        // Do nothing if a drag is in progress.\n        if (this._dragData) {\n            return;\n        }\n        // Check if the add button was clicked.\n        var addButtonClicked = this.addButtonEnabled &&\n            this.addButtonNode.contains(event.target);\n        // Lookup the tab nodes.\n        var tabs = this.contentNode.children;\n        // Find the index of the pressed tab.\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(tabs, function (tab) {\n            return _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(tab, event.clientX, event.clientY);\n        });\n        // Do nothing if the press is not on a tab or the add button.\n        if (index === -1 && !addButtonClicked) {\n            return;\n        }\n        // Pressing on a tab stops the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Initialize the non-measured parts of the drag data.\n        this._dragData = {\n            tab: tabs[index],\n            index: index,\n            pressX: event.clientX,\n            pressY: event.clientY,\n            tabPos: -1,\n            tabSize: -1,\n            tabPressPos: -1,\n            targetIndex: -1,\n            tabLayout: null,\n            contentRect: null,\n            override: null,\n            dragActive: false,\n            dragAborted: false,\n            detachRequested: false\n        };\n        // Add the document mouse up listener.\n        document.addEventListener('mouseup', this, true);\n        // Do nothing else if the middle button or add button is clicked.\n        if (event.button === 1 || addButtonClicked) {\n            return;\n        }\n        // Do nothing else if the close icon is clicked.\n        var icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n        if (icon && icon.contains(event.target)) {\n            return;\n        }\n        // Add the extra listeners if the tabs are movable.\n        if (this.tabsMovable) {\n            document.addEventListener('mousemove', this, true);\n            document.addEventListener('keydown', this, true);\n            document.addEventListener('contextmenu', this, true);\n        }\n        // Update the current index as appropriate.\n        if (this.allowDeselect && this.currentIndex === index) {\n            this.currentIndex = -1;\n        }\n        else {\n            this.currentIndex = index;\n        }\n        // Do nothing else if there is no current tab.\n        if (this.currentIndex === -1) {\n            return;\n        }\n        // Emit the tab activate request signal.\n        this._tabActivateRequested.emit({\n            index: this.currentIndex, title: this.currentTitle\n        });\n    };\n    /**\n     * Handle the `'mousemove'` event for the tab bar.\n     */\n    TabBar.prototype._evtMouseMove = function (event) {\n        // Do nothing if no drag is in progress.\n        var data = this._dragData;\n        if (!data) {\n            return;\n        }\n        // Suppress the event during a drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Lookup the tab nodes.\n        var tabs = this.contentNode.children;\n        // Bail early if the drag threshold has not been met.\n        if (!data.dragActive && !Private$c.dragExceeded(data, event)) {\n            return;\n        }\n        // Activate the drag if necessary.\n        if (!data.dragActive) {\n            // Fill in the rest of the drag data measurements.\n            var tabRect = data.tab.getBoundingClientRect();\n            if (this._orientation === 'horizontal') {\n                data.tabPos = data.tab.offsetLeft;\n                data.tabSize = tabRect.width;\n                data.tabPressPos = data.pressX - tabRect.left;\n            }\n            else {\n                data.tabPos = data.tab.offsetTop;\n                data.tabSize = tabRect.height;\n                data.tabPressPos = data.pressY - tabRect.top;\n            }\n            data.tabLayout = Private$c.snapTabLayout(tabs, this._orientation);\n            data.contentRect = this.contentNode.getBoundingClientRect();\n            data.override = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__.Drag.overrideCursor('default');\n            // Add the dragging style classes.\n            data.tab.classList.add('lm-mod-dragging');\n            this.addClass('lm-mod-dragging');\n            /* <DEPRECATED> */\n            data.tab.classList.add('p-mod-dragging');\n            this.addClass('p-mod-dragging');\n            /* </DEPRECATED> */\n            // Mark the drag as active.\n            data.dragActive = true;\n        }\n        // Emit the detach requested signal if the threshold is exceeded.\n        if (!data.detachRequested && Private$c.detachExceeded(data, event)) {\n            // Only emit the signal once per drag cycle.\n            data.detachRequested = true;\n            // Setup the arguments for the signal.\n            var index = data.index;\n            var clientX = event.clientX;\n            var clientY = event.clientY;\n            var tab = tabs[index];\n            var title = this._titles[index];\n            // Emit the tab detach requested signal.\n            this._tabDetachRequested.emit({ index: index, title: title, tab: tab, clientX: clientX, clientY: clientY });\n            // Bail if the signal handler aborted the drag.\n            if (data.dragAborted) {\n                return;\n            }\n        }\n        // Update the positions of the tabs.\n        Private$c.layoutTabs(tabs, data, event, this._orientation);\n    };\n    /**\n     * Handle the `'mouseup'` event for the document.\n     */\n    TabBar.prototype._evtMouseUp = function (event) {\n        var _this = this;\n        // Do nothing if it's not a left or middle mouse release.\n        if (event.button !== 0 && event.button !== 1) {\n            return;\n        }\n        // Do nothing if no drag is in progress.\n        var data = this._dragData;\n        if (!data) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Remove the extra mouse event listeners.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('contextmenu', this, true);\n        // Handle a release when the drag is not active.\n        if (!data.dragActive) {\n            // Clear the drag data.\n            this._dragData = null;\n            // Handle clicking the add button.\n            var addButtonClicked = this.addButtonEnabled &&\n                this.addButtonNode.contains(event.target);\n            if (addButtonClicked) {\n                this._addRequested.emit(undefined);\n                return;\n            }\n            // Lookup the tab nodes.\n            var tabs = this.contentNode.children;\n            // Find the index of the released tab.\n            var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(tabs, function (tab) {\n                return _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(tab, event.clientX, event.clientY);\n            });\n            // Do nothing if the release is not on the original pressed tab.\n            if (index !== data.index) {\n                return;\n            }\n            // Ignore the release if the title is not closable.\n            var title = this._titles[index];\n            if (!title.closable) {\n                return;\n            }\n            // Emit the close requested signal if the middle button is released.\n            if (event.button === 1) {\n                this._tabCloseRequested.emit({ index: index, title: title });\n                return;\n            }\n            // Emit the close requested signal if the close icon was released.\n            var icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n            if (icon && icon.contains(event.target)) {\n                this._tabCloseRequested.emit({ index: index, title: title });\n                return;\n            }\n            // Otherwise, there is nothing left to do.\n            return;\n        }\n        // Do nothing if the left button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Position the tab at its final resting position.\n        Private$c.finalizeTabPosition(data, this._orientation);\n        // Remove the dragging class from the tab so it can be transitioned.\n        data.tab.classList.remove('lm-mod-dragging');\n        /* <DEPRECATED> */\n        data.tab.classList.remove('p-mod-dragging');\n        /* </DEPRECATED> */\n        // Parse the transition duration for releasing the tab.\n        var duration = Private$c.parseTransitionDuration(data.tab);\n        // Complete the release on a timer to allow the tab to transition.\n        setTimeout(function () {\n            // Do nothing if the drag has been aborted.\n            if (data.dragAborted) {\n                return;\n            }\n            // Clear the drag data reference.\n            _this._dragData = null;\n            // Reset the positions of the tabs.\n            Private$c.resetTabPositions(_this.contentNode.children, _this._orientation);\n            // Clear the cursor grab.\n            data.override.dispose();\n            // Remove the remaining dragging style.\n            _this.removeClass('lm-mod-dragging');\n            /* <DEPRECATED> */\n            _this.removeClass('p-mod-dragging');\n            /* </DEPRECATED> */\n            // If the tab was not moved, there is nothing else to do.\n            var i = data.index;\n            var j = data.targetIndex;\n            if (j === -1 || i === j) {\n                return;\n            }\n            // Move the title to the new locations.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(_this._titles, i, j);\n            // Adjust the current index for the move.\n            _this._adjustCurrentForMove(i, j);\n            // Emit the tab moved signal.\n            _this._tabMoved.emit({\n                fromIndex: i, toIndex: j, title: _this._titles[j]\n            });\n            // Update the tabs immediately to prevent flicker.\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(_this, Widget.Msg.UpdateRequest);\n        }, duration);\n    };\n    /**\n     * Release the mouse and restore the non-dragged tab positions.\n     */\n    TabBar.prototype._releaseMouse = function () {\n        // Do nothing if no drag is in progress.\n        var data = this._dragData;\n        if (!data) {\n            return;\n        }\n        // Clear the drag data reference.\n        this._dragData = null;\n        // Remove the extra mouse listeners.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('contextmenu', this, true);\n        // Indicate the drag has been aborted. This allows the mouse\n        // event handlers to return early when the drag is canceled.\n        data.dragAborted = true;\n        // If the drag is not active, there's nothing more to do.\n        if (!data.dragActive) {\n            return;\n        }\n        // Reset the tabs to their non-dragged positions.\n        Private$c.resetTabPositions(this.contentNode.children, this._orientation);\n        // Clear the cursor override.\n        data.override.dispose();\n        // Clear the dragging style classes.\n        data.tab.classList.remove('lm-mod-dragging');\n        this.removeClass('lm-mod-dragging');\n        /* <DEPRECATED> */\n        data.tab.classList.remove('p-mod-dragging');\n        this.removeClass('p-mod-dragging');\n        /* </DEPRECATED> */\n    };\n    /**\n     * Adjust the current index for a tab insert operation.\n     *\n     * This method accounts for the tab bar's insertion behavior when\n     * adjusting the current index and emitting the changed signal.\n     */\n    TabBar.prototype._adjustCurrentForInsert = function (i, title) {\n        // Lookup commonly used variables.\n        var ct = this.currentTitle;\n        var ci = this._currentIndex;\n        var bh = this.insertBehavior;\n        // TODO: do we need to do an update to update the aria-selected attribute?\n        // Handle the behavior where the new tab is always selected,\n        // or the behavior where the new tab is selected if needed.\n        if (bh === 'select-tab' || (bh === 'select-tab-if-needed' && ci === -1)) {\n            this._currentIndex = i;\n            this._previousTitle = ct;\n            this._currentChanged.emit({\n                previousIndex: ci, previousTitle: ct,\n                currentIndex: i, currentTitle: title\n            });\n            return;\n        }\n        // Otherwise, silently adjust the current index if needed.\n        if (ci >= i) {\n            this._currentIndex++;\n        }\n    };\n    /**\n     * Adjust the current index for a tab move operation.\n     *\n     * This method will not cause the actual current tab to change.\n     * It silently adjusts the index to account for the given move.\n     */\n    TabBar.prototype._adjustCurrentForMove = function (i, j) {\n        if (this._currentIndex === i) {\n            this._currentIndex = j;\n        }\n        else if (this._currentIndex < i && this._currentIndex >= j) {\n            this._currentIndex++;\n        }\n        else if (this._currentIndex > i && this._currentIndex <= j) {\n            this._currentIndex--;\n        }\n    };\n    /**\n     * Adjust the current index for a tab remove operation.\n     *\n     * This method accounts for the tab bar's remove behavior when\n     * adjusting the current index and emitting the changed signal.\n     */\n    TabBar.prototype._adjustCurrentForRemove = function (i, title) {\n        // Lookup commonly used variables.\n        var ci = this._currentIndex;\n        var bh = this.removeBehavior;\n        // Silently adjust the index if the current tab is not removed.\n        if (ci !== i) {\n            if (ci > i) {\n                this._currentIndex--;\n            }\n            return;\n        }\n        // TODO: do we need to do an update to adjust the aria-selected value?\n        // No tab gets selected if the tab bar is empty.\n        if (this._titles.length === 0) {\n            this._currentIndex = -1;\n            this._currentChanged.emit({\n                previousIndex: i, previousTitle: title,\n                currentIndex: -1, currentTitle: null\n            });\n            return;\n        }\n        // Handle behavior where the next sibling tab is selected.\n        if (bh === 'select-tab-after') {\n            this._currentIndex = Math.min(i, this._titles.length - 1);\n            this._currentChanged.emit({\n                previousIndex: i, previousTitle: title,\n                currentIndex: this._currentIndex, currentTitle: this.currentTitle\n            });\n            return;\n        }\n        // Handle behavior where the previous sibling tab is selected.\n        if (bh === 'select-tab-before') {\n            this._currentIndex = Math.max(0, i - 1);\n            this._currentChanged.emit({\n                previousIndex: i, previousTitle: title,\n                currentIndex: this._currentIndex, currentTitle: this.currentTitle\n            });\n            return;\n        }\n        // Handle behavior where the previous history tab is selected.\n        if (bh === 'select-previous-tab') {\n            if (this._previousTitle) {\n                this._currentIndex = this._titles.indexOf(this._previousTitle);\n                this._previousTitle = null;\n            }\n            else {\n                this._currentIndex = Math.min(i, this._titles.length - 1);\n            }\n            this._currentChanged.emit({\n                previousIndex: i, previousTitle: title,\n                currentIndex: this._currentIndex, currentTitle: this.currentTitle\n            });\n            return;\n        }\n        // Otherwise, no tab gets selected.\n        this._currentIndex = -1;\n        this._currentChanged.emit({\n            previousIndex: i, previousTitle: title,\n            currentIndex: -1, currentTitle: null\n        });\n    };\n    /**\n     * Handle the `changed` signal of a title object.\n     */\n    TabBar.prototype._onTitleChanged = function (sender) {\n        this.update();\n    };\n    return TabBar;\n}(Widget));\n/**\n * The namespace for the `TabBar` class statics.\n */\n(function (TabBar) {\n    /**\n     * The default implementation of `IRenderer`.\n     *\n     * #### Notes\n     * Subclasses are free to reimplement rendering methods as needed.\n     */\n    var Renderer = /** @class */ (function () {\n        /**\n         * Construct a new renderer.\n         */\n        function Renderer() {\n            /**\n             * A selector which matches the close icon node in a tab.\n             */\n            this.closeIconSelector = '.lm-TabBar-tabCloseIcon';\n            this._tabID = 0;\n            this._tabKeys = new WeakMap();\n        }\n        /**\n         * Render the virtual element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab.\n         */\n        Renderer.prototype.renderTab = function (data) {\n            var title = data.title.caption;\n            var key = this.createTabKey(data);\n            var id = key;\n            var style = this.createTabStyle(data);\n            var className = this.createTabClass(data);\n            var dataset = this.createTabDataset(data);\n            var aria = this.createTabARIA(data);\n            if (data.title.closable) {\n                return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li(__assign({ id: id, key: key, className: className, title: title, style: style, dataset: dataset }, aria), this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data)));\n            }\n            else {\n                return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li(__assign({ id: id, key: key, className: className, title: title, style: style, dataset: dataset }, aria), this.renderIcon(data), this.renderLabel(data)));\n            }\n        };\n        /**\n         * Render the icon element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab icon.\n         */\n        Renderer.prototype.renderIcon = function (data) {\n            var title = data.title;\n            var className = this.createIconClass(data);\n            /* <DEPRECATED> */\n            if (typeof title.icon === 'string') {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, title.iconLabel);\n            }\n            /* </DEPRECATED> */\n            // if title.icon is undefined, it will be ignored\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, title.icon, title.iconLabel);\n        };\n        /**\n         * Render the label element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab label.\n         */\n        Renderer.prototype.renderLabel = function (data) {\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-TabBar-tabLabel'\n                    /* <DEPRECATED> */\n                    + ' p-TabBar-tabLabel'\n                /* </DEPRECATED> */\n            }, data.title.label);\n        };\n        /**\n         * Render the close icon element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab close icon.\n         */\n        Renderer.prototype.renderCloseIcon = function (data) {\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({\n                className: 'lm-TabBar-tabCloseIcon'\n                    /* <DEPRECATED> */\n                    + ' p-TabBar-tabCloseIcon'\n                /* </DEPRECATED> */\n            });\n        };\n        /**\n         * Create a unique render key for the tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The unique render key for the tab.\n         *\n         * #### Notes\n         * This method caches the key against the tab title the first time\n         * the key is generated. This enables efficient rendering of moved\n         * tabs and avoids subtle hover style artifacts.\n         */\n        Renderer.prototype.createTabKey = function (data) {\n            var key = this._tabKeys.get(data.title);\n            if (key === undefined) {\n                key = \"tab-key-\" + this._tabID++;\n                this._tabKeys.set(data.title, key);\n            }\n            return key;\n        };\n        /**\n         * Create the inline style object for a tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The inline style data for the tab.\n         */\n        Renderer.prototype.createTabStyle = function (data) {\n            return { zIndex: \"\" + data.zIndex };\n        };\n        /**\n         * Create the class name for the tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The full class name for the tab.\n         */\n        Renderer.prototype.createTabClass = function (data) {\n            var name = 'lm-TabBar-tab';\n            /* <DEPRECATED> */\n            name += ' p-TabBar-tab';\n            /* </DEPRECATED> */\n            if (data.title.className) {\n                name += \" \" + data.title.className;\n            }\n            if (data.title.closable) {\n                name += ' lm-mod-closable';\n                /* <DEPRECATED> */\n                name += ' p-mod-closable';\n                /* </DEPRECATED> */\n            }\n            if (data.current) {\n                name += ' lm-mod-current';\n                /* <DEPRECATED> */\n                name += ' p-mod-current';\n                /* </DEPRECATED> */\n            }\n            return name;\n        };\n        /**\n         * Create the dataset for a tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The dataset for the tab.\n         */\n        Renderer.prototype.createTabDataset = function (data) {\n            return data.title.dataset;\n        };\n        /**\n         * Create the ARIA attributes for a tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The ARIA attributes for the tab.\n         */\n        Renderer.prototype.createTabARIA = function (data) {\n            return { role: 'tab', 'aria-selected': data.current.toString() };\n        };\n        /**\n         * Create the class name for the tab icon.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The full class name for the tab icon.\n         */\n        Renderer.prototype.createIconClass = function (data) {\n            var name = 'lm-TabBar-tabIcon';\n            /* <DEPRECATED> */\n            name += ' p-TabBar-tabIcon';\n            /* </DEPRECATED> */\n            var extra = data.title.iconClass;\n            return extra ? name + \" \" + extra : name;\n        };\n        return Renderer;\n    }());\n    TabBar.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    TabBar.defaultRenderer = new Renderer();\n    /**\n     * A selector which matches the add button node in the tab bar.\n     */\n    TabBar.addButtonSelector = '.lm-TabBar-addButton';\n})(TabBar || (TabBar = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$c;\n(function (Private) {\n    /**\n     * The start drag distance threshold.\n     */\n    Private.DRAG_THRESHOLD = 5;\n    /**\n     * The detach distance threshold.\n     */\n    Private.DETACH_THRESHOLD = 20;\n    /**\n     * Create the DOM node for a tab bar.\n     */\n    function createNode() {\n        var node = document.createElement('div');\n        var content = document.createElement('ul');\n        content.setAttribute('role', 'tablist');\n        content.className = 'lm-TabBar-content';\n        /* <DEPRECATED> */\n        content.classList.add('p-TabBar-content');\n        /* </DEPRECATED> */\n        node.appendChild(content);\n        var add = document.createElement('div');\n        add.className = 'lm-TabBar-addButton lm-mod-hidden';\n        node.appendChild(add);\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Coerce a title or options into a real title.\n     */\n    function asTitle(value) {\n        return value instanceof Title ? value : new Title(value);\n    }\n    Private.asTitle = asTitle;\n    /**\n     * Parse the transition duration for a tab node.\n     */\n    function parseTransitionDuration(tab) {\n        var style = window.getComputedStyle(tab);\n        return 1000 * (parseFloat(style.transitionDuration) || 0);\n    }\n    Private.parseTransitionDuration = parseTransitionDuration;\n    /**\n     * Get a snapshot of the current tab layout values.\n     */\n    function snapTabLayout(tabs, orientation) {\n        var layout = new Array(tabs.length);\n        for (var i = 0, n = tabs.length; i < n; ++i) {\n            var node = tabs[i];\n            var style = window.getComputedStyle(node);\n            if (orientation === 'horizontal') {\n                layout[i] = {\n                    pos: node.offsetLeft,\n                    size: node.offsetWidth,\n                    margin: parseFloat(style.marginLeft) || 0\n                };\n            }\n            else {\n                layout[i] = {\n                    pos: node.offsetTop,\n                    size: node.offsetHeight,\n                    margin: parseFloat(style.marginTop) || 0\n                };\n            }\n        }\n        return layout;\n    }\n    Private.snapTabLayout = snapTabLayout;\n    /**\n     * Test if the event exceeds the drag threshold.\n     */\n    function dragExceeded(data, event) {\n        var dx = Math.abs(event.clientX - data.pressX);\n        var dy = Math.abs(event.clientY - data.pressY);\n        return dx >= Private.DRAG_THRESHOLD || dy >= Private.DRAG_THRESHOLD;\n    }\n    Private.dragExceeded = dragExceeded;\n    /**\n     * Test if the event exceeds the drag detach threshold.\n     */\n    function detachExceeded(data, event) {\n        var rect = data.contentRect;\n        return ((event.clientX < rect.left - Private.DETACH_THRESHOLD) ||\n            (event.clientX >= rect.right + Private.DETACH_THRESHOLD) ||\n            (event.clientY < rect.top - Private.DETACH_THRESHOLD) ||\n            (event.clientY >= rect.bottom + Private.DETACH_THRESHOLD));\n    }\n    Private.detachExceeded = detachExceeded;\n    /**\n     * Update the relative tab positions and computed target index.\n     */\n    function layoutTabs(tabs, data, event, orientation) {\n        // Compute the orientation-sensitive values.\n        var pressPos;\n        var localPos;\n        var clientPos;\n        var clientSize;\n        if (orientation === 'horizontal') {\n            pressPos = data.pressX;\n            localPos = event.clientX - data.contentRect.left;\n            clientPos = event.clientX;\n            clientSize = data.contentRect.width;\n        }\n        else {\n            pressPos = data.pressY;\n            localPos = event.clientY - data.contentRect.top;\n            clientPos = event.clientY;\n            clientSize = data.contentRect.height;\n        }\n        // Compute the target data.\n        var targetIndex = data.index;\n        var targetPos = localPos - data.tabPressPos;\n        var targetEnd = targetPos + data.tabSize;\n        // Update the relative tab positions.\n        for (var i = 0, n = tabs.length; i < n; ++i) {\n            var pxPos = void 0;\n            var layout = data.tabLayout[i];\n            var threshold = layout.pos + (layout.size >> 1);\n            if (i < data.index && targetPos < threshold) {\n                pxPos = data.tabSize + data.tabLayout[i + 1].margin + \"px\";\n                targetIndex = Math.min(targetIndex, i);\n            }\n            else if (i > data.index && targetEnd > threshold) {\n                pxPos = -data.tabSize - layout.margin + \"px\";\n                targetIndex = Math.max(targetIndex, i);\n            }\n            else if (i === data.index) {\n                var ideal = clientPos - pressPos;\n                var limit = clientSize - (data.tabPos + data.tabSize);\n                pxPos = Math.max(-data.tabPos, Math.min(ideal, limit)) + \"px\";\n            }\n            else {\n                pxPos = '';\n            }\n            if (orientation === 'horizontal') {\n                tabs[i].style.left = pxPos;\n            }\n            else {\n                tabs[i].style.top = pxPos;\n            }\n        }\n        // Update the computed target index.\n        data.targetIndex = targetIndex;\n    }\n    Private.layoutTabs = layoutTabs;\n    /**\n     * Position the drag tab at its final resting relative position.\n     */\n    function finalizeTabPosition(data, orientation) {\n        // Compute the orientation-sensitive client size.\n        var clientSize;\n        if (orientation === 'horizontal') {\n            clientSize = data.contentRect.width;\n        }\n        else {\n            clientSize = data.contentRect.height;\n        }\n        // Compute the ideal final tab position.\n        var ideal;\n        if (data.targetIndex === data.index) {\n            ideal = 0;\n        }\n        else if (data.targetIndex > data.index) {\n            var tgt = data.tabLayout[data.targetIndex];\n            ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;\n        }\n        else {\n            var tgt = data.tabLayout[data.targetIndex];\n            ideal = tgt.pos - data.tabPos;\n        }\n        // Compute the tab position limit.\n        var limit = clientSize - (data.tabPos + data.tabSize);\n        var final = Math.max(-data.tabPos, Math.min(ideal, limit));\n        // Set the final orientation-sensitive position.\n        if (orientation === 'horizontal') {\n            data.tab.style.left = final + \"px\";\n        }\n        else {\n            data.tab.style.top = final + \"px\";\n        }\n    }\n    Private.finalizeTabPosition = finalizeTabPosition;\n    /**\n     * Reset the relative positions of the given tabs.\n     */\n    function resetTabPositions(tabs, orientation) {\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(tabs, function (tab) {\n            if (orientation === 'horizontal') {\n                tab.style.left = '';\n            }\n            else {\n                tab.style.top = '';\n            }\n        });\n    }\n    Private.resetTabPositions = resetTabPositions;\n})(Private$c || (Private$c = {}));\n\n/**\n * A layout which provides a flexible docking arrangement.\n *\n * #### Notes\n * The consumer of this layout is responsible for handling all signals\n * from the generated tab bars and managing the visibility of widgets\n * and tab bars as needed.\n */\nvar DockLayout = /** @class */ (function (_super) {\n    __extends(DockLayout, _super);\n    /**\n     * Construct a new dock layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    function DockLayout(options) {\n        var _this = _super.call(this) || this;\n        _this._spacing = 4;\n        _this._dirty = false;\n        _this._root = null;\n        _this._box = null;\n        _this._items = new Map();\n        _this.renderer = options.renderer;\n        if (options.spacing !== undefined) {\n            _this._spacing = Utils$1.clampDimension(options.spacing);\n        }\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     *\n     * #### Notes\n     * This will clear and dispose all widgets in the layout.\n     */\n    DockLayout.prototype.dispose = function () {\n        // Get an iterator over the widgets in the layout.\n        var widgets = this.iter();\n        // Dispose of the layout items.\n        this._items.forEach(function (item) { item.dispose(); });\n        // Clear the layout state before disposing the widgets.\n        this._box = null;\n        this._root = null;\n        this._items.clear();\n        // Dispose of the widgets contained in the old layout root.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(widgets, function (widget) { widget.dispose(); });\n        // Dispose of the base class.\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(DockLayout.prototype, \"spacing\", {\n        /**\n         * Get the inter-element spacing for the dock layout.\n         */\n        get: function () {\n            return this._spacing;\n        },\n        /**\n         * Set the inter-element spacing for the dock layout.\n         */\n        set: function (value) {\n            value = Utils$1.clampDimension(value);\n            if (this._spacing === value) {\n                return;\n            }\n            this._spacing = value;\n            if (!this.parent) {\n                return;\n            }\n            this.parent.fit();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockLayout.prototype, \"isEmpty\", {\n        /**\n         * Whether the dock layout is empty.\n         */\n        get: function () {\n            return this._root === null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over all widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     *\n     * #### Notes\n     * This iterator includes the generated tab bars.\n     */\n    DockLayout.prototype.iter = function () {\n        return this._root ? this._root.iterAllWidgets() : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Create an iterator over the user widgets in the layout.\n     *\n     * @returns A new iterator over the user widgets in the layout.\n     *\n     * #### Notes\n     * This iterator does not include the generated tab bars.\n     */\n    DockLayout.prototype.widgets = function () {\n        return this._root ? this._root.iterUserWidgets() : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Create an iterator over the selected widgets in the layout.\n     *\n     * @returns A new iterator over the selected user widgets.\n     *\n     * #### Notes\n     * This iterator yields the widgets corresponding to the current tab\n     * of each tab bar in the layout.\n     */\n    DockLayout.prototype.selectedWidgets = function () {\n        return this._root ? this._root.iterSelectedWidgets() : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Create an iterator over the tab bars in the layout.\n     *\n     * @returns A new iterator over the tab bars in the layout.\n     *\n     * #### Notes\n     * This iterator does not include the user widgets.\n     */\n    DockLayout.prototype.tabBars = function () {\n        return this._root ? this._root.iterTabBars() : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Create an iterator over the handles in the layout.\n     *\n     * @returns A new iterator over the handles in the layout.\n     */\n    DockLayout.prototype.handles = function () {\n        return this._root ? this._root.iterHandles() : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Move a handle to the given offset position.\n     *\n     * @param handle - The handle to move.\n     *\n     * @param offsetX - The desired offset X position of the handle.\n     *\n     * @param offsetY - The desired offset Y position of the handle.\n     *\n     * #### Notes\n     * If the given handle is not contained in the layout, this is no-op.\n     *\n     * The handle will be moved as close as possible to the desired\n     * position without violating any of the layout constraints.\n     *\n     * Only one of the coordinates is used depending on the orientation\n     * of the handle. This method accepts both coordinates to make it\n     * easy to invoke from a mouse move event without needing to know\n     * the handle orientation.\n     */\n    DockLayout.prototype.moveHandle = function (handle, offsetX, offsetY) {\n        // Bail early if there is no root or if the handle is hidden.\n        var hidden = handle.classList.contains('lm-mod-hidden');\n        /* <DEPRECATED> */\n        hidden = hidden || handle.classList.contains('p-mod-hidden');\n        /* </DEPRECATED> */\n        if (!this._root || hidden) {\n            return;\n        }\n        // Lookup the split node for the handle.\n        var data = this._root.findSplitNode(handle);\n        if (!data) {\n            return;\n        }\n        // Compute the desired delta movement for the handle.\n        var delta;\n        if (data.node.orientation === 'horizontal') {\n            delta = offsetX - handle.offsetLeft;\n        }\n        else {\n            delta = offsetY - handle.offsetTop;\n        }\n        // Bail if there is no handle movement.\n        if (delta === 0) {\n            return;\n        }\n        // Prevent sibling resizing unless needed.\n        data.node.holdSizes();\n        // Adjust the sizers to reflect the handle movement.\n        BoxEngine.adjust(data.node.sizers, data.index, delta);\n        // Update the layout of the widgets.\n        if (this.parent) {\n            this.parent.update();\n        }\n    };\n    /**\n     * Save the current configuration of the dock layout.\n     *\n     * @returns A new config object for the current layout state.\n     *\n     * #### Notes\n     * The return value can be provided to the `restoreLayout` method\n     * in order to restore the layout to its current configuration.\n     */\n    DockLayout.prototype.saveLayout = function () {\n        // Bail early if there is no root.\n        if (!this._root) {\n            return { main: null };\n        }\n        // Hold the current sizes in the layout tree.\n        this._root.holdAllSizes();\n        // Return the layout config.\n        return { main: this._root.createConfig() };\n    };\n    /**\n     * Restore the layout to a previously saved configuration.\n     *\n     * @param config - The layout configuration to restore.\n     *\n     * #### Notes\n     * Widgets which currently belong to the layout but which are not\n     * contained in the config will be unparented.\n     */\n    DockLayout.prototype.restoreLayout = function (config) {\n        var _this = this;\n        // Create the widget set for validating the config.\n        var widgetSet = new Set();\n        // Normalize the main area config and collect the widgets.\n        var mainConfig;\n        if (config.main) {\n            mainConfig = Private$d.normalizeAreaConfig(config.main, widgetSet);\n        }\n        else {\n            mainConfig = null;\n        }\n        // Create iterators over the old content.\n        var oldWidgets = this.widgets();\n        var oldTabBars = this.tabBars();\n        var oldHandles = this.handles();\n        // Clear the root before removing the old content.\n        this._root = null;\n        // Unparent the old widgets which are not in the new config.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(oldWidgets, function (widget) {\n            if (!widgetSet.has(widget)) {\n                widget.parent = null;\n            }\n        });\n        // Dispose of the old tab bars.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(oldTabBars, function (tabBar) {\n            tabBar.dispose();\n        });\n        // Remove the old handles.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(oldHandles, function (handle) {\n            if (handle.parentNode) {\n                handle.parentNode.removeChild(handle);\n            }\n        });\n        // Reparent the new widgets to the current parent.\n        widgetSet.forEach(function (widget) {\n            widget.parent = _this.parent;\n        });\n        // Create the root node for the new config.\n        if (mainConfig) {\n            this._root = Private$d.realizeAreaConfig(mainConfig, {\n                createTabBar: function () { return _this._createTabBar(); },\n                createHandle: function () { return _this._createHandle(); }\n            });\n        }\n        else {\n            this._root = null;\n        }\n        // If there is no parent, there is nothing more to do.\n        if (!this.parent) {\n            return;\n        }\n        // Attach the new widgets to the parent.\n        widgetSet.forEach(function (widget) {\n            _this.attachWidget(widget);\n        });\n        // Post a fit request to the parent.\n        this.parent.fit();\n    };\n    /**\n     * Add a widget to the dock layout.\n     *\n     * @param widget - The widget to add to the dock layout.\n     *\n     * @param options - The additional options for adding the widget.\n     *\n     * #### Notes\n     * The widget will be moved if it is already contained in the layout.\n     *\n     * An error will be thrown if the reference widget is invalid.\n     */\n    DockLayout.prototype.addWidget = function (widget, options) {\n        if (options === void 0) { options = {}; }\n        // Parse the options.\n        var ref = options.ref || null;\n        var mode = options.mode || 'tab-after';\n        // Find the tab node which holds the reference widget.\n        var refNode = null;\n        if (this._root && ref) {\n            refNode = this._root.findTabNode(ref);\n        }\n        // Throw an error if the reference widget is invalid.\n        if (ref && !refNode) {\n            throw new Error('Reference widget is not in the layout.');\n        }\n        // Reparent the widget to the current layout parent.\n        widget.parent = this.parent;\n        // Insert the widget according to the insert mode.\n        switch (mode) {\n            case 'tab-after':\n                this._insertTab(widget, ref, refNode, true);\n                break;\n            case 'tab-before':\n                this._insertTab(widget, ref, refNode, false);\n                break;\n            case 'split-top':\n                this._insertSplit(widget, ref, refNode, 'vertical', false);\n                break;\n            case 'split-left':\n                this._insertSplit(widget, ref, refNode, 'horizontal', false);\n                break;\n            case 'split-right':\n                this._insertSplit(widget, ref, refNode, 'horizontal', true);\n                break;\n            case 'split-bottom':\n                this._insertSplit(widget, ref, refNode, 'vertical', true);\n                break;\n        }\n        // Do nothing else if there is no parent widget.\n        if (!this.parent) {\n            return;\n        }\n        // Ensure the widget is attached to the parent widget.\n        this.attachWidget(widget);\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Remove a widget from the layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    DockLayout.prototype.removeWidget = function (widget) {\n        // Remove the widget from its current layout location.\n        this._removeWidget(widget);\n        // Do nothing else if there is no parent widget.\n        if (!this.parent) {\n            return;\n        }\n        // Detach the widget from the parent widget.\n        this.detachWidget(widget);\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Find the tab area which contains the given client position.\n     *\n     * @param clientX - The client X position of interest.\n     *\n     * @param clientY - The client Y position of interest.\n     *\n     * @returns The geometry of the tab area at the given position, or\n     *   `null` if there is no tab area at the given position.\n     */\n    DockLayout.prototype.hitTestTabAreas = function (clientX, clientY) {\n        // Bail early if hit testing cannot produce valid results.\n        if (!this._root || !this.parent || !this.parent.isVisible) {\n            return null;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        }\n        // Convert from client to local coordinates.\n        var rect = this.parent.node.getBoundingClientRect();\n        var x = clientX - rect.left - this._box.borderLeft;\n        var y = clientY - rect.top - this._box.borderTop;\n        // Find the tab layout node at the local position.\n        var tabNode = this._root.hitTestTabNodes(x, y);\n        // Bail if a tab layout node was not found.\n        if (!tabNode) {\n            return null;\n        }\n        // Extract the data from the tab node.\n        var tabBar = tabNode.tabBar, top = tabNode.top, left = tabNode.left, width = tabNode.width, height = tabNode.height;\n        // Compute the right and bottom edges of the tab area.\n        var borderWidth = this._box.borderLeft + this._box.borderRight;\n        var borderHeight = this._box.borderTop + this._box.borderBottom;\n        var right = rect.width - borderWidth - (left + width);\n        var bottom = rect.height - borderHeight - (top + height);\n        // Return the hit test results.\n        return { tabBar: tabBar, x: x, y: y, top: top, left: left, right: right, bottom: bottom, width: width, height: height };\n    };\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    DockLayout.prototype.init = function () {\n        var _this = this;\n        // Perform superclass initialization.\n        _super.prototype.init.call(this);\n        // Attach each widget to the parent.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) { _this.attachWidget(widget); });\n        // Attach each handle to the parent.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.handles(), function (handle) { _this.parent.node.appendChild(handle); });\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Attach the widget to the layout parent widget.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a no-op if the widget is already attached.\n     */\n    DockLayout.prototype.attachWidget = function (widget) {\n        // Do nothing if the widget is already attached.\n        if (this.parent.node === widget.node.parentNode) {\n            return;\n        }\n        // Create the layout item for the widget.\n        this._items.set(widget, new LayoutItem(widget));\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    };\n    /**\n     * Detach the widget from the layout parent widget.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a no-op if the widget is not attached.\n     */\n    DockLayout.prototype.detachWidget = function (widget) {\n        // Do nothing if the widget is not attached.\n        if (this.parent.node !== widget.node.parentNode) {\n            return;\n        }\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Delete the layout item for the widget.\n        var item = this._items.get(widget);\n        if (item) {\n            this._items.delete(widget);\n            item.dispose();\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    DockLayout.prototype.onBeforeShow = function (msg) {\n        _super.prototype.onBeforeShow.call(this, msg);\n        this.parent.update();\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    DockLayout.prototype.onBeforeAttach = function (msg) {\n        _super.prototype.onBeforeAttach.call(this, msg);\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    DockLayout.prototype.onChildShown = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    DockLayout.prototype.onChildHidden = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    DockLayout.prototype.onResize = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    DockLayout.prototype.onUpdateRequest = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    DockLayout.prototype.onFitRequest = function (msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    };\n    /**\n     * Remove the specified widget from the layout structure.\n     *\n     * #### Notes\n     * This is a no-op if the widget is not in the layout tree.\n     *\n     * This does not detach the widget from the parent node.\n     */\n    DockLayout.prototype._removeWidget = function (widget) {\n        // Bail early if there is no layout root.\n        if (!this._root) {\n            return;\n        }\n        // Find the tab node which contains the given widget.\n        var tabNode = this._root.findTabNode(widget);\n        // Bail early if the tab node is not found.\n        if (!tabNode) {\n            return;\n        }\n        Private$d.removeAria(widget);\n        // If there are multiple tabs, just remove the widget's tab.\n        if (tabNode.tabBar.titles.length > 1) {\n            tabNode.tabBar.removeTab(widget.title);\n            return;\n        }\n        // Otherwise, the tab node needs to be removed...\n        // Dispose the tab bar.\n        tabNode.tabBar.dispose();\n        // Handle the case where the tab node is the root.\n        if (this._root === tabNode) {\n            this._root = null;\n            return;\n        }\n        // Otherwise, remove the tab node from its parent...\n        // Prevent widget resizing unless needed.\n        this._root.holdAllSizes();\n        // Clear the parent reference on the tab node.\n        var splitNode = tabNode.parent;\n        tabNode.parent = null;\n        // Remove the tab node from its parent split node.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeFirstOf(splitNode.children, tabNode);\n        var handle = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(splitNode.handles, i);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(splitNode.sizers, i);\n        // Remove the handle from its parent DOM node.\n        if (handle.parentNode) {\n            handle.parentNode.removeChild(handle);\n        }\n        // If there are multiple children, just update the handles.\n        if (splitNode.children.length > 1) {\n            splitNode.syncHandles();\n            return;\n        }\n        // Otherwise, the split node also needs to be removed...\n        // Clear the parent reference on the split node.\n        var maybeParent = splitNode.parent;\n        splitNode.parent = null;\n        // Lookup the remaining child node and handle.\n        var childNode = splitNode.children[0];\n        var childHandle = splitNode.handles[0];\n        // Clear the split node data.\n        splitNode.children.length = 0;\n        splitNode.handles.length = 0;\n        splitNode.sizers.length = 0;\n        // Remove the child handle from its parent node.\n        if (childHandle.parentNode) {\n            childHandle.parentNode.removeChild(childHandle);\n        }\n        // Handle the case where the split node is the root.\n        if (this._root === splitNode) {\n            childNode.parent = null;\n            this._root = childNode;\n            return;\n        }\n        // Otherwise, move the child node to the parent node...\n        var parentNode = maybeParent;\n        // Lookup the index of the split node.\n        var j = parentNode.children.indexOf(splitNode);\n        // Handle the case where the child node is a tab node.\n        if (childNode instanceof Private$d.TabLayoutNode) {\n            childNode.parent = parentNode;\n            parentNode.children[j] = childNode;\n            return;\n        }\n        // Remove the split data from the parent.\n        var splitHandle = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(parentNode.handles, j);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(parentNode.children, j);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(parentNode.sizers, j);\n        // Remove the handle from its parent node.\n        if (splitHandle.parentNode) {\n            splitHandle.parentNode.removeChild(splitHandle);\n        }\n        // The child node and the split parent node will have the same\n        // orientation. Merge the grand-children with the parent node.\n        for (var i_1 = 0, n = childNode.children.length; i_1 < n; ++i_1) {\n            var gChild = childNode.children[i_1];\n            var gHandle = childNode.handles[i_1];\n            var gSizer = childNode.sizers[i_1];\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(parentNode.children, j + i_1, gChild);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(parentNode.handles, j + i_1, gHandle);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(parentNode.sizers, j + i_1, gSizer);\n            gChild.parent = parentNode;\n        }\n        // Clear the child node.\n        childNode.children.length = 0;\n        childNode.handles.length = 0;\n        childNode.sizers.length = 0;\n        childNode.parent = null;\n        // Sync the handles on the parent node.\n        parentNode.syncHandles();\n    };\n    /**\n     * Insert a widget next to an existing tab.\n     *\n     * #### Notes\n     * This does not attach the widget to the parent widget.\n     */\n    DockLayout.prototype._insertTab = function (widget, ref, refNode, after) {\n        // Do nothing if the tab is inserted next to itself.\n        if (widget === ref) {\n            return;\n        }\n        // Create the root if it does not exist.\n        if (!this._root) {\n            var tabNode = new Private$d.TabLayoutNode(this._createTabBar());\n            tabNode.tabBar.addTab(widget.title);\n            this._root = tabNode;\n            Private$d.addAria(widget, tabNode.tabBar);\n            return;\n        }\n        // Use the first tab node as the ref node if needed.\n        if (!refNode) {\n            refNode = this._root.findFirstTabNode();\n        }\n        // If the widget is not contained in the ref node, ensure it is\n        // removed from the layout and hidden before being added again.\n        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {\n            this._removeWidget(widget);\n            widget.hide();\n        }\n        // Lookup the target index for inserting the tab.\n        var index;\n        if (ref) {\n            index = refNode.tabBar.titles.indexOf(ref.title);\n        }\n        else {\n            index = refNode.tabBar.currentIndex;\n        }\n        // Insert the widget's tab relative to the target index.\n        refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);\n        Private$d.addAria(widget, refNode.tabBar);\n    };\n    /**\n     * Insert a widget as a new split area.\n     *\n     * #### Notes\n     * This does not attach the widget to the parent widget.\n     */\n    DockLayout.prototype._insertSplit = function (widget, ref, refNode, orientation, after) {\n        // Do nothing if there is no effective split.\n        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {\n            return;\n        }\n        // Ensure the widget is removed from the current layout.\n        this._removeWidget(widget);\n        // Create the tab layout node to hold the widget.\n        var tabNode = new Private$d.TabLayoutNode(this._createTabBar());\n        tabNode.tabBar.addTab(widget.title);\n        Private$d.addAria(widget, tabNode.tabBar);\n        // Set the root if it does not exist.\n        if (!this._root) {\n            this._root = tabNode;\n            return;\n        }\n        // If the ref node parent is null, split the root.\n        if (!refNode || !refNode.parent) {\n            // Ensure the root is split with the correct orientation.\n            var root = this._splitRoot(orientation);\n            // Determine the insert index for the new tab node.\n            var i_2 = after ? root.children.length : 0;\n            // Normalize the split node.\n            root.normalizeSizes();\n            // Create the sizer for new tab node.\n            var sizer = Private$d.createSizer(refNode ? 1 : Private$d.GOLDEN_RATIO);\n            // Insert the tab node sized to the golden ratio.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(root.children, i_2, tabNode);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(root.sizers, i_2, sizer);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(root.handles, i_2, this._createHandle());\n            tabNode.parent = root;\n            // Re-normalize the split node to maintain the ratios.\n            root.normalizeSizes();\n            // Finally, synchronize the visibility of the handles.\n            root.syncHandles();\n            return;\n        }\n        // Lookup the split node for the ref widget.\n        var splitNode = refNode.parent;\n        // If the split node already had the correct orientation,\n        // the widget can be inserted into the split node directly.\n        if (splitNode.orientation === orientation) {\n            // Find the index of the ref node.\n            var i_3 = splitNode.children.indexOf(refNode);\n            // Normalize the split node.\n            splitNode.normalizeSizes();\n            // Consume half the space for the insert location.\n            var s = splitNode.sizers[i_3].sizeHint /= 2;\n            // Insert the tab node sized to the other half.\n            var j_1 = i_3 + (after ? 1 : 0);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(splitNode.children, j_1, tabNode);\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(splitNode.sizers, j_1, Private$d.createSizer(s));\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(splitNode.handles, j_1, this._createHandle());\n            tabNode.parent = splitNode;\n            // Finally, synchronize the visibility of the handles.\n            splitNode.syncHandles();\n            return;\n        }\n        // Remove the ref node from the split node.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeFirstOf(splitNode.children, refNode);\n        // Create a new normalized split node for the children.\n        var childNode = new Private$d.SplitLayoutNode(orientation);\n        childNode.normalized = true;\n        // Add the ref node sized to half the space.\n        childNode.children.push(refNode);\n        childNode.sizers.push(Private$d.createSizer(0.5));\n        childNode.handles.push(this._createHandle());\n        refNode.parent = childNode;\n        // Add the tab node sized to the other half.\n        var j = after ? 1 : 0;\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(childNode.children, j, tabNode);\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(childNode.sizers, j, Private$d.createSizer(0.5));\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(childNode.handles, j, this._createHandle());\n        tabNode.parent = childNode;\n        // Synchronize the visibility of the handles.\n        childNode.syncHandles();\n        // Finally, add the new child node to the original split node.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(splitNode.children, i, childNode);\n        childNode.parent = splitNode;\n    };\n    /**\n     * Ensure the root is a split node with the given orientation.\n     */\n    DockLayout.prototype._splitRoot = function (orientation) {\n        // Bail early if the root already meets the requirements.\n        var oldRoot = this._root;\n        if (oldRoot instanceof Private$d.SplitLayoutNode) {\n            if (oldRoot.orientation === orientation) {\n                return oldRoot;\n            }\n        }\n        // Create a new root node with the specified orientation.\n        var newRoot = this._root = new Private$d.SplitLayoutNode(orientation);\n        // Add the old root to the new root.\n        if (oldRoot) {\n            newRoot.children.push(oldRoot);\n            newRoot.sizers.push(Private$d.createSizer(0));\n            newRoot.handles.push(this._createHandle());\n            oldRoot.parent = newRoot;\n        }\n        // Return the new root as a convenience.\n        return newRoot;\n    };\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    DockLayout.prototype._fit = function () {\n        // Set up the computed minimum size.\n        var minW = 0;\n        var minH = 0;\n        // Update the size limits for the layout tree.\n        if (this._root) {\n            var limits = this._root.fit(this._spacing, this._items);\n            minW = limits.minWidth;\n            minH = limits.minHeight;\n        }\n        // Update the box sizing and add it to the computed min size.\n        var box = this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        var style = this.parent.node.style;\n        style.minWidth = minW + \"px\";\n        style.minHeight = minH + \"px\";\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    };\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    DockLayout.prototype._update = function (offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Bail early if there is no root layout node.\n        if (!this._root) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the actual layout bounds adjusted for border and padding.\n        var x = this._box.paddingTop;\n        var y = this._box.paddingLeft;\n        var width = offsetWidth - this._box.horizontalSum;\n        var height = offsetHeight - this._box.verticalSum;\n        // Update the geometry of the layout tree.\n        this._root.update(x, y, width, height, this._spacing, this._items);\n    };\n    /**\n     * Create a new tab bar for use by the dock layout.\n     *\n     * #### Notes\n     * The tab bar will be attached to the parent if it exists.\n     */\n    DockLayout.prototype._createTabBar = function () {\n        // Create the tab bar using the renderer.\n        var tabBar = this.renderer.createTabBar();\n        // Enforce necessary tab bar behavior.\n        tabBar.orientation = 'horizontal';\n        // Reparent and attach the tab bar to the parent if possible.\n        if (this.parent) {\n            tabBar.parent = this.parent;\n            this.attachWidget(tabBar);\n        }\n        // Return the initialized tab bar.\n        return tabBar;\n    };\n    /**\n     * Create a new handle for the dock layout.\n     *\n     * #### Notes\n     * The handle will be attached to the parent if it exists.\n     */\n    DockLayout.prototype._createHandle = function () {\n        // Create the handle using the renderer.\n        var handle = this.renderer.createHandle();\n        // Initialize the handle layout behavior.\n        var style = handle.style;\n        style.position = 'absolute';\n        style.top = '0';\n        style.left = '0';\n        style.width = '0';\n        style.height = '0';\n        // Attach the handle to the parent if it exists.\n        if (this.parent) {\n            this.parent.node.appendChild(handle);\n        }\n        // Return the initialized handle.\n        return handle;\n    };\n    return DockLayout;\n}(Layout));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$d;\n(function (Private) {\n    /**\n     * A fraction used for sizing root panels; ~= `1 / golden_ratio`.\n     */\n    Private.GOLDEN_RATIO = 0.618;\n    /**\n     * Create a box sizer with an initial size hint.\n     */\n    function createSizer(hint) {\n        var sizer = new BoxSizer();\n        sizer.sizeHint = hint;\n        sizer.size = hint;\n        return sizer;\n    }\n    Private.createSizer = createSizer;\n    /**\n     * Normalize an area config object and collect the visited widgets.\n     */\n    function normalizeAreaConfig(config, widgetSet) {\n        var result;\n        if (config.type === 'tab-area') {\n            result = normalizeTabAreaConfig(config, widgetSet);\n        }\n        else {\n            result = normalizeSplitAreaConfig(config, widgetSet);\n        }\n        return result;\n    }\n    Private.normalizeAreaConfig = normalizeAreaConfig;\n    /**\n     * Convert a normalized area config into a layout tree.\n     */\n    function realizeAreaConfig(config, renderer) {\n        var node;\n        if (config.type === 'tab-area') {\n            node = realizeTabAreaConfig(config, renderer);\n        }\n        else {\n            node = realizeSplitAreaConfig(config, renderer);\n        }\n        return node;\n    }\n    Private.realizeAreaConfig = realizeAreaConfig;\n    /**\n     * A layout node which holds the data for a tabbed area.\n     */\n    var TabLayoutNode = /** @class */ (function () {\n        /**\n         * Construct a new tab layout node.\n         *\n         * @param tabBar - The tab bar to use for the layout node.\n         */\n        function TabLayoutNode(tabBar) {\n            /**\n             * The parent of the layout node.\n             */\n            this.parent = null;\n            this._top = 0;\n            this._left = 0;\n            this._width = 0;\n            this._height = 0;\n            var tabSizer = new BoxSizer();\n            var widgetSizer = new BoxSizer();\n            tabSizer.stretch = 0;\n            widgetSizer.stretch = 1;\n            this.tabBar = tabBar;\n            this.sizers = [tabSizer, widgetSizer];\n        }\n        Object.defineProperty(TabLayoutNode.prototype, \"top\", {\n            /**\n             * The most recent value for the `top` edge of the layout box.\n             */\n            get: function () {\n                return this._top;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TabLayoutNode.prototype, \"left\", {\n            /**\n             * The most recent value for the `left` edge of the layout box.\n             */\n            get: function () {\n                return this._left;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TabLayoutNode.prototype, \"width\", {\n            /**\n             * The most recent value for the `width` of the layout box.\n             */\n            get: function () {\n                return this._width;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TabLayoutNode.prototype, \"height\", {\n            /**\n             * The most recent value for the `height` of the layout box.\n             */\n            get: function () {\n                return this._height;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Create an iterator for all widgets in the layout tree.\n         */\n        TabLayoutNode.prototype.iterAllWidgets = function () {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.chain)((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.once)(this.tabBar), this.iterUserWidgets());\n        };\n        /**\n         * Create an iterator for the user widgets in the layout tree.\n         */\n        TabLayoutNode.prototype.iterUserWidgets = function () {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this.tabBar.titles, function (title) { return title.owner; });\n        };\n        /**\n         * Create an iterator for the selected widgets in the layout tree.\n         */\n        TabLayoutNode.prototype.iterSelectedWidgets = function () {\n            var title = this.tabBar.currentTitle;\n            return title ? (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.once)(title.owner) : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n        };\n        /**\n         * Create an iterator for the tab bars in the layout tree.\n         */\n        TabLayoutNode.prototype.iterTabBars = function () {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.once)(this.tabBar);\n        };\n        /**\n         * Create an iterator for the handles in the layout tree.\n         */\n        TabLayoutNode.prototype.iterHandles = function () {\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n        };\n        /**\n         * Find the tab layout node which contains the given widget.\n         */\n        TabLayoutNode.prototype.findTabNode = function (widget) {\n            return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;\n        };\n        /**\n         * Find the split layout node which contains the given handle.\n         */\n        TabLayoutNode.prototype.findSplitNode = function (handle) {\n            return null;\n        };\n        /**\n         * Find the first tab layout node in a layout tree.\n         */\n        TabLayoutNode.prototype.findFirstTabNode = function () {\n            return this;\n        };\n        /**\n         * Find the tab layout node which contains the local point.\n         */\n        TabLayoutNode.prototype.hitTestTabNodes = function (x, y) {\n            if (x < this._left || x >= this._left + this._width) {\n                return null;\n            }\n            if (y < this._top || y >= this._top + this._height) {\n                return null;\n            }\n            return this;\n        };\n        /**\n         * Create a configuration object for the layout tree.\n         */\n        TabLayoutNode.prototype.createConfig = function () {\n            var widgets = this.tabBar.titles.map(function (title) { return title.owner; });\n            var currentIndex = this.tabBar.currentIndex;\n            return { type: 'tab-area', widgets: widgets, currentIndex: currentIndex };\n        };\n        /**\n         * Recursively hold all of the sizes in the layout tree.\n         *\n         * This ignores the sizers of tab layout nodes.\n         */\n        TabLayoutNode.prototype.holdAllSizes = function () {\n            return;\n        };\n        /**\n         * Fit the layout tree.\n         */\n        TabLayoutNode.prototype.fit = function (spacing, items) {\n            // Set up the limit variables.\n            var minWidth = 0;\n            var minHeight = 0;\n            var maxWidth = Infinity;\n            var maxHeight = Infinity;\n            // Lookup the tab bar layout item.\n            var tabBarItem = items.get(this.tabBar);\n            // Lookup the widget layout item.\n            var current = this.tabBar.currentTitle;\n            var widgetItem = current ? items.get(current.owner) : undefined;\n            // Lookup the tab bar and widget sizers.\n            var _a = this.sizers, tabBarSizer = _a[0], widgetSizer = _a[1];\n            // Update the tab bar limits.\n            if (tabBarItem) {\n                tabBarItem.fit();\n            }\n            // Update the widget limits.\n            if (widgetItem) {\n                widgetItem.fit();\n            }\n            // Update the results and sizer for the tab bar.\n            if (tabBarItem && !tabBarItem.isHidden) {\n                minWidth = Math.max(minWidth, tabBarItem.minWidth);\n                minHeight += tabBarItem.minHeight;\n                tabBarSizer.minSize = tabBarItem.minHeight;\n                tabBarSizer.maxSize = tabBarItem.maxHeight;\n            }\n            else {\n                tabBarSizer.minSize = 0;\n                tabBarSizer.maxSize = 0;\n            }\n            // Update the results and sizer for the current widget.\n            if (widgetItem && !widgetItem.isHidden) {\n                minWidth = Math.max(minWidth, widgetItem.minWidth);\n                minHeight += widgetItem.minHeight;\n                widgetSizer.minSize = widgetItem.minHeight;\n                widgetSizer.maxSize = Infinity;\n            }\n            else {\n                widgetSizer.minSize = 0;\n                widgetSizer.maxSize = Infinity;\n            }\n            // Return the computed size limits for the layout node.\n            return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };\n        };\n        /**\n         * Update the layout tree.\n         */\n        TabLayoutNode.prototype.update = function (left, top, width, height, spacing, items) {\n            // Update the layout box values.\n            this._top = top;\n            this._left = left;\n            this._width = width;\n            this._height = height;\n            // Lookup the tab bar layout item.\n            var tabBarItem = items.get(this.tabBar);\n            // Lookup the widget layout item.\n            var current = this.tabBar.currentTitle;\n            var widgetItem = current ? items.get(current.owner) : undefined;\n            // Distribute the layout space to the sizers.\n            BoxEngine.calc(this.sizers, height);\n            // Update the tab bar item using the computed size.\n            if (tabBarItem && !tabBarItem.isHidden) {\n                var size = this.sizers[0].size;\n                tabBarItem.update(left, top, width, size);\n                top += size;\n            }\n            // Layout the widget using the computed size.\n            if (widgetItem && !widgetItem.isHidden) {\n                var size = this.sizers[1].size;\n                widgetItem.update(left, top, width, size);\n            }\n        };\n        return TabLayoutNode;\n    }());\n    Private.TabLayoutNode = TabLayoutNode;\n    /**\n     * A layout node which holds the data for a split area.\n     */\n    var SplitLayoutNode = /** @class */ (function () {\n        /**\n         * Construct a new split layout node.\n         *\n         * @param orientation - The orientation of the node.\n         */\n        function SplitLayoutNode(orientation) {\n            /**\n             * The parent of the layout node.\n             */\n            this.parent = null;\n            /**\n             * Whether the sizers have been normalized.\n             */\n            this.normalized = false;\n            /**\n             * The child nodes for the split node.\n             */\n            this.children = [];\n            /**\n             * The box sizers for the layout children.\n             */\n            this.sizers = [];\n            /**\n             * The handles for the layout children.\n             */\n            this.handles = [];\n            this.orientation = orientation;\n        }\n        /**\n         * Create an iterator for all widgets in the layout tree.\n         */\n        SplitLayoutNode.prototype.iterAllWidgets = function () {\n            var children = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this.children, function (child) { return child.iterAllWidgets(); });\n            return new _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ChainIterator(children);\n        };\n        /**\n         * Create an iterator for the user widgets in the layout tree.\n         */\n        SplitLayoutNode.prototype.iterUserWidgets = function () {\n            var children = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this.children, function (child) { return child.iterUserWidgets(); });\n            return new _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ChainIterator(children);\n        };\n        /**\n         * Create an iterator for the selected widgets in the layout tree.\n         */\n        SplitLayoutNode.prototype.iterSelectedWidgets = function () {\n            var children = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this.children, function (child) { return child.iterSelectedWidgets(); });\n            return new _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ChainIterator(children);\n        };\n        /**\n         * Create an iterator for the tab bars in the layout tree.\n         */\n        SplitLayoutNode.prototype.iterTabBars = function () {\n            var children = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this.children, function (child) { return child.iterTabBars(); });\n            return new _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ChainIterator(children);\n        };\n        /**\n         * Create an iterator for the handles in the layout tree.\n         */\n        SplitLayoutNode.prototype.iterHandles = function () {\n            var children = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this.children, function (child) { return child.iterHandles(); });\n            return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.chain)(this.handles, new _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ChainIterator(children));\n        };\n        /**\n         * Find the tab layout node which contains the given widget.\n         */\n        SplitLayoutNode.prototype.findTabNode = function (widget) {\n            for (var i = 0, n = this.children.length; i < n; ++i) {\n                var result = this.children[i].findTabNode(widget);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        /**\n         * Find the split layout node which contains the given handle.\n         */\n        SplitLayoutNode.prototype.findSplitNode = function (handle) {\n            var index = this.handles.indexOf(handle);\n            if (index !== -1) {\n                return { index: index, node: this };\n            }\n            for (var i = 0, n = this.children.length; i < n; ++i) {\n                var result = this.children[i].findSplitNode(handle);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        /**\n         * Find the first tab layout node in a layout tree.\n         */\n        SplitLayoutNode.prototype.findFirstTabNode = function () {\n            if (this.children.length === 0) {\n                return null;\n            }\n            return this.children[0].findFirstTabNode();\n        };\n        /**\n         * Find the tab layout node which contains the local point.\n         */\n        SplitLayoutNode.prototype.hitTestTabNodes = function (x, y) {\n            for (var i = 0, n = this.children.length; i < n; ++i) {\n                var result = this.children[i].hitTestTabNodes(x, y);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        /**\n         * Create a configuration object for the layout tree.\n         */\n        SplitLayoutNode.prototype.createConfig = function () {\n            var orientation = this.orientation;\n            var sizes = this.createNormalizedSizes();\n            var children = this.children.map(function (child) { return child.createConfig(); });\n            return { type: 'split-area', orientation: orientation, children: children, sizes: sizes };\n        };\n        /**\n         * Sync the visibility and orientation of the handles.\n         */\n        SplitLayoutNode.prototype.syncHandles = function () {\n            var _this = this;\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.handles, function (handle, i) {\n                handle.setAttribute('data-orientation', _this.orientation);\n                if (i === _this.handles.length - 1) {\n                    handle.classList.add('lm-mod-hidden');\n                    /* <DEPRECATED> */\n                    handle.classList.add('p-mod-hidden');\n                    /* </DEPRECATED> */\n                }\n                else {\n                    handle.classList.remove('lm-mod-hidden');\n                    /* <DEPRECATED> */\n                    handle.classList.remove('p-mod-hidden');\n                    /* </DEPRECATED> */\n                }\n            });\n        };\n        /**\n         * Hold the current sizes of the box sizers.\n         *\n         * This sets the size hint of each sizer to its current size.\n         */\n        SplitLayoutNode.prototype.holdSizes = function () {\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.sizers, function (sizer) { sizer.sizeHint = sizer.size; });\n        };\n        /**\n         * Recursively hold all of the sizes in the layout tree.\n         *\n         * This ignores the sizers of tab layout nodes.\n         */\n        SplitLayoutNode.prototype.holdAllSizes = function () {\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.children, function (child) { return child.holdAllSizes(); });\n            this.holdSizes();\n        };\n        /**\n         * Normalize the sizes of the split layout node.\n         */\n        SplitLayoutNode.prototype.normalizeSizes = function () {\n            // Bail early if the sizers are empty.\n            var n = this.sizers.length;\n            if (n === 0) {\n                return;\n            }\n            // Hold the current sizes of the sizers.\n            this.holdSizes();\n            // Compute the sum of the sizes.\n            var sum = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.reduce)(this.sizers, function (v, sizer) { return v + sizer.sizeHint; }, 0);\n            // Normalize the sizes based on the sum.\n            if (sum === 0) {\n                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.sizers, function (sizer) {\n                    sizer.size = sizer.sizeHint = 1 / n;\n                });\n            }\n            else {\n                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.sizers, function (sizer) {\n                    sizer.size = sizer.sizeHint /= sum;\n                });\n            }\n            // Mark the sizes as normalized.\n            this.normalized = true;\n        };\n        /**\n         * Snap the normalized sizes of the split layout node.\n         */\n        SplitLayoutNode.prototype.createNormalizedSizes = function () {\n            // Bail early if the sizers are empty.\n            var n = this.sizers.length;\n            if (n === 0) {\n                return [];\n            }\n            // Grab the current sizes of the sizers.\n            var sizes = this.sizers.map(function (sizer) { return sizer.size; });\n            // Compute the sum of the sizes.\n            var sum = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.reduce)(sizes, function (v, size) { return v + size; }, 0);\n            // Normalize the sizes based on the sum.\n            if (sum === 0) {\n                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(sizes, function (size, i) { sizes[i] = 1 / n; });\n            }\n            else {\n                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(sizes, function (size, i) { sizes[i] = size / sum; });\n            }\n            // Return the normalized sizes.\n            return sizes;\n        };\n        /**\n         * Fit the layout tree.\n         */\n        SplitLayoutNode.prototype.fit = function (spacing, items) {\n            // Compute the required fixed space.\n            var horizontal = this.orientation === 'horizontal';\n            var fixed = Math.max(0, this.children.length - 1) * spacing;\n            // Set up the limit variables.\n            var minWidth = horizontal ? fixed : 0;\n            var minHeight = horizontal ? 0 : fixed;\n            var maxWidth = Infinity;\n            var maxHeight = Infinity;\n            // Fit the children and update the limits.\n            for (var i = 0, n = this.children.length; i < n; ++i) {\n                var limits = this.children[i].fit(spacing, items);\n                if (horizontal) {\n                    minHeight = Math.max(minHeight, limits.minHeight);\n                    minWidth += limits.minWidth;\n                    this.sizers[i].minSize = limits.minWidth;\n                }\n                else {\n                    minWidth = Math.max(minWidth, limits.minWidth);\n                    minHeight += limits.minHeight;\n                    this.sizers[i].minSize = limits.minHeight;\n                }\n            }\n            // Return the computed limits for the layout node.\n            return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };\n        };\n        /**\n         * Update the layout tree.\n         */\n        SplitLayoutNode.prototype.update = function (left, top, width, height, spacing, items) {\n            // Compute the available layout space.\n            var horizontal = this.orientation === 'horizontal';\n            var fixed = Math.max(0, this.children.length - 1) * spacing;\n            var space = Math.max(0, (horizontal ? width : height) - fixed);\n            // De-normalize the sizes if needed.\n            if (this.normalized) {\n                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.sizers, function (sizer) { sizer.sizeHint *= space; });\n                this.normalized = false;\n            }\n            // Distribute the layout space to the sizers.\n            BoxEngine.calc(this.sizers, space);\n            // Update the geometry of the child nodes and handles.\n            for (var i = 0, n = this.children.length; i < n; ++i) {\n                var child = this.children[i];\n                var size = this.sizers[i].size;\n                var handleStyle = this.handles[i].style;\n                if (horizontal) {\n                    child.update(left, top, size, height, spacing, items);\n                    left += size;\n                    handleStyle.top = top + \"px\";\n                    handleStyle.left = left + \"px\";\n                    handleStyle.width = spacing + \"px\";\n                    handleStyle.height = height + \"px\";\n                    left += spacing;\n                }\n                else {\n                    child.update(left, top, width, size, spacing, items);\n                    top += size;\n                    handleStyle.top = top + \"px\";\n                    handleStyle.left = left + \"px\";\n                    handleStyle.width = width + \"px\";\n                    handleStyle.height = spacing + \"px\";\n                    top += spacing;\n                }\n            }\n        };\n        return SplitLayoutNode;\n    }());\n    Private.SplitLayoutNode = SplitLayoutNode;\n    function addAria(widget, tabBar) {\n        widget.node.setAttribute('role', 'tabpanel');\n        var renderer = tabBar.renderer;\n        if (renderer instanceof TabBar.Renderer) {\n            var tabId = renderer.createTabKey({ title: widget.title, current: false, zIndex: 0 });\n            widget.node.setAttribute('aria-labelledby', tabId);\n        }\n    }\n    Private.addAria = addAria;\n    function removeAria(widget) {\n        widget.node.removeAttribute('role');\n        widget.node.removeAttribute('aria-labelledby');\n    }\n    Private.removeAria = removeAria;\n    /**\n     * Normalize a tab area config and collect the visited widgets.\n     */\n    function normalizeTabAreaConfig(config, widgetSet) {\n        // Bail early if there is no content.\n        if (config.widgets.length === 0) {\n            return null;\n        }\n        // Setup the filtered widgets array.\n        var widgets = [];\n        // Filter the config for unique widgets.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(config.widgets, function (widget) {\n            if (!widgetSet.has(widget)) {\n                widgetSet.add(widget);\n                widgets.push(widget);\n            }\n        });\n        // Bail if there are no effective widgets.\n        if (widgets.length === 0) {\n            return null;\n        }\n        // Normalize the current index.\n        var index = config.currentIndex;\n        if (index !== -1 && (index < 0 || index >= widgets.length)) {\n            index = 0;\n        }\n        // Return a normalized config object.\n        return { type: 'tab-area', widgets: widgets, currentIndex: index };\n    }\n    /**\n     * Normalize a split area config and collect the visited widgets.\n     */\n    function normalizeSplitAreaConfig(config, widgetSet) {\n        // Set up the result variables.\n        var orientation = config.orientation;\n        var children = [];\n        var sizes = [];\n        // Normalize the config children.\n        for (var i = 0, n = config.children.length; i < n; ++i) {\n            // Normalize the child config.\n            var child = normalizeAreaConfig(config.children[i], widgetSet);\n            // Ignore an empty child.\n            if (!child) {\n                continue;\n            }\n            // Add the child or hoist its content as appropriate.\n            if (child.type === 'tab-area' || child.orientation !== orientation) {\n                children.push(child);\n                sizes.push(Math.abs(config.sizes[i] || 0));\n            }\n            else {\n                children.push.apply(children, child.children);\n                sizes.push.apply(sizes, child.sizes);\n            }\n        }\n        // Bail if there are no effective children.\n        if (children.length === 0) {\n            return null;\n        }\n        // If there is only one effective child, return that child.\n        if (children.length === 1) {\n            return children[0];\n        }\n        // Return a normalized config object.\n        return { type: 'split-area', orientation: orientation, children: children, sizes: sizes };\n    }\n    /**\n     * Convert a normalized tab area config into a layout tree.\n     */\n    function realizeTabAreaConfig(config, renderer) {\n        // Create the tab bar for the layout node.\n        var tabBar = renderer.createTabBar();\n        // Hide each widget and add it to the tab bar.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(config.widgets, function (widget) {\n            widget.hide();\n            tabBar.addTab(widget.title);\n            Private.addAria(widget, tabBar);\n        });\n        // Set the current index of the tab bar.\n        tabBar.currentIndex = config.currentIndex;\n        // Return the new tab layout node.\n        return new TabLayoutNode(tabBar);\n    }\n    /**\n     * Convert a normalized split area config into a layout tree.\n     */\n    function realizeSplitAreaConfig(config, renderer) {\n        // Create the split layout node.\n        var node = new SplitLayoutNode(config.orientation);\n        // Add each child to the layout node.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(config.children, function (child, i) {\n            // Create the child data for the layout node.\n            var childNode = realizeAreaConfig(child, renderer);\n            var sizer = createSizer(config.sizes[i]);\n            var handle = renderer.createHandle();\n            // Add the child data to the layout node.\n            node.children.push(childNode);\n            node.handles.push(handle);\n            node.sizers.push(sizer);\n            // Update the parent for the child node.\n            childNode.parent = node;\n        });\n        // Synchronize the handle state for the layout node.\n        node.syncHandles();\n        // Normalize the sizes for the layout node.\n        node.normalizeSizes();\n        // Return the new layout node.\n        return node;\n    }\n})(Private$d || (Private$d = {}));\n\n/**\n * A widget which provides a flexible docking area for widgets.\n */\nvar DockPanel = /** @class */ (function (_super) {\n    __extends(DockPanel, _super);\n    /**\n     * Construct a new dock panel.\n     *\n     * @param options - The options for initializing the panel.\n     */\n    function DockPanel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this._drag = null;\n        _this._tabsMovable = true;\n        _this._tabsConstrained = false;\n        _this._addButtonEnabled = false;\n        _this._pressData = null;\n        _this._layoutModified = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._addRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this.addClass('lm-DockPanel');\n        /* <DEPRECATED> */\n        _this.addClass('p-DockPanel');\n        /* </DEPRECATED> */\n        _this._mode = options.mode || 'multiple-document';\n        _this._renderer = options.renderer || DockPanel.defaultRenderer;\n        _this._edges = options.edges || Private$e.DEFAULT_EDGES;\n        if (options.tabsMovable !== undefined) {\n            _this._tabsMovable = options.tabsMovable;\n        }\n        if (options.tabsConstrained !== undefined) {\n            _this._tabsConstrained = options.tabsConstrained;\n        }\n        if (options.addButtonEnabled !== undefined) {\n            _this._addButtonEnabled = options.addButtonEnabled;\n        }\n        // Toggle the CSS mode attribute.\n        _this.dataset['mode'] = _this._mode;\n        // Create the delegate renderer for the layout.\n        var renderer = {\n            createTabBar: function () { return _this._createTabBar(); },\n            createHandle: function () { return _this._createHandle(); }\n        };\n        // Set up the dock layout for the panel.\n        _this.layout = new DockLayout({ renderer: renderer, spacing: options.spacing });\n        // Set up the overlay drop indicator.\n        _this.overlay = options.overlay || new DockPanel.Overlay();\n        _this.node.appendChild(_this.overlay.node);\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the panel.\n     */\n    DockPanel.prototype.dispose = function () {\n        // Ensure the mouse is released.\n        this._releaseMouse();\n        // Hide the overlay.\n        this.overlay.hide(0);\n        // Cancel a drag if one is in progress.\n        if (this._drag) {\n            this._drag.dispose();\n        }\n        // Dispose of the base class.\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(DockPanel.prototype, \"layoutModified\", {\n        /**\n         * A signal emitted when the layout configuration is modified.\n         *\n         * #### Notes\n         * This signal is emitted whenever the current layout configuration\n         * may have changed.\n         *\n         * This signal is emitted asynchronously in a collapsed fashion, so\n         * that multiple synchronous modifications results in only a single\n         * emit of the signal.\n         */\n        get: function () {\n            return this._layoutModified;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"addRequested\", {\n        /**\n         * A signal emitted when the add button on a tab bar is clicked.\n         *\n         */\n        get: function () {\n            return this._addRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"renderer\", {\n        /**\n         * The renderer used by the dock panel.\n         */\n        get: function () {\n            return this.layout.renderer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"spacing\", {\n        /**\n         * Get the spacing between the widgets.\n         */\n        get: function () {\n            return this.layout.spacing;\n        },\n        /**\n         * Set the spacing between the widgets.\n         */\n        set: function (value) {\n            this.layout.spacing = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"mode\", {\n        /**\n         * Get the mode for the dock panel.\n         */\n        get: function () {\n            return this._mode;\n        },\n        /**\n         * Set the mode for the dock panel.\n         *\n         * #### Notes\n         * Changing the mode is a destructive operation with respect to the\n         * panel's layout configuration. If layout state must be preserved,\n         * save the current layout config before changing the mode.\n         */\n        set: function (value) {\n            // Bail early if the mode does not change.\n            if (this._mode === value) {\n                return;\n            }\n            // Update the internal mode.\n            this._mode = value;\n            // Toggle the CSS mode attribute.\n            this.dataset['mode'] = value;\n            // Get the layout for the panel.\n            var layout = this.layout;\n            // Configure the layout for the specified mode.\n            switch (value) {\n                case 'multiple-document':\n                    (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(layout.tabBars(), function (tabBar) { tabBar.show(); });\n                    break;\n                case 'single-document':\n                    layout.restoreLayout(Private$e.createSingleDocumentConfig(this));\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n            // Schedule an emit of the layout modified signal.\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"tabsMovable\", {\n        /**\n         * Whether the tabs can be dragged / moved at runtime.\n         */\n        get: function () {\n            return this._tabsMovable;\n        },\n        /**\n         * Enable / Disable draggable / movable tabs.\n         */\n        set: function (value) {\n            this._tabsMovable = value;\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.tabBars(), function (tabbar) { tabbar.tabsMovable = value; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"tabsConstrained\", {\n        /**\n         * Whether the tabs are constrained to their source dock panel\n         */\n        get: function () {\n            return this._tabsConstrained;\n        },\n        /**\n         * Constrain/Allow tabs to be dragged outside of this dock panel\n         */\n        set: function (value) {\n            this._tabsConstrained = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"addButtonEnabled\", {\n        /**\n         * Whether the add buttons for each tab bar are enabled.\n         */\n        get: function () {\n            return this._addButtonEnabled;\n        },\n        /**\n         * Set whether the add buttons for each tab bar are enabled.\n         */\n        set: function (value) {\n            this._addButtonEnabled = value;\n            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this.tabBars(), function (tabbar) { tabbar.addButtonEnabled = value; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DockPanel.prototype, \"isEmpty\", {\n        /**\n         * Whether the dock panel is empty.\n         */\n        get: function () {\n            return this.layout.isEmpty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over the user widgets in the panel.\n     *\n     * @returns A new iterator over the user widgets in the panel.\n     *\n     * #### Notes\n     * This iterator does not include the generated tab bars.\n     */\n    DockPanel.prototype.widgets = function () {\n        return this.layout.widgets();\n    };\n    /**\n     * Create an iterator over the selected widgets in the panel.\n     *\n     * @returns A new iterator over the selected user widgets.\n     *\n     * #### Notes\n     * This iterator yields the widgets corresponding to the current tab\n     * of each tab bar in the panel.\n     */\n    DockPanel.prototype.selectedWidgets = function () {\n        return this.layout.selectedWidgets();\n    };\n    /**\n     * Create an iterator over the tab bars in the panel.\n     *\n     * @returns A new iterator over the tab bars in the panel.\n     *\n     * #### Notes\n     * This iterator does not include the user widgets.\n     */\n    DockPanel.prototype.tabBars = function () {\n        return this.layout.tabBars();\n    };\n    /**\n     * Create an iterator over the handles in the panel.\n     *\n     * @returns A new iterator over the handles in the panel.\n     */\n    DockPanel.prototype.handles = function () {\n        return this.layout.handles();\n    };\n    /**\n     * Select a specific widget in the dock panel.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * This will make the widget the current widget in its tab area.\n     */\n    DockPanel.prototype.selectWidget = function (widget) {\n        // Find the tab bar which contains the widget.\n        var tabBar = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(this.tabBars(), function (bar) {\n            return bar.titles.indexOf(widget.title) !== -1;\n        });\n        // Throw an error if no tab bar is found.\n        if (!tabBar) {\n            throw new Error('Widget is not contained in the dock panel.');\n        }\n        // Ensure the widget is the current widget.\n        tabBar.currentTitle = widget.title;\n    };\n    /**\n     * Activate a specified widget in the dock panel.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * This will select and activate the given widget.\n     */\n    DockPanel.prototype.activateWidget = function (widget) {\n        this.selectWidget(widget);\n        widget.activate();\n    };\n    /**\n     * Save the current layout configuration of the dock panel.\n     *\n     * @returns A new config object for the current layout state.\n     *\n     * #### Notes\n     * The return value can be provided to the `restoreLayout` method\n     * in order to restore the layout to its current configuration.\n     */\n    DockPanel.prototype.saveLayout = function () {\n        return this.layout.saveLayout();\n    };\n    /**\n     * Restore the layout to a previously saved configuration.\n     *\n     * @param config - The layout configuration to restore.\n     *\n     * #### Notes\n     * Widgets which currently belong to the layout but which are not\n     * contained in the config will be unparented.\n     *\n     * The dock panel automatically reverts to `'multiple-document'`\n     * mode when a layout config is restored.\n     */\n    DockPanel.prototype.restoreLayout = function (config) {\n        // Reset the mode.\n        this._mode = 'multiple-document';\n        // Restore the layout.\n        this.layout.restoreLayout(config);\n        // Flush the message loop on IE and Edge to prevent flicker.\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Platform.IS_EDGE || _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Platform.IS_IE) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.flush();\n        }\n        // Schedule an emit of the layout modified signal.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n    };\n    /**\n     * Add a widget to the dock panel.\n     *\n     * @param widget - The widget to add to the dock panel.\n     *\n     * @param options - The additional options for adding the widget.\n     *\n     * #### Notes\n     * If the panel is in single document mode, the options are ignored\n     * and the widget is always added as tab in the hidden tab bar.\n     */\n    DockPanel.prototype.addWidget = function (widget, options) {\n        if (options === void 0) { options = {}; }\n        // Add the widget to the layout.\n        if (this._mode === 'single-document') {\n            this.layout.addWidget(widget);\n        }\n        else {\n            this.layout.addWidget(widget, options);\n        }\n        // Schedule an emit of the layout modified signal.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n    };\n    /**\n     * Process a message sent to the widget.\n     *\n     * @param msg - The message sent to the widget.\n     */\n    DockPanel.prototype.processMessage = function (msg) {\n        if (msg.type === 'layout-modified') {\n            this._layoutModified.emit(undefined);\n        }\n        else {\n            _super.prototype.processMessage.call(this, msg);\n        }\n    };\n    /**\n     * Handle the DOM events for the dock panel.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the panel's DOM node. It should\n     * not be called directly by user code.\n     */\n    DockPanel.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    DockPanel.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('lm-dragenter', this);\n        this.node.addEventListener('lm-dragleave', this);\n        this.node.addEventListener('lm-dragover', this);\n        this.node.addEventListener('lm-drop', this);\n        this.node.addEventListener('mousedown', this);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    DockPanel.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('lm-dragenter', this);\n        this.node.removeEventListener('lm-dragleave', this);\n        this.node.removeEventListener('lm-dragover', this);\n        this.node.removeEventListener('lm-drop', this);\n        this.node.removeEventListener('mousedown', this);\n        this._releaseMouse();\n    };\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    DockPanel.prototype.onChildAdded = function (msg) {\n        // Ignore the generated tab bars.\n        if (Private$e.isGeneratedTabBarProperty.get(msg.child)) {\n            return;\n        }\n        // Add the widget class to the child.\n        msg.child.addClass('lm-DockPanel-widget');\n        /* <DEPRECATED> */\n        msg.child.addClass('p-DockPanel-widget');\n        /* </DEPRECATED> */\n    };\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    DockPanel.prototype.onChildRemoved = function (msg) {\n        // Ignore the generated tab bars.\n        if (Private$e.isGeneratedTabBarProperty.get(msg.child)) {\n            return;\n        }\n        // Remove the widget class from the child.\n        msg.child.removeClass('lm-DockPanel-widget');\n        /* <DEPRECATED> */\n        msg.child.removeClass('p-DockPanel-widget');\n        /* </DEPRECATED> */\n        // Schedule an emit of the layout modified signal.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n    };\n    /**\n     * Handle the `'lm-dragenter'` event for the dock panel.\n     */\n    DockPanel.prototype._evtDragEnter = function (event) {\n        // If the factory mime type is present, mark the event as\n        // handled in order to get the rest of the drag events.\n        if (event.mimeData.hasData('application/vnd.lumino.widget-factory')) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n    /**\n     * Handle the `'lm-dragleave'` event for the dock panel.\n     */\n    DockPanel.prototype._evtDragLeave = function (event) {\n        // Mark the event as handled.\n        event.preventDefault();\n        event.stopPropagation();\n        // The new target might be a descendant, so we might still handle the drop.\n        // Hide asynchronously so that if a lm-dragover event bubbles up to us, the\n        // hide is cancelled by the lm-dragover handler's show overlay logic.\n        this.overlay.hide(1);\n    };\n    /**\n     * Handle the `'lm-dragover'` event for the dock panel.\n     */\n    DockPanel.prototype._evtDragOver = function (event) {\n        // Mark the event as handled.\n        event.preventDefault();\n        event.stopPropagation();\n        // Show the drop indicator overlay and update the drop\n        // action based on the drop target zone under the mouse.\n        if ((this._tabsConstrained && event.source !== this) || this._showOverlay(event.clientX, event.clientY) === 'invalid') {\n            event.dropAction = 'none';\n        }\n        else {\n            event.dropAction = event.proposedAction;\n        }\n    };\n    /**\n     * Handle the `'lm-drop'` event for the dock panel.\n     */\n    DockPanel.prototype._evtDrop = function (event) {\n        // Mark the event as handled.\n        event.preventDefault();\n        event.stopPropagation();\n        // Hide the drop indicator overlay.\n        this.overlay.hide(0);\n        // Bail if the proposed action is to do nothing.\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        // Find the drop target under the mouse.\n        var clientX = event.clientX, clientY = event.clientY;\n        var _a = Private$e.findDropTarget(this, clientX, clientY, this._edges), zone = _a.zone, target = _a.target;\n        // Bail if the drop zone is invalid.\n        if (zone === 'invalid') {\n            event.dropAction = 'none';\n            return;\n        }\n        // Bail if the factory mime type has invalid data.\n        var mimeData = event.mimeData;\n        var factory = mimeData.getData('application/vnd.lumino.widget-factory');\n        if (typeof factory !== 'function') {\n            event.dropAction = 'none';\n            return;\n        }\n        // Bail if the factory does not produce a widget.\n        var widget = factory();\n        if (!(widget instanceof Widget)) {\n            event.dropAction = 'none';\n            return;\n        }\n        // Bail if the widget is an ancestor of the dock panel.\n        if (widget.contains(this)) {\n            event.dropAction = 'none';\n            return;\n        }\n        // Find the reference widget for the drop target.\n        var ref = target ? Private$e.getDropRef(target.tabBar) : null;\n        // Add the widget according to the indicated drop zone.\n        switch (zone) {\n            case 'root-all':\n                this.addWidget(widget);\n                break;\n            case 'root-top':\n                this.addWidget(widget, { mode: 'split-top' });\n                break;\n            case 'root-left':\n                this.addWidget(widget, { mode: 'split-left' });\n                break;\n            case 'root-right':\n                this.addWidget(widget, { mode: 'split-right' });\n                break;\n            case 'root-bottom':\n                this.addWidget(widget, { mode: 'split-bottom' });\n                break;\n            case 'widget-all':\n                this.addWidget(widget, { mode: 'tab-after', ref: ref });\n                break;\n            case 'widget-top':\n                this.addWidget(widget, { mode: 'split-top', ref: ref });\n                break;\n            case 'widget-left':\n                this.addWidget(widget, { mode: 'split-left', ref: ref });\n                break;\n            case 'widget-right':\n                this.addWidget(widget, { mode: 'split-right', ref: ref });\n                break;\n            case 'widget-bottom':\n                this.addWidget(widget, { mode: 'split-bottom', ref: ref });\n                break;\n            case 'widget-tab':\n                this.addWidget(widget, { mode: 'tab-after', ref: ref });\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Accept the proposed drop action.\n        event.dropAction = event.proposedAction;\n        // Activate the dropped widget.\n        this.activateWidget(widget);\n    };\n    /**\n     * Handle the `'keydown'` event for the dock panel.\n     */\n    DockPanel.prototype._evtKeyDown = function (event) {\n        // Stop input events during drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Release the mouse if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            // Finalize the mouse release.\n            this._releaseMouse();\n            // Schedule an emit of the layout modified signal.\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n        }\n    };\n    /**\n     * Handle the `'mousedown'` event for the dock panel.\n     */\n    DockPanel.prototype._evtMouseDown = function (event) {\n        // Do nothing if the left mouse button is not pressed.\n        if (event.button !== 0) {\n            return;\n        }\n        // Find the handle which contains the mouse target, if any.\n        var layout = this.layout;\n        var target = event.target;\n        var handle = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(layout.handles(), function (handle) { return handle.contains(target); });\n        if (!handle) {\n            return;\n        }\n        // Stop the event when a handle is pressed.\n        event.preventDefault();\n        event.stopPropagation();\n        // Add the extra document listeners.\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Compute the offset deltas for the handle press.\n        var rect = handle.getBoundingClientRect();\n        var deltaX = event.clientX - rect.left;\n        var deltaY = event.clientY - rect.top;\n        // Override the cursor and store the press data.\n        var style = window.getComputedStyle(handle);\n        var override = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__.Drag.overrideCursor(style.cursor);\n        this._pressData = { handle: handle, deltaX: deltaX, deltaY: deltaY, override: override };\n    };\n    /**\n     * Handle the `'mousemove'` event for the dock panel.\n     */\n    DockPanel.prototype._evtMouseMove = function (event) {\n        // Bail early if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Stop the event when dragging a handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Compute the desired offset position for the handle.\n        var rect = this.node.getBoundingClientRect();\n        var xPos = event.clientX - rect.left - this._pressData.deltaX;\n        var yPos = event.clientY - rect.top - this._pressData.deltaY;\n        // Set the handle as close to the desired position as possible.\n        var layout = this.layout;\n        layout.moveHandle(this._pressData.handle, xPos, yPos);\n    };\n    /**\n     * Handle the `'mouseup'` event for the dock panel.\n     */\n    DockPanel.prototype._evtMouseUp = function (event) {\n        // Do nothing if the left mouse button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event when releasing a handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Finalize the mouse release.\n        this._releaseMouse();\n        // Schedule an emit of the layout modified signal.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n    };\n    /**\n     * Release the mouse grab for the dock panel.\n     */\n    DockPanel.prototype._releaseMouse = function () {\n        // Bail early if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the override cursor.\n        this._pressData.override.dispose();\n        this._pressData = null;\n        // Remove the extra document listeners.\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    };\n    /**\n     * Show the overlay indicator at the given client position.\n     *\n     * Returns the drop zone at the specified client position.\n     *\n     * #### Notes\n     * If the position is not over a valid zone, the overlay is hidden.\n     */\n    DockPanel.prototype._showOverlay = function (clientX, clientY) {\n        // Find the dock target for the given client position.\n        var _a = Private$e.findDropTarget(this, clientX, clientY, this._edges), zone = _a.zone, target = _a.target;\n        // If the drop zone is invalid, hide the overlay and bail.\n        if (zone === 'invalid') {\n            this.overlay.hide(100);\n            return zone;\n        }\n        // Setup the variables needed to compute the overlay geometry.\n        var top;\n        var left;\n        var right;\n        var bottom;\n        var box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.node); // TODO cache this?\n        var rect = this.node.getBoundingClientRect();\n        // Compute the overlay geometry based on the dock zone.\n        switch (zone) {\n            case 'root-all':\n                top = box.paddingTop;\n                left = box.paddingLeft;\n                right = box.paddingRight;\n                bottom = box.paddingBottom;\n                break;\n            case 'root-top':\n                top = box.paddingTop;\n                left = box.paddingLeft;\n                right = box.paddingRight;\n                bottom = rect.height * Private$e.GOLDEN_RATIO;\n                break;\n            case 'root-left':\n                top = box.paddingTop;\n                left = box.paddingLeft;\n                right = rect.width * Private$e.GOLDEN_RATIO;\n                bottom = box.paddingBottom;\n                break;\n            case 'root-right':\n                top = box.paddingTop;\n                left = rect.width * Private$e.GOLDEN_RATIO;\n                right = box.paddingRight;\n                bottom = box.paddingBottom;\n                break;\n            case 'root-bottom':\n                top = rect.height * Private$e.GOLDEN_RATIO;\n                left = box.paddingLeft;\n                right = box.paddingRight;\n                bottom = box.paddingBottom;\n                break;\n            case 'widget-all':\n                top = target.top;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom;\n                break;\n            case 'widget-top':\n                top = target.top;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom + target.height / 2;\n                break;\n            case 'widget-left':\n                top = target.top;\n                left = target.left;\n                right = target.right + target.width / 2;\n                bottom = target.bottom;\n                break;\n            case 'widget-right':\n                top = target.top;\n                left = target.left + target.width / 2;\n                right = target.right;\n                bottom = target.bottom;\n                break;\n            case 'widget-bottom':\n                top = target.top + target.height / 2;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom;\n                break;\n            case 'widget-tab':\n                var tabHeight = target.tabBar.node.getBoundingClientRect().height;\n                top = target.top;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom + target.height - tabHeight;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Show the overlay with the computed geometry.\n        this.overlay.show({ top: top, left: left, right: right, bottom: bottom });\n        // Finally, return the computed drop zone.\n        return zone;\n    };\n    /**\n     * Create a new tab bar for use by the panel.\n     */\n    DockPanel.prototype._createTabBar = function () {\n        // Create the tab bar.\n        var tabBar = this._renderer.createTabBar();\n        // Set the generated tab bar property for the tab bar.\n        Private$e.isGeneratedTabBarProperty.set(tabBar, true);\n        // Hide the tab bar when in single document mode.\n        if (this._mode === 'single-document') {\n            tabBar.hide();\n        }\n        // Enforce necessary tab bar behavior.\n        // TODO do we really want to enforce *all* of these?\n        tabBar.tabsMovable = this._tabsMovable;\n        tabBar.allowDeselect = false;\n        tabBar.addButtonEnabled = this._addButtonEnabled;\n        tabBar.removeBehavior = 'select-previous-tab';\n        tabBar.insertBehavior = 'select-tab-if-needed';\n        // Connect the signal handlers for the tab bar.\n        tabBar.tabMoved.connect(this._onTabMoved, this);\n        tabBar.currentChanged.connect(this._onCurrentChanged, this);\n        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);\n        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);\n        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);\n        tabBar.addRequested.connect(this._onTabAddRequested, this);\n        // Return the initialized tab bar.\n        return tabBar;\n    };\n    /**\n     * Create a new handle for use by the panel.\n     */\n    DockPanel.prototype._createHandle = function () {\n        return this._renderer.createHandle();\n    };\n    /**\n     * Handle the `tabMoved` signal from a tab bar.\n     */\n    DockPanel.prototype._onTabMoved = function () {\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n    };\n    /**\n     * Handle the `currentChanged` signal from a tab bar.\n     */\n    DockPanel.prototype._onCurrentChanged = function (sender, args) {\n        // Extract the previous and current title from the args.\n        var previousTitle = args.previousTitle, currentTitle = args.currentTitle;\n        // Hide the previous widget.\n        if (previousTitle) {\n            previousTitle.owner.hide();\n        }\n        // Show the current widget.\n        if (currentTitle) {\n            currentTitle.owner.show();\n        }\n        // Flush the message loop on IE and Edge to prevent flicker.\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Platform.IS_EDGE || _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Platform.IS_IE) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.flush();\n        }\n        // Schedule an emit of the layout modified signal.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.postMessage(this, Private$e.LayoutModified);\n    };\n    /**\n     * Handle the `addRequested` signal from a tab bar.\n     */\n    DockPanel.prototype._onTabAddRequested = function (sender) {\n        this._addRequested.emit(sender);\n    };\n    /**\n     * Handle the `tabActivateRequested` signal from a tab bar.\n     */\n    DockPanel.prototype._onTabActivateRequested = function (sender, args) {\n        args.title.owner.activate();\n    };\n    /**\n     * Handle the `tabCloseRequested` signal from a tab bar.\n     */\n    DockPanel.prototype._onTabCloseRequested = function (sender, args) {\n        args.title.owner.close();\n    };\n    /**\n     * Handle the `tabDetachRequested` signal from a tab bar.\n     */\n    DockPanel.prototype._onTabDetachRequested = function (sender, args) {\n        var _this = this;\n        // Do nothing if a drag is already in progress.\n        if (this._drag) {\n            return;\n        }\n        // Release the tab bar's hold on the mouse.\n        sender.releaseMouse();\n        // Extract the data from the args.\n        var title = args.title, tab = args.tab, clientX = args.clientX, clientY = args.clientY;\n        // Setup the mime data for the drag operation.\n        var mimeData = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_6__.MimeData();\n        var factory = function () { return title.owner; };\n        mimeData.setData('application/vnd.lumino.widget-factory', factory);\n        // Create the drag image for the drag operation.\n        var dragImage = tab.cloneNode(true);\n        // Create the drag object to manage the drag-drop operation.\n        this._drag = new _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__.Drag({\n            mimeData: mimeData, dragImage: dragImage,\n            proposedAction: 'move',\n            supportedActions: 'move',\n            source: this\n        });\n        // Hide the tab node in the original tab.\n        tab.classList.add('lm-mod-hidden');\n        /* <DEPRECATED> */\n        tab.classList.add('p-mod-hidden');\n        // Create the cleanup callback.\n        var cleanup = (function () {\n            _this._drag = null;\n            tab.classList.remove('lm-mod-hidden');\n            /* <DEPRECATED> */\n            tab.classList.remove('p-mod-hidden');\n        });\n        // Start the drag operation and cleanup when done.\n        this._drag.start(clientX, clientY).then(cleanup);\n    };\n    return DockPanel;\n}(Widget));\n/**\n * The namespace for the `DockPanel` class statics.\n */\n(function (DockPanel) {\n    /**\n     * A concrete implementation of `IOverlay`.\n     *\n     * This is the default overlay implementation for a dock panel.\n     */\n    var Overlay = /** @class */ (function () {\n        /**\n         * Construct a new overlay.\n         */\n        function Overlay() {\n            this._timer = -1;\n            this._hidden = true;\n            this.node = document.createElement('div');\n            this.node.classList.add('lm-DockPanel-overlay');\n            this.node.classList.add('lm-mod-hidden');\n            /* <DEPRECATED> */\n            this.node.classList.add('p-DockPanel-overlay');\n            this.node.classList.add('p-mod-hidden');\n            this.node.style.position = 'absolute';\n        }\n        /**\n         * Show the overlay using the given overlay geometry.\n         *\n         * @param geo - The desired geometry for the overlay.\n         */\n        Overlay.prototype.show = function (geo) {\n            // Update the position of the overlay.\n            var style = this.node.style;\n            style.top = geo.top + \"px\";\n            style.left = geo.left + \"px\";\n            style.right = geo.right + \"px\";\n            style.bottom = geo.bottom + \"px\";\n            // Clear any pending hide timer.\n            clearTimeout(this._timer);\n            this._timer = -1;\n            // If the overlay is already visible, we're done.\n            if (!this._hidden) {\n                return;\n            }\n            // Clear the hidden flag.\n            this._hidden = false;\n            // Finally, show the overlay.\n            this.node.classList.remove('lm-mod-hidden');\n            /* <DEPRECATED> */\n            this.node.classList.remove('p-mod-hidden');\n        };\n        /**\n         * Hide the overlay node.\n         *\n         * @param delay - The delay (in ms) before hiding the overlay.\n         *   A delay value <= 0 will hide the overlay immediately.\n         */\n        Overlay.prototype.hide = function (delay) {\n            var _this = this;\n            // Do nothing if the overlay is already hidden.\n            if (this._hidden) {\n                return;\n            }\n            // Hide immediately if the delay is <= 0.\n            if (delay <= 0) {\n                clearTimeout(this._timer);\n                this._timer = -1;\n                this._hidden = true;\n                this.node.classList.add('lm-mod-hidden');\n                /* <DEPRECATED> */\n                this.node.classList.add('p-mod-hidden');\n                return;\n            }\n            // Do nothing if a hide is already pending.\n            if (this._timer !== -1) {\n                return;\n            }\n            // Otherwise setup the hide timer.\n            this._timer = window.setTimeout(function () {\n                _this._timer = -1;\n                _this._hidden = true;\n                _this.node.classList.add('lm-mod-hidden');\n                /* <DEPRECATED> */\n                _this.node.classList.add('p-mod-hidden');\n            }, delay);\n        };\n        return Overlay;\n    }());\n    DockPanel.Overlay = Overlay;\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    var Renderer = /** @class */ (function () {\n        function Renderer() {\n        }\n        /**\n         * Create a new tab bar for use with a dock panel.\n         *\n         * @returns A new tab bar for a dock panel.\n         */\n        Renderer.prototype.createTabBar = function () {\n            var bar = new TabBar();\n            bar.addClass('lm-DockPanel-tabBar');\n            /* <DEPRECATED> */\n            bar.addClass('p-DockPanel-tabBar');\n            /* </DEPRECATED> */\n            return bar;\n        };\n        /**\n         * Create a new handle node for use with a dock panel.\n         *\n         * @returns A new handle node for a dock panel.\n         */\n        Renderer.prototype.createHandle = function () {\n            var handle = document.createElement('div');\n            handle.className = 'lm-DockPanel-handle';\n            /* <DEPRECATED> */\n            handle.classList.add('p-DockPanel-handle');\n            return handle;\n        };\n        return Renderer;\n    }());\n    DockPanel.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    DockPanel.defaultRenderer = new Renderer();\n})(DockPanel || (DockPanel = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$e;\n(function (Private) {\n    /**\n     * A fraction used for sizing root panels; ~= `1 / golden_ratio`.\n     */\n    Private.GOLDEN_RATIO = 0.618;\n    /**\n     * The default sizes for the edge drop zones, in pixels.\n     */\n    Private.DEFAULT_EDGES = {\n        /**\n         * The size of the top edge dock zone for the root panel, in pixels.\n         * This is different from the others to distinguish between the top\n         * tab bar and the top root zone.\n         */\n        top: 12,\n        /**\n         * The size of the edge dock zone for the root panel, in pixels.\n         */\n        right: 40,\n        /**\n         * The size of the edge dock zone for the root panel, in pixels.\n         */\n        bottom: 40,\n        /**\n         * The size of the edge dock zone for the root panel, in pixels.\n         */\n        left: 40\n    };\n    /**\n     * A singleton `'layout-modified'` conflatable message.\n     */\n    Private.LayoutModified = new _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.ConflatableMessage('layout-modified');\n    /**\n     * An attached property used to track generated tab bars.\n     */\n    Private.isGeneratedTabBarProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'isGeneratedTabBar',\n        create: function () { return false; }\n    });\n    /**\n     * Create a single document config for the widgets in a dock panel.\n     */\n    function createSingleDocumentConfig(panel) {\n        // Return an empty config if the panel is empty.\n        if (panel.isEmpty) {\n            return { main: null };\n        }\n        // Get a flat array of the widgets in the panel.\n        var widgets = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.toArray)(panel.widgets());\n        // Get the first selected widget in the panel.\n        var selected = panel.selectedWidgets().next();\n        // Compute the current index for the new config.\n        var currentIndex = selected ? widgets.indexOf(selected) : -1;\n        // Return the single document config.\n        return { main: { type: 'tab-area', widgets: widgets, currentIndex: currentIndex } };\n    }\n    Private.createSingleDocumentConfig = createSingleDocumentConfig;\n    /**\n     * Find the drop target at the given client position.\n     */\n    function findDropTarget(panel, clientX, clientY, edges) {\n        // Bail if the mouse is not over the dock panel.\n        if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(panel.node, clientX, clientY)) {\n            return { zone: 'invalid', target: null };\n        }\n        // Look up the layout for the panel.\n        var layout = panel.layout;\n        // If the layout is empty, indicate the entire root drop zone.\n        if (layout.isEmpty) {\n            return { zone: 'root-all', target: null };\n        }\n        // Test the edge zones when in multiple document mode.\n        if (panel.mode === 'multiple-document') {\n            // Get the client rect for the dock panel.\n            var panelRect = panel.node.getBoundingClientRect();\n            // Compute the distance to each edge of the panel.\n            var pl = clientX - panelRect.left + 1;\n            var pt = clientY - panelRect.top + 1;\n            var pr = panelRect.right - clientX;\n            var pb = panelRect.bottom - clientY;\n            // Find the minimum distance to an edge.\n            var pd = Math.min(pt, pr, pb, pl);\n            // Return a root zone if the mouse is within an edge.\n            switch (pd) {\n                case pt:\n                    if (pt < edges.top) {\n                        return { zone: 'root-top', target: null };\n                    }\n                    break;\n                case pr:\n                    if (pr < edges.right) {\n                        return { zone: 'root-right', target: null };\n                    }\n                    break;\n                case pb:\n                    if (pb < edges.bottom) {\n                        return { zone: 'root-bottom', target: null };\n                    }\n                    break;\n                case pl:\n                    if (pl < edges.left) {\n                        return { zone: 'root-left', target: null };\n                    }\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Hit test the dock layout at the given client position.\n        var target = layout.hitTestTabAreas(clientX, clientY);\n        // Bail if no target area was found.\n        if (!target) {\n            return { zone: 'invalid', target: null };\n        }\n        // Return the whole tab area when in single document mode.\n        if (panel.mode === 'single-document') {\n            return { zone: 'widget-all', target: target };\n        }\n        // Compute the distance to each edge of the tab area.\n        var al = target.x - target.left + 1;\n        var at = target.y - target.top + 1;\n        var ar = target.left + target.width - target.x;\n        var ab = target.top + target.height - target.y;\n        var tabHeight = target.tabBar.node.getBoundingClientRect().height;\n        if (at < tabHeight) {\n            return { zone: 'widget-tab', target: target };\n        }\n        // Get the X and Y edge sizes for the area.\n        var rx = Math.round(target.width / 3);\n        var ry = Math.round(target.height / 3);\n        // If the mouse is not within an edge, indicate the entire area.\n        if (al > rx && ar > rx && at > ry && ab > ry) {\n            return { zone: 'widget-all', target: target };\n        }\n        // Scale the distances by the slenderness ratio.\n        al /= rx;\n        at /= ry;\n        ar /= rx;\n        ab /= ry;\n        // Find the minimum distance to the area edge.\n        var ad = Math.min(al, at, ar, ab);\n        // Find the widget zone for the area edge.\n        var zone;\n        switch (ad) {\n            case al:\n                zone = 'widget-left';\n                break;\n            case at:\n                zone = 'widget-top';\n                break;\n            case ar:\n                zone = 'widget-right';\n                break;\n            case ab:\n                zone = 'widget-bottom';\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Return the final drop target.\n        return { zone: zone, target: target };\n    }\n    Private.findDropTarget = findDropTarget;\n    /**\n     * Get the drop reference widget for a tab bar.\n     */\n    function getDropRef(tabBar) {\n        if (tabBar.titles.length === 0) {\n            return null;\n        }\n        if (tabBar.currentTitle) {\n            return tabBar.currentTitle.owner;\n        }\n        return tabBar.titles[tabBar.titles.length - 1].owner;\n    }\n    Private.getDropRef = getDropRef;\n})(Private$e || (Private$e = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A class which tracks focus among a set of widgets.\n *\n * This class is useful when code needs to keep track of the most\n * recently focused widget(s) among a set of related widgets.\n */\nvar FocusTracker = /** @class */ (function () {\n    /**\n     * Construct a new focus tracker.\n     */\n    function FocusTracker() {\n        this._counter = 0;\n        this._widgets = [];\n        this._activeWidget = null;\n        this._currentWidget = null;\n        this._numbers = new Map();\n        this._nodes = new Map();\n        this._activeChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n        this._currentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    FocusTracker.prototype.dispose = function () {\n        var _this = this;\n        // Do nothing if the tracker is already disposed.\n        if (this._counter < 0) {\n            return;\n        }\n        // Mark the tracker as disposed.\n        this._counter = -1;\n        // Clear the connections for the tracker.\n        _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal.clearData(this);\n        // Remove all event listeners.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this._widgets, function (w) {\n            w.node.removeEventListener('focus', _this, true);\n            w.node.removeEventListener('blur', _this, true);\n        });\n        // Clear the internal data structures.\n        this._activeWidget = null;\n        this._currentWidget = null;\n        this._nodes.clear();\n        this._numbers.clear();\n        this._widgets.length = 0;\n    };\n    Object.defineProperty(FocusTracker.prototype, \"currentChanged\", {\n        /**\n         * A signal emitted when the current widget has changed.\n         */\n        get: function () {\n            return this._currentChanged;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FocusTracker.prototype, \"activeChanged\", {\n        /**\n         * A signal emitted when the active widget has changed.\n         */\n        get: function () {\n            return this._activeChanged;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FocusTracker.prototype, \"isDisposed\", {\n        /**\n         * A flag indicating whether the tracker is disposed.\n         */\n        get: function () {\n            return this._counter < 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FocusTracker.prototype, \"currentWidget\", {\n        /**\n         * The current widget in the tracker.\n         *\n         * #### Notes\n         * The current widget is the widget among the tracked widgets which\n         * has the *descendant node* which has most recently been focused.\n         *\n         * The current widget will not be updated if the node loses focus. It\n         * will only be updated when a different tracked widget gains focus.\n         *\n         * If the current widget is removed from the tracker, the previous\n         * current widget will be restored.\n         *\n         * This behavior is intended to follow a user's conceptual model of\n         * a semantically \"current\" widget, where the \"last thing of type X\"\n         * to be interacted with is the \"current instance of X\", regardless\n         * of whether that instance still has focus.\n         */\n        get: function () {\n            return this._currentWidget;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FocusTracker.prototype, \"activeWidget\", {\n        /**\n         * The active widget in the tracker.\n         *\n         * #### Notes\n         * The active widget is the widget among the tracked widgets which\n         * has the *descendant node* which is currently focused.\n         */\n        get: function () {\n            return this._activeWidget;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FocusTracker.prototype, \"widgets\", {\n        /**\n         * A read only array of the widgets being tracked.\n         */\n        get: function () {\n            return this._widgets;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the focus number for a particular widget in the tracker.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The focus number for the given widget, or `-1` if the\n     *   widget has not had focus since being added to the tracker, or\n     *   is not contained by the tracker.\n     *\n     * #### Notes\n     * The focus number indicates the relative order in which the widgets\n     * have gained focus. A widget with a larger number has gained focus\n     * more recently than a widget with a smaller number.\n     *\n     * The `currentWidget` will always have the largest focus number.\n     *\n     * All widgets start with a focus number of `-1`, which indicates that\n     * the widget has not been focused since being added to the tracker.\n     */\n    FocusTracker.prototype.focusNumber = function (widget) {\n        var n = this._numbers.get(widget);\n        return n === undefined ? -1 : n;\n    };\n    /**\n     * Test whether the focus tracker contains a given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns `true` if the widget is tracked, `false` otherwise.\n     */\n    FocusTracker.prototype.has = function (widget) {\n        return this._numbers.has(widget);\n    };\n    /**\n     * Add a widget to the focus tracker.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * A widget will be automatically removed from the tracker if it\n     * is disposed after being added.\n     *\n     * If the widget is already tracked, this is a no-op.\n     */\n    FocusTracker.prototype.add = function (widget) {\n        // Do nothing if the widget is already tracked.\n        if (this._numbers.has(widget)) {\n            return;\n        }\n        // Test whether the widget has focus.\n        var focused = widget.node.contains(document.activeElement);\n        // Set up the initial focus number.\n        var n = focused ? this._counter++ : -1;\n        // Add the widget to the internal data structures.\n        this._widgets.push(widget);\n        this._numbers.set(widget, n);\n        this._nodes.set(widget.node, widget);\n        // Set up the event listeners. The capturing phase must be used\n        // since the 'focus' and 'blur' events don't bubble and Firefox\n        // doesn't support the 'focusin' or 'focusout' events.\n        widget.node.addEventListener('focus', this, true);\n        widget.node.addEventListener('blur', this, true);\n        // Connect the disposed signal handler.\n        widget.disposed.connect(this._onWidgetDisposed, this);\n        // Set the current and active widgets if needed.\n        if (focused) {\n            this._setWidgets(widget, widget);\n        }\n    };\n    /**\n     * Remove a widget from the focus tracker.\n     *\n     * #### Notes\n     * If the widget is the `currentWidget`, the previous current widget\n     * will become the new `currentWidget`.\n     *\n     * A widget will be automatically removed from the tracker if it\n     * is disposed after being added.\n     *\n     * If the widget is not tracked, this is a no-op.\n     */\n    FocusTracker.prototype.remove = function (widget) {\n        var _this = this;\n        // Bail early if the widget is not tracked.\n        if (!this._numbers.has(widget)) {\n            return;\n        }\n        // Disconnect the disposed signal handler.\n        widget.disposed.disconnect(this._onWidgetDisposed, this);\n        // Remove the event listeners.\n        widget.node.removeEventListener('focus', this, true);\n        widget.node.removeEventListener('blur', this, true);\n        // Remove the widget from the internal data structures.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeFirstOf(this._widgets, widget);\n        this._nodes.delete(widget.node);\n        this._numbers.delete(widget);\n        // Bail early if the widget is not the current widget.\n        if (this._currentWidget !== widget) {\n            return;\n        }\n        // Filter the widgets for those which have had focus.\n        var valid = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.filter)(this._widgets, function (w) { return _this._numbers.get(w) !== -1; });\n        // Get the valid widget with the max focus number.\n        var previous = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.max)(valid, function (first, second) {\n            var a = _this._numbers.get(first);\n            var b = _this._numbers.get(second);\n            return a - b;\n        }) || null;\n        // Set the current and active widgets.\n        this._setWidgets(previous, null);\n    };\n    /**\n     * Handle the DOM events for the focus tracker.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the tracked nodes. It should\n     * not be called directly by user code.\n     */\n    FocusTracker.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'focus':\n                this._evtFocus(event);\n                break;\n            case 'blur':\n                this._evtBlur(event);\n                break;\n        }\n    };\n    /**\n     * Set the current and active widgets for the tracker.\n     */\n    FocusTracker.prototype._setWidgets = function (current, active) {\n        // Swap the current widget.\n        var oldCurrent = this._currentWidget;\n        this._currentWidget = current;\n        // Swap the active widget.\n        var oldActive = this._activeWidget;\n        this._activeWidget = active;\n        // Emit the `currentChanged` signal if needed.\n        if (oldCurrent !== current) {\n            this._currentChanged.emit({ oldValue: oldCurrent, newValue: current });\n        }\n        // Emit the `activeChanged` signal if needed.\n        if (oldActive !== active) {\n            this._activeChanged.emit({ oldValue: oldActive, newValue: active });\n        }\n    };\n    /**\n     * Handle the `'focus'` event for a tracked widget.\n     */\n    FocusTracker.prototype._evtFocus = function (event) {\n        // Find the widget which gained focus, which is known to exist.\n        var widget = this._nodes.get(event.currentTarget);\n        // Update the focus number if necessary.\n        if (widget !== this._currentWidget) {\n            this._numbers.set(widget, this._counter++);\n        }\n        // Set the current and active widgets.\n        this._setWidgets(widget, widget);\n    };\n    /**\n     * Handle the `'blur'` event for a tracked widget.\n     */\n    FocusTracker.prototype._evtBlur = function (event) {\n        // Find the widget which lost focus, which is known to exist.\n        var widget = this._nodes.get(event.currentTarget);\n        // Get the node which being focused after this blur.\n        var focusTarget = event.relatedTarget;\n        // If no other node is being focused, clear the active widget.\n        if (!focusTarget) {\n            this._setWidgets(this._currentWidget, null);\n            return;\n        }\n        // Bail if the focus widget is not changing.\n        if (widget.node.contains(focusTarget)) {\n            return;\n        }\n        // If no tracked widget is being focused, clear the active widget.\n        if (!(0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(this._widgets, function (w) { return w.node.contains(focusTarget); })) {\n            this._setWidgets(this._currentWidget, null);\n            return;\n        }\n    };\n    /**\n     * Handle the `disposed` signal for a tracked widget.\n     */\n    FocusTracker.prototype._onWidgetDisposed = function (sender) {\n        this.remove(sender);\n    };\n    return FocusTracker;\n}());\n\n/**\n * A layout which arranges its widgets in a grid.\n */\nvar GridLayout = /** @class */ (function (_super) {\n    __extends(GridLayout, _super);\n    /**\n     * Construct a new grid layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    function GridLayout(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this._dirty = false;\n        _this._rowSpacing = 4;\n        _this._columnSpacing = 4;\n        _this._items = [];\n        _this._rowStarts = [];\n        _this._columnStarts = [];\n        _this._rowSizers = [new BoxSizer()];\n        _this._columnSizers = [new BoxSizer()];\n        _this._box = null;\n        if (options.rowCount !== undefined) {\n            Private$f.reallocSizers(_this._rowSizers, options.rowCount);\n        }\n        if (options.columnCount !== undefined) {\n            Private$f.reallocSizers(_this._columnSizers, options.columnCount);\n        }\n        if (options.rowSpacing !== undefined) {\n            _this._rowSpacing = Private$f.clampValue(options.rowSpacing);\n        }\n        if (options.columnSpacing !== undefined) {\n            _this._columnSpacing = Private$f.clampValue(options.columnSpacing);\n        }\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    GridLayout.prototype.dispose = function () {\n        // Dispose of the widgets and layout items.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this._items, function (item) {\n            var widget = item.widget;\n            item.dispose();\n            widget.dispose();\n        });\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        this._rowStarts.length = 0;\n        this._rowSizers.length = 0;\n        this._columnStarts.length = 0;\n        this._columnSizers.length = 0;\n        // Dispose of the rest of the layout.\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(GridLayout.prototype, \"rowCount\", {\n        /**\n         * Get the number of rows in the layout.\n         */\n        get: function () {\n            return this._rowSizers.length;\n        },\n        /**\n         * Set the number of rows in the layout.\n         *\n         * #### Notes\n         * The minimum row count is `1`.\n         */\n        set: function (value) {\n            // Do nothing if the row count does not change.\n            if (value === this.rowCount) {\n                return;\n            }\n            // Reallocate the row sizers.\n            Private$f.reallocSizers(this._rowSizers, value);\n            // Schedule a fit of the parent.\n            if (this.parent) {\n                this.parent.fit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GridLayout.prototype, \"columnCount\", {\n        /**\n         * Get the number of columns in the layout.\n         */\n        get: function () {\n            return this._columnSizers.length;\n        },\n        /**\n         * Set the number of columns in the layout.\n         *\n         * #### Notes\n         * The minimum column count is `1`.\n         */\n        set: function (value) {\n            // Do nothing if the column count does not change.\n            if (value === this.columnCount) {\n                return;\n            }\n            // Reallocate the column sizers.\n            Private$f.reallocSizers(this._columnSizers, value);\n            // Schedule a fit of the parent.\n            if (this.parent) {\n                this.parent.fit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GridLayout.prototype, \"rowSpacing\", {\n        /**\n         * Get the row spacing for the layout.\n         */\n        get: function () {\n            return this._rowSpacing;\n        },\n        /**\n         * Set the row spacing for the layout.\n         */\n        set: function (value) {\n            // Clamp the spacing to the allowed range.\n            value = Private$f.clampValue(value);\n            // Bail if the spacing does not change\n            if (this._rowSpacing === value) {\n                return;\n            }\n            // Update the internal spacing.\n            this._rowSpacing = value;\n            // Schedule a fit of the parent.\n            if (this.parent) {\n                this.parent.fit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GridLayout.prototype, \"columnSpacing\", {\n        /**\n         * Get the column spacing for the layout.\n         */\n        get: function () {\n            return this._columnSpacing;\n        },\n        /**\n         * Set the col spacing for the layout.\n         */\n        set: function (value) {\n            // Clamp the spacing to the allowed range.\n            value = Private$f.clampValue(value);\n            // Bail if the spacing does not change\n            if (this._columnSpacing === value) {\n                return;\n            }\n            // Update the internal spacing.\n            this._columnSpacing = value;\n            // Schedule a fit of the parent.\n            if (this.parent) {\n                this.parent.fit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the stretch factor for a specific row.\n     *\n     * @param index - The row index of interest.\n     *\n     * @returns The stretch factor for the row.\n     *\n     * #### Notes\n     * This returns `-1` if the index is out of range.\n     */\n    GridLayout.prototype.rowStretch = function (index) {\n        var sizer = this._rowSizers[index];\n        return sizer ? sizer.stretch : -1;\n    };\n    /**\n     * Set the stretch factor for a specific row.\n     *\n     * @param index - The row index of interest.\n     *\n     * @param value - The stretch factor for the row.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    GridLayout.prototype.setRowStretch = function (index, value) {\n        // Look up the row sizer.\n        var sizer = this._rowSizers[index];\n        // Bail if the index is out of range.\n        if (!sizer) {\n            return;\n        }\n        // Clamp the value to the allowed range.\n        value = Private$f.clampValue(value);\n        // Bail if the stretch does not change.\n        if (sizer.stretch === value) {\n            return;\n        }\n        // Update the sizer stretch.\n        sizer.stretch = value;\n        // Schedule an update of the parent.\n        if (this.parent) {\n            this.parent.update();\n        }\n    };\n    /**\n     * Get the stretch factor for a specific column.\n     *\n     * @param index - The column index of interest.\n     *\n     * @returns The stretch factor for the column.\n     *\n     * #### Notes\n     * This returns `-1` if the index is out of range.\n     */\n    GridLayout.prototype.columnStretch = function (index) {\n        var sizer = this._columnSizers[index];\n        return sizer ? sizer.stretch : -1;\n    };\n    /**\n     * Set the stretch factor for a specific column.\n     *\n     * @param index - The column index of interest.\n     *\n     * @param value - The stretch factor for the column.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    GridLayout.prototype.setColumnStretch = function (index, value) {\n        // Look up the column sizer.\n        var sizer = this._columnSizers[index];\n        // Bail if the index is out of range.\n        if (!sizer) {\n            return;\n        }\n        // Clamp the value to the allowed range.\n        value = Private$f.clampValue(value);\n        // Bail if the stretch does not change.\n        if (sizer.stretch === value) {\n            return;\n        }\n        // Update the sizer stretch.\n        sizer.stretch = value;\n        // Schedule an update of the parent.\n        if (this.parent) {\n            this.parent.update();\n        }\n    };\n    /**\n     * Create an iterator over the widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     */\n    GridLayout.prototype.iter = function () {\n        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.map)(this._items, function (item) { return item.widget; });\n    };\n    /**\n     * Add a widget to the grid layout.\n     *\n     * @param widget - The widget to add to the layout.\n     *\n     * #### Notes\n     * If the widget is already contained in the layout, this is no-op.\n     */\n    GridLayout.prototype.addWidget = function (widget) {\n        // Look up the index for the widget.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this._items, function (it) { return it.widget === widget; });\n        // Bail if the widget is already in the layout.\n        if (i !== -1) {\n            return;\n        }\n        // Add the widget to the layout.\n        this._items.push(new LayoutItem(widget));\n        // Attach the widget to the parent.\n        if (this.parent) {\n            this.attachWidget(widget);\n        }\n    };\n    /**\n     * Remove a widget from the grid layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    GridLayout.prototype.removeWidget = function (widget) {\n        // Look up the index for the widget.\n        var i = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this._items, function (it) { return it.widget === widget; });\n        // Bail if the widget is not in the layout.\n        if (i === -1) {\n            return;\n        }\n        // Remove the widget from the layout.\n        var item = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._items, i);\n        // Detach the widget from the parent.\n        if (this.parent) {\n            this.detachWidget(widget);\n        }\n        // Dispose the layout item.\n        item.dispose();\n    };\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    GridLayout.prototype.init = function () {\n        var _this = this;\n        _super.prototype.init.call(this);\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) { _this.attachWidget(widget); });\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param widget - The widget to attach to the parent.\n     */\n    GridLayout.prototype.attachWidget = function (widget) {\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param widget - The widget to detach from the parent.\n     */\n    GridLayout.prototype.detachWidget = function (widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    GridLayout.prototype.onBeforeShow = function (msg) {\n        _super.prototype.onBeforeShow.call(this, msg);\n        this.parent.update();\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    GridLayout.prototype.onBeforeAttach = function (msg) {\n        _super.prototype.onBeforeAttach.call(this, msg);\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    GridLayout.prototype.onChildShown = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    GridLayout.prototype.onChildHidden = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    GridLayout.prototype.onResize = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    GridLayout.prototype.onUpdateRequest = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    GridLayout.prototype.onFitRequest = function (msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    };\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    GridLayout.prototype._fit = function () {\n        // Reset the min sizes of the sizers.\n        for (var i = 0, n = this.rowCount; i < n; ++i) {\n            this._rowSizers[i].minSize = 0;\n        }\n        for (var i = 0, n = this.columnCount; i < n; ++i) {\n            this._columnSizers[i].minSize = 0;\n        }\n        // Filter for the visible layout items.\n        var items = this._items.filter(function (it) { return !it.isHidden; });\n        // Fit the layout items.\n        for (var i = 0, n = items.length; i < n; ++i) {\n            items[i].fit();\n        }\n        // Get the max row and column index.\n        var maxRow = this.rowCount - 1;\n        var maxCol = this.columnCount - 1;\n        // Sort the items by row span.\n        items.sort(Private$f.rowSpanCmp);\n        // Update the min sizes of the row sizers.\n        for (var i = 0, n = items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = items[i];\n            // Get the row bounds for the item.\n            var config = GridLayout.getCellConfig(item.widget);\n            var r1 = Math.min(config.row, maxRow);\n            var r2 = Math.min(config.row + config.rowSpan - 1, maxRow);\n            // Distribute the minimum height to the sizers as needed.\n            Private$f.distributeMin(this._rowSizers, r1, r2, item.minHeight);\n        }\n        // Sort the items by column span.\n        items.sort(Private$f.columnSpanCmp);\n        // Update the min sizes of the column sizers.\n        for (var i = 0, n = items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = items[i];\n            // Get the column bounds for the item.\n            var config = GridLayout.getCellConfig(item.widget);\n            var c1 = Math.min(config.column, maxCol);\n            var c2 = Math.min(config.column + config.columnSpan - 1, maxCol);\n            // Distribute the minimum width to the sizers as needed.\n            Private$f.distributeMin(this._columnSizers, c1, c2, item.minWidth);\n        }\n        // If no size constraint is needed, just update the parent.\n        if (this.fitPolicy === 'set-no-constraint') {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n            return;\n        }\n        // Set up the computed min size.\n        var minH = maxRow * this._rowSpacing;\n        var minW = maxCol * this._columnSpacing;\n        // Add the sizer minimums to the computed min size.\n        for (var i = 0, n = this.rowCount; i < n; ++i) {\n            minH += this._rowSizers[i].minSize;\n        }\n        for (var i = 0, n = this.columnCount; i < n; ++i) {\n            minW += this._columnSizers[i].minSize;\n        }\n        // Update the box sizing and add it to the computed min size.\n        var box = this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        var style = this.parent.node.style;\n        style.minWidth = minW + \"px\";\n        style.minHeight = minH + \"px\";\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    };\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    GridLayout.prototype._update = function (offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the layout area adjusted for border and padding.\n        var top = this._box.paddingTop;\n        var left = this._box.paddingLeft;\n        var width = offsetWidth - this._box.horizontalSum;\n        var height = offsetHeight - this._box.verticalSum;\n        // Get the max row and column index.\n        var maxRow = this.rowCount - 1;\n        var maxCol = this.columnCount - 1;\n        // Compute the total fixed row and column space.\n        var fixedRowSpace = maxRow * this._rowSpacing;\n        var fixedColSpace = maxCol * this._columnSpacing;\n        // Distribute the available space to the box sizers.\n        BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));\n        BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));\n        // Update the row start positions.\n        for (var i = 0, pos = top, n = this.rowCount; i < n; ++i) {\n            this._rowStarts[i] = pos;\n            pos += this._rowSizers[i].size + this._rowSpacing;\n        }\n        // Update the column start positions.\n        for (var i = 0, pos = left, n = this.columnCount; i < n; ++i) {\n            this._columnStarts[i] = pos;\n            pos += this._columnSizers[i].size + this._columnSpacing;\n        }\n        // Update the geometry of the layout items.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Fetch the cell bounds for the widget.\n            var config = GridLayout.getCellConfig(item.widget);\n            var r1 = Math.min(config.row, maxRow);\n            var c1 = Math.min(config.column, maxCol);\n            var r2 = Math.min(config.row + config.rowSpan - 1, maxRow);\n            var c2 = Math.min(config.column + config.columnSpan - 1, maxCol);\n            // Compute the cell geometry.\n            var x = this._columnStarts[c1];\n            var y = this._rowStarts[r1];\n            var w = this._columnStarts[c2] + this._columnSizers[c2].size - x;\n            var h = this._rowStarts[r2] + this._rowSizers[r2].size - y;\n            // Update the geometry of the layout item.\n            item.update(x, y, w, h);\n        }\n    };\n    return GridLayout;\n}(Layout));\n/**\n * The namespace for the `GridLayout` class statics.\n */\n(function (GridLayout) {\n    /**\n     * Get the cell config for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The cell config for the widget.\n     */\n    function getCellConfig(widget) {\n        return Private$f.cellConfigProperty.get(widget);\n    }\n    GridLayout.getCellConfig = getCellConfig;\n    /**\n     * Set the cell config for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the cell config.\n     */\n    function setCellConfig(widget, value) {\n        Private$f.cellConfigProperty.set(widget, Private$f.normalizeConfig(value));\n    }\n    GridLayout.setCellConfig = setCellConfig;\n})(GridLayout || (GridLayout = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$f;\n(function (Private) {\n    /**\n     * The property descriptor for the widget cell config.\n     */\n    Private.cellConfigProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_3__.AttachedProperty({\n        name: 'cellConfig',\n        create: function () { return ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }); },\n        changed: onChildCellConfigChanged\n    });\n    /**\n     * Normalize a partial cell config object.\n     */\n    function normalizeConfig(config) {\n        var row = Math.max(0, Math.floor(config.row || 0));\n        var column = Math.max(0, Math.floor(config.column || 0));\n        var rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));\n        var columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));\n        return { row: row, column: column, rowSpan: rowSpan, columnSpan: columnSpan };\n    }\n    Private.normalizeConfig = normalizeConfig;\n    /**\n     * Clamp a value to an integer >= 0.\n     */\n    function clampValue(value) {\n        return Math.max(0, Math.floor(value));\n    }\n    Private.clampValue = clampValue;\n    /**\n     * A sort comparison function for row spans.\n     */\n    function rowSpanCmp(a, b) {\n        var c1 = Private.cellConfigProperty.get(a.widget);\n        var c2 = Private.cellConfigProperty.get(b.widget);\n        return c1.rowSpan - c2.rowSpan;\n    }\n    Private.rowSpanCmp = rowSpanCmp;\n    /**\n     * A sort comparison function for column spans.\n     */\n    function columnSpanCmp(a, b) {\n        var c1 = Private.cellConfigProperty.get(a.widget);\n        var c2 = Private.cellConfigProperty.get(b.widget);\n        return c1.columnSpan - c2.columnSpan;\n    }\n    Private.columnSpanCmp = columnSpanCmp;\n    /**\n     * Reallocate the box sizers for the given grid dimensions.\n     */\n    function reallocSizers(sizers, count) {\n        // Coerce the count to the valid range.\n        count = Math.max(1, Math.floor(count));\n        // Add the missing sizers.\n        while (sizers.length < count) {\n            sizers.push(new BoxSizer());\n        }\n        // Remove the extra sizers.\n        if (sizers.length > count) {\n            sizers.length = count;\n        }\n    }\n    Private.reallocSizers = reallocSizers;\n    /**\n     * Distribute a min size constraint across a range of sizers.\n     */\n    function distributeMin(sizers, i1, i2, minSize) {\n        // Sanity check the indices.\n        if (i2 < i1) {\n            return;\n        }\n        // Handle the simple case of no cell span.\n        if (i1 === i2) {\n            var sizer = sizers[i1];\n            sizer.minSize = Math.max(sizer.minSize, minSize);\n            return;\n        }\n        // Compute the total current min size of the span.\n        var totalMin = 0;\n        for (var i = i1; i <= i2; ++i) {\n            totalMin += sizers[i].minSize;\n        }\n        // Do nothing if the total is greater than the required.\n        if (totalMin >= minSize) {\n            return;\n        }\n        // Compute the portion of the space to allocate to each sizer.\n        var portion = (minSize - totalMin) / (i2 - i1 + 1);\n        // Add the portion to each sizer.\n        for (var i = i1; i <= i2; ++i) {\n            sizers[i].minSize += portion;\n        }\n    }\n    Private.distributeMin = distributeMin;\n    /**\n     * The change handler for the child cell config property.\n     */\n    function onChildCellConfigChanged(child) {\n        if (child.parent && child.parent.layout instanceof GridLayout) {\n            child.parent.fit();\n        }\n    }\n})(Private$f || (Private$f = {}));\n\n/**\n * A widget which displays menus as a canonical menu bar.\n */\nvar MenuBar = /** @class */ (function (_super) {\n    __extends(MenuBar, _super);\n    /**\n     * Construct a new menu bar.\n     *\n     * @param options - The options for initializing the menu bar.\n     */\n    function MenuBar(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { node: Private$g.createNode() }) || this;\n        _this._activeIndex = -1;\n        _this._menus = [];\n        _this._childMenu = null;\n        _this.addClass('lm-MenuBar');\n        /* <DEPRECATED> */\n        _this.addClass('p-MenuBar');\n        /* </DEPRECATED> */\n        _this.setFlag(Widget.Flag.DisallowLayout);\n        _this.renderer = options.renderer || MenuBar.defaultRenderer;\n        _this._forceItemsPosition = options.forceItemsPosition || { forceX: true, forceY: true };\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    MenuBar.prototype.dispose = function () {\n        this._closeChildMenu();\n        this._menus.length = 0;\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(MenuBar.prototype, \"childMenu\", {\n        /**\n         * The child menu of the menu bar.\n         *\n         * #### Notes\n         * This will be `null` if the menu bar does not have an open menu.\n         */\n        get: function () {\n            return this._childMenu;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MenuBar.prototype, \"contentNode\", {\n        /**\n         * Get the menu bar content node.\n         *\n         * #### Notes\n         * This is the node which holds the menu title nodes.\n         *\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-MenuBar-content')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MenuBar.prototype, \"activeMenu\", {\n        /**\n         * Get the currently active menu.\n         */\n        get: function () {\n            return this._menus[this._activeIndex] || null;\n        },\n        /**\n         * Set the currently active menu.\n         *\n         * #### Notes\n         * If the menu does not exist, the menu will be set to `null`.\n         */\n        set: function (value) {\n            this.activeIndex = value ? this._menus.indexOf(value) : -1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MenuBar.prototype, \"activeIndex\", {\n        /**\n         * Get the index of the currently active menu.\n         *\n         * #### Notes\n         * This will be `-1` if no menu is active.\n         */\n        get: function () {\n            return this._activeIndex;\n        },\n        /**\n         * Set the index of the currently active menu.\n         *\n         * #### Notes\n         * If the menu cannot be activated, the index will be set to `-1`.\n         */\n        set: function (value) {\n            // Adjust the value for an out of range index.\n            if (value < 0 || value >= this._menus.length) {\n                value = -1;\n            }\n            // Bail early if the index will not change.\n            if (this._activeIndex === value) {\n                return;\n            }\n            // Update the active index.\n            this._activeIndex = value;\n            // Update focus to new active index\n            if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {\n                this.contentNode.childNodes[this._activeIndex].focus();\n            }\n            // Schedule an update of the items.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MenuBar.prototype, \"menus\", {\n        /**\n         * A read-only array of the menus in the menu bar.\n         */\n        get: function () {\n            return this._menus;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Open the active menu and activate its first menu item.\n     *\n     * #### Notes\n     * If there is no active menu, this is a no-op.\n     */\n    MenuBar.prototype.openActiveMenu = function () {\n        // Bail early if there is no active item.\n        if (this._activeIndex === -1) {\n            return;\n        }\n        // Open the child menu.\n        this._openChildMenu();\n        // Activate the first item in the child menu.\n        if (this._childMenu) {\n            this._childMenu.activeIndex = -1;\n            this._childMenu.activateNextItem();\n        }\n    };\n    /**\n     * Add a menu to the end of the menu bar.\n     *\n     * @param menu - The menu to add to the menu bar.\n     *\n     * #### Notes\n     * If the menu is already added to the menu bar, it will be moved.\n     */\n    MenuBar.prototype.addMenu = function (menu) {\n        this.insertMenu(this._menus.length, menu);\n    };\n    /**\n     * Insert a menu into the menu bar at the specified index.\n     *\n     * @param index - The index at which to insert the menu.\n     *\n     * @param menu - The menu to insert into the menu bar.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the menus.\n     *\n     * If the menu is already added to the menu bar, it will be moved.\n     */\n    MenuBar.prototype.insertMenu = function (index, menu) {\n        // Close the child menu before making changes.\n        this._closeChildMenu();\n        // Look up the index of the menu.\n        var i = this._menus.indexOf(menu);\n        // Clamp the insert index to the array bounds.\n        var j = Math.max(0, Math.min(index, this._menus.length));\n        // If the menu is not in the array, insert it.\n        if (i === -1) {\n            // Insert the menu into the array.\n            _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._menus, j, menu);\n            // Add the styling class to the menu.\n            menu.addClass('lm-MenuBar-menu');\n            /* <DEPRECATED> */\n            menu.addClass('p-MenuBar-menu');\n            /* </DEPRECATED> */\n            // Connect to the menu signals.\n            menu.aboutToClose.connect(this._onMenuAboutToClose, this);\n            menu.menuRequested.connect(this._onMenuMenuRequested, this);\n            menu.title.changed.connect(this._onTitleChanged, this);\n            // Schedule an update of the items.\n            this.update();\n            // There is nothing more to do.\n            return;\n        }\n        // Otherwise, the menu exists in the array and should be moved.\n        // Adjust the index if the location is at the end of the array.\n        if (j === this._menus.length) {\n            j--;\n        }\n        // Bail if there is no effective move.\n        if (i === j) {\n            return;\n        }\n        // Move the menu to the new locations.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._menus, i, j);\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Remove a menu from the menu bar.\n     *\n     * @param menu - The menu to remove from the menu bar.\n     *\n     * #### Notes\n     * This is a no-op if the menu is not in the menu bar.\n     */\n    MenuBar.prototype.removeMenu = function (menu) {\n        this.removeMenuAt(this._menus.indexOf(menu));\n    };\n    /**\n     * Remove the menu at a given index from the menu bar.\n     *\n     * @param index - The index of the menu to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    MenuBar.prototype.removeMenuAt = function (index) {\n        // Close the child menu before making changes.\n        this._closeChildMenu();\n        // Remove the menu from the array.\n        var menu = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._menus, index);\n        // Bail if the index is out of range.\n        if (!menu) {\n            return;\n        }\n        // Disconnect from the menu signals.\n        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);\n        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);\n        menu.title.changed.disconnect(this._onTitleChanged, this);\n        // Remove the styling class from the menu.\n        menu.removeClass('lm-MenuBar-menu');\n        /* <DEPRECATED> */\n        menu.removeClass('p-MenuBar-menu');\n        /* </DEPRECATED> */\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Remove all menus from the menu bar.\n     */\n    MenuBar.prototype.clearMenus = function () {\n        // Bail if there is nothing to remove.\n        if (this._menus.length === 0) {\n            return;\n        }\n        // Close the child menu before making changes.\n        this._closeChildMenu();\n        // Disconnect from the menu signals and remove the styling class.\n        for (var _i = 0, _a = this._menus; _i < _a.length; _i++) {\n            var menu = _a[_i];\n            menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);\n            menu.menuRequested.disconnect(this._onMenuMenuRequested, this);\n            menu.title.changed.disconnect(this._onTitleChanged, this);\n            menu.removeClass('lm-MenuBar-menu');\n            /* <DEPRECATED> */\n            menu.removeClass('p-MenuBar-menu');\n            /* </DEPRECATED> */\n        }\n        // Clear the menus array.\n        this._menus.length = 0;\n        // Schedule an update of the items.\n        this.update();\n    };\n    /**\n     * Handle the DOM events for the menu bar.\n     *\n     * @param event - The DOM event sent to the menu bar.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the menu bar's DOM nodes. It\n     * should not be called directly by user code.\n     */\n    MenuBar.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseleave':\n                this._evtMouseLeave(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    MenuBar.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('keydown', this);\n        this.node.addEventListener('mousedown', this);\n        this.node.addEventListener('mousemove', this);\n        this.node.addEventListener('mouseleave', this);\n        this.node.addEventListener('contextmenu', this);\n    };\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    MenuBar.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('keydown', this);\n        this.node.removeEventListener('mousedown', this);\n        this.node.removeEventListener('mousemove', this);\n        this.node.removeEventListener('mouseleave', this);\n        this.node.removeEventListener('contextmenu', this);\n        this._closeChildMenu();\n    };\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    MenuBar.prototype.onActivateRequest = function (msg) {\n        if (this.isAttached) {\n            this.node.focus();\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    MenuBar.prototype.onUpdateRequest = function (msg) {\n        var _this = this;\n        var menus = this._menus;\n        var renderer = this.renderer;\n        var activeIndex = this._activeIndex;\n        var content = new Array(menus.length);\n        var _loop_1 = function (i, n) {\n            var title = menus[i].title;\n            var active = i === activeIndex;\n            content[i] = renderer.renderItem({\n                title: title,\n                active: active,\n                onfocus: function () {\n                    _this.activeIndex = i;\n                }\n            });\n        };\n        for (var i = 0, n = menus.length; i < n; ++i) {\n            _loop_1(i);\n        }\n        _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.VirtualDOM.render(content, this.contentNode);\n    };\n    /**\n     * Handle the `'keydown'` event for the menu bar.\n     */\n    MenuBar.prototype._evtKeyDown = function (event) {\n        // A menu bar handles all keydown events.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the key code for the event.\n        var kc = event.keyCode;\n        // Enter, Up Arrow, Down Arrow\n        if (kc === 13 || kc === 38 || kc === 40) {\n            this.openActiveMenu();\n            return;\n        }\n        // Escape\n        if (kc === 27) {\n            this._closeChildMenu();\n            this.activeIndex = -1;\n            this.node.blur();\n            return;\n        }\n        // Left Arrow\n        if (kc === 37) {\n            var i = this._activeIndex;\n            var n = this._menus.length;\n            this.activeIndex = i === 0 ? n - 1 : i - 1;\n            return;\n        }\n        // Right Arrow\n        if (kc === 39) {\n            var i = this._activeIndex;\n            var n = this._menus.length;\n            this.activeIndex = i === n - 1 ? 0 : i + 1;\n            return;\n        }\n        // Get the pressed key character.\n        var key = (0,_lumino_keyboard__WEBPACK_IMPORTED_MODULE_10__.getKeyboardLayout)().keyForKeydownEvent(event);\n        // Bail if the key is not valid.\n        if (!key) {\n            return;\n        }\n        // Search for the next best matching mnemonic item.\n        var start = this._activeIndex + 1;\n        var result = Private$g.findMnemonic(this._menus, key, start);\n        // Handle the requested mnemonic based on the search results.\n        // If exactly one mnemonic is matched, that menu is opened.\n        // Otherwise, the next mnemonic is activated if available,\n        // followed by the auto mnemonic if available.\n        if (result.index !== -1 && !result.multiple) {\n            this.activeIndex = result.index;\n            this.openActiveMenu();\n        }\n        else if (result.index !== -1) {\n            this.activeIndex = result.index;\n        }\n        else if (result.auto !== -1) {\n            this.activeIndex = result.auto;\n        }\n    };\n    /**\n     * Handle the `'mousedown'` event for the menu bar.\n     */\n    MenuBar.prototype._evtMouseDown = function (event) {\n        // Bail if the mouse press was not on the menu bar. This can occur\n        // when the document listener is installed for an active menu bar.\n        if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(this.node, event.clientX, event.clientY)) {\n            return;\n        }\n        // Stop the propagation of the event. Immediate propagation is\n        // also stopped so that an open menu does not handle the event.\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n        // Check if the mouse is over one of the menu items.\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this.contentNode.children, function (node) {\n            return _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(node, event.clientX, event.clientY);\n        });\n        // If the press was not on an item, close the child menu.\n        if (index === -1) {\n            this._closeChildMenu();\n            return;\n        }\n        // If the press was not the left mouse button, do nothing further.\n        if (event.button !== 0) {\n            return;\n        }\n        // Otherwise, toggle the open state of the child menu.\n        if (this._childMenu) {\n            this._closeChildMenu();\n            this.activeIndex = index;\n        }\n        else {\n            this.activeIndex = index;\n            this._openChildMenu();\n        }\n    };\n    /**\n     * Handle the `'mousemove'` event for the menu bar.\n     */\n    MenuBar.prototype._evtMouseMove = function (event) {\n        // Check if the mouse is over one of the menu items.\n        var index = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.findFirstIndex(this.contentNode.children, function (node) {\n            return _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(node, event.clientX, event.clientY);\n        });\n        // Bail early if the active index will not change.\n        if (index === this._activeIndex) {\n            return;\n        }\n        // Bail early if a child menu is open and the mouse is not over\n        // an item. This allows the child menu to be kept open when the\n        // mouse is over the empty part of the menu bar.\n        if (index === -1 && this._childMenu) {\n            return;\n        }\n        // Update the active index to the hovered item.\n        this.activeIndex = index;\n        // Open the new menu if a menu is already open.\n        if (this._childMenu) {\n            this._openChildMenu();\n        }\n    };\n    /**\n     * Handle the `'mouseleave'` event for the menu bar.\n     */\n    MenuBar.prototype._evtMouseLeave = function (event) {\n        // Reset the active index if there is no open menu.\n        if (!this._childMenu) {\n            this.activeIndex = -1;\n        }\n    };\n    /**\n     * Open the child menu at the active index immediately.\n     *\n     * If a different child menu is already open, it will be closed,\n     * even if there is no active menu.\n     */\n    MenuBar.prototype._openChildMenu = function () {\n        // If there is no active menu, close the current menu.\n        var newMenu = this.activeMenu;\n        if (!newMenu) {\n            this._closeChildMenu();\n            return;\n        }\n        // Bail if there is no effective menu change.\n        var oldMenu = this._childMenu;\n        if (oldMenu === newMenu) {\n            return;\n        }\n        // Swap the internal menu reference.\n        this._childMenu = newMenu;\n        // Close the current menu, or setup for the new menu.\n        if (oldMenu) {\n            oldMenu.close();\n        }\n        else {\n            this.addClass('lm-mod-active');\n            /* <DEPRECATED> */\n            this.addClass('p-mod-active');\n            /* </DEPRECATED> */\n            document.addEventListener('mousedown', this, true);\n        }\n        // Ensure the menu bar is updated and look up the item node.\n        _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n        var itemNode = this.contentNode.children[this._activeIndex];\n        // Get the positioning data for the new menu.\n        var _a = itemNode.getBoundingClientRect(), left = _a.left, bottom = _a.bottom;\n        // Open the new menu at the computed location.\n        newMenu.open(left, bottom, this._forceItemsPosition);\n    };\n    /**\n     * Close the child menu immediately.\n     *\n     * This is a no-op if a child menu is not open.\n     */\n    MenuBar.prototype._closeChildMenu = function () {\n        // Bail if no child menu is open.\n        if (!this._childMenu) {\n            return;\n        }\n        // Remove the active class from the menu bar.\n        this.removeClass('lm-mod-active');\n        /* <DEPRECATED> */\n        this.removeClass('p-mod-active');\n        /* </DEPRECATED> */\n        // Remove the document listeners.\n        document.removeEventListener('mousedown', this, true);\n        // Clear the internal menu reference.\n        var menu = this._childMenu;\n        this._childMenu = null;\n        // Close the menu.\n        menu.close();\n        // Reset the active index.\n        this.activeIndex = -1;\n    };\n    /**\n     * Handle the `aboutToClose` signal of a menu.\n     */\n    MenuBar.prototype._onMenuAboutToClose = function (sender) {\n        // Bail if the sender is not the child menu.\n        if (sender !== this._childMenu) {\n            return;\n        }\n        // Remove the active class from the menu bar.\n        this.removeClass('lm-mod-active');\n        /* <DEPRECATED> */\n        this.removeClass('p-mod-active');\n        /* </DEPRECATED> */\n        // Remove the document listeners.\n        document.removeEventListener('mousedown', this, true);\n        // Clear the internal menu reference.\n        this._childMenu = null;\n        // Reset the active index.\n        this.activeIndex = -1;\n    };\n    /**\n     * Handle the `menuRequested` signal of a child menu.\n     */\n    MenuBar.prototype._onMenuMenuRequested = function (sender, args) {\n        // Bail if the sender is not the child menu.\n        if (sender !== this._childMenu) {\n            return;\n        }\n        // Look up the active index and menu count.\n        var i = this._activeIndex;\n        var n = this._menus.length;\n        // Active the next requested index.\n        switch (args) {\n            case 'next':\n                this.activeIndex = i === n - 1 ? 0 : i + 1;\n                break;\n            case 'previous':\n                this.activeIndex = i === 0 ? n - 1 : i - 1;\n                break;\n        }\n        // Open the active menu.\n        this.openActiveMenu();\n    };\n    /**\n     * Handle the `changed` signal of a title object.\n     */\n    MenuBar.prototype._onTitleChanged = function () {\n        this.update();\n    };\n    return MenuBar;\n}(Widget));\n/**\n * The namespace for the `MenuBar` class statics.\n */\n(function (MenuBar) {\n    /**\n     * The default implementation of `IRenderer`.\n     *\n     * #### Notes\n     * Subclasses are free to reimplement rendering methods as needed.\n     */\n    var Renderer = /** @class */ (function () {\n        /**\n         * Construct a new renderer.\n         */\n        function Renderer() {\n        }\n        /**\n         * Render the virtual element for a menu bar item.\n         *\n         * @param data - The data to use for rendering the item.\n         *\n         * @returns A virtual element representing the item.\n         */\n        Renderer.prototype.renderItem = function (data) {\n            var className = this.createItemClass(data);\n            var dataset = this.createItemDataset(data);\n            var aria = this.createItemARIA(data);\n            return (_lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.li(__assign({ className: className, dataset: dataset, tabindex: '0', onfocus: data.onfocus }, aria), this.renderIcon(data), this.renderLabel(data)));\n        };\n        /**\n         * Render the icon element for a menu bar item.\n         *\n         * @param data - The data to use for rendering the icon.\n         *\n         * @returns A virtual element representing the item icon.\n         */\n        Renderer.prototype.renderIcon = function (data) {\n            var className = this.createIconClass(data);\n            /* <DEPRECATED> */\n            if (typeof data.title.icon === 'string') {\n                return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, data.title.iconLabel);\n            }\n            /* </DEPRECATED> */\n            // if data.title.icon is undefined, it will be ignored\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: className }, data.title.icon, data.title.iconLabel);\n        };\n        /**\n         * Render the label element for a menu item.\n         *\n         * @param data - The data to use for rendering the label.\n         *\n         * @returns A virtual element representing the item label.\n         */\n        Renderer.prototype.renderLabel = function (data) {\n            var content = this.formatLabel(data);\n            return _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.div({ className: 'lm-MenuBar-itemLabel'\n                    /* <DEPRECATED> */\n                    + ' p-MenuBar-itemLabel'\n                /* </DEPRECATED> */\n            }, content);\n        };\n        /**\n         * Create the class name for the menu bar item.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the menu item.\n         */\n        Renderer.prototype.createItemClass = function (data) {\n            var name = 'lm-MenuBar-item';\n            /* <DEPRECATED> */\n            name += ' p-MenuBar-item';\n            /* </DEPRECATED> */\n            if (data.title.className) {\n                name += \" \" + data.title.className;\n            }\n            if (data.active) {\n                name += ' lm-mod-active';\n                /* <DEPRECATED> */\n                name += ' p-mod-active';\n                /* </DEPRECATED> */\n            }\n            return name;\n        };\n        /**\n         * Create the dataset for a menu bar item.\n         *\n         * @param data - The data to use for the item.\n         *\n         * @returns The dataset for the menu bar item.\n         */\n        Renderer.prototype.createItemDataset = function (data) {\n            return data.title.dataset;\n        };\n        /**\n         * Create the aria attributes for menu bar item.\n         *\n         * @param data - The data to use for the aria attributes.\n         *\n         * @returns The aria attributes object for the item.\n         */\n        Renderer.prototype.createItemARIA = function (data) {\n            return { role: 'menuitem', 'aria-haspopup': 'true' };\n        };\n        /**\n         * Create the class name for the menu bar item icon.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the item icon.\n         */\n        Renderer.prototype.createIconClass = function (data) {\n            var name = 'lm-MenuBar-itemIcon';\n            /* <DEPRECATED> */\n            name += ' p-MenuBar-itemIcon';\n            /* </DEPRECATED> */\n            var extra = data.title.iconClass;\n            return extra ? name + \" \" + extra : name;\n        };\n        /**\n         * Create the render content for the label node.\n         *\n         * @param data - The data to use for the label content.\n         *\n         * @returns The content to add to the label node.\n         */\n        Renderer.prototype.formatLabel = function (data) {\n            // Fetch the label text and mnemonic index.\n            var _a = data.title, label = _a.label, mnemonic = _a.mnemonic;\n            // If the index is out of range, do not modify the label.\n            if (mnemonic < 0 || mnemonic >= label.length) {\n                return label;\n            }\n            // Split the label into parts.\n            var prefix = label.slice(0, mnemonic);\n            var suffix = label.slice(mnemonic + 1);\n            var char = label[mnemonic];\n            // Wrap the mnemonic character in a span.\n            var span = _lumino_virtualdom__WEBPACK_IMPORTED_MODULE_8__.h.span({\n                className: 'lm-MenuBar-itemMnemonic'\n                    /* <DEPRECATED> */\n                    + ' p-MenuBar-itemMnemonic'\n                /* </DEPRECATED> */\n            }, char);\n            // Return the content parts.\n            return [prefix, span, suffix];\n        };\n        return Renderer;\n    }());\n    MenuBar.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    MenuBar.defaultRenderer = new Renderer();\n})(MenuBar || (MenuBar = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$g;\n(function (Private) {\n    /**\n     * Create the DOM node for a menu bar.\n     */\n    function createNode() {\n        var node = document.createElement('div');\n        var content = document.createElement('ul');\n        content.className = 'lm-MenuBar-content';\n        /* <DEPRECATED> */\n        content.classList.add('p-MenuBar-content');\n        /* </DEPRECATED> */\n        node.appendChild(content);\n        content.setAttribute('role', 'menubar');\n        node.tabIndex = 0;\n        content.tabIndex = 0;\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Find the best matching mnemonic item.\n     *\n     * The search starts at the given index and wraps around.\n     */\n    function findMnemonic(menus, key, start) {\n        // Setup the result variables.\n        var index = -1;\n        var auto = -1;\n        var multiple = false;\n        // Normalize the key to upper case.\n        var upperKey = key.toUpperCase();\n        // Search the items from the given start index.\n        for (var i = 0, n = menus.length; i < n; ++i) {\n            // Compute the wrapped index.\n            var k = (i + start) % n;\n            // Look up the menu title.\n            var title = menus[k].title;\n            // Ignore titles with an empty label.\n            if (title.label.length === 0) {\n                continue;\n            }\n            // Look up the mnemonic index for the label.\n            var mn = title.mnemonic;\n            // Handle a valid mnemonic index.\n            if (mn >= 0 && mn < title.label.length) {\n                if (title.label[mn].toUpperCase() === upperKey) {\n                    if (index === -1) {\n                        index = k;\n                    }\n                    else {\n                        multiple = true;\n                    }\n                }\n                continue;\n            }\n            // Finally, handle the auto index if possible.\n            if (auto === -1 && title.label[0].toUpperCase() === upperKey) {\n                auto = k;\n            }\n        }\n        // Return the search results.\n        return { index: index, multiple: multiple, auto: auto };\n    }\n    Private.findMnemonic = findMnemonic;\n})(Private$g || (Private$g = {}));\n\n/**\n * A widget which implements a canonical scroll bar.\n */\nvar ScrollBar = /** @class */ (function (_super) {\n    __extends(ScrollBar, _super);\n    /**\n     * Construct a new scroll bar.\n     *\n     * @param options - The options for initializing the scroll bar.\n     */\n    function ScrollBar(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { node: Private$h.createNode() }) || this;\n        /**\n         * A timeout callback for repeating the mouse press.\n         */\n        _this._onRepeat = function () {\n            // Clear the repeat timer id.\n            _this._repeatTimer = -1;\n            // Bail if the mouse has been released.\n            if (!_this._pressData) {\n                return;\n            }\n            // Look up the part that was pressed.\n            var part = _this._pressData.part;\n            // Bail if the thumb was pressed.\n            if (part === 'thumb') {\n                return;\n            }\n            // Schedule the timer for another repeat.\n            _this._repeatTimer = window.setTimeout(_this._onRepeat, 20);\n            // Get the current mouse position.\n            var mouseX = _this._pressData.mouseX;\n            var mouseY = _this._pressData.mouseY;\n            // Handle a decrement button repeat.\n            if (part === 'decrement') {\n                // Bail if the mouse is not over the button.\n                if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(_this.decrementNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Emit the step requested signal.\n                _this._stepRequested.emit('decrement');\n                // Finished.\n                return;\n            }\n            // Handle an increment button repeat.\n            if (part === 'increment') {\n                // Bail if the mouse is not over the button.\n                if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(_this.incrementNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Emit the step requested signal.\n                _this._stepRequested.emit('increment');\n                // Finished.\n                return;\n            }\n            // Handle a track repeat.\n            if (part === 'track') {\n                // Bail if the mouse is not over the track.\n                if (!_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(_this.trackNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Fetch the thumb node.\n                var thumbNode = _this.thumbNode;\n                // Bail if the mouse is over the thumb.\n                if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.hitTest(thumbNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Fetch the client rect for the thumb.\n                var thumbRect = thumbNode.getBoundingClientRect();\n                // Determine the direction for the page request.\n                var dir = void 0;\n                if (_this._orientation === 'horizontal') {\n                    dir = mouseX < thumbRect.left ? 'decrement' : 'increment';\n                }\n                else {\n                    dir = mouseY < thumbRect.top ? 'decrement' : 'increment';\n                }\n                // Emit the page requested signal.\n                _this._pageRequested.emit(dir);\n                // Finished.\n                return;\n            }\n        };\n        _this._value = 0;\n        _this._page = 10;\n        _this._maximum = 100;\n        _this._repeatTimer = -1;\n        _this._pressData = null;\n        _this._thumbMoved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._stepRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._pageRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this.addClass('lm-ScrollBar');\n        /* <DEPRECATED> */\n        _this.addClass('p-ScrollBar');\n        /* </DEPRECATED> */\n        _this.setFlag(Widget.Flag.DisallowLayout);\n        // Set the orientation.\n        _this._orientation = options.orientation || 'vertical';\n        _this.dataset['orientation'] = _this._orientation;\n        // Parse the rest of the options.\n        if (options.maximum !== undefined) {\n            _this._maximum = Math.max(0, options.maximum);\n        }\n        if (options.page !== undefined) {\n            _this._page = Math.max(0, options.page);\n        }\n        if (options.value !== undefined) {\n            _this._value = Math.max(0, Math.min(options.value, _this._maximum));\n        }\n        return _this;\n    }\n    Object.defineProperty(ScrollBar.prototype, \"thumbMoved\", {\n        /**\n         * A signal emitted when the user moves the scroll thumb.\n         *\n         * #### Notes\n         * The payload is the current value of the scroll bar.\n         */\n        get: function () {\n            return this._thumbMoved;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"stepRequested\", {\n        /**\n         * A signal emitted when the user clicks a step button.\n         *\n         * #### Notes\n         * The payload is whether a decrease or increase is requested.\n         */\n        get: function () {\n            return this._stepRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"pageRequested\", {\n        /**\n         * A signal emitted when the user clicks the scroll track.\n         *\n         * #### Notes\n         * The payload is whether a decrease or increase is requested.\n         */\n        get: function () {\n            return this._pageRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"orientation\", {\n        /**\n         * Get the orientation of the scroll bar.\n         */\n        get: function () {\n            return this._orientation;\n        },\n        /**\n         * Set the orientation of the scroll bar.\n         */\n        set: function (value) {\n            // Do nothing if the orientation does not change.\n            if (this._orientation === value) {\n                return;\n            }\n            // Release the mouse before making changes.\n            this._releaseMouse();\n            // Update the internal orientation.\n            this._orientation = value;\n            this.dataset['orientation'] = value;\n            // Schedule an update the scroll bar.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"value\", {\n        /**\n         * Get the current value of the scroll bar.\n         */\n        get: function () {\n            return this._value;\n        },\n        /**\n         * Set the current value of the scroll bar.\n         *\n         * #### Notes\n         * The value will be clamped to the range `[0, maximum]`.\n         */\n        set: function (value) {\n            // Clamp the value to the allowable range.\n            value = Math.max(0, Math.min(value, this._maximum));\n            // Do nothing if the value does not change.\n            if (this._value === value) {\n                return;\n            }\n            // Update the internal value.\n            this._value = value;\n            // Schedule an update the scroll bar.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"page\", {\n        /**\n         * Get the page size of the scroll bar.\n         *\n         * #### Notes\n         * The page size is the amount of visible content in the scrolled\n         * region, expressed in data units. It determines the size of the\n         * scroll bar thumb.\n         */\n        get: function () {\n            return this._page;\n        },\n        /**\n         * Set the page size of the scroll bar.\n         *\n         * #### Notes\n         * The page size will be clamped to the range `[0, Infinity]`.\n         */\n        set: function (value) {\n            // Clamp the page size to the allowable range.\n            value = Math.max(0, value);\n            // Do nothing if the value does not change.\n            if (this._page === value) {\n                return;\n            }\n            // Update the internal page size.\n            this._page = value;\n            // Schedule an update the scroll bar.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"maximum\", {\n        /**\n         * Get the maximum value of the scroll bar.\n         */\n        get: function () {\n            return this._maximum;\n        },\n        /**\n         * Set the maximum value of the scroll bar.\n         *\n         * #### Notes\n         * The max size will be clamped to the range `[0, Infinity]`.\n         */\n        set: function (value) {\n            // Clamp the value to the allowable range.\n            value = Math.max(0, value);\n            // Do nothing if the value does not change.\n            if (this._maximum === value) {\n                return;\n            }\n            // Update the internal values.\n            this._maximum = value;\n            // Clamp the current value to the new range.\n            this._value = Math.min(this._value, value);\n            // Schedule an update the scroll bar.\n            this.update();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"decrementNode\", {\n        /**\n         * The scroll bar decrement button node.\n         *\n         * #### Notes\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-ScrollBar-button')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"incrementNode\", {\n        /**\n         * The scroll bar increment button node.\n         *\n         * #### Notes\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-ScrollBar-button')[1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"trackNode\", {\n        /**\n         * The scroll bar track node.\n         *\n         * #### Notes\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-ScrollBar-track')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScrollBar.prototype, \"thumbNode\", {\n        /**\n         * The scroll bar thumb node.\n         *\n         * #### Notes\n         * Modifying this node directly can lead to undefined behavior.\n         */\n        get: function () {\n            return this.node.getElementsByClassName('lm-ScrollBar-thumb')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Handle the DOM events for the scroll bar.\n     *\n     * @param event - The DOM event sent to the scroll bar.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the scroll bar's DOM node.\n     *\n     * This should not be called directly by user code.\n     */\n    ScrollBar.prototype.handleEvent = function (event) {\n        switch (event.type) {\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    };\n    /**\n     * A method invoked on a 'before-attach' message.\n     */\n    ScrollBar.prototype.onBeforeAttach = function (msg) {\n        this.node.addEventListener('mousedown', this);\n        this.update();\n    };\n    /**\n     * A method invoked on an 'after-detach' message.\n     */\n    ScrollBar.prototype.onAfterDetach = function (msg) {\n        this.node.removeEventListener('mousedown', this);\n        this._releaseMouse();\n    };\n    /**\n     * A method invoked on an 'update-request' message.\n     */\n    ScrollBar.prototype.onUpdateRequest = function (msg) {\n        // Convert the value and page into percentages.\n        var value = this._value * 100 / this._maximum;\n        var page = this._page * 100 / (this._page + this._maximum);\n        // Clamp the value and page to the relevant range.\n        value = Math.max(0, Math.min(value, 100));\n        page = Math.max(0, Math.min(page, 100));\n        // Fetch the thumb style.\n        var thumbStyle = this.thumbNode.style;\n        // Update the thumb style for the current orientation.\n        if (this._orientation === 'horizontal') {\n            thumbStyle.top = '';\n            thumbStyle.height = '';\n            thumbStyle.left = value + \"%\";\n            thumbStyle.width = page + \"%\";\n            thumbStyle.transform = \"translate(\" + -value + \"%, 0%)\";\n        }\n        else {\n            thumbStyle.left = '';\n            thumbStyle.width = '';\n            thumbStyle.top = value + \"%\";\n            thumbStyle.height = page + \"%\";\n            thumbStyle.transform = \"translate(0%, \" + -value + \"%)\";\n        }\n    };\n    /**\n     * Handle the `'keydown'` event for the scroll bar.\n     */\n    ScrollBar.prototype._evtKeyDown = function (event) {\n        // Stop all input events during drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Ignore anything except the `Escape` key.\n        if (event.keyCode !== 27) {\n            return;\n        }\n        // Fetch the previous scroll value.\n        var value = this._pressData ? this._pressData.value : -1;\n        // Release the mouse.\n        this._releaseMouse();\n        // Restore the old scroll value if possible.\n        if (value !== -1) {\n            this._moveThumb(value);\n        }\n    };\n    /**\n     * Handle the `'mousedown'` event for the scroll bar.\n     */\n    ScrollBar.prototype._evtMouseDown = function (event) {\n        // Do nothing if it's not a left mouse press.\n        if (event.button !== 0) {\n            return;\n        }\n        // Send an activate request to the scroll bar. This can be\n        // used by message hooks to activate something relevant.\n        this.activate();\n        // Do nothing if the mouse is already captured.\n        if (this._pressData) {\n            return;\n        }\n        // Find the pressed scroll bar part.\n        var part = Private$h.findPart(this, event.target);\n        // Do nothing if the part is not of interest.\n        if (!part) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Override the mouse cursor.\n        var override = _lumino_dragdrop__WEBPACK_IMPORTED_MODULE_5__.Drag.overrideCursor('default');\n        // Set up the press data.\n        this._pressData = {\n            part: part, override: override,\n            delta: -1, value: -1,\n            mouseX: event.clientX,\n            mouseY: event.clientY\n        };\n        // Add the extra event listeners.\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Handle a thumb press.\n        if (part === 'thumb') {\n            // Fetch the thumb node.\n            var thumbNode = this.thumbNode;\n            // Fetch the client rect for the thumb.\n            var thumbRect = thumbNode.getBoundingClientRect();\n            // Update the press data delta for the current orientation.\n            if (this._orientation === 'horizontal') {\n                this._pressData.delta = event.clientX - thumbRect.left;\n            }\n            else {\n                this._pressData.delta = event.clientY - thumbRect.top;\n            }\n            // Add the active class to the thumb node.\n            thumbNode.classList.add('lm-mod-active');\n            /* <DEPRECATED> */\n            thumbNode.classList.add('p-mod-active');\n            /* </DEPRECATED> */\n            // Store the current value in the press data.\n            this._pressData.value = this._value;\n            // Finished.\n            return;\n        }\n        // Handle a track press.\n        if (part === 'track') {\n            // Fetch the client rect for the thumb.\n            var thumbRect = this.thumbNode.getBoundingClientRect();\n            // Determine the direction for the page request.\n            var dir = void 0;\n            if (this._orientation === 'horizontal') {\n                dir = event.clientX < thumbRect.left ? 'decrement' : 'increment';\n            }\n            else {\n                dir = event.clientY < thumbRect.top ? 'decrement' : 'increment';\n            }\n            // Start the repeat timer.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n            // Emit the page requested signal.\n            this._pageRequested.emit(dir);\n            // Finished.\n            return;\n        }\n        // Handle a decrement button press.\n        if (part === 'decrement') {\n            // Add the active class to the decrement node.\n            this.decrementNode.classList.add('lm-mod-active');\n            /* <DEPRECATED> */\n            this.decrementNode.classList.add('p-mod-active');\n            /* </DEPRECATED> */\n            // Start the repeat timer.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n            // Emit the step requested signal.\n            this._stepRequested.emit('decrement');\n            // Finished.\n            return;\n        }\n        // Handle an increment button press.\n        if (part === 'increment') {\n            // Add the active class to the increment node.\n            this.incrementNode.classList.add('lm-mod-active');\n            /* <DEPRECATED> */\n            this.incrementNode.classList.add('p-mod-active');\n            /* </DEPRECATED> */\n            // Start the repeat timer.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n            // Emit the step requested signal.\n            this._stepRequested.emit('increment');\n            // Finished.\n            return;\n        }\n    };\n    /**\n     * Handle the `'mousemove'` event for the scroll bar.\n     */\n    ScrollBar.prototype._evtMouseMove = function (event) {\n        // Do nothing if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Update the mouse position.\n        this._pressData.mouseX = event.clientX;\n        this._pressData.mouseY = event.clientY;\n        // Bail if the thumb is not being dragged.\n        if (this._pressData.part !== 'thumb') {\n            return;\n        }\n        // Get the client rect for the thumb and track.\n        var thumbRect = this.thumbNode.getBoundingClientRect();\n        var trackRect = this.trackNode.getBoundingClientRect();\n        // Fetch the scroll geometry based on the orientation.\n        var trackPos;\n        var trackSpan;\n        if (this._orientation === 'horizontal') {\n            trackPos = event.clientX - trackRect.left - this._pressData.delta;\n            trackSpan = trackRect.width - thumbRect.width;\n        }\n        else {\n            trackPos = event.clientY - trackRect.top - this._pressData.delta;\n            trackSpan = trackRect.height - thumbRect.height;\n        }\n        // Compute the desired value from the scroll geometry.\n        var value = trackSpan === 0 ? 0 : trackPos * this._maximum / trackSpan;\n        // Move the thumb to the computed value.\n        this._moveThumb(value);\n    };\n    /**\n     * Handle the `'mouseup'` event for the scroll bar.\n     */\n    ScrollBar.prototype._evtMouseUp = function (event) {\n        // Do nothing if it's not a left mouse release.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Release the mouse.\n        this._releaseMouse();\n    };\n    /**\n     * Release the mouse and restore the node states.\n     */\n    ScrollBar.prototype._releaseMouse = function () {\n        // Bail if there is no press data.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the repeat timer.\n        clearTimeout(this._repeatTimer);\n        this._repeatTimer = -1;\n        // Clear the press data.\n        this._pressData.override.dispose();\n        this._pressData = null;\n        // Remove the extra event listeners.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('contextmenu', this, true);\n        // Remove the active classes from the nodes.\n        this.thumbNode.classList.remove('lm-mod-active');\n        this.decrementNode.classList.remove('lm-mod-active');\n        this.incrementNode.classList.remove('lm-mod-active');\n        /* <DEPRECATED> */\n        this.thumbNode.classList.remove('p-mod-active');\n        this.decrementNode.classList.remove('p-mod-active');\n        this.incrementNode.classList.remove('p-mod-active');\n        /* </DEPRECATED> */\n    };\n    /**\n     * Move the thumb to the specified position.\n     */\n    ScrollBar.prototype._moveThumb = function (value) {\n        // Clamp the value to the allowed range.\n        value = Math.max(0, Math.min(value, this._maximum));\n        // Bail if the value does not change.\n        if (this._value === value) {\n            return;\n        }\n        // Update the internal value.\n        this._value = value;\n        // Schedule an update of the scroll bar.\n        this.update();\n        // Emit the thumb moved signal.\n        this._thumbMoved.emit(value);\n    };\n    return ScrollBar;\n}(Widget));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$h;\n(function (Private) {\n    /**\n     * Create the DOM node for a scroll bar.\n     */\n    function createNode() {\n        var node = document.createElement('div');\n        var decrement = document.createElement('div');\n        var increment = document.createElement('div');\n        var track = document.createElement('div');\n        var thumb = document.createElement('div');\n        decrement.className = 'lm-ScrollBar-button';\n        increment.className = 'lm-ScrollBar-button';\n        decrement.dataset['action'] = 'decrement';\n        increment.dataset['action'] = 'increment';\n        track.className = 'lm-ScrollBar-track';\n        thumb.className = 'lm-ScrollBar-thumb';\n        /* <DEPRECATED> */\n        decrement.classList.add('p-ScrollBar-button');\n        increment.classList.add('p-ScrollBar-button');\n        track.classList.add('p-ScrollBar-track');\n        thumb.classList.add('p-ScrollBar-thumb');\n        /* </DEPRECATED> */\n        track.appendChild(thumb);\n        node.appendChild(decrement);\n        node.appendChild(track);\n        node.appendChild(increment);\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Find the scroll bar part which contains the given target.\n     */\n    function findPart(scrollBar, target) {\n        // Test the thumb.\n        if (scrollBar.thumbNode.contains(target)) {\n            return 'thumb';\n        }\n        // Test the track.\n        if (scrollBar.trackNode.contains(target)) {\n            return 'track';\n        }\n        // Test the decrement button.\n        if (scrollBar.decrementNode.contains(target)) {\n            return 'decrement';\n        }\n        // Test the increment button.\n        if (scrollBar.incrementNode.contains(target)) {\n            return 'increment';\n        }\n        // Indicate no match.\n        return null;\n    }\n    Private.findPart = findPart;\n})(Private$h || (Private$h = {}));\n\n/**\n * A concrete layout implementation which holds a single widget.\n *\n * #### Notes\n * This class is useful for creating simple container widgets which\n * hold a single child. The child should be positioned with CSS.\n */\nvar SingletonLayout = /** @class */ (function (_super) {\n    __extends(SingletonLayout, _super);\n    function SingletonLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._widget = null;\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    SingletonLayout.prototype.dispose = function () {\n        if (this._widget) {\n            var widget = this._widget;\n            this._widget = null;\n            widget.dispose();\n        }\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(SingletonLayout.prototype, \"widget\", {\n        /**\n         * Get the child widget for the layout.\n         */\n        get: function () {\n            return this._widget;\n        },\n        /**\n         * Set the child widget for the layout.\n         *\n         * #### Notes\n         * Setting the child widget will cause the old child widget to be\n         * automatically disposed. If that is not desired, set the parent\n         * of the old child to `null` before assigning a new child.\n         */\n        set: function (widget) {\n            // Remove the widget from its current parent. This is a no-op\n            // if the widget's parent is already the layout parent widget.\n            if (widget) {\n                widget.parent = this.parent;\n            }\n            // Bail early if the widget does not change.\n            if (this._widget === widget) {\n                return;\n            }\n            // Dispose of the old child widget.\n            if (this._widget) {\n                this._widget.dispose();\n            }\n            // Update the internal widget.\n            this._widget = widget;\n            // Attach the new child widget if needed.\n            if (this.parent && widget) {\n                this.attachWidget(widget);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an iterator over the widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     */\n    SingletonLayout.prototype.iter = function () {\n        return this._widget ? (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.once)(this._widget) : (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.empty)();\n    };\n    /**\n     * Remove a widget from the layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    SingletonLayout.prototype.removeWidget = function (widget) {\n        // Bail early if the widget does not exist in the layout.\n        if (this._widget !== widget) {\n            return;\n        }\n        // Clear the internal widget.\n        this._widget = null;\n        // If the layout is parented, detach the widget from the DOM.\n        if (this.parent) {\n            this.detachWidget(widget);\n        }\n    };\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    SingletonLayout.prototype.init = function () {\n        var _this = this;\n        _super.prototype.init.call(this);\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this, function (widget) { _this.attachWidget(widget); });\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the single layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation adds the widgets's node to the parent's\n     * node at the proper location, and sends the appropriate attach\n     * messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is added to the parent's node.\n     */\n    SingletonLayout.prototype.attachWidget = function (widget) {\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the single layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation removes the widget's node from the\n     * parent's node, and sends the appropriate detach messages to the\n     * widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is removed from the parent's node.\n     */\n    SingletonLayout.prototype.detachWidget = function (widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n    };\n    return SingletonLayout;\n}(Layout));\n\n/**\n * A layout where visible widgets are stacked atop one another.\n *\n * #### Notes\n * The Z-order of the visible widgets follows their layout order.\n */\nvar StackedLayout = /** @class */ (function (_super) {\n    __extends(StackedLayout, _super);\n    function StackedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._dirty = false;\n        _this._items = [];\n        _this._box = null;\n        return _this;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    StackedLayout.prototype.dispose = function () {\n        // Dispose of the layout items.\n        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(this._items, function (item) { item.dispose(); });\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        // Dispose of the rest of the layout.\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    StackedLayout.prototype.attachWidget = function (index, widget) {\n        // Create and add a new layout item for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.insert(this._items, index, new LayoutItem(widget));\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    StackedLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {\n        // Move the layout item for the widget.\n        _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.move(this._items, fromIndex, toIndex);\n        // Post an update request for the parent widget.\n        this.parent.update();\n    };\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    StackedLayout.prototype.detachWidget = function (index, widget) {\n        // Remove the layout item for the widget.\n        var item = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAt(this._items, index);\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Reset the z-index for the widget.\n        item.widget.node.style.zIndex = '';\n        // Dispose of the layout item.\n        item.dispose();\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    StackedLayout.prototype.onBeforeShow = function (msg) {\n        _super.prototype.onBeforeShow.call(this, msg);\n        this.parent.update();\n    };\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    StackedLayout.prototype.onBeforeAttach = function (msg) {\n        _super.prototype.onBeforeAttach.call(this, msg);\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    StackedLayout.prototype.onChildShown = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    StackedLayout.prototype.onChildHidden = function (msg) {\n        this.parent.fit();\n    };\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    StackedLayout.prototype.onResize = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    };\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    StackedLayout.prototype.onUpdateRequest = function (msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    };\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    StackedLayout.prototype.onFitRequest = function (msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    };\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    StackedLayout.prototype._fit = function () {\n        // Set up the computed minimum size.\n        var minW = 0;\n        var minH = 0;\n        // Update the computed minimum size.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Update the size limits for the item.\n            item.fit();\n            // Update the computed minimum size.\n            minW = Math.max(minW, item.minWidth);\n            minH = Math.max(minH, item.minHeight);\n        }\n        // Update the box sizing and add it to the computed min size.\n        var box = this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        var style = this.parent.node.style;\n        style.minWidth = minW + \"px\";\n        style.minHeight = minH + \"px\";\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    };\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    StackedLayout.prototype._update = function (offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Compute the visible item count.\n        var nVisible = 0;\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Bail early if there are no visible items to layout.\n        if (nVisible === 0) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the actual layout bounds adjusted for border and padding.\n        var top = this._box.paddingTop;\n        var left = this._box.paddingLeft;\n        var width = offsetWidth - this._box.horizontalSum;\n        var height = offsetHeight - this._box.verticalSum;\n        // Update the widget stacking order and layout geometry.\n        for (var i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            var item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Set the z-index for the widget.\n            item.widget.node.style.zIndex = \"\" + i;\n            // Update the item geometry.\n            item.update(left, top, width, height);\n        }\n    };\n    return StackedLayout;\n}(PanelLayout));\n\n/**\n * A panel where visible widgets are stacked atop one another.\n *\n * #### Notes\n * This class provides a convenience wrapper around a [[StackedLayout]].\n */\nvar StackedPanel = /** @class */ (function (_super) {\n    __extends(StackedPanel, _super);\n    /**\n     * Construct a new stacked panel.\n     *\n     * @param options - The options for initializing the panel.\n     */\n    function StackedPanel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, { layout: Private$i.createLayout(options) }) || this;\n        _this._widgetRemoved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this.addClass('lm-StackedPanel');\n        /* <DEPRECATED> */\n        _this.addClass('p-StackedPanel');\n        return _this;\n        /* </DEPRECATED> */\n    }\n    Object.defineProperty(StackedPanel.prototype, \"widgetRemoved\", {\n        /**\n         * A signal emitted when a widget is removed from a stacked panel.\n         */\n        get: function () {\n            return this._widgetRemoved;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    StackedPanel.prototype.onChildAdded = function (msg) {\n        msg.child.addClass('lm-StackedPanel-child');\n        /* <DEPRECATED> */\n        msg.child.addClass('p-StackedPanel-child');\n        /* </DEPRECATED> */\n    };\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    StackedPanel.prototype.onChildRemoved = function (msg) {\n        msg.child.removeClass('lm-StackedPanel-child');\n        /* <DEPRECATED> */\n        msg.child.removeClass('p-StackedPanel-child');\n        /* </DEPRECATED> */\n        this._widgetRemoved.emit(msg.child);\n    };\n    return StackedPanel;\n}(Panel));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$i;\n(function (Private) {\n    /**\n     * Create a stacked layout for the given panel options.\n     */\n    function createLayout(options) {\n        return options.layout || new StackedLayout();\n    }\n    Private.createLayout = createLayout;\n})(Private$i || (Private$i = {}));\n\n/**\n * A widget which combines a `TabBar` and a `StackedPanel`.\n *\n * #### Notes\n * This is a simple panel which handles the common case of a tab bar\n * placed next to a content area. The selected tab controls the widget\n * which is shown in the content area.\n *\n * For use cases which require more control than is provided by this\n * panel, the `TabBar` widget may be used independently.\n */\nvar TabPanel = /** @class */ (function (_super) {\n    __extends(TabPanel, _super);\n    /**\n     * Construct a new tab panel.\n     *\n     * @param options - The options for initializing the tab panel.\n     */\n    function TabPanel(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this._currentChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this._addRequested = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(_this);\n        _this.addClass('lm-TabPanel');\n        /* <DEPRECATED> */\n        _this.addClass('p-TabPanel');\n        /* </DEPRECATED> */\n        // Create the tab bar and stacked panel.\n        _this.tabBar = new TabBar(options);\n        _this.tabBar.addClass('lm-TabPanel-tabBar');\n        _this.stackedPanel = new StackedPanel();\n        _this.stackedPanel.addClass('lm-TabPanel-stackedPanel');\n        /* <DEPRECATED> */\n        _this.tabBar.addClass('p-TabPanel-tabBar');\n        _this.stackedPanel.addClass('p-TabPanel-stackedPanel');\n        /* </DEPRECATED> */\n        // Connect the tab bar signal handlers.\n        _this.tabBar.tabMoved.connect(_this._onTabMoved, _this);\n        _this.tabBar.currentChanged.connect(_this._onCurrentChanged, _this);\n        _this.tabBar.tabCloseRequested.connect(_this._onTabCloseRequested, _this);\n        _this.tabBar.tabActivateRequested.connect(_this._onTabActivateRequested, _this);\n        _this.tabBar.addRequested.connect(_this._onTabAddRequested, _this);\n        // Connect the stacked panel signal handlers.\n        _this.stackedPanel.widgetRemoved.connect(_this._onWidgetRemoved, _this);\n        // Get the data related to the placement.\n        _this._tabPlacement = options.tabPlacement || 'top';\n        var direction = Private$j.directionFromPlacement(_this._tabPlacement);\n        var orientation = Private$j.orientationFromPlacement(_this._tabPlacement);\n        // Configure the tab bar for the placement.\n        _this.tabBar.orientation = orientation;\n        _this.tabBar.dataset['placement'] = _this._tabPlacement;\n        // Create the box layout.\n        var layout = new BoxLayout({ direction: direction, spacing: 0 });\n        // Set the stretch factors for the child widgets.\n        BoxLayout.setStretch(_this.tabBar, 0);\n        BoxLayout.setStretch(_this.stackedPanel, 1);\n        // Add the child widgets to the layout.\n        layout.addWidget(_this.tabBar);\n        layout.addWidget(_this.stackedPanel);\n        // Install the layout on the tab panel.\n        _this.layout = layout;\n        return _this;\n    }\n    Object.defineProperty(TabPanel.prototype, \"currentChanged\", {\n        /**\n         * A signal emitted when the current tab is changed.\n         *\n         * #### Notes\n         * This signal is emitted when the currently selected tab is changed\n         * either through user or programmatic interaction.\n         *\n         * Notably, this signal is not emitted when the index of the current\n         * tab changes due to tabs being inserted, removed, or moved. It is\n         * only emitted when the actual current tab node is changed.\n         */\n        get: function () {\n            return this._currentChanged;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"currentIndex\", {\n        /**\n         * Get the index of the currently selected tab.\n         *\n         * #### Notes\n         * This will be `-1` if no tab is selected.\n         */\n        get: function () {\n            return this.tabBar.currentIndex;\n        },\n        /**\n         * Set the index of the currently selected tab.\n         *\n         * #### Notes\n         * If the index is out of range, it will be set to `-1`.\n         */\n        set: function (value) {\n            this.tabBar.currentIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"currentWidget\", {\n        /**\n         * Get the currently selected widget.\n         *\n         * #### Notes\n         * This will be `null` if there is no selected tab.\n         */\n        get: function () {\n            var title = this.tabBar.currentTitle;\n            return title ? title.owner : null;\n        },\n        /**\n         * Set the currently selected widget.\n         *\n         * #### Notes\n         * If the widget is not in the panel, it will be set to `null`.\n         */\n        set: function (value) {\n            this.tabBar.currentTitle = value ? value.title : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"tabsMovable\", {\n        /**\n         * Get the whether the tabs are movable by the user.\n         *\n         * #### Notes\n         * Tabs can always be moved programmatically.\n         */\n        get: function () {\n            return this.tabBar.tabsMovable;\n        },\n        /**\n         * Set the whether the tabs are movable by the user.\n         *\n         * #### Notes\n         * Tabs can always be moved programmatically.\n         */\n        set: function (value) {\n            this.tabBar.tabsMovable = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"addButtonEnabled\", {\n        /**\n         * Get the whether the add button is enabled.\n         *\n         */\n        get: function () {\n            return this.tabBar.addButtonEnabled;\n        },\n        /**\n         * Set the whether the add button is enabled.\n         *\n         */\n        set: function (value) {\n            this.tabBar.addButtonEnabled = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"tabPlacement\", {\n        /**\n         * Get the tab placement for the tab panel.\n         *\n         * #### Notes\n         * This controls the position of the tab bar relative to the content.\n         */\n        get: function () {\n            return this._tabPlacement;\n        },\n        /**\n         * Set the tab placement for the tab panel.\n         *\n         * #### Notes\n         * This controls the position of the tab bar relative to the content.\n         */\n        set: function (value) {\n            // Bail if the placement does not change.\n            if (this._tabPlacement === value) {\n                return;\n            }\n            // Update the internal value.\n            this._tabPlacement = value;\n            // Get the values related to the placement.\n            var direction = Private$j.directionFromPlacement(value);\n            var orientation = Private$j.orientationFromPlacement(value);\n            // Configure the tab bar for the placement.\n            this.tabBar.orientation = orientation;\n            this.tabBar.dataset['placement'] = value;\n            // Update the layout direction.\n            this.layout.direction = direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"addRequested\", {\n        /**\n         * A signal emitted when the add button on a tab bar is clicked.\n         *\n         */\n        get: function () {\n            return this._addRequested;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TabPanel.prototype, \"widgets\", {\n        /**\n         * A read-only array of the widgets in the panel.\n         */\n        get: function () {\n            return this.stackedPanel.widgets;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Add a widget to the end of the tab panel.\n     *\n     * @param widget - The widget to add to the tab panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     *\n     * The widget's `title` is used to populate the tab.\n     */\n    TabPanel.prototype.addWidget = function (widget) {\n        this.insertWidget(this.widgets.length, widget);\n    };\n    /**\n     * Insert a widget into the tab panel at a specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into to the tab panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     *\n     * The widget's `title` is used to populate the tab.\n     */\n    TabPanel.prototype.insertWidget = function (index, widget) {\n        if (widget !== this.currentWidget) {\n            widget.hide();\n        }\n        this.stackedPanel.insertWidget(index, widget);\n        this.tabBar.insertTab(index, widget.title);\n        widget.node.setAttribute('role', 'tabpanel');\n        var renderer = this.tabBar.renderer;\n        if (renderer instanceof TabBar.Renderer) {\n            var tabId = renderer.createTabKey({ title: widget.title, current: false, zIndex: 0 });\n            widget.node.setAttribute('aria-labelledby', tabId);\n        }\n    };\n    /**\n     * Handle the `currentChanged` signal from the tab bar.\n     */\n    TabPanel.prototype._onCurrentChanged = function (sender, args) {\n        // Extract the previous and current title from the args.\n        var previousIndex = args.previousIndex, previousTitle = args.previousTitle, currentIndex = args.currentIndex, currentTitle = args.currentTitle;\n        // Extract the widgets from the titles.\n        var previousWidget = previousTitle ? previousTitle.owner : null;\n        var currentWidget = currentTitle ? currentTitle.owner : null;\n        // Hide the previous widget.\n        if (previousWidget) {\n            previousWidget.hide();\n        }\n        // Show the current widget.\n        if (currentWidget) {\n            currentWidget.show();\n        }\n        // Emit the `currentChanged` signal for the tab panel.\n        this._currentChanged.emit({\n            previousIndex: previousIndex, previousWidget: previousWidget, currentIndex: currentIndex, currentWidget: currentWidget\n        });\n        // Flush the message loop on IE and Edge to prevent flicker.\n        if (_lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Platform.IS_EDGE || _lumino_domutils__WEBPACK_IMPORTED_MODULE_1__.Platform.IS_IE) {\n            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.flush();\n        }\n    };\n    /**\n     * Handle the `tabAddRequested` signal from the tab bar.\n     */\n    TabPanel.prototype._onTabAddRequested = function (sender, args) {\n        this._addRequested.emit(sender);\n    };\n    /**\n     * Handle the `tabActivateRequested` signal from the tab bar.\n     */\n    TabPanel.prototype._onTabActivateRequested = function (sender, args) {\n        args.title.owner.activate();\n    };\n    /**\n     * Handle the `tabCloseRequested` signal from the tab bar.\n     */\n    TabPanel.prototype._onTabCloseRequested = function (sender, args) {\n        args.title.owner.close();\n    };\n    /**\n     * Handle the `tabMoved` signal from the tab bar.\n     */\n    TabPanel.prototype._onTabMoved = function (sender, args) {\n        this.stackedPanel.insertWidget(args.toIndex, args.title.owner);\n    };\n    /**\n     * Handle the `widgetRemoved` signal from the stacked panel.\n     */\n    TabPanel.prototype._onWidgetRemoved = function (sender, widget) {\n        widget.node.removeAttribute('role');\n        widget.node.removeAttribute('aria-labelledby');\n        this.tabBar.removeTab(widget.title);\n    };\n    return TabPanel;\n}(Widget));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$j;\n(function (Private) {\n    /**\n     * Convert a tab placement to tab bar orientation.\n     */\n    function orientationFromPlacement(plc) {\n        return placementToOrientationMap[plc];\n    }\n    Private.orientationFromPlacement = orientationFromPlacement;\n    /**\n     * Convert a tab placement to a box layout direction.\n     */\n    function directionFromPlacement(plc) {\n        return placementToDirectionMap[plc];\n    }\n    Private.directionFromPlacement = directionFromPlacement;\n    /**\n     * A mapping of tab placement to tab bar orientation.\n     */\n    var placementToOrientationMap = {\n        'top': 'horizontal',\n        'left': 'vertical',\n        'right': 'vertical',\n        'bottom': 'horizontal'\n    };\n    /**\n     * A mapping of tab placement to box layout direction.\n     */\n    var placementToDirectionMap = {\n        'top': 'top-to-bottom',\n        'left': 'left-to-right',\n        'right': 'right-to-left',\n        'bottom': 'bottom-to-top'\n    };\n})(Private$j || (Private$j = {}));\n\n\n//# sourceMappingURL=index.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWluby93aWRnZXRzL2Rpc3QvaW5kZXguZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnSjtBQUM5RTtBQUNXO0FBQ3ZCO0FBQ1g7QUFDSDtBQUNjO0FBQ0g7QUFDQTtBQUNLO0FBQ0g7O0FBRXJEO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUJBQW1CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWdCO0FBQ3hCLFFBQVEsb0VBQXFCO0FBQzdCLFFBQVEsMEVBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzRUFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0VBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0Isc0VBQXVCO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsd0RBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUNBQXlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpRUFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlFQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBa0I7QUFDakQsS0FBSyxzQ0FBc0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxDQUFDLHNEQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLENBQUMsc0RBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9FQUFvRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFnQjtBQUNoRDtBQUNBLG1DQUFtQyxtQkFBbUIsY0FBYyxJQUFJO0FBQ3hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEIsUUFBUSwwRUFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWixZQUFZLHNFQUF1QjtBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaLFlBQVksc0VBQXVCO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1osWUFBWSxzRUFBdUI7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWixZQUFZLHNFQUF1QjtBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaLFlBQVksc0VBQXVCO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1osWUFBWSxzRUFBdUI7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBLGdCQUFnQixzRUFBdUI7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0EsZ0JBQWdCLHNFQUF1QjtBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQSxnQkFBZ0Isc0VBQXVCO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBLGdCQUFnQixzRUFBdUI7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtRUFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0VBQWdCO0FBQzlEO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0VBQWdCO0FBQzVEO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdFQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG9CQUFvQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFlO0FBQ3ZCLFFBQVEsOERBQWU7QUFDdkIsUUFBUSw4REFBZTtBQUN2QjtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYTtBQUNyQixRQUFRLDREQUFhO0FBQ3JCLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFpQjtBQUNwQyxxQkFBcUIsZ0VBQWlCO0FBQ3RDLFFBQVEsZ0VBQWlCO0FBQ3pCO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtFQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBZ0I7QUFDbEQ7QUFDQSw4QkFBOEIsV0FBVztBQUN6QywwQ0FBMEMsd0NBQXdDO0FBQ2xGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5QkFBeUI7QUFDM0UscURBQXFELGVBQWUsOEJBQThCLGlCQUFpQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLGdEQUFnRDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHdDQUF3Qyx5Q0FBeUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzRUFBdUI7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFtQjtBQUMxQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDBEQUEwRCxjQUFjLHlDQUF5QztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUF1QjtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0VBQXVCO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSSxnQ0FBZ0MsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWU7QUFDdkI7QUFDQSxRQUFRLDhEQUFlO0FBQ3ZCO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYTtBQUNyQjtBQUNBLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFpQjtBQUNwQztBQUNBLFFBQVEsZ0VBQWlCO0FBQ3pCO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdFQUFnQjtBQUNsRDtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDBDQUEwQyx3Q0FBd0M7QUFDbEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFnQjtBQUNwRDtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLDBDQUEwQyx3Q0FBd0M7QUFDbEY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx3Q0FBd0MseUNBQXlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9EQUFvRDtBQUN2RywyQ0FBMkMsaUNBQWlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0VBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0UsWUFBWSxpRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0NBQXNDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQThDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0VBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0VBQXVCO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFJLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9CQUFvQixvREFBSTtBQUN4QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBSyxHQUFHLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUssR0FBRyxzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3Qiw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFtQiw4QkFBOEIsc0RBQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2RUFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFtQixnQ0FBZ0Msc0RBQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlFQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFtQixtQ0FBbUMsZUFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUE4RDtBQUN6RjtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQW1EO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrRUFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxRUFBc0I7QUFDN0MscURBQXFELGdFQUFpQjtBQUN0RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFEQUFNO0FBQ3hDLG1DQUFtQyxxREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0VBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxRUFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQSxRQUFRLGlFQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0VBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0VBQXVCO0FBQzNDLG1CQUFtQixnRUFBa0I7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQUksWUFBWTtBQUNwQyx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFLLEdBQUcsc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBSyxHQUFHLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyw4QkFBOEI7QUFDekY7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZFQUErQjtBQUNuRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEMsZ0JBQWdCLGdFQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrRUFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFFQUFzQjtBQUNqRCwyREFBMkQsZ0VBQWlCO0FBQzVFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBa0I7QUFDckMsWUFBWSxxRUFBc0I7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyx3Q0FBd0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhEQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJFQUE2QjtBQUM5QyxpQkFBaUIsMkVBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxREFBTTtBQUNwQyxvQ0FBb0MscURBQU07QUFDMUMsa0NBQWtDLHFEQUFNO0FBQ3hDLHVDQUF1QyxxREFBTTtBQUM3Qyx3Q0FBd0MscURBQU07QUFDOUMsMENBQTBDLHFEQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0RBQWdEO0FBQzlGO0FBQ0EsUUFBUSxpRUFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzRUFBdUI7QUFDM0MsbUJBQW1CLGdFQUFrQjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsaUNBQWlDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0VBQXVCO0FBQzNDLG1CQUFtQixnRUFBa0I7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUVBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwRUFBMEU7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBdUI7QUFDL0MsdUJBQXVCLGdFQUFrQjtBQUN6QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBSSxZQUFZLHNGQUFzRjtBQUM5SDtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFJLFlBQVksc0ZBQXNGO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQUssR0FBRyxzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLLEdBQUcsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJLDhCQUE4QixtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdEQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdEQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsd0RBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd0RBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd0RBQUs7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0UsNENBQTRDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUksMkJBQTJCLDZCQUE2QjtBQUNwRTtBQUNBLFFBQVEsdURBQUkscUNBQXFDLHdDQUF3QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBc0I7QUFDdEMscUJBQXFCLGdFQUFpQjtBQUN0QyxRQUFRLGdFQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFpQjtBQUMzQyxRQUFRLGdFQUFpQjtBQUN6QixRQUFRLGdFQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFlO0FBQzNCLFlBQVksOERBQWU7QUFDM0IsWUFBWSw4REFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFlO0FBQzNCLFlBQVksOERBQWU7QUFDM0IsWUFBWSw4REFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBZTtBQUMzQixZQUFZLDhEQUFlO0FBQzNCLFlBQVksOERBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWU7QUFDdkIsUUFBUSw4REFBZTtBQUN2QixRQUFRLDhEQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQUssQ0FBQyx1REFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFHLHdDQUF3QyxxQkFBcUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFJLGdCQUFnQix3REFBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxxQkFBcUI7QUFDekY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQUcsbUNBQW1DLGdDQUFnQztBQUNqRyx1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzREFBRyxtQ0FBbUMsaUNBQWlDO0FBQ2xHLHVCQUF1Qiw0REFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFHLG1DQUFtQyxxQ0FBcUM7QUFDdEcsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQUcsbUNBQW1DLDZCQUE2QjtBQUM5Rix1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzREFBRyxtQ0FBbUMsNkJBQTZCO0FBQzlGLG1CQUFtQix3REFBSyxtQkFBbUIsNERBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDhCQUE4QjtBQUM5RixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQUksaUNBQWlDLDhCQUE4QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQUksbUNBQW1DLDhCQUE4QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFNLG9DQUFvQyw0QkFBNEI7QUFDNUY7QUFDQTtBQUNBLGdCQUFnQix1REFBSTtBQUNwQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFJO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0Esc0JBQXNCLHlEQUFNLDZCQUE2QixrQkFBa0I7QUFDM0U7QUFDQTtBQUNBLGdCQUFnQix1REFBSSw2QkFBNkIsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQUksNkJBQTZCLHdCQUF3QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBSSxpQ0FBaUMsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnREFBZ0Q7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxREFBTTtBQUMxQyxrQ0FBa0MscURBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkUsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0MsOENBQThDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1REFBSSx1Q0FBdUMsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQUkscUNBQXFDLDZCQUE2QjtBQUNsRixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBSSxxQ0FBcUMsa0NBQWtDO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVEQUFJO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBZ0IsSUFBSSw0REFBYztBQUM5QyxZQUFZLGdFQUFpQjtBQUM3QjtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFtQjtBQUM1RDtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBO0FBQ0EseUNBQXlDLCtCQUErQjtBQUN4RTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQztBQUN6RTtBQUNBO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBSSx1Q0FBdUMsaUNBQWlDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQW1CO0FBQzFDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBb0IsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFvRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWdCLElBQUksNERBQWM7QUFDOUMsWUFBWSxnRUFBaUI7QUFDN0I7QUFDQTtBQUNBLFFBQVEsc0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBUTtBQUNuQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlFQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0VBQWdCO0FBQzVEO0FBQ0EsOEJBQThCO0FBQzlCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHNCQUFzQiwwREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdFQUFrQjtBQUMvQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscURBQU07QUFDeEMsbUNBQW1DLHFEQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEI7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQU0sK0JBQStCLHNDQUFzQztBQUMvRjtBQUNBLHVCQUF1QixzREFBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5Q0FBeUM7QUFDakY7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUFJLCtCQUErQixzQ0FBc0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQUcsZ0NBQWdDLHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNFQUF1Qiw4QkFBOEIsOEJBQThCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0VBQXVCLDhCQUE4Qiw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJLDJCQUEyQiw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0U7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnRUFBZ0I7QUFDckQ7QUFDQSw4QkFBOEIsVUFBVSw4Q0FBOEMsSUFBSTtBQUMxRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQSxRQUFRLGlFQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvRUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNFQUF1QjtBQUMzQyxtQkFBbUIsZ0VBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0VBQXVCO0FBQzNDLG1CQUFtQixnRUFBa0I7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBSSxZQUFZLDhFQUE4RTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQUssR0FBRyxzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLLEdBQUcsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHdDQUF3Qyw4QkFBOEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRUFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQU07QUFDdEMsbUNBQW1DLHFEQUFNO0FBQ3pDLG1DQUFtQyxxREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBSSxpQkFBaUIsd0RBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQUksMkJBQTJCLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSSxnQ0FBZ0MsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQWU7QUFDdkI7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBaUI7QUFDcEM7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrRUFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHdDQUF3Qyx5Q0FBeUM7QUFDakYsbUNBQW1DLHFEQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esb0NBQW9DLHFEQUFNO0FBQzFDLGtDQUFrQyxxREFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdEQUFnRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSw4REFBZ0IsSUFBSSw0REFBYztBQUM5QyxZQUFZLGdFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7O0FBRThTO0FBQzdVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vbm9kZV9tb2R1bGVzL0BsdW1pbm8vd2lkZ2V0cy9kaXN0L2luZGV4LmVzNi5qcz9kODM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVtcHR5LCBlYWNoLCBpdGVyLCBBcnJheUV4dCwgU3RyaW5nRXh0LCBjaGFpbiwgb25jZSwgbWFwLCBDaGFpbkl0ZXJhdG9yLCByZWR1Y2UsIGZpbmQsIHRvQXJyYXksIGZpbHRlciwgbWF4IH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuaW1wb3J0IHsgRWxlbWVudEV4dCwgU2VsZWN0b3IsIFBsYXRmb3JtIH0gZnJvbSAnQGx1bWluby9kb211dGlscyc7XG5pbXBvcnQgeyBNZXNzYWdlTG9vcCwgTWVzc2FnZSwgQ29uZmxhdGFibGVNZXNzYWdlIH0gZnJvbSAnQGx1bWluby9tZXNzYWdpbmcnO1xuaW1wb3J0IHsgQXR0YWNoZWRQcm9wZXJ0eSB9IGZyb20gJ0BsdW1pbm8vcHJvcGVydGllcyc7XG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5pbXBvcnQgeyBEcmFnIH0gZnJvbSAnQGx1bWluby9kcmFnZHJvcCc7XG5pbXBvcnQgeyBKU09ORXh0LCBNaW1lRGF0YSB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcbmltcG9ydCB7IENvbW1hbmRSZWdpc3RyeSB9IGZyb20gJ0BsdW1pbm8vY29tbWFuZHMnO1xuaW1wb3J0IHsgVmlydHVhbERPTSwgaCB9IGZyb20gJ0BsdW1pbm8vdmlydHVhbGRvbSc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlRGVsZWdhdGUgfSBmcm9tICdAbHVtaW5vL2Rpc3Bvc2FibGUnO1xuaW1wb3J0IHsgZ2V0S2V5Ym9hcmRMYXlvdXQgfSBmcm9tICdAbHVtaW5vL2tleWJvYXJkJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG4vLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBQaG9zcGhvckpTIENvbnRyaWJ1dG9yc1xufFxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxufFxufCBUaGUgZnVsbCBsaWNlbnNlIGlzIGluIHRoZSBmaWxlIExJQ0VOU0UsIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb2Z0d2FyZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQSBzaXplciBvYmplY3QgZm9yIHVzZSB3aXRoIHRoZSBib3ggZW5naW5lIGxheW91dCBmdW5jdGlvbnMuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogQSBib3ggc2l6ZXIgaG9sZHMgdGhlIGdlb21ldHJ5IGluZm9ybWF0aW9uIGZvciBhbiBvYmplY3QgYWxvbmcgYW5cbiAqIGFyYml0cmFyeSBsYXlvdXQgb3JpZW50YXRpb24uXG4gKlxuICogRm9yIGJlc3QgcGVyZm9ybWFuY2UsIHRoaXMgY2xhc3Mgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSByYXcgZGF0YVxuICogc3RydWN0LiBJdCBzaG91bGQgbm90IHR5cGljYWxseSBiZSBzdWJjbGFzc2VkLlxuICovXG52YXIgQm94U2l6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm94U2l6ZXIoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJlZmVycmVkIHNpemUgZm9yIHRoZSBzaXplci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgc2l6ZXIgd2lsbCBiZSBnaXZlbiB0aGlzIGluaXRpYWwgc2l6ZSBzdWJqZWN0IHRvIGl0cyBzaXplXG4gICAgICAgICAqIGJvdW5kcy4gVGhlIHNpemVyIHdpbGwgbm90IGRldmlhdGUgZnJvbSB0aGlzIHNpemUgdW5sZXNzIHN1Y2hcbiAgICAgICAgICogZGV2aWF0aW9uIGlzIHJlcXVpcmVkIHRvIGZpdCBpbnRvIHRoZSBhdmFpbGFibGUgbGF5b3V0IHNwYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGVyZSBpcyBubyBsaW1pdCB0byB0aGlzIHZhbHVlLCBidXQgaXQgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZVxuICAgICAgICAgKiBib3VuZHMgZGVmaW5lZCBieSBbW21pblNpemVdXSBhbmQgW1ttYXhTaXplXV0uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAwYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZUhpbnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2l6ZSBvZiB0aGUgc2l6ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIHNpemVyIHdpbGwgbmV2ZXIgYmUgc2l6ZWQgbGVzcyB0aGFuIHRoaXMgdmFsdWUsIGV2ZW4gaWZcbiAgICAgICAgICogaXQgbWVhbnMgdGhlIHNpemVyIHdpbGwgb3ZlcmZsb3cgdGhlIGF2YWlsYWJsZSBsYXlvdXQgc3BhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGlzIHZhbHVlIGxpZXMgaW4gdGhlIHJhbmdlIGBbMCwgSW5maW5pdHkpYFxuICAgICAgICAgKiBhbmQgdGhhdCBpdCBpcyBgPD1gIHRvIFtbbWF4U2l6ZV1dLiBGYWlsdXJlIHRvIGFkaGVyZSB0byB0aGlzXG4gICAgICAgICAqIGNvbnN0cmFpbnQgd2lsbCB5aWVsZCB1bmRlZmluZWQgcmVzdWx0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDBgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5TaXplID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHNpemVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBzaXplciB3aWxsIG5ldmVyIGJlIHNpemVkIGdyZWF0ZXIgdGhhbiB0aGlzIHZhbHVlLCBldmVuIGlmXG4gICAgICAgICAqIGl0IG1lYW5zIHRoZSBzaXplciB3aWxsIHVuZGVyZmxvdyB0aGUgYXZhaWxhYmxlIGxheW91dCBzcGFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgdmFsdWUgbGllcyBpbiB0aGUgcmFuZ2UgYFswLCBJbmZpbml0eV1gXG4gICAgICAgICAqIGFuZCB0aGF0IGl0IGlzIGA+PWAgdG8gW1ttaW5TaXplXV0uIEZhaWx1cmUgdG8gYWRoZXJlIHRvIHRoaXNcbiAgICAgICAgICogY29uc3RyYWludCB3aWxsIHlpZWxkIHVuZGVmaW5lZCByZXN1bHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgSW5maW5pdHlgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhTaXplID0gSW5maW5pdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RyZXRjaCBmYWN0b3IgZm9yIHRoZSBzaXplci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIGNvbnRyb2xzIGhvdyBtdWNoIHRoZSBzaXplciBzdHJldGNoZXMgcmVsYXRpdmUgdG8gaXRzIHNpYmxpbmdcbiAgICAgICAgICogc2l6ZXJzIHdoZW4gbGF5b3V0IHNwYWNlIGlzIGRpc3RyaWJ1dGVkLiBBIHN0cmV0Y2ggZmFjdG9yIG9mIHplcm9cbiAgICAgICAgICogaXMgc3BlY2lhbCBhbmQgd2lsbCBjYXVzZSB0aGUgc2l6ZXIgdG8gb25seSBiZSByZXNpemVkIGFmdGVyIGFsbFxuICAgICAgICAgKiBvdGhlciBzaXplcnMgd2l0aCBhIHN0cmV0Y2ggZmFjdG9yIGdyZWF0ZXIgdGhhbiB6ZXJvIGhhdmUgYmVlblxuICAgICAgICAgKiByZXNpemVkIHRvIHRoZWlyIGxpbWl0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgdmFsdWUgaXMgYW4gaW50ZWdlciB0aGF0IGxpZXMgaW4gdGhlIHJhbmdlXG4gICAgICAgICAqIGBbMCwgSW5maW5pdHkpYC4gRmFpbHVyZSB0byBhZGhlcmUgdG8gdGhpcyBjb25zdHJhaW50IHdpbGwgeWllbGRcbiAgICAgICAgICogdW5kZWZpbmVkIHJlc3VsdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAxYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RyZXRjaCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcHV0ZWQgc2l6ZSBvZiB0aGUgc2l6ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyB2YWx1ZSBpcyB0aGUgb3V0cHV0IG9mIGEgY2FsbCB0byBbW2JveENhbGNdXS4gSXQgcmVwcmVzZW50c1xuICAgICAgICAgKiB0aGUgY29tcHV0ZWQgc2l6ZSBmb3IgdGhlIG9iamVjdCBhbG9uZyB0aGUgbGF5b3V0IG9yaWVudGF0aW9uLFxuICAgICAgICAgKiBhbmQgd2lsbCBhbHdheXMgbGllIGluIHRoZSByYW5nZSBgW21pblNpemUsIG1heFNpemVdYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSBpcyBvdXRwdXQgb25seS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2hhbmdpbmcgdGhpcyB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIHN0b3JhZ2UgcHJvcGVydHkgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgdXNlZCBhcyB0ZW1wb3Jhcnkgc3RvcmFnZSBieSB0aGUgbGF5b3V0IGFsZ29yaXRobS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2hhbmdpbmcgdGhpcyB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBCb3hTaXplcjtcbn0oKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBib3ggZW5naW5lIGxheW91dCBmdW5jdGlvbnMuXG4gKi9cbnZhciBCb3hFbmdpbmU7XG4oZnVuY3Rpb24gKEJveEVuZ2luZSkge1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgb3B0aW1hbCBsYXlvdXQgc2l6ZXMgZm9yIGEgc2VxdWVuY2Ugb2YgYm94IHNpemVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgZGlzdHJpYnV0ZXMgdGhlIGF2YWlsYWJsZSBsYXlvdXQgc3BhY2UgYW1vbmcgdGhlIGJveCBzaXplcnNcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICpcbiAgICAgKiAxLiBJbml0aWFsaXplIHRoZSBzaXplcnMncyBzaXplIHRvIGl0cyBzaXplIGhpbnQgYW5kIGNvbXB1dGUgdGhlXG4gICAgICogICAgc3VtcyBmb3IgZWFjaCBvZiBzaXplIGhpbnQsIG1pbiBzaXplLCBhbmQgbWF4IHNpemUuXG4gICAgICpcbiAgICAgKiAyLiBJZiB0aGUgdG90YWwgc2l6ZSBoaW50IGVxdWFscyB0aGUgYXZhaWxhYmxlIHNwYWNlLCByZXR1cm4uXG4gICAgICpcbiAgICAgKiAzLiBJZiB0aGUgYXZhaWxhYmxlIHNwYWNlIGlzIGxlc3MgdGhhbiB0aGUgdG90YWwgbWluIHNpemUsIHNldCBhbGxcbiAgICAgKiAgICBzaXplcnMgdG8gdGhlaXIgbWluIHNpemUgYW5kIHJldHVybi5cbiAgICAgKlxuICAgICAqIDQuIElmIHRoZSBhdmFpbGFibGUgc3BhY2UgaXMgZ3JlYXRlciB0aGFuIHRoZSB0b3RhbCBtYXggc2l6ZSwgc2V0XG4gICAgICogICAgYWxsIHNpemVycyB0byB0aGVpciBtYXggc2l6ZSBhbmQgcmV0dXJuLlxuICAgICAqXG4gICAgICogNS4gSWYgdGhlIGxheW91dCBzcGFjZSBpcyBsZXNzIHRoYW4gdGhlIHRvdGFsIHNpemUgaGludCwgZGlzdHJpYnV0ZVxuICAgICAqICAgIHRoZSBuZWdhdGl2ZSBkZWx0YSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogICAgYS4gU2hyaW5rIGVhY2ggc2l6ZXIgd2l0aCBhIHN0cmV0Y2ggZmFjdG9yIGdyZWF0ZXIgdGhhbiB6ZXJvIGJ5XG4gICAgICogICAgICAgYW4gYW1vdW50IHByb3BvcnRpb25hbCB0byB0aGUgbmVnYXRpdmUgc3BhY2UgYW5kIHRoZSBzdW0gb2ZcbiAgICAgKiAgICAgICBzdHJldGNoIGZhY3RvcnMuIElmIHRoZSBzaXplciByZWFjaGVzIGl0cyBtaW4gc2l6ZSwgcmVtb3ZlXG4gICAgICogICAgICAgaXQgYW5kIGl0cyBzdHJldGNoIGZhY3RvciBmcm9tIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqICAgIGIuIElmIGFmdGVyIGFkanVzdGluZyBhbGwgc3RyZXRjaCBzaXplcnMgdGhlcmUgcmVtYWlucyBuZWdhdGl2ZVxuICAgICAqICAgICAgIHNwYWNlLCBkaXN0cmlidXRlIHRoZSBzcGFjZSBlcXVhbGx5IGFtb25nIHRoZSBzaXplcnMgd2l0aCBhXG4gICAgICogICAgICAgc3RyZXRjaCBmYWN0b3Igb2YgemVyby4gSWYgYSBzaXplciByZWFjaGVzIGl0cyBtaW4gc2l6ZSxcbiAgICAgKiAgICAgICByZW1vdmUgaXQgZnJvbSB0aGUgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiA2LiBJZiB0aGUgbGF5b3V0IHNwYWNlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdG90YWwgc2l6ZSBoaW50LFxuICAgICAqICAgIGRpc3RyaWJ1dGUgdGhlIHBvc2l0aXZlIGRlbHRhIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiAgICBhLiBFeHBhbmQgZWFjaCBzaXplciB3aXRoIGEgc3RyZXRjaCBmYWN0b3IgZ3JlYXRlciB0aGFuIHplcm8gYnlcbiAgICAgKiAgICAgICBhbiBhbW91bnQgcHJvcG9ydGlvbmFsIHRvIHRoZSBwb3N0aXZlIHNwYWNlIGFuZCB0aGUgc3VtIG9mXG4gICAgICogICAgICAgc3RyZXRjaCBmYWN0b3JzLiBJZiB0aGUgc2l6ZXIgcmVhY2hlcyBpdHMgbWF4IHNpemUsIHJlbW92ZVxuICAgICAqICAgICAgIGl0IGFuZCBpdHMgc3RyZXRjaCBmYWN0b3IgZnJvbSB0aGUgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiAgICBiLiBJZiBhZnRlciBhZGp1c3RpbmcgYWxsIHN0cmV0Y2ggc2l6ZXJzIHRoZXJlIHJlbWFpbnMgcG9zaXRpdmVcbiAgICAgKiAgICAgICBzcGFjZSwgZGlzdHJpYnV0ZSB0aGUgc3BhY2UgZXF1YWxseSBhbW9uZyB0aGUgc2l6ZXJzIHdpdGggYVxuICAgICAqICAgICAgIHN0cmV0Y2ggZmFjdG9yIG9mIHplcm8uIElmIGEgc2l6ZXIgcmVhY2hlcyBpdHMgbWF4IHNpemUsXG4gICAgICogICAgICAgcmVtb3ZlIGl0IGZyb20gdGhlIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogNy4gcmV0dXJuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2l6ZXJzIC0gVGhlIHNpemVycyBmb3IgYSBwYXJ0aWN1bGFyIGxheW91dCBsaW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNwYWNlIC0gVGhlIGF2YWlsYWJsZSBsYXlvdXQgc3BhY2UgZm9yIHRoZSBzaXplcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVsdGEgYmV0d2VlbiB0aGUgcHJvdmlkZWQgYXZhaWxhYmxlIHNwYWNlIGFuZCB0aGVcbiAgICAgKiAgIGFjdHVhbCBjb25zdW1lZCBzcGFjZS4gVGhpcyB2YWx1ZSB3aWxsIGJlIHplcm8gaWYgdGhlIHNpemVyc1xuICAgICAqICAgY2FuIGJlIGFkanVzdGVkIHRvIGZpdCwgbmVnYXRpdmUgaWYgdGhlIGF2YWlsYWJsZSBzcGFjZSBpcyB0b29cbiAgICAgKiAgIHNtYWxsLCBhbmQgcG9zaXRpdmUgaWYgdGhlIGF2YWlsYWJsZSBzcGFjZSBpcyB0b28gbGFyZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIFtbc2l6ZV1dIG9mIGVhY2ggc2l6ZXIgaXMgdXBkYXRlZCB3aXRoIHRoZSBjb21wdXRlZCBzaXplLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lIHRvIHJlY29tcHV0ZSB0aGUgbGF5b3V0IGZvclxuICAgICAqIGFuIGV4aXN0aW5nIHNlcXVlbmNlIG9mIHNpemVycy4gVGhlIHByZXZpb3VzbHkgY29tcHV0ZWQgcmVzdWx0cyB3aWxsXG4gICAgICogaGF2ZSBubyBlZmZlY3Qgb24gdGhlIG5ldyBvdXRwdXQuIEl0IGlzIHRoZXJlZm9yZSBub3QgbmVjZXNzYXJ5IHRvXG4gICAgICogY3JlYXRlIG5ldyBzaXplciBvYmplY3RzIG9uIGVhY2ggcmVzaXplIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGMoc2l6ZXJzLCBzcGFjZSkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIHZhciBjb3VudCA9IHNpemVycy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHVwIHRoZSBzaXplIGFuZCBzdHJldGNoIGNvdW50ZXJzLlxuICAgICAgICB2YXIgdG90YWxNaW4gPSAwO1xuICAgICAgICB2YXIgdG90YWxNYXggPSAwO1xuICAgICAgICB2YXIgdG90YWxTaXplID0gMDtcbiAgICAgICAgdmFyIHRvdGFsU3RyZXRjaCA9IDA7XG4gICAgICAgIHZhciBzdHJldGNoQ291bnQgPSAwO1xuICAgICAgICAvLyBTZXR1cCB0aGUgc2l6ZXJzIGFuZCBjb21wdXRlIHRoZSB0b3RhbHMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNpemVyID0gc2l6ZXJzW2ldO1xuICAgICAgICAgICAgdmFyIG1pbiA9IHNpemVyLm1pblNpemU7XG4gICAgICAgICAgICB2YXIgbWF4ID0gc2l6ZXIubWF4U2l6ZTtcbiAgICAgICAgICAgIHZhciBoaW50ID0gc2l6ZXIuc2l6ZUhpbnQ7XG4gICAgICAgICAgICBzaXplci5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICBzaXplci5zaXplID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihoaW50LCBtYXgpKTtcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBzaXplci5zaXplO1xuICAgICAgICAgICAgdG90YWxNaW4gKz0gbWluO1xuICAgICAgICAgICAgdG90YWxNYXggKz0gbWF4O1xuICAgICAgICAgICAgaWYgKHNpemVyLnN0cmV0Y2ggPiAwKSB7XG4gICAgICAgICAgICAgICAgdG90YWxTdHJldGNoICs9IHNpemVyLnN0cmV0Y2g7XG4gICAgICAgICAgICAgICAgc3RyZXRjaENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNwYWNlIGlzIGVxdWFsIHRvIHRoZSB0b3RhbCBzaXplLCByZXR1cm4gZWFybHkuXG4gICAgICAgIGlmIChzcGFjZSA9PT0gdG90YWxTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3BhY2UgaXMgbGVzcyB0aGFuIHRoZSB0b3RhbCBtaW4sIG1pbmltaXplIGVhY2ggc2l6ZXIuXG4gICAgICAgIGlmIChzcGFjZSA8PSB0b3RhbE1pbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemVyID0gc2l6ZXJzW2ldO1xuICAgICAgICAgICAgICAgIHNpemVyLnNpemUgPSBzaXplci5taW5TaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNwYWNlIC0gdG90YWxNaW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNwYWNlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdG90YWwgbWF4LCBtYXhpbWl6ZSBlYWNoIHNpemVyLlxuICAgICAgICBpZiAoc3BhY2UgPj0gdG90YWxNYXgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplciA9IHNpemVyc1tpXTtcbiAgICAgICAgICAgICAgICBzaXplci5zaXplID0gc2l6ZXIubWF4U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzcGFjZSAtIHRvdGFsTWF4O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsb29wcyBiZWxvdyBwZXJmb3JtIHN1Yi1waXhlbCBwcmVjaXNpb24gc2l6aW5nLiBBIG5lYXIgemVyb1xuICAgICAgICAvLyB2YWx1ZSBpcyB1c2VkIGZvciBjb21wYXJlcyBpbnN0ZWFkIG9mIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgIC8vIGxvb3AgdGVybWluYXRlcyB3aGVuIHRoZSBzdWJkaXZpZGVkIHNwYWNlIGlzIHJlYXNvbmFibHkgc21hbGwuXG4gICAgICAgIHZhciBuZWFyWmVybyA9IDAuMDE7XG4gICAgICAgIC8vIEEgY291bnRlciB3aGljaCBpcyBkZWNyZW1lbnRlZCBlYWNoIHRpbWUgYSBzaXplciBpcyByZXNpemVkIHRvXG4gICAgICAgIC8vIGl0cyBsaW1pdC4gVGhpcyBlbnN1cmVzIHRoZSBsb29wcyB0ZXJtaW5hdGUgZXZlbiBpZiB0aGVyZSBpc1xuICAgICAgICAvLyBzcGFjZSByZW1haW5pbmcgdG8gZGlzdHJpYnV0ZS5cbiAgICAgICAgdmFyIG5vdERvbmVDb3VudCA9IGNvdW50O1xuICAgICAgICAvLyBEaXN0cmlidXRlIG5lZ2F0aXZlIGRlbHRhIHNwYWNlLlxuICAgICAgICBpZiAoc3BhY2UgPCB0b3RhbFNpemUpIHtcbiAgICAgICAgICAgIC8vIFNocmluayBlYWNoIHN0cmV0Y2hhYmxlIHNpemVyIGJ5IGFuIGFtb3VudCBwcm9wb3J0aW9uYWwgdG8gaXRzXG4gICAgICAgICAgICAvLyBzdHJldGNoIGZhY3Rvci4gSWYgYSBzaXplciByZWFjaGVzIGl0cyBtaW4gc2l6ZSBpdCdzIG1hcmtlZCBhc1xuICAgICAgICAgICAgLy8gZG9uZS4gVGhlIGxvb3AgcHJvZ3Jlc3NlcyBpbiBwaGFzZXMgd2hlcmUgZWFjaCBzaXplciBpcyBnaXZlblxuICAgICAgICAgICAgLy8gYSBjaGFuY2UgdG8gY29uc3VtZSBpdHMgZmFpciBzaGFyZSBmb3IgdGhlIHBhc3MsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgYSBzaXplciBiZWZvcmUgaXQgcmVhY2hlZCBpdHMgbGltaXQuIFRoaXMgY29udGludWVzXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGUgc3RyZXRjaGFibGUgc2l6ZXJzIG9yIHRoZSBmcmVlIHNwYWNlIGlzIGV4aGF1c3RlZC5cbiAgICAgICAgICAgIHZhciBmcmVlU3BhY2UgPSB0b3RhbFNpemUgLSBzcGFjZTtcbiAgICAgICAgICAgIHdoaWxlIChzdHJldGNoQ291bnQgPiAwICYmIGZyZWVTcGFjZSA+IG5lYXJaZXJvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RTcGFjZSA9IGZyZWVTcGFjZTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdFN0cmV0Y2ggPSB0b3RhbFN0cmV0Y2g7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplciA9IHNpemVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVyLmRvbmUgfHwgc2l6ZXIuc3RyZXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFtdCA9IHNpemVyLnN0cmV0Y2ggKiBkaXN0U3BhY2UgLyBkaXN0U3RyZXRjaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVyLnNpemUgLSBhbXQgPD0gc2l6ZXIubWluU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJlZVNwYWNlIC09IHNpemVyLnNpemUgLSBzaXplci5taW5TaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTdHJldGNoIC09IHNpemVyLnN0cmV0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplci5zaXplID0gc2l6ZXIubWluU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVyLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90RG9uZUNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJldGNoQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyZWVTcGFjZSAtPSBhbXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplci5zaXplIC09IGFtdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgYW55IHJlbWFpbmluZyBzcGFjZSBldmVubHkgYW1vbmcgdGhlIG5vbi1zdHJldGNoYWJsZVxuICAgICAgICAgICAgLy8gc2l6ZXJzLiBUaGlzIHByb2dyZXNzZXMgaW4gcGhhc2VzIGluIHRoZSBzYW1lIG1hbm5lciBhcyBhYm92ZS5cbiAgICAgICAgICAgIHdoaWxlIChub3REb25lQ291bnQgPiAwICYmIGZyZWVTcGFjZSA+IG5lYXJaZXJvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFtdCA9IGZyZWVTcGFjZSAvIG5vdERvbmVDb3VudDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVyID0gc2l6ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZXIuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVyLnNpemUgLSBhbXQgPD0gc2l6ZXIubWluU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJlZVNwYWNlIC09IHNpemVyLnNpemUgLSBzaXplci5taW5TaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXIuc2l6ZSA9IHNpemVyLm1pblNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdERvbmVDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJlZVNwYWNlIC09IGFtdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVyLnNpemUgLT0gYW10O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERpc3RyaWJ1dGUgcG9zaXRpdmUgZGVsdGEgc3BhY2UuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRXhwYW5kIGVhY2ggc3RyZXRjaGFibGUgc2l6ZXIgYnkgYW4gYW1vdW50IHByb3BvcnRpb25hbCB0byBpdHNcbiAgICAgICAgICAgIC8vIHN0cmV0Y2ggZmFjdG9yLiBJZiBhIHNpemVyIHJlYWNoZXMgaXRzIG1heCBzaXplIGl0J3MgbWFya2VkIGFzXG4gICAgICAgICAgICAvLyBkb25lLiBUaGUgbG9vcCBwcm9ncmVzc2VzIGluIHBoYXNlcyB3aGVyZSBlYWNoIHNpemVyIGlzIGdpdmVuXG4gICAgICAgICAgICAvLyBhIGNoYW5jZSB0byBjb25zdW1lIGl0cyBmYWlyIHNoYXJlIGZvciB0aGUgcGFzcywgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciBhIHNpemVyIGJlZm9yZSBpdCByZWFjaGVkIGl0cyBsaW1pdC4gVGhpcyBjb250aW51ZXNcbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBzdHJldGNoYWJsZSBzaXplcnMgb3IgdGhlIGZyZWUgc3BhY2UgaXMgZXhoYXVzdGVkLlxuICAgICAgICAgICAgdmFyIGZyZWVTcGFjZSA9IHNwYWNlIC0gdG90YWxTaXplO1xuICAgICAgICAgICAgd2hpbGUgKHN0cmV0Y2hDb3VudCA+IDAgJiYgZnJlZVNwYWNlID4gbmVhclplcm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdFNwYWNlID0gZnJlZVNwYWNlO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0U3RyZXRjaCA9IHRvdGFsU3RyZXRjaDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVyID0gc2l6ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZXIuZG9uZSB8fCBzaXplci5zdHJldGNoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYW10ID0gc2l6ZXIuc3RyZXRjaCAqIGRpc3RTcGFjZSAvIGRpc3RTdHJldGNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZXIuc2l6ZSArIGFtdCA+PSBzaXplci5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmVlU3BhY2UgLT0gc2l6ZXIubWF4U2l6ZSAtIHNpemVyLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFN0cmV0Y2ggLT0gc2l6ZXIuc3RyZXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVyLnNpemUgPSBzaXplci5tYXhTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXIuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3REb25lQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmV0Y2hDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJlZVNwYWNlIC09IGFtdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVyLnNpemUgKz0gYW10O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzdHJpYnV0ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGV2ZW5seSBhbW9uZyB0aGUgbm9uLXN0cmV0Y2hhYmxlXG4gICAgICAgICAgICAvLyBzaXplcnMuIFRoaXMgcHJvZ3Jlc3NlcyBpbiBwaGFzZXMgaW4gdGhlIHNhbWUgbWFubmVyIGFzIGFib3ZlLlxuICAgICAgICAgICAgd2hpbGUgKG5vdERvbmVDb3VudCA+IDAgJiYgZnJlZVNwYWNlID4gbmVhclplcm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYW10ID0gZnJlZVNwYWNlIC8gbm90RG9uZUNvdW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZXIgPSBzaXplcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplci5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZXIuc2l6ZSArIGFtdCA+PSBzaXplci5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmVlU3BhY2UgLT0gc2l6ZXIubWF4U2l6ZSAtIHNpemVyLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplci5zaXplID0gc2l6ZXIubWF4U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVyLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90RG9uZUNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmVlU3BhY2UgLT0gYW10O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXIuc2l6ZSArPSBhbXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5kaWNhdGUgdGhhdCB0aGUgY29uc3VtZWQgc3BhY2UgZXF1YWxzIHRoZSBhdmFpbGFibGUgc3BhY2UuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBCb3hFbmdpbmUuY2FsYyA9IGNhbGM7XG4gICAgLyoqXG4gICAgICogQWRqdXN0IGEgc2l6ZXIgYnkgYSBkZWx0YSBhbmQgdXBkYXRlIGl0cyBuZWlnaGJvcnMgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2l6ZXJzIC0gVGhlIHNpemVycyB3aGljaCBzaG91bGQgYmUgYWRqdXN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNpemVyIHRvIGdyb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgYW1vdW50IHRvIGFkanVzdCB0aGUgc2l6ZXIsIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgd2lsbCBhZGp1c3QgdGhlIGluZGljYXRlZCBzaXplciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudCwgYWxvbmdcbiAgICAgKiB3aXRoIHRoZSBzaXplcyBvZiB0aGUgYXBwcm9wcmlhdGUgbmVpZ2hib3JzLCBzdWJqZWN0IHRvIHRoZSBsaW1pdHNcbiAgICAgKiBzcGVjaWZpZWQgYnkgZWFjaCBvZiB0aGUgc2l6ZXJzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBpbXBsZW1lbnRpbmcgYm94IGxheW91dHMgd2hlcmUgdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBiZXR3ZWVuIHRoZSBzaXplcnMgYXJlIGludGVyYWN0aXZlbHkgYWRqdXN0YWJsZSBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGp1c3Qoc2l6ZXJzLCBpbmRleCwgZGVsdGEpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIGlmIChzaXplcnMubGVuZ3RoID09PSAwIHx8IGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcGF0Y2ggdG8gdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgZ3Jvd1NpemVyKHNpemVycywgaW5kZXgsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNocmlua1NpemVyKHNpemVycywgaW5kZXgsIC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQm94RW5naW5lLmFkanVzdCA9IGFkanVzdDtcbiAgICAvKipcbiAgICAgKiBHcm93IGEgc2l6ZXIgYnkgYSBwb3NpdGl2ZSBkZWx0YSBhbmQgYWRqdXN0IG5laWdoYm9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm93U2l6ZXIoc2l6ZXJzLCBpbmRleCwgZGVsdGEpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBob3cgbXVjaCB0aGUgaXRlbXMgdG8gdGhlIGxlZnQgY2FuIGV4cGFuZC5cbiAgICAgICAgdmFyIGdyb3dMaW1pdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaXplciA9IHNpemVyc1tpXTtcbiAgICAgICAgICAgIGdyb3dMaW1pdCArPSBzaXplci5tYXhTaXplIC0gc2l6ZXIuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIGhvdyBtdWNoIHRoZSBpdGVtcyB0byB0aGUgcmlnaHQgY2FuIHNocmluay5cbiAgICAgICAgdmFyIHNocmlua0xpbWl0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMSwgbiA9IHNpemVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaXplciA9IHNpemVyc1tpXTtcbiAgICAgICAgICAgIHNocmlua0xpbWl0ICs9IHNpemVyLnNpemUgLSBzaXplci5taW5TaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRoZSBkZWx0YSBhZGp1c3RtZW50IHRvIHRoZSBsaW1pdHMuXG4gICAgICAgIGRlbHRhID0gTWF0aC5taW4oZGVsdGEsIGdyb3dMaW1pdCwgc2hyaW5rTGltaXQpO1xuICAgICAgICAvLyBHcm93IHRoZSBzaXplcnMgdG8gdGhlIGxlZnQgYnkgdGhlIGRlbHRhLlxuICAgICAgICB2YXIgZ3JvdyA9IGRlbHRhO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPj0gMCAmJiBncm93ID4gMDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXIgPSBzaXplcnNbaV07XG4gICAgICAgICAgICB2YXIgbGltaXQgPSBzaXplci5tYXhTaXplIC0gc2l6ZXIuc2l6ZTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA+PSBncm93KSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIuc2l6ZUhpbnQgPSBzaXplci5zaXplICsgZ3JvdztcbiAgICAgICAgICAgICAgICBncm93ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemVyLnNpemVIaW50ID0gc2l6ZXIuc2l6ZSArIGxpbWl0O1xuICAgICAgICAgICAgICAgIGdyb3cgLT0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hyaW5rIHRoZSBzaXplcnMgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBkZWx0YS5cbiAgICAgICAgdmFyIHNocmluayA9IGRlbHRhO1xuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxLCBuID0gc2l6ZXJzLmxlbmd0aDsgaSA8IG4gJiYgc2hyaW5rID4gMDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXIgPSBzaXplcnNbaV07XG4gICAgICAgICAgICB2YXIgbGltaXQgPSBzaXplci5zaXplIC0gc2l6ZXIubWluU2l6ZTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA+PSBzaHJpbmspIHtcbiAgICAgICAgICAgICAgICBzaXplci5zaXplSGludCA9IHNpemVyLnNpemUgLSBzaHJpbms7XG4gICAgICAgICAgICAgICAgc2hyaW5rID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemVyLnNpemVIaW50ID0gc2l6ZXIuc2l6ZSAtIGxpbWl0O1xuICAgICAgICAgICAgICAgIHNocmluayAtPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaHJpbmsgYSBzaXplciBieSBhIHBvc2l0aXZlIGRlbHRhIGFuZCBhZGp1c3QgbmVpZ2hib3JzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNocmlua1NpemVyKHNpemVycywgaW5kZXgsIGRlbHRhKSB7XG4gICAgICAgIC8vIENvbXB1dGUgaG93IG11Y2ggdGhlIGl0ZW1zIHRvIHRoZSByaWdodCBjYW4gZXhwYW5kLlxuICAgICAgICB2YXIgZ3Jvd0xpbWl0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMSwgbiA9IHNpemVycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaXplciA9IHNpemVyc1tpXTtcbiAgICAgICAgICAgIGdyb3dMaW1pdCArPSBzaXplci5tYXhTaXplIC0gc2l6ZXIuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIGhvdyBtdWNoIHRoZSBpdGVtcyB0byB0aGUgbGVmdCBjYW4gc2hyaW5rLlxuICAgICAgICB2YXIgc2hyaW5rTGltaXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBpbmRleDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXIgPSBzaXplcnNbaV07XG4gICAgICAgICAgICBzaHJpbmtMaW1pdCArPSBzaXplci5zaXplIC0gc2l6ZXIubWluU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGFtcCB0aGUgZGVsdGEgYWRqdXN0bWVudCB0byB0aGUgbGltaXRzLlxuICAgICAgICBkZWx0YSA9IE1hdGgubWluKGRlbHRhLCBncm93TGltaXQsIHNocmlua0xpbWl0KTtcbiAgICAgICAgLy8gR3JvdyB0aGUgc2l6ZXJzIHRvIHRoZSByaWdodCBieSB0aGUgZGVsdGEuXG4gICAgICAgIHZhciBncm93ID0gZGVsdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDEsIG4gPSBzaXplcnMubGVuZ3RoOyBpIDwgbiAmJiBncm93ID4gMDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXIgPSBzaXplcnNbaV07XG4gICAgICAgICAgICB2YXIgbGltaXQgPSBzaXplci5tYXhTaXplIC0gc2l6ZXIuc2l6ZTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA+PSBncm93KSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIuc2l6ZUhpbnQgPSBzaXplci5zaXplICsgZ3JvdztcbiAgICAgICAgICAgICAgICBncm93ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemVyLnNpemVIaW50ID0gc2l6ZXIuc2l6ZSArIGxpbWl0O1xuICAgICAgICAgICAgICAgIGdyb3cgLT0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hyaW5rIHRoZSBzaXplcnMgdG8gdGhlIGxlZnQgYnkgdGhlIGRlbHRhLlxuICAgICAgICB2YXIgc2hyaW5rID0gZGVsdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwICYmIHNocmluayA+IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIHNpemVyID0gc2l6ZXJzW2ldO1xuICAgICAgICAgICAgdmFyIGxpbWl0ID0gc2l6ZXIuc2l6ZSAtIHNpemVyLm1pblNpemU7XG4gICAgICAgICAgICBpZiAobGltaXQgPj0gc2hyaW5rKSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIuc2l6ZUhpbnQgPSBzaXplci5zaXplIC0gc2hyaW5rO1xuICAgICAgICAgICAgICAgIHNocmluayA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaXplci5zaXplSGludCA9IHNpemVyLnNpemUgLSBsaW1pdDtcbiAgICAgICAgICAgICAgICBzaHJpbmsgLT0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KShCb3hFbmdpbmUgfHwgKEJveEVuZ2luZSA9IHt9KSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBBbiBvYmplY3Qgd2hpY2ggaG9sZHMgZGF0YSByZWxhdGVkIHRvIGFuIG9iamVjdCdzIHRpdGxlLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIEEgdGl0bGUgb2JqZWN0IGlzIGludGVuZGVkIHRvIGhvbGQgdGhlIGRhdGEgbmVjZXNzYXJ5IHRvIGRpc3BsYXkgYVxuICogaGVhZGVyIGZvciBhIHBhcnRpY3VsYXIgb2JqZWN0LiBBIGNvbW1vbiBleGFtcGxlIGlzIHRoZSBgVGFiUGFuZWxgLFxuICogd2hpY2ggdXNlcyB0aGUgd2lkZ2V0IHRpdGxlIHRvIHBvcHVsYXRlIHRoZSB0YWIgZm9yIGEgY2hpbGQgd2lkZ2V0LlxuICovXG52YXIgVGl0bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHRpdGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaXRsZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsID0gJyc7XG4gICAgICAgIHRoaXMuX2NhcHRpb24gPSAnJztcbiAgICAgICAgdGhpcy5fbW5lbW9uaWMgPSAtMTtcbiAgICAgICAgdGhpcy5faWNvbkNsYXNzID0gJyc7XG4gICAgICAgIHRoaXMuX2ljb25MYWJlbCA9ICcnO1xuICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSAnJztcbiAgICAgICAgdGhpcy5fY2xvc2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubW5lbW9uaWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbW5lbW9uaWMgPSBvcHRpb25zLm1uZW1vbmljO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmljb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaWNvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gLl9pY29uIGlzIG51bGwsIHRoZSAuaWNvbiBnZXR0ZXIgd2lsbCBhbGlhcyAuaWNvbkNsYXNzXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNsYXNzID0gb3B0aW9ucy5pY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX2ljb24gPSBvcHRpb25zLmljb247XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdW5zZXQsIGRlZmF1bHQgdG8gYWxpYXNpbmcgLmljb25DbGFzc1xuICAgICAgICAgICAgdGhpcy5faWNvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICBpZiAob3B0aW9ucy5pY29uQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5faWNvbkNsYXNzID0gb3B0aW9ucy5pY29uQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaWNvbkxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25MYWJlbCA9IG9wdGlvbnMuaWNvbkxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmljb25SZW5kZXJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uID0gb3B0aW9ucy5pY29uUmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXB0aW9uID0gb3B0aW9ucy5jYXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbG9zYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zYWJsZSA9IG9wdGlvbnMuY2xvc2FibGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YXNldCA9IG9wdGlvbnMuZGF0YXNldCB8fCB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGxlLnByb3RvdHlwZSwgXCJjaGFuZ2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHRpdGxlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0bGUucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGFiZWwgZm9yIHRoZSB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbGFiZWwgZm9yIHRoZSB0aXRsZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh1bmRlZmluZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0bGUucHJvdG90eXBlLCBcIm1uZW1vbmljXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbW5lbW9uaWMgaW5kZXggZm9yIHRoZSB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgLTFgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW5lbW9uaWM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1uZW1vbmljIGluZGV4IGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21uZW1vbmljID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21uZW1vbmljID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGxlLnByb3RvdHlwZSwgXCJpY29uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaWNvbiByZW5kZXJlciBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogREVQUkVDQVRFRDogaWYgc2V0IHRvIGEgc3RyaW5nIHZhbHVlLCB0aGUgLmljb24gZmllbGQgd2lsbCBmdW5jdGlvbiBhc1xuICAgICAgICAgKiBhbiBhbGlhcyBmb3IgdGhlIC5pY29uQ2xhc3MgZmllbGQsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9pY29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGlhcyAuaWNvbkNsYXNzIGlmIC5faWNvbiBoYXMgYmVlbiBleHBsaWNpdGx5IG51bGxlZFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmljb25DbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pY29uO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBpY29uIHJlbmRlcmVyIGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogQSByZW5kZXJlciBpcyBhbiBvYmplY3QgdGhhdCBzdXBwbGllcyBhIHJlbmRlciBhbmQgdW5yZW5kZXIgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIERFUFJFQ0FURUQ6IGlmIHNldCB0byBhIHN0cmluZyB2YWx1ZSwgdGhlIC5pY29uIGZpZWxkIHdpbGwgZnVuY3Rpb24gYXNcbiAgICAgICAgICogYW4gYWxpYXMgZm9yIHRoZSAuaWNvbkNsYXNzIGZpZWxkLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlIC8qIDwvREVQUkVDQVRFRD4gKi8pIHtcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gLl9pY29uIGlzIG51bGwsIHRoZSAuaWNvbiBnZXR0ZXIgd2lsbCBhbGlhcyAuaWNvbkNsYXNzXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faWNvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9pY29uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRsZS5wcm90b3R5cGUsIFwiaWNvbkNsYXNzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaWNvbiBjbGFzcyBuYW1lIGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWNvbkNsYXNzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBpY29uIGNsYXNzIG5hbWUgZm9yIHRoZSB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBNdWx0aXBsZSBjbGFzcyBuYW1lcyBjYW4gYmUgc2VwYXJhdGVkIHdpdGggd2hpdGVzcGFjZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWNvbkNsYXNzID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ljb25DbGFzcyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRsZS5wcm90b3R5cGUsIFwiaWNvbkxhYmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaWNvbiBsYWJlbCBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ljb25MYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgaWNvbiBsYWJlbCBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIE11bHRpcGxlIGNsYXNzIG5hbWVzIGNhbiBiZSBzZXBhcmF0ZWQgd2l0aCB3aGl0ZXNwYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pY29uTGFiZWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faWNvbkxhYmVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGxlLnByb3RvdHlwZSwgXCJpY29uUmVuZGVyZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBpY29uYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWNvbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGljb25gIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pY29uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRsZS5wcm90b3R5cGUsIFwiY2FwdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNhcHRpb24gZm9yIHRoZSB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjYXB0aW9uIGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhcHRpb24gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FwdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRsZS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZXh0cmEgY2xhc3MgbmFtZSBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgZXh0cmEgY2xhc3MgbmFtZSBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIE11bHRpcGxlIGNsYXNzIG5hbWVzIGNhbiBiZSBzZXBhcmF0ZWQgd2l0aCB3aGl0ZXNwYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGFzc05hbWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGxlLnByb3RvdHlwZSwgXCJjbG9zYWJsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNsb3NhYmxlIHN0YXRlIGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NhYmxlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjbG9zYWJsZSBzdGF0ZSBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgY29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgaWNvbiB3aGVuIGFwcGxpY2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NhYmxlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Nsb3NhYmxlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGxlLnByb3RvdHlwZSwgXCJkYXRhc2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZGF0YXNldCBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGFuIGVtcHR5IGRhdGFzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhc2V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBkYXRhc2V0IGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBjb250cm9scyB0aGUgZGF0YSBhdHRyaWJ1dGVzIHdoZW4gYXBwbGljYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGF0YXNldCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRhc2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRpdGxlO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBvZiB0aGUgbHVtaW5vIHdpZGdldCBoaWVyYXJjaHkuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhpcyBjbGFzcyB3aWxsIHR5cGljYWxseSBiZSBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIGNyZWF0ZSBhIHVzZWZ1bFxuICogd2lkZ2V0LiBIb3dldmVyLCBpdCBjYW4gYmUgdXNlZCBkaXJlY3RseSB0byBob3N0IGV4dGVybmFsbHkgY3JlYXRlZFxuICogY29udGVudC5cbiAqL1xudmFyIFdpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSB3aWRnZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV2lkZ2V0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZSA9IFByaXZhdGUuY3JlYXRlTm9kZShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnbG0tV2lkZ2V0Jyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdwLVdpZGdldCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHdpZGdldCBhbmQgaXRzIGRlc2NlbmRhbnQgd2lkZ2V0cy5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJdCBpcyB1bnNhZmUgdG8gdXNlIHRoZSB3aWRnZXQgYWZ0ZXIgaXQgaGFzIGJlZW4gZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgbWFkZSB0byB0aGlzIG1ldGhvZCBhZnRlciB0aGUgZmlyc3QgYXJlIGEgbm8tb3AuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB3aWRnZXQgaXMgYWxyZWFkeSBkaXNwb3NlZC5cbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgZGlzcG9zZWQgZmxhZyBhbmQgZW1pdCB0aGUgZGlzcG9zZWQgc2lnbmFsLlxuICAgICAgICB0aGlzLnNldEZsYWcoV2lkZ2V0LkZsYWcuSXNEaXNwb3NlZCk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgLy8gUmVtb3ZlIG9yIGRldGFjaCB0aGUgd2lkZ2V0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBXaWRnZXQuZGV0YWNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIHdpZGdldCBsYXlvdXQuXG4gICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSBleHRyYSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgd2lkZ2V0LlxuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgICAgICBNZXNzYWdlTG9vcC5jbGVhckRhdGEodGhpcyk7XG4gICAgICAgIEF0dGFjaGVkUHJvcGVydHkuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwiZGlzcG9zZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSB3aWRnZXQgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwiaXNEaXNwb3NlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIHdpZGdldCBoYXMgYmVlbiBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVzdEZsYWcoV2lkZ2V0LkZsYWcuSXNEaXNwb3NlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaWRnZXQucHJvdG90eXBlLCBcImlzQXR0YWNoZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSB3aWRnZXQncyBub2RlIGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlc3RGbGFnKFdpZGdldC5GbGFnLklzQXR0YWNoZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJpc0hpZGRlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIHdpZGdldCBpcyBleHBsaWNpdGx5IGhpZGRlbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVzdEZsYWcoV2lkZ2V0LkZsYWcuSXNIaWRkZW4pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJpc1Zpc2libGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSB3aWRnZXQgaXMgdmlzaWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBBIHdpZGdldCBpcyB2aXNpYmxlIHdoZW4gaXQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSwgaXMgbm90XG4gICAgICAgICAqIGV4cGxpY2l0bHkgaGlkZGVuLCBhbmQgaGFzIG5vIGV4cGxpY2l0bHkgaGlkZGVuIGFuY2VzdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVzdEZsYWcoV2lkZ2V0LkZsYWcuSXNWaXNpYmxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwidGl0bGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpdGxlIG9iamVjdCBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgdGl0bGUgb2JqZWN0IGlzIHVzZWQgYnkgc29tZSBjb250YWluZXIgd2lkZ2V0cyB3aGVuIGRpc3BsYXlpbmdcbiAgICAgICAgICogdGhlIHdpZGdldCBhbG9uZ3NpZGUgc29tZSB0aXRsZSwgc3VjaCBhcyBhIHRhYiBwYW5lbCBvciBzaWRlIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogU2luY2Ugbm90IGFsbCB3aWRnZXRzIHdpbGwgdXNlIHRoZSB0aXRsZSwgaXQgaXMgY3JlYXRlZCBvbiBkZW1hbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgb3duZXJgIHByb3BlcnR5IG9mIHRoZSB0aXRsZSBpcyBzZXQgdG8gdGhpcyB3aWRnZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcml2YXRlLnRpdGxlUHJvcGVydHkuZ2V0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSB3aWRnZXQncyBET00gbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgaWQgb2YgdGhlIHdpZGdldCdzIERPTSBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5pZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJkYXRhc2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhc2V0IGZvciB0aGUgd2lkZ2V0J3MgRE9NIG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZGF0YXNldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcGFyZW50IG9mIHRoZSB3aWRnZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHBhcmVudCBvZiB0aGUgd2lkZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIENoaWxkcmVuIGFyZSB0eXBpY2FsbHkgYWRkZWQgdG8gYSB3aWRnZXQgYnkgdXNpbmcgYSBsYXlvdXQsIHdoaWNoXG4gICAgICAgICAqIG1lYW5zIHVzZXIgY29kZSB3aWxsIG5vdCBub3JtYWxseSBzZXQgdGhlIHBhcmVudCB3aWRnZXQgZGlyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB3aWRnZXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSBpdHMgb2xkIHBhcmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZXJlIGlzIG5vIGVmZmVjdGl2ZSBwYXJlbnQgY2hhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY29udGFpbnModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmVudCB3aWRnZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICF0aGlzLl9wYXJlbnQuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBuZXcgV2lkZ2V0LkNoaWxkTWVzc2FnZSgnY2hpbGQtcmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHRoaXMuX3BhcmVudCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhdGhpcy5fcGFyZW50LmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbmV3IFdpZGdldC5DaGlsZE1lc3NhZ2UoJ2NoaWxkLWFkZGVkJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5fcGFyZW50LCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLCBXaWRnZXQuTXNnLlBhcmVudENoYW5nZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lkZ2V0LnByb3RvdHlwZSwgXCJsYXlvdXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXlvdXQgZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGxheW91dCBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgbGF5b3V0IGlzIHNpbmdsZS11c2Ugb25seS4gSXQgY2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAqIGZpcnN0IGFzc2lnbm1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBsYXlvdXQgaXMgZGlzcG9zZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSB3aWRnZXQgaXMgZGlzcG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xheW91dCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50ZXN0RmxhZyhXaWRnZXQuRmxhZy5EaXNhbGxvd0xheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgd2lkZ2V0IGxheW91dC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjaGFuZ2Ugd2lkZ2V0IGxheW91dC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgbGF5b3V0IHBhcmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IHZhbHVlO1xuICAgICAgICAgICAgdmFsdWUucGFyZW50ID0gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHdpZGdldCdzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igb3ZlciB0aGUgY2hpbGRyZW4gb2YgdGhlIHdpZGdldC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgd2lkZ2V0IG11c3QgaGF2ZSBhIHBvcHVsYXRlZCBsYXlvdXQgaW4gb3JkZXIgdG8gaGF2ZSBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIElmIGEgbGF5b3V0IGlzIG5vdCBpbnN0YWxsZWQsIHRoZSByZXR1cm5lZCBpdGVyYXRvciB3aWxsIGJlIGVtcHR5LlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQgPyB0aGlzLl9sYXlvdXQuaXRlcigpIDogZW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIHdpZGdldCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhpcyB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIGRlc2NlbmRhbnQgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB3aWRnZXQgaXMgYSBkZXNjZW5kYW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICBmb3IgKHZhciB2YWx1ZSA9IHdpZGdldDsgdmFsdWU7IHZhbHVlID0gdmFsdWUuX3BhcmVudCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoZSB3aWRnZXQncyBET00gbm9kZSBoYXMgdGhlIGdpdmVuIGNsYXNzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBjbGFzcyBuYW1lIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBub2RlIGhhcyB0aGUgY2xhc3MsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGNsYXNzIG5hbWUgdG8gdGhlIHdpZGdldCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgY2xhc3MgbmFtZSB0byBhZGQgdG8gdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIGNsYXNzIG5hbWUgaXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgbm9kZSwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAqXG4gICAgICogVGhlIGNsYXNzIG5hbWUgbXVzdCBub3QgY29udGFpbiB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNsYXNzIG5hbWUgZnJvbSB0aGUgd2lkZ2V0J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBjbGFzcyBuYW1lIHRvIHJlbW92ZSBmcm9tIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSBjbGFzcyBuYW1lIGlzIG5vdCB5ZXQgYWRkZWQgdG8gdGhlIG5vZGUsIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgKlxuICAgICAqIFRoZSBjbGFzcyBuYW1lIG11c3Qgbm90IGNvbnRhaW4gd2hpdGVzcGFjZS5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgYSBjbGFzcyBuYW1lIG9uIHRoZSB3aWRnZXQncyBET00gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIGNsYXNzIG5hbWUgdG8gdG9nZ2xlIG9uIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlIC0gV2hldGhlciB0byBmb3JjZSBhZGQgdGhlIGNsYXNzIChgdHJ1ZWApIG9yIGZvcmNlXG4gICAgICogICByZW1vdmUgdGhlIGNsYXNzIChgZmFsc2VgKS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgcHJlc2VuY2Ugb2ZcbiAgICAgKiAgIHRoZSBjbGFzcyB3aWxsIGJlIHRvZ2dsZWQgZnJvbSBpdHMgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY2xhc3MgaXMgbm93IHByZXNlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBjbGFzcyBuYW1lIG11c3Qgbm90IGNvbnRhaW4gd2hpdGVzcGFjZS5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKG5hbWUsIGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmNsYXNzTGlzdC50b2dnbGUobmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQb3N0IGFuIGAndXBkYXRlLXJlcXVlc3QnYCBtZXNzYWdlIHRvIHRoZSB3aWRnZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIHNpbXBsZSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIHBvc3RpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMsIFdpZGdldC5Nc2cuVXBkYXRlUmVxdWVzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQb3N0IGEgYCdmaXQtcmVxdWVzdCdgIG1lc3NhZ2UgdG8gdGhlIHdpZGdldC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgc2ltcGxlIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgcG9zdGluZyB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTWVzc2FnZUxvb3AucG9zdE1lc3NhZ2UodGhpcywgV2lkZ2V0Lk1zZy5GaXRSZXF1ZXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBvc3QgYW4gYCdhY3RpdmF0ZS1yZXF1ZXN0J2AgbWVzc2FnZSB0byB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgYSBzaW1wbGUgY29udmVuaWVuY2UgbWV0aG9kIGZvciBwb3N0aW5nIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMsIFdpZGdldC5Nc2cuQWN0aXZhdGVSZXF1ZXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBgJ2Nsb3NlLXJlcXVlc3QnYCBtZXNzYWdlIHRvIHRoZSB3aWRnZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIHNpbXBsZSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIHNlbmRpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcywgV2lkZ2V0Lk1zZy5DbG9zZVJlcXVlc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgd2lkZ2V0IGFuZCBtYWtlIGl0IHZpc2libGUgdG8gaXRzIHBhcmVudCB3aWRnZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBjYXVzZXMgdGhlIFtbaXNIaWRkZW5dXSBwcm9wZXJ0eSB0byBiZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgdGhlIHdpZGdldCBpcyBub3QgZXhwbGljaXRseSBoaWRkZW4sIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXN0RmxhZyhXaWRnZXQuRmxhZy5Jc0hpZGRlbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKSkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcywgV2lkZ2V0Lk1zZy5CZWZvcmVTaG93KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyRmxhZyhXaWRnZXQuRmxhZy5Jc0hpZGRlbik7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ2xtLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgJiYgKCF0aGlzLnBhcmVudCB8fCB0aGlzLnBhcmVudC5pc1Zpc2libGUpKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLCBXaWRnZXQuTXNnLkFmdGVyU2hvdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gbmV3IFdpZGdldC5DaGlsZE1lc3NhZ2UoJ2NoaWxkLXNob3duJywgdGhpcyk7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLnBhcmVudCwgbXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgd2lkZ2V0IGFuZCBtYWtlIGl0IGhpZGRlbiB0byBpdHMgcGFyZW50IHdpZGdldC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGNhdXNlcyB0aGUgW1tpc0hpZGRlbl1dIHByb3BlcnR5IHRvIGJlIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB3aWRnZXQgaXMgZXhwbGljaXRseSBoaWRkZW4sIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRlc3RGbGFnKFdpZGdldC5GbGFnLklzSGlkZGVuKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgJiYgKCF0aGlzLnBhcmVudCB8fCB0aGlzLnBhcmVudC5pc1Zpc2libGUpKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLCBXaWRnZXQuTXNnLkJlZm9yZUhpZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RmxhZyhXaWRnZXQuRmxhZy5Jc0hpZGRlbik7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2xtLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQgJiYgKCF0aGlzLnBhcmVudCB8fCB0aGlzLnBhcmVudC5pc1Zpc2libGUpKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLCBXaWRnZXQuTXNnLkFmdGVySGlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gbmV3IFdpZGdldC5DaGlsZE1lc3NhZ2UoJ2NoaWxkLWhpZGRlbicsIHRoaXMpO1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5wYXJlbnQsIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3cgb3IgaGlkZSB0aGUgd2lkZ2V0IGFjY29yZGluZyB0byBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGlkZGVuIC0gYHRydWVgIHRvIGhpZGUgdGhlIHdpZGdldCwgb3IgYGZhbHNlYCB0byBzaG93IGl0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGBoaWRlKClgIGFuZCBgc2hvdygpYC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLnNldEhpZGRlbiA9IGZ1bmN0aW9uIChoaWRkZW4pIHtcbiAgICAgICAgaWYgKGhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiB3aWRnZXQgZmxhZyBpcyBzZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIG5vdCB0eXBpY2FsbHkgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLnRlc3RGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGZsYWcpICE9PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBnaXZlbiB3aWRnZXQgZmxhZy5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHdpbGwgbm90IHR5cGljYWxseSBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgdXNlciBjb2RlLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUuc2V0RmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzIHw9IGZsYWc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgZ2l2ZW4gd2lkZ2V0IGZsYWcuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIG5vdCB0eXBpY2FsbHkgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLmNsZWFyRmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzICY9IH5mbGFnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIG1lc3NhZ2Ugc2VudCB0byB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHNlbnQgdG8gdGhlIHdpZGdldC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBTdWJjbGFzc2VzIG1heSByZWltcGxlbWVudCB0aGlzIG1ldGhvZCBhcyBuZWVkZWQuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncmVzaXplJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZS1yZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25VcGRhdGVSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaXQtcmVxdWVzdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMYXlvdXQobXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRml0UmVxdWVzdChtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlLXNob3cnOlxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGF5b3V0KG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkJlZm9yZVNob3cobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyLXNob3cnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmxhZyhXaWRnZXQuRmxhZy5Jc1Zpc2libGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGF5b3V0KG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFmdGVyU2hvdyhtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlLWhpZGUnOlxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGF5b3V0KG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUhpZGUobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyLWhpZGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGbGFnKFdpZGdldC5GbGFnLklzVmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMYXlvdXQobXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWZ0ZXJIaWRlKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWZvcmUtYXR0YWNoJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25CZWZvcmVBdHRhY2gobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyLWF0dGFjaCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZsYWcoV2lkZ2V0LkZsYWcuSXNWaXNpYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGbGFnKFdpZGdldC5GbGFnLklzQXR0YWNoZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGF5b3V0KG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFmdGVyQXR0YWNoKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWZvcmUtZGV0YWNoJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25CZWZvcmVEZXRhY2gobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyLWRldGFjaCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckZsYWcoV2lkZ2V0LkZsYWcuSXNWaXNpYmxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRmxhZyhXaWRnZXQuRmxhZy5Jc0F0dGFjaGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25BZnRlckRldGFjaChtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWN0aXZhdGUtcmVxdWVzdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMYXlvdXQobXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWN0aXZhdGVSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjbG9zZS1yZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZVJlcXVlc3QobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkLWFkZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGlsZEFkZGVkKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaGlsZC1yZW1vdmVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxheW91dChtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGlsZFJlbW92ZWQobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMYXlvdXQobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52b2tlIHRoZSBtZXNzYWdlIHByb2Nlc3Npbmcgcm91dGluZSBvZiB0aGUgd2lkZ2V0J3MgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHRvIGRpc3BhdGNoIHRvIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSB3aWRnZXQgZG9lcyBub3QgaGF2ZSBhIGxheW91dC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBub3QgdHlwaWNhbGx5IGJlIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5ub3RpZnlMYXlvdXQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5wcm9jZXNzUGFyZW50TWVzc2FnZShtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjbG9zZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB1bnBhcmVudHMgb3IgZGV0YWNoZXMgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLm9uQ2xvc2VSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIFdpZGdldC5kZXRhY2godGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ3Jlc2l6ZSdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIChtc2cpIHsgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAndXBkYXRlLXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaGFuZGxlciBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2ZpdC1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGhhbmRsZXIgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLm9uRml0UmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHsgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWN0aXZhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5vbkFjdGl2YXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHsgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtc2hvdydgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5vbkJlZm9yZVNob3cgPSBmdW5jdGlvbiAobXNnKSB7IH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FmdGVyLXNob3cnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaGFuZGxlciBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUub25BZnRlclNob3cgPSBmdW5jdGlvbiAobXNnKSB7IH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnYmVmb3JlLWhpZGUnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaGFuZGxlciBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUub25CZWZvcmVIaWRlID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhZnRlci1oaWRlJ2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGhhbmRsZXIgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLm9uQWZ0ZXJIaWRlID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1hdHRhY2gnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaGFuZGxlciBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUub25CZWZvcmVBdHRhY2ggPSBmdW5jdGlvbiAobXNnKSB7IH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5vbkFmdGVyQXR0YWNoID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaGFuZGxlciBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIFdpZGdldC5wcm90b3R5cGUub25CZWZvcmVEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7IH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FmdGVyLWRldGFjaCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5vbkFmdGVyRGV0YWNoID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2NoaWxkLWFkZGVkJ2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGhhbmRsZXIgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLm9uQ2hpbGRBZGRlZCA9IGZ1bmN0aW9uIChtc2cpIHsgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1yZW1vdmVkJ2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGhhbmRsZXIgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBXaWRnZXQucHJvdG90eXBlLm9uQ2hpbGRSZW1vdmVkID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIHJldHVybiBXaWRnZXQ7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYFdpZGdldGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChXaWRnZXQpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlbnVtIG9mIHdpZGdldCBiaXQgZmxhZ3MuXG4gICAgICovXG4gICAgdmFyIEZsYWc7XG4gICAgKGZ1bmN0aW9uIChGbGFnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkZ2V0IGhhcyBiZWVuIGRpc3Bvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgRmxhZ1tGbGFnW1wiSXNEaXNwb3NlZFwiXSA9IDFdID0gXCJJc0Rpc3Bvc2VkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkZ2V0IGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICAgICAqL1xuICAgICAgICBGbGFnW0ZsYWdbXCJJc0F0dGFjaGVkXCJdID0gMl0gPSBcIklzQXR0YWNoZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWRnZXQgaXMgaGlkZGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgRmxhZ1tGbGFnW1wiSXNIaWRkZW5cIl0gPSA0XSA9IFwiSXNIaWRkZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWRnZXQgaXMgdmlzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIEZsYWdbRmxhZ1tcIklzVmlzaWJsZVwiXSA9IDhdID0gXCJJc1Zpc2libGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGF5b3V0IGNhbm5vdCBiZSBzZXQgb24gdGhlIHdpZGdldC5cbiAgICAgICAgICovXG4gICAgICAgIEZsYWdbRmxhZ1tcIkRpc2FsbG93TGF5b3V0XCJdID0gMTZdID0gXCJEaXNhbGxvd0xheW91dFwiO1xuICAgIH0pKEZsYWcgPSBXaWRnZXQuRmxhZyB8fCAoV2lkZ2V0LkZsYWcgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBzdGF0ZWxlc3MgbWVzc2FnZXMgcmVsYXRlZCB0byB3aWRnZXRzLlxuICAgICAqL1xuICAgIHZhciBNc2c7XG4gICAgKGZ1bmN0aW9uIChNc2cpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGAnYmVmb3JlLXNob3cnYCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBpcyBzZW50IHRvIGEgd2lkZ2V0IGJlZm9yZSBpdCBiZWNvbWVzIHZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBpcyAqKm5vdCoqIHNlbnQgd2hlbiB0aGUgd2lkZ2V0IGlzIGJlaW5nIGF0dGFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgTXNnLkJlZm9yZVNob3cgPSBuZXcgTWVzc2FnZSgnYmVmb3JlLXNob3cnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGAnYWZ0ZXItc2hvdydgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzIHNlbnQgdG8gYSB3aWRnZXQgYWZ0ZXIgaXQgYmVjb21lcyB2aXNpYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1lc3NhZ2UgaXMgKipub3QqKiBzZW50IHdoZW4gdGhlIHdpZGdldCBpcyBiZWluZyBhdHRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIE1zZy5BZnRlclNob3cgPSBuZXcgTWVzc2FnZSgnYWZ0ZXItc2hvdycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaW5nbGV0b24gYCdiZWZvcmUtaGlkZSdgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzIHNlbnQgdG8gYSB3aWRnZXQgYmVmb3JlIGl0IGJlY29tZXMgbm90LXZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBpcyAqKm5vdCoqIHNlbnQgd2hlbiB0aGUgd2lkZ2V0IGlzIGJlaW5nIGRldGFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgTXNnLkJlZm9yZUhpZGUgPSBuZXcgTWVzc2FnZSgnYmVmb3JlLWhpZGUnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGAnYWZ0ZXItaGlkZSdgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzIHNlbnQgdG8gYSB3aWRnZXQgYWZ0ZXIgaXQgYmVjb21lcyBub3QtdmlzaWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzICoqbm90Kiogc2VudCB3aGVuIHRoZSB3aWRnZXQgaXMgYmVpbmcgZGV0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBNc2cuQWZ0ZXJIaWRlID0gbmV3IE1lc3NhZ2UoJ2FmdGVyLWhpZGUnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzIHNlbnQgdG8gYSB3aWRnZXQgYmVmb3JlIGl0IGlzIGF0dGFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgTXNnLkJlZm9yZUF0dGFjaCA9IG5ldyBNZXNzYWdlKCdiZWZvcmUtYXR0YWNoJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpbmdsZXRvbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzIHNlbnQgdG8gYSB3aWRnZXQgYWZ0ZXIgaXQgaXMgYXR0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBNc2cuQWZ0ZXJBdHRhY2ggPSBuZXcgTWVzc2FnZSgnYWZ0ZXItYXR0YWNoJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpbmdsZXRvbiBgJ2JlZm9yZS1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBpcyBzZW50IHRvIGEgd2lkZ2V0IGJlZm9yZSBpdCBpcyBkZXRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIE1zZy5CZWZvcmVEZXRhY2ggPSBuZXcgTWVzc2FnZSgnYmVmb3JlLWRldGFjaCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaW5nbGV0b24gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBpcyBzZW50IHRvIGEgd2lkZ2V0IGFmdGVyIGl0IGlzIGRldGFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgTXNnLkFmdGVyRGV0YWNoID0gbmV3IE1lc3NhZ2UoJ2FmdGVyLWRldGFjaCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaW5nbGV0b24gYCdwYXJlbnQtY2hhbmdlZCdgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIGlzIHNlbnQgdG8gYSB3aWRnZXQgd2hlbiBpdHMgcGFyZW50IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgTXNnLlBhcmVudENoYW5nZWQgPSBuZXcgTWVzc2FnZSgncGFyZW50LWNoYW5nZWQnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGNvbmZsYXRhYmxlIGAndXBkYXRlLXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBjYW4gYmUgZGlzcGF0Y2hlZCB0byBzdXBwb3J0aW5nIHdpZGdldHMgaW4gb3JkZXIgdG9cbiAgICAgICAgICogdXBkYXRlIHRoZWlyIGNvbnRlbnQgYmFzZWQgb24gdGhlIGN1cnJlbnQgd2lkZ2V0IHN0YXRlLiBOb3QgYWxsXG4gICAgICAgICAqIHdpZGdldHMgd2lsbCByZXNwb25kIHRvIG1lc3NhZ2VzIG9mIHRoaXMgdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHdpZGdldHMgd2l0aCBhIGxheW91dCwgdGhpcyBtZXNzYWdlIHdpbGwgaW5mb3JtIHRoZSBsYXlvdXQgdG9cbiAgICAgICAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBpdHMgY2hpbGQgd2lkZ2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIE1zZy5VcGRhdGVSZXF1ZXN0ID0gbmV3IENvbmZsYXRhYmxlTWVzc2FnZSgndXBkYXRlLXJlcXVlc3QnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGNvbmZsYXRhYmxlIGAnZml0LXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIEZvciB3aWRnZXRzIHdpdGggYSBsYXlvdXQsIHRoaXMgbWVzc2FnZSB3aWxsIGluZm9ybSB0aGUgbGF5b3V0IHRvXG4gICAgICAgICAqIHJlY2FsY3VsYXRlIGl0cyBzaXplIGNvbnN0cmFpbnRzIHRvIGZpdCB0aGUgc3BhY2UgcmVxdWlyZW1lbnRzIG9mXG4gICAgICAgICAqIGl0cyBjaGlsZCB3aWRnZXRzLCBhbmQgdG8gdXBkYXRlIHRoZWlyIHBvc2l0aW9uIGFuZCBzaXplLiBOb3QgYWxsXG4gICAgICAgICAqIGxheW91dHMgd2lsbCByZXNwb25kIHRvIG1lc3NhZ2VzIG9mIHRoaXMgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIE1zZy5GaXRSZXF1ZXN0ID0gbmV3IENvbmZsYXRhYmxlTWVzc2FnZSgnZml0LXJlcXVlc3QnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGNvbmZsYXRhYmxlIGAnYWN0aXZhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBtZXNzYWdlIHNob3VsZCBiZSBkaXNwYXRjaGVkIHRvIGEgd2lkZ2V0IHdoZW4gaXQgc2hvdWxkXG4gICAgICAgICAqIHBlcmZvcm0gdGhlIGFjdGlvbnMgbmVjZXNzYXJ5IHRvIGFjdGl2YXRlIHRoZSB3aWRnZXQsIHdoaWNoXG4gICAgICAgICAqIG1heSBpbmNsdWRlIGZvY3VzaW5nIGl0cyBub2RlIG9yIGRlc2NlbmRhbnQgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIE1zZy5BY3RpdmF0ZVJlcXVlc3QgPSBuZXcgQ29uZmxhdGFibGVNZXNzYWdlKCdhY3RpdmF0ZS1yZXF1ZXN0Jyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpbmdsZXRvbiBjb25mbGF0YWJsZSBgJ2Nsb3NlLXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgbWVzc2FnZSBzaG91bGQgYmUgZGlzcGF0Y2hlZCB0byBhIHdpZGdldCB3aGVuIGl0IHNob3VsZCBjbG9zZVxuICAgICAgICAgKiBhbmQgcmVtb3ZlIGl0c2VsZiBmcm9tIHRoZSB3aWRnZXQgaGllcmFyY2h5LlxuICAgICAgICAgKi9cbiAgICAgICAgTXNnLkNsb3NlUmVxdWVzdCA9IG5ldyBDb25mbGF0YWJsZU1lc3NhZ2UoJ2Nsb3NlLXJlcXVlc3QnKTtcbiAgICB9KShNc2cgPSBXaWRnZXQuTXNnIHx8IChXaWRnZXQuTXNnID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgY2xhc3MgZm9yIGNoaWxkIHJlbGF0ZWQgbWVzc2FnZXMuXG4gICAgICovXG4gICAgdmFyIENoaWxkTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENoaWxkTWVzc2FnZSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBjaGlsZCBtZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSBtZXNzYWdlIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjaGlsZCAtIFRoZSBjaGlsZCB3aWRnZXQgZm9yIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ2hpbGRNZXNzYWdlKHR5cGUsIGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hpbGRNZXNzYWdlO1xuICAgIH0oTWVzc2FnZSkpO1xuICAgIFdpZGdldC5DaGlsZE1lc3NhZ2UgPSBDaGlsZE1lc3NhZ2U7XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGNsYXNzIGZvciBgJ3Jlc2l6ZSdgIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHZhciBSZXNpemVNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVzaXplTWVzc2FnZSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyByZXNpemUgbWVzc2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIC0gVGhlICoqb2Zmc2V0IHdpZHRoKiogb2YgdGhlIHdpZGdldCwgb3IgYC0xYCBpZlxuICAgICAgICAgKiAgIHRoZSB3aWR0aCBpcyBub3Qga25vd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgKipvZmZzZXQgaGVpZ2h0Kiogb2YgdGhlIHdpZGdldCwgb3IgYC0xYCBpZlxuICAgICAgICAgKiAgIHRoZSBoZWlnaHQgaXMgbm90IGtub3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVzaXplTWVzc2FnZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAncmVzaXplJykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBfdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc2l6ZU1lc3NhZ2U7XG4gICAgfShNZXNzYWdlKSk7XG4gICAgV2lkZ2V0LlJlc2l6ZU1lc3NhZ2UgPSBSZXNpemVNZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgUmVzaXplTWVzc2FnZWAgY2xhc3Mgc3RhdGljcy5cbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKFJlc2l6ZU1lc3NhZ2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2luZ2xldG9uIGAncmVzaXplJ2AgbWVzc2FnZSB3aXRoIGFuIHVua25vd24gc2l6ZS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc2l6ZU1lc3NhZ2UuVW5rbm93blNpemUgPSBuZXcgUmVzaXplTWVzc2FnZSgtMSwgLTEpO1xuICAgIH0pKFJlc2l6ZU1lc3NhZ2UgPSBXaWRnZXQuUmVzaXplTWVzc2FnZSB8fCAoV2lkZ2V0LlJlc2l6ZU1lc3NhZ2UgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIHdpZGdldCB0byBhIGhvc3QgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBob3N0IC0gVGhlIERPTSBub2RlIHRvIHVzZSBhcyB0aGUgd2lkZ2V0J3MgaG9zdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWYgLSBUaGUgY2hpbGQgb2YgYGhvc3RgIHRvIHVzZSBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICogICBJZiB0aGlzIGlzIHByb3ZpZGVkLCB0aGUgd2lkZ2V0IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoaXNcbiAgICAgKiAgIG5vZGUgaW4gdGhlIGhvc3QuIFRoZSBkZWZhdWx0IGlzIGBudWxsYCwgd2hpY2ggd2lsbCBjYXVzZSB0aGVcbiAgICAgKiAgIHdpZGdldCB0byBiZSBhZGRlZCBhcyB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgaG9zdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHdpZGdldCBpcyBub3QgYSByb290IHdpZGdldCwgaWZcbiAgICAgKiB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgYXR0YWNoZWQsIG9yIGlmIHRoZSBob3N0IGlzIG5vdCBhdHRhY2hlZFxuICAgICAqIHRvIHRoZSBET00uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXR0YWNoKHdpZGdldCwgaG9zdCwgcmVmKSB7XG4gICAgICAgIGlmIChyZWYgPT09IHZvaWQgMCkgeyByZWYgPSBudWxsOyB9XG4gICAgICAgIGlmICh3aWRnZXQucGFyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhdHRhY2ggYSBjaGlsZCB3aWRnZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldC5pc0F0dGFjaGVkIHx8IGRvY3VtZW50LmJvZHkuY29udGFpbnMod2lkZ2V0Lm5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpZGdldCBpcyBhbHJlYWR5IGF0dGFjaGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhob3N0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3N0IGlzIG5vdCBhdHRhY2hlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQmVmb3JlQXR0YWNoKTtcbiAgICAgICAgaG9zdC5pbnNlcnRCZWZvcmUod2lkZ2V0Lm5vZGUsIHJlZik7XG4gICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckF0dGFjaCk7XG4gICAgfVxuICAgIFdpZGdldC5hdHRhY2ggPSBhdHRhY2g7XG4gICAgLyoqXG4gICAgICogRGV0YWNoIHRoZSB3aWRnZXQgZnJvbSBpdHMgaG9zdCBET00gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgd2lkZ2V0IGlzIG5vdCBhIHJvb3Qgd2lkZ2V0LFxuICAgICAqIG9yIGlmIHRoZSB3aWRnZXQgaXMgbm90IGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV0YWNoKHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0LnBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0YWNoIGEgY2hpbGQgd2lkZ2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2lkZ2V0LmlzQXR0YWNoZWQgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMod2lkZ2V0Lm5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpZGdldCBpcyBub3QgYXR0YWNoZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkJlZm9yZURldGFjaCk7XG4gICAgICAgIHdpZGdldC5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQWZ0ZXJEZXRhY2gpO1xuICAgIH1cbiAgICBXaWRnZXQuZGV0YWNoID0gZGV0YWNoO1xufSkoV2lkZ2V0IHx8IChXaWRnZXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQW4gYXR0YWNoZWQgcHJvcGVydHkgZm9yIHRoZSB3aWRnZXQgdGl0bGUgb2JqZWN0LlxuICAgICAqL1xuICAgIFByaXZhdGUudGl0bGVQcm9wZXJ0eSA9IG5ldyBBdHRhY2hlZFByb3BlcnR5KHtcbiAgICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAob3duZXIpIHsgcmV0dXJuIG5ldyBUaXRsZSh7IG93bmVyOiBvd25lciB9KTsgfSxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBET00gbm9kZSBmb3IgdGhlIGdpdmVuIHdpZGdldCBvcHRpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5ub2RlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob3B0aW9ucy50YWcgfHwgJ2RpdicpO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xufSkoUHJpdmF0ZSB8fCAoUHJpdmF0ZSA9IHt9KSk7XG5cbi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLyoqXG4gKiBBbiBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjcmVhdGluZyBsdW1pbm8gbGF5b3V0cy5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBBIGxheW91dCBpcyB1c2VkIHRvIGFkZCB3aWRnZXRzIHRvIGEgcGFyZW50IGFuZCB0byBhcnJhbmdlIHRob3NlXG4gKiB3aWRnZXRzIHdpdGhpbiB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gKlxuICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgd2hpY2ggaXMgcmVxdWlyZWQgb2ZcbiAqIG5lYXJseSBhbGwgbGF5b3V0cy4gSXQgbXVzdCBiZSBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIGJlIHVzZWZ1bC5cbiAqXG4gKiBOb3RhYmx5LCB0aGlzIGNsYXNzIGRvZXMgbm90IGRlZmluZSBhIHVuaWZvcm0gaW50ZXJmYWNlIGZvciBhZGRpbmdcbiAqIHdpZGdldHMgdG8gdGhlIGxheW91dC4gQSBzdWJjbGFzcyBzaG91bGQgZGVmaW5lIHRoYXQgQVBJIGluIGEgd2F5XG4gKiB3aGljaCBpcyBtZWFuaW5nZnVsIGZvciBpdHMgaW50ZW5kZWQgdXNlLlxuICovXG52YXIgTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIGxheW91dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXRQb2xpY3kgPSBvcHRpb25zLmZpdFBvbGljeSB8fCAnc2V0LW1pbi1zaXplJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHNob3VsZCBiZSByZWltcGxlbWVudGVkIHRvIGNsZWFyIGFuZCBkaXNwb3NlIG9mIHRoZSB3aWRnZXRzLlxuICAgICAqXG4gICAgICogQWxsIHJlaW1wbGVtZW50YXRpb25zIHNob3VsZCBjYWxsIHRoZSBzdXBlcmNsYXNzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHBhcmVudCBpcyBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBMYXlvdXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgU2lnbmFsLmNsZWFyRGF0YSh0aGlzKTtcbiAgICAgICAgQXR0YWNoZWRQcm9wZXJ0eS5jbGVhckRhdGEodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0LnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgbGF5b3V0IGlzIGRpc3Bvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXQucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBhcmVudCB3aWRnZXQgb2YgdGhlIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcGFyZW50IHdpZGdldCBvZiB0aGUgbGF5b3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgc2V0IGF1dG9tYXRpY2FsbHkgd2hlbiBpbnN0YWxsaW5nIHRoZSBsYXlvdXQgb24gdGhlIHBhcmVudFxuICAgICAgICAgKiB3aWRnZXQuIFRoZSBwYXJlbnQgd2lkZ2V0IHNob3VsZCBub3QgYmUgc2V0IGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgcGFyZW50IHdpZGdldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXlvdXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyZW50IHdpZGdldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXQucHJvdG90eXBlLCBcImZpdFBvbGljeVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZpdCBwb2xpY3kgZm9yIHRoZSBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIGZpdCBwb2xpY3kgY29udHJvbHMgdGhlIGNvbXB1dGVkIHNpemUgY29uc3RyYWludHMgd2hpY2ggYXJlXG4gICAgICAgICAqIGFwcGxpZWQgdG8gdGhlIHBhcmVudCB3aWRnZXQgYnkgdGhlIGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBsYXlvdXQgaW1wbGVtZW50YXRpb25zIG1heSBpZ25vcmUgdGhlIGZpdCBwb2xpY3kuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXRQb2xpY3k7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGZpdCBwb2xpY3kgZm9yIHRoZSBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIGZpdCBwb2xpY3kgY29udHJvbHMgdGhlIGNvbXB1dGVkIHNpemUgY29uc3RyYWludHMgd2hpY2ggYXJlXG4gICAgICAgICAqIGFwcGxpZWQgdG8gdGhlIHBhcmVudCB3aWRnZXQgYnkgdGhlIGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBsYXlvdXQgaW1wbGVtZW50YXRpb25zIG1heSBpZ25vcmUgdGhlIGZpdCBwb2xpY3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIENoYW5naW5nIHRoZSBmaXQgcG9saWN5IHdpbGwgY2xlYXIgdGhlIGN1cnJlbnQgc2l6ZSBjb25zdHJhaW50XG4gICAgICAgICAqIGZvciB0aGUgcGFyZW50IHdpZGdldCBhbmQgdGhlbiByZS1maXQgdGhlIHBhcmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSBwb2xpY3kgZG9lcyBub3QgY2hhbmdlXG4gICAgICAgICAgICBpZiAodGhpcy5fZml0UG9saWN5ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgcG9saWN5LlxuICAgICAgICAgICAgdGhpcy5fZml0UG9saWN5ID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgc2l6ZSBjb25zdHJhaW50cyBhbmQgc2NoZWR1bGUgYSBmaXQgb2YgdGhlIHBhcmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9wYXJlbnQubm9kZS5zdHlsZTtcbiAgICAgICAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9ICcnO1xuICAgICAgICAgICAgICAgIHN0eWxlLm1pbkhlaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIHN0eWxlLm1heFdpZHRoID0gJyc7XG4gICAgICAgICAgICAgICAgc3R5bGUubWF4SGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LmZpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgbWVzc2FnZSBzZW50IHRvIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlIHNlbnQgdG8gdGhlIHBhcmVudCB3aWRnZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgd2lkZ2V0IHRvIHByb2Nlc3MgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyBtYXkgcmVpbXBsZW1lbnQgdGhpcyBtZXRob2QgYXMgbmVlZGVkLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUucHJvY2Vzc1BhcmVudE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZShtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlLXJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHRoaXMub25VcGRhdGVSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaXQtcmVxdWVzdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZpdFJlcXVlc3QobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZS1zaG93JzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQmVmb3JlU2hvdyhtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWZ0ZXItc2hvdyc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFmdGVyU2hvdyhtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlLWhpZGUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25CZWZvcmVIaWRlKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZnRlci1oaWRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWZ0ZXJIaWRlKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWZvcmUtYXR0YWNoJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQmVmb3JlQXR0YWNoKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZnRlci1hdHRhY2gnOlxuICAgICAgICAgICAgICAgIHRoaXMub25BZnRlckF0dGFjaChtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlLWRldGFjaCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkJlZm9yZURldGFjaChtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWZ0ZXItZGV0YWNoJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWZ0ZXJEZXRhY2gobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkLXJlbW92ZWQnOlxuICAgICAgICAgICAgICAgIHRoaXMub25DaGlsZFJlbW92ZWQobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkLXNob3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hpbGRTaG93bihtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2hpbGQtaGlkZGVuJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hpbGRIaWRkZW4obXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBsYXlvdXQgaW5pdGlhbGl6YXRpb24gd2hpY2ggcmVxdWlyZXMgdGhlIHBhcmVudCB3aWRnZXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGF5b3V0IGlzIGluc3RhbGxlZFxuICAgICAqIG9uIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVwYXJlbnRzIGFsbCBvZiB0aGUgd2lkZ2V0cyB0byB0aGVcbiAgICAgKiBsYXlvdXQgcGFyZW50IHdpZGdldC5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIHJlaW1wbGVtZW50IHRoaXMgbWV0aG9kIGFuZCBhdHRhY2ggdGhlIGNoaWxkXG4gICAgICogd2lkZ2V0IG5vZGVzIHRvIHRoZSBwYXJlbnQgd2lkZ2V0J3Mgbm9kZS5cbiAgICAgKi9cbiAgICBMYXlvdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgd2lkZ2V0LnBhcmVudCA9IF90aGlzLnBhcmVudDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdyZXNpemUnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBsYXlvdXQgc2hvdWxkIGVuc3VyZSB0aGF0IGl0cyB3aWRnZXRzIGFyZSByZXNpemVkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgbGF5b3V0IHNwYWNlLCBhbmQgdGhhdCB0aGV5IGFyZSBzZW50IGEgYCdyZXNpemUnYFxuICAgICAqIG1lc3NhZ2UgaWYgYXBwcm9wcmlhdGUuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBzZW5kcyBhbiBgVW5rbm93blNpemVgXG4gICAgICogcmVzaXplIG1lc3NhZ2UgdG8gYWxsIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSByZWltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMgYXMgbmVlZGVkLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuUmVzaXplTWVzc2FnZS5Vbmtub3duU2l6ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ3VwZGF0ZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgbGF5b3V0IHNob3VsZCBlbnN1cmUgdGhhdCBpdHMgd2lkZ2V0cyBhcmUgcmVzaXplZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgYXZhaWxhYmxlIGxheW91dCBzcGFjZSwgYW5kIHRoYXQgdGhleSBhcmUgc2VudCBhIGAncmVzaXplJ2BcbiAgICAgKiBtZXNzYWdlIGlmIGFwcHJvcHJpYXRlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2Qgc2VuZHMgYW4gYFVua25vd25TaXplYFxuICAgICAqIHJlc2l6ZSBtZXNzYWdlIHRvIGFsbCB3aWRnZXRzLlxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgcmVpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIGFzIG5lZWRlZC5cbiAgICAgKi9cbiAgICBMYXlvdXQucHJvdG90eXBlLm9uVXBkYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZWFjaCh0aGlzLCBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5SZXNpemVNZXNzYWdlLlVua25vd25TaXplKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBmb3J3YXJkcyB0aGUgbWVzc2FnZVxuICAgICAqIHRvIGFsbCB3aWRnZXRzLiBJdCBhc3N1bWVzIGFsbCB3aWRnZXQgbm9kZXMgYXJlIGF0dGFjaGVkIHRvIHRoZVxuICAgICAqIHBhcmVudCB3aWRnZXQgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWF5IGJlIHJlaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhcyBuZWVkZWQuXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZWFjaCh0aGlzLCBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZm9yd2FyZHMgdGhlIG1lc3NhZ2VcbiAgICAgKiB0byBhbGwgd2lkZ2V0cy4gSXQgYXNzdW1lcyBhbGwgd2lkZ2V0IG5vZGVzIGFyZSBhdHRhY2hlZCB0byB0aGVcbiAgICAgKiBwYXJlbnQgd2lkZ2V0IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSByZWltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMgYXMgbmVlZGVkLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUub25BZnRlckF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZWFjaCh0aGlzLCBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnYmVmb3JlLWRldGFjaCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZm9yd2FyZHMgdGhlIG1lc3NhZ2VcbiAgICAgKiB0byBhbGwgd2lkZ2V0cy4gSXQgYXNzdW1lcyBhbGwgd2lkZ2V0IG5vZGVzIGFyZSBhdHRhY2hlZCB0byB0aGVcbiAgICAgKiBwYXJlbnQgd2lkZ2V0IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSByZWltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMgYXMgbmVlZGVkLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUub25CZWZvcmVEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBtc2cpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGZvcndhcmRzIHRoZSBtZXNzYWdlXG4gICAgICogdG8gYWxsIHdpZGdldHMuIEl0IGFzc3VtZXMgYWxsIHdpZGdldCBub2RlcyBhcmUgYXR0YWNoZWQgdG8gdGhlXG4gICAgICogcGFyZW50IHdpZGdldCBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgcmVpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIGFzIG5lZWRlZC5cbiAgICAgKi9cbiAgICBMYXlvdXQucHJvdG90eXBlLm9uQWZ0ZXJEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBtc2cpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1zaG93J2AgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBmb3J3YXJkcyB0aGUgbWVzc2FnZSB0b1xuICAgICAqIGFsbCBub24taGlkZGVuIHdpZGdldHMuIEl0IGFzc3VtZXMgYWxsIHdpZGdldCBub2RlcyBhcmUgYXR0YWNoZWRcbiAgICAgKiB0byB0aGUgcGFyZW50IHdpZGdldCBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgcmVpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIGFzIG5lZWRlZC5cbiAgICAgKi9cbiAgICBMYXlvdXQucHJvdG90eXBlLm9uQmVmb3JlU2hvdyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZWFjaCh0aGlzLCBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBpZiAoIXdpZGdldC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWZ0ZXItc2hvdydgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZm9yd2FyZHMgdGhlIG1lc3NhZ2UgdG9cbiAgICAgKiBhbGwgbm9uLWhpZGRlbiB3aWRnZXRzLiBJdCBhc3N1bWVzIGFsbCB3aWRnZXQgbm9kZXMgYXJlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIHBhcmVudCB3aWRnZXQgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWF5IGJlIHJlaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhcyBuZWVkZWQuXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5vbkFmdGVyU2hvdyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgZWFjaCh0aGlzLCBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBpZiAoIXdpZGdldC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtaGlkZSdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgZm9yd2FyZHMgdGhlIG1lc3NhZ2UgdG9cbiAgICAgKiBhbGwgbm9uLWhpZGRlbiB3aWRnZXRzLiBJdCBhc3N1bWVzIGFsbCB3aWRnZXQgbm9kZXMgYXJlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIHBhcmVudCB3aWRnZXQgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWF5IGJlIHJlaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyBhcyBuZWVkZWQuXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZUhpZGUgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKCF3aWRnZXQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FmdGVyLWhpZGUnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGZvcndhcmRzIHRoZSBtZXNzYWdlIHRvXG4gICAgICogYWxsIG5vbi1oaWRkZW4gd2lkZ2V0cy4gSXQgYXNzdW1lcyBhbGwgd2lkZ2V0IG5vZGVzIGFyZSBhdHRhY2hlZFxuICAgICAqIHRvIHRoZSBwYXJlbnQgd2lkZ2V0IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSByZWltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMgYXMgbmVlZGVkLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUub25BZnRlckhpZGUgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKCF3aWRnZXQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtcmVtb3ZlZCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSB0aGUgY2hpbGQgd2lkZ2V0IGZyb20gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkICoqbm90KiogdHlwaWNhbGx5IHJlaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUub25DaGlsZFJlbW92ZWQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0KG1zZy5jaGlsZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdmaXQtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5vbkZpdFJlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7IH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtc2hvd24nYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgaGFuZGxlciBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIExheW91dC5wcm90b3R5cGUub25DaGlsZFNob3duID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2NoaWxkLWhpZGRlbidgIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBoYW5kbGVyIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5vbkNoaWxkSGlkZGVuID0gZnVuY3Rpb24gKG1zZykgeyB9O1xuICAgIHJldHVybiBMYXlvdXQ7XG59KCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYExheW91dGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChMYXlvdXQpIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhvcml6b250YWwgYWxpZ25tZW50IGZvciBhIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGhvcml6b250YWwgYWxpZ25tZW50IGZvciB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSBsYXlvdXQgd2lkdGggYWxsb2NhdGVkIHRvIGEgd2lkZ2V0IGlzIGxhcmdlciB0aGFuIGl0cyBtYXhcbiAgICAgKiB3aWR0aCwgdGhlIGhvcml6b250YWwgYWxpZ25tZW50IGNvbnRyb2xzIGhvdyB0aGUgd2lkZ2V0IGlzIHBsYWNlZFxuICAgICAqIHdpdGhpbiB0aGUgZXh0cmEgaG9yaXpvbnRhbCBzcGFjZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBhbGxvY2F0ZWQgd2lkdGggaXMgbGVzcyB0aGFuIHRoZSB3aWRnZXQncyBtYXggd2lkdGgsIHRoZVxuICAgICAqIGhvcml6b250YWwgYWxpZ25tZW50IGhhcyBubyBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBTb21lIGxheW91dCBpbXBsZW1lbnRhdGlvbnMgbWF5IGlnbm9yZSBob3Jpem9udGFsIGFsaWdubWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb3Jpem9udGFsQWxpZ25tZW50KHdpZGdldCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZSQxLmhvcml6b250YWxBbGlnbm1lbnRQcm9wZXJ0eS5nZXQod2lkZ2V0KTtcbiAgICB9XG4gICAgTGF5b3V0LmdldEhvcml6b250YWxBbGlnbm1lbnQgPSBnZXRIb3Jpem9udGFsQWxpZ25tZW50O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgZm9yIGEgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgZm9yIHRoZSBob3Jpem9udGFsIGFsaWdubWVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiB0aGUgbGF5b3V0IHdpZHRoIGFsbG9jYXRlZCB0byBhIHdpZGdldCBpcyBsYXJnZXIgdGhhbiBpdHMgbWF4XG4gICAgICogd2lkdGgsIHRoZSBob3Jpem9udGFsIGFsaWdubWVudCBjb250cm9scyBob3cgdGhlIHdpZGdldCBpcyBwbGFjZWRcbiAgICAgKiB3aXRoaW4gdGhlIGV4dHJhIGhvcml6b250YWwgc3BhY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYWxsb2NhdGVkIHdpZHRoIGlzIGxlc3MgdGhhbiB0aGUgd2lkZ2V0J3MgbWF4IHdpZHRoLCB0aGVcbiAgICAgKiBob3Jpem9udGFsIGFsaWdubWVudCBoYXMgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogU29tZSBsYXlvdXQgaW1wbGVtZW50YXRpb25zIG1heSBpZ25vcmUgaG9yaXpvbnRhbCBhbGlnbm1lbnQuXG4gICAgICpcbiAgICAgKiBDaGFuZ2luZyB0aGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgd2lsbCBwb3N0IGFuIGB1cGRhdGUtcmVxdWVzdGBcbiAgICAgKiBtZXNzYWdlIHRvIHdpZGdldCdzIHBhcmVudCwgcHJvdmlkZWQgdGhlIHBhcmVudCBoYXMgYSBsYXlvdXRcbiAgICAgKiBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0SG9yaXpvbnRhbEFsaWdubWVudCh3aWRnZXQsIHZhbHVlKSB7XG4gICAgICAgIFByaXZhdGUkMS5ob3Jpem9udGFsQWxpZ25tZW50UHJvcGVydHkuc2V0KHdpZGdldCwgdmFsdWUpO1xuICAgIH1cbiAgICBMYXlvdXQuc2V0SG9yaXpvbnRhbEFsaWdubWVudCA9IHNldEhvcml6b250YWxBbGlnbm1lbnQ7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgZm9yIGEgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVydGljYWwgYWxpZ25tZW50IGZvciB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSBsYXlvdXQgaGVpZ2h0IGFsbG9jYXRlZCB0byBhIHdpZGdldCBpcyBsYXJnZXIgdGhhbiBpdHMgbWF4XG4gICAgICogaGVpZ2h0LCB0aGUgdmVydGljYWwgYWxpZ25tZW50IGNvbnRyb2xzIGhvdyB0aGUgd2lkZ2V0IGlzIHBsYWNlZFxuICAgICAqIHdpdGhpbiB0aGUgZXh0cmEgdmVydGljYWwgc3BhY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYWxsb2NhdGVkIGhlaWdodCBpcyBsZXNzIHRoYW4gdGhlIHdpZGdldCdzIG1heCBoZWlnaHQsIHRoZVxuICAgICAqIHZlcnRpY2FsIGFsaWdubWVudCBoYXMgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogU29tZSBsYXlvdXQgaW1wbGVtZW50YXRpb25zIG1heSBpZ25vcmUgdmVydGljYWwgYWxpZ25tZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZlcnRpY2FsQWxpZ25tZW50KHdpZGdldCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZSQxLnZlcnRpY2FsQWxpZ25tZW50UHJvcGVydHkuZ2V0KHdpZGdldCk7XG4gICAgfVxuICAgIExheW91dC5nZXRWZXJ0aWNhbEFsaWdubWVudCA9IGdldFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmVydGljYWwgYWxpZ25tZW50IGZvciBhIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciB0aGUgdmVydGljYWwgYWxpZ25tZW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSBsYXlvdXQgaGVpZ2h0IGFsbG9jYXRlZCB0byBhIHdpZGdldCBpcyBsYXJnZXIgdGhhbiBpdHMgbWF4XG4gICAgICogaGVpZ2h0LCB0aGUgdmVydGljYWwgYWxpZ25tZW50IGNvbnRyb2xzIGhvdyB0aGUgd2lkZ2V0IGlzIHBsYWNlZFxuICAgICAqIHdpdGhpbiB0aGUgZXh0cmEgdmVydGljYWwgc3BhY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYWxsb2NhdGVkIGhlaWdodCBpcyBsZXNzIHRoYW4gdGhlIHdpZGdldCdzIG1heCBoZWlnaHQsIHRoZVxuICAgICAqIHZlcnRpY2FsIGFsaWdubWVudCBoYXMgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogU29tZSBsYXlvdXQgaW1wbGVtZW50YXRpb25zIG1heSBpZ25vcmUgdmVydGljYWwgYWxpZ25tZW50LlxuICAgICAqXG4gICAgICogQ2hhbmdpbmcgdGhlIGhvcml6b250YWwgYWxpZ25tZW50IHdpbGwgcG9zdCBhbiBgdXBkYXRlLXJlcXVlc3RgXG4gICAgICogbWVzc2FnZSB0byB3aWRnZXQncyBwYXJlbnQsIHByb3ZpZGVkIHRoZSBwYXJlbnQgaGFzIGEgbGF5b3V0XG4gICAgICogaW5zdGFsbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFZlcnRpY2FsQWxpZ25tZW50KHdpZGdldCwgdmFsdWUpIHtcbiAgICAgICAgUHJpdmF0ZSQxLnZlcnRpY2FsQWxpZ25tZW50UHJvcGVydHkuc2V0KHdpZGdldCwgdmFsdWUpO1xuICAgIH1cbiAgICBMYXlvdXQuc2V0VmVydGljYWxBbGlnbm1lbnQgPSBzZXRWZXJ0aWNhbEFsaWdubWVudDtcbn0pKExheW91dCB8fCAoTGF5b3V0ID0ge30pKTtcbi8qKlxuICogQW4gb2JqZWN0IHdoaWNoIGFzc2lzdHMgaW4gdGhlIGFic29sdXRlIGxheW91dCBvZiB3aWRnZXRzLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZnVsIHdoZW4gaW1wbGVtZW50aW5nIGEgbGF5b3V0IHdoaWNoIGFycmFuZ2VzIGl0c1xuICogd2lkZ2V0cyB1c2luZyBhYnNvbHV0ZSBwb3NpdGlvbmluZy5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgYnkgbmVhcmx5IGFsbCBvZiB0aGUgYnVpbHQtaW4gbHVtaW5vIGxheW91dHMuXG4gKi9cbnZhciBMYXlvdXRJdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBsYXlvdXQgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGJlIG1hbmFnZWQgYnkgdGhlIGl0ZW0uXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIHdpZGdldCB3aWxsIGJlIHNldCB0byBhYnNvbHV0ZSBwb3NpdGlvbmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXlvdXRJdGVtKHdpZGdldCkge1xuICAgICAgICB0aGlzLl90b3AgPSBOYU47XG4gICAgICAgIHRoaXMuX2xlZnQgPSBOYU47XG4gICAgICAgIHRoaXMuX3dpZHRoID0gTmFOO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBOYU47XG4gICAgICAgIHRoaXMuX21pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fbWluSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5fbWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldC5ub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgdGhlIGxheW91dCBpdGVtLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgd2lsbCByZXNldCB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBMYXlvdXRJdGVtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBpdGVtIGlzIGFscmVhZHkgZGlzcG9zZWQuXG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhlIGl0ZW0gYXMgZGlzcG9zZWQuXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHdpZGdldCBzdHlsZS5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy53aWRnZXQubm9kZS5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgc3R5bGUudG9wID0gJyc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0SXRlbS5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXB1dGVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHdpZGdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHZhbHVlIGNhbiBiZSB1cGRhdGVkIGJ5IGNhbGxpbmcgdGhlIGBmaXRgIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbldpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0SXRlbS5wcm90b3R5cGUsIFwibWluSGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wdXRlZCBtaW5pbXVtIGhlaWdodCBvZiB0aGUgd2lkZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgdmFsdWUgY2FuIGJlIHVwZGF0ZWQgYnkgY2FsbGluZyB0aGUgYGZpdGAgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWluSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0SXRlbS5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXB1dGVkIG1heGltdW0gd2lkdGggb2YgdGhlIHdpZGdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHZhbHVlIGNhbiBiZSB1cGRhdGVkIGJ5IGNhbGxpbmcgdGhlIGBmaXRgIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0SXRlbS5wcm90b3R5cGUsIFwibWF4SGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wdXRlZCBtYXhpbXVtIGhlaWdodCBvZiB0aGUgd2lkZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgdmFsdWUgY2FuIGJlIHVwZGF0ZWQgYnkgY2FsbGluZyB0aGUgYGZpdGAgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4SGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0SXRlbS5wcm90b3R5cGUsIFwiaXNEaXNwb3NlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBsYXlvdXQgaXRlbSBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0SXRlbS5wcm90b3R5cGUsIFwiaXNIaWRkZW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbWFuYWdlZCB3aWRnZXQgaXMgaGlkZGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQuaXNIaWRkZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRJdGVtLnByb3RvdHlwZSwgXCJpc1Zpc2libGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbWFuYWdlZCB3aWRnZXQgaXMgdmlzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LmlzVmlzaWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dEl0ZW0ucHJvdG90eXBlLCBcImlzQXR0YWNoZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbWFuYWdlZCB3aWRnZXQgaXMgYXR0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZGdldC5pc0F0dGFjaGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNvbXB1dGVkIHNpemUgbGltaXRzIG9mIHRoZSBtYW5hZ2VkIHdpZGdldC5cbiAgICAgKi9cbiAgICBMYXlvdXRJdGVtLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW1pdHMgPSBFbGVtZW50RXh0LnNpemVMaW1pdHModGhpcy53aWRnZXQubm9kZSk7XG4gICAgICAgIHRoaXMuX21pbldpZHRoID0gbGltaXRzLm1pbldpZHRoO1xuICAgICAgICB0aGlzLl9taW5IZWlnaHQgPSBsaW1pdHMubWluSGVpZ2h0O1xuICAgICAgICB0aGlzLl9tYXhXaWR0aCA9IGxpbWl0cy5tYXhXaWR0aDtcbiAgICAgICAgdGhpcy5fbWF4SGVpZ2h0ID0gbGltaXRzLm1heEhlaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIG1hbmFnZWQgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlZnQgLSBUaGUgbGVmdCBlZGdlIHBvc2l0aW9uIG9mIHRoZSBsYXlvdXQgYm94LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvcCAtIFRoZSB0b3AgZWRnZSBwb3NpdGlvbiBvZiB0aGUgbGF5b3V0IGJveC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbGF5b3V0IGJveC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBsYXlvdXQgYm94LlxuICAgICAqL1xuICAgIExheW91dEl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gQ2xhbXAgdGhlIHNpemUgdG8gdGhlIGNvbXB1dGVkIHNpemUgbGltaXRzLlxuICAgICAgICB2YXIgY2xhbXBXID0gTWF0aC5tYXgodGhpcy5fbWluV2lkdGgsIE1hdGgubWluKHdpZHRoLCB0aGlzLl9tYXhXaWR0aCkpO1xuICAgICAgICB2YXIgY2xhbXBIID0gTWF0aC5tYXgodGhpcy5fbWluSGVpZ2h0LCBNYXRoLm1pbihoZWlnaHQsIHRoaXMuX21heEhlaWdodCkpO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGxlZnQgZWRnZSBmb3IgdGhlIGhvcml6b250YWwgYWxpZ25tZW50LCBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjbGFtcFcgPCB3aWR0aCkge1xuICAgICAgICAgICAgc3dpdGNoIChMYXlvdXQuZ2V0SG9yaXpvbnRhbEFsaWdubWVudCh0aGlzLndpZGdldCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgbGVmdCArPSAod2lkdGggLSBjbGFtcFcpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IHdpZHRoIC0gY2xhbXBXO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkanVzdCB0aGUgdG9wIGVkZ2UgZm9yIHRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQsIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKGNsYW1wSCA8IGhlaWdodCkge1xuICAgICAgICAgICAgc3dpdGNoIChMYXlvdXQuZ2V0VmVydGljYWxBbGlnbm1lbnQodGhpcy53aWRnZXQpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdG9wICs9IChoZWlnaHQgLSBjbGFtcEgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgdG9wICs9IGhlaWdodCAtIGNsYW1wSDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdXAgdGhlIHJlc2l6ZSB2YXJpYWJsZXMuXG4gICAgICAgIHZhciByZXNpemVkID0gZmFsc2U7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMud2lkZ2V0Lm5vZGUuc3R5bGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIHdpZGdldCBpZiBuZWVkZWQuXG4gICAgICAgIGlmICh0aGlzLl90b3AgIT09IHRvcCkge1xuICAgICAgICAgICAgdGhpcy5fdG9wID0gdG9wO1xuICAgICAgICAgICAgc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB3aWRnZXQgaWYgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fbGVmdCAhPT0gbGVmdCkge1xuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdpZHRoIG9mIHRoZSB3aWRnZXQgaWYgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5fd2lkdGggIT09IGNsYW1wVykge1xuICAgICAgICAgICAgcmVzaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IGNsYW1wVztcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gY2xhbXBXICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSB3aWRnZXQgaWYgbmVlZGVkLlxuICAgICAgICBpZiAodGhpcy5faGVpZ2h0ICE9PSBjbGFtcEgpIHtcbiAgICAgICAgICAgIHJlc2l6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gY2xhbXBIO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY2xhbXBIICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgYSByZXNpemUgbWVzc2FnZSB0byB0aGUgd2lkZ2V0IGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKHJlc2l6ZWQpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBuZXcgV2lkZ2V0LlJlc2l6ZU1lc3NhZ2UoY2xhbXBXLCBjbGFtcEgpO1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy53aWRnZXQsIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXRJdGVtO1xufSgpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSQxO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGF0dGFjaGVkIHByb3BlcnR5IGZvciBhIHdpZGdldCBob3Jpem9udGFsIGFsaWdubWVudC5cbiAgICAgKi9cbiAgICBQcml2YXRlLmhvcml6b250YWxBbGlnbm1lbnRQcm9wZXJ0eSA9IG5ldyBBdHRhY2hlZFByb3BlcnR5KHtcbiAgICAgICAgbmFtZTogJ2hvcml6b250YWxBbGlnbm1lbnQnLFxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdjZW50ZXInOyB9LFxuICAgICAgICBjaGFuZ2VkOiBvbkFsaWdubWVudENoYW5nZWRcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgYXR0YWNoZWQgcHJvcGVydHkgZm9yIGEgd2lkZ2V0IHZlcnRpY2FsIGFsaWdubWVudC5cbiAgICAgKi9cbiAgICBQcml2YXRlLnZlcnRpY2FsQWxpZ25tZW50UHJvcGVydHkgPSBuZXcgQXR0YWNoZWRQcm9wZXJ0eSh7XG4gICAgICAgIG5hbWU6ICd2ZXJ0aWNhbEFsaWdubWVudCcsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ3RvcCc7IH0sXG4gICAgICAgIGNoYW5nZWQ6IG9uQWxpZ25tZW50Q2hhbmdlZFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGFuZ2UgaGFuZGxlciBmb3IgdGhlIGF0dGFjaGVkIGFsaWdubWVudCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQWxpZ25tZW50Q2hhbmdlZChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50ICYmIGNoaWxkLnBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pKFByaXZhdGUkMSB8fCAoUHJpdmF0ZSQxID0ge30pKTtcblxuLyoqXG4gKiBBIGNvbmNyZXRlIGxheW91dCBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgbWFueSB1c2UgY2FzZXMuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhpcyBjbGFzcyBpcyBzdWl0YWJsZSBhcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBhIHZhcmlldHkgb2ZcbiAqIGxheW91dHMsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIGRpcmVjdGx5IHdpdGggc3RhbmRhcmQgQ1NTIHRvIGxheW91dCBhXG4gKiBjb2xsZWN0aW9uIG9mIHdpZGdldHMuXG4gKi9cbnZhciBQYW5lbExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWxMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFuZWxMYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fd2lkZ2V0cyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIGNsZWFyIGFuZCBkaXNwb3NlIGFsbCB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBBbGwgcmVpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGNhbGwgdGhlIHN1cGVyY2xhc3MgbWV0aG9kLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcGFyZW50IGlzIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIFBhbmVsTGF5b3V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fd2lkZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl93aWRnZXRzLnBvcCgpLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYW5lbExheW91dC5wcm90b3R5cGUsIFwid2lkZ2V0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlYWQtb25seSBhcnJheSBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkZ2V0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHdpZGdldHMgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIG92ZXIgdGhlIHdpZGdldHMgaW4gdGhlIGxheW91dC5cbiAgICAgKi9cbiAgICBQYW5lbExheW91dC5wcm90b3R5cGUuaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXIodGhpcy5fd2lkZ2V0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB3aWRnZXQgdG8gdGhlIGVuZCBvZiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYWRkIHRvIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHdpZGdldCBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgbGF5b3V0LCBpdCB3aWxsIGJlIG1vdmVkLlxuICAgICAqL1xuICAgIFBhbmVsTGF5b3V0LnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0V2lkZ2V0KHRoaXMuX3dpZGdldHMubGVuZ3RoLCB3aWRnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgd2lkZ2V0IGludG8gdGhlIGxheW91dCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gaW5zZXJ0IGludG8gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgaW5kZXggd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSBib3VuZHMgb2YgdGhlIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgYWRkZWQgdG8gdGhlIGxheW91dCwgaXQgd2lsbCBiZSBtb3ZlZC5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICovXG4gICAgUGFuZWxMYXlvdXQucHJvdG90eXBlLmluc2VydFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCwgd2lkZ2V0KSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50LiBUaGlzIGlzIGEgbm8tb3BcbiAgICAgICAgLy8gaWYgdGhlIHdpZGdldCdzIHBhcmVudCBpcyBhbHJlYWR5IHRoZSBsYXlvdXQgcGFyZW50IHdpZGdldC5cbiAgICAgICAgd2lkZ2V0LnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAvLyBMb29rIHVwIHRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSB3aWRnZXQuXG4gICAgICAgIHZhciBpID0gdGhpcy5fd2lkZ2V0cy5pbmRleE9mKHdpZGdldCk7XG4gICAgICAgIC8vIENsYW1wIHRoZSBpbnNlcnQgaW5kZXggdG8gdGhlIGFycmF5IGJvdW5kcy5cbiAgICAgICAgdmFyIGogPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5fd2lkZ2V0cy5sZW5ndGgpKTtcbiAgICAgICAgLy8gSWYgdGhlIHdpZGdldCBpcyBub3QgaW4gdGhlIGFycmF5LCBpbnNlcnQgaXQuXG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSB3aWRnZXQgaW50byB0aGUgYXJyYXkuXG4gICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQodGhpcy5fd2lkZ2V0cywgaiwgd2lkZ2V0KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXlvdXQgaXMgcGFyZW50ZWQsIGF0dGFjaCB0aGUgd2lkZ2V0IHRvIHRoZSBET00uXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFdpZGdldChqLCB3aWRnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm90aGluZyBtb3JlIHRvIGRvLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHdpZGdldCBleGlzdHMgaW4gdGhlIGFycmF5IGFuZCBzaG91bGQgYmUgbW92ZWQuXG4gICAgICAgIC8vIEFkanVzdCB0aGUgaW5kZXggaWYgdGhlIGxvY2F0aW9uIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICBpZiAoaiA9PT0gdGhpcy5fd2lkZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGVmZmVjdGl2ZSBtb3ZlLlxuICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgdGhlIHdpZGdldCB0byB0aGUgbmV3IGxvY2F0aW9uLlxuICAgICAgICBBcnJheUV4dC5tb3ZlKHRoaXMuX3dpZGdldHMsIGksIGopO1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGlzIHBhcmVudGVkLCBtb3ZlIHRoZSB3aWRnZXQgaW4gdGhlIERPTS5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVXaWRnZXQoaSwgaiwgd2lkZ2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgd2lkZ2V0IGZyb20gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogQSB3aWRnZXQgaXMgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIGxheW91dCB3aGVuIGl0cyBgcGFyZW50YFxuICAgICAqIGlzIHNldCB0byBgbnVsbGAuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGludm9rZWQgZGlyZWN0bHkgd2hlblxuICAgICAqIHJlbW92aW5nIGEgd2lkZ2V0IGZyb20gYSBsYXlvdXQgd2hpY2ggaGFzIHlldCB0byBiZSBpbnN0YWxsZWQgb24gYVxuICAgICAqIHBhcmVudCB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkb2VzICpub3QqIG1vZGlmeSB0aGUgd2lkZ2V0J3MgYHBhcmVudGAuXG4gICAgICovXG4gICAgUGFuZWxMYXlvdXQucHJvdG90eXBlLnJlbW92ZVdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVXaWRnZXRBdCh0aGlzLl93aWRnZXRzLmluZGV4T2Yod2lkZ2V0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHdpZGdldCBhdCBhIGdpdmVuIGluZGV4IGZyb20gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgd2lkZ2V0IHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBBIHdpZGdldCBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgbGF5b3V0IHdoZW4gaXRzIGBwYXJlbnRgXG4gICAgICogaXMgc2V0IHRvIGBudWxsYC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCBkaXJlY3RseSB3aGVuXG4gICAgICogcmVtb3ZpbmcgYSB3aWRnZXQgZnJvbSBhIGxheW91dCB3aGljaCBoYXMgeWV0IHRvIGJlIGluc3RhbGxlZCBvbiBhXG4gICAgICogcGFyZW50IHdpZGdldC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgKm5vdCogbW9kaWZ5IHRoZSB3aWRnZXQncyBgcGFyZW50YC5cbiAgICAgKlxuICAgICAqICMjIyMgVW5kZWZpbmVkIEJlaGF2aW9yXG4gICAgICogQW4gYGluZGV4YCB3aGljaCBpcyBub24taW50ZWdyYWwuXG4gICAgICovXG4gICAgUGFuZWxMYXlvdXQucHJvdG90eXBlLnJlbW92ZVdpZGdldEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gdGhlIGFycmF5LlxuICAgICAgICB2YXIgd2lkZ2V0ID0gQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5fd2lkZ2V0cywgaW5kZXgpO1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGlzIHBhcmVudGVkLCBkZXRhY2ggdGhlIHdpZGdldCBmcm9tIHRoZSBET00uXG4gICAgICAgIGlmICh3aWRnZXQgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoV2lkZ2V0KGluZGV4LCB3aWRnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGxheW91dCBpbml0aWFsaXphdGlvbiB3aGljaCByZXF1aXJlcyB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgKi9cbiAgICBQYW5lbExheW91dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCwgaW5kZXgpIHtcbiAgICAgICAgICAgIF90aGlzLmF0dGFjaFdpZGdldChpbmRleCwgd2lkZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSB3aWRnZXQgdG8gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYXR0YWNoIHRvIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHBhbmVsIGxheW91dCBhdCB0aGVcbiAgICAgKiBhcHByb3ByaWF0ZSB0aW1lLiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBhZGRzIHRoZSB3aWRnZXRzJ3Mgbm9kZSB0byB0aGUgcGFyZW50J3NcbiAgICAgKiBub2RlIGF0IHRoZSBwcm9wZXIgbG9jYXRpb24sIGFuZCBzZW5kcyB0aGUgYXBwcm9wcmlhdGUgYXR0YWNoXG4gICAgICogbWVzc2FnZXMgdG8gdGhlIHdpZGdldCBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIG1heSByZWltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBjb250cm9sIGhvdyB0aGUgd2lkZ2V0J3NcbiAgICAgKiBub2RlIGlzIGFkZGVkIHRvIHRoZSBwYXJlbnQncyBub2RlLlxuICAgICAqL1xuICAgIFBhbmVsTGF5b3V0LnByb3RvdHlwZS5hdHRhY2hXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHdpZGdldCkge1xuICAgICAgICAvLyBMb29rIHVwIHRoZSBuZXh0IHNpYmxpbmcgcmVmZXJlbmNlIG5vZGUuXG4gICAgICAgIHZhciByZWYgPSB0aGlzLnBhcmVudC5ub2RlLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVBdHRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCB0aGUgd2lkZ2V0J3Mgbm9kZSBiZWZvcmUgdGhlIHNpYmxpbmcuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuaW5zZXJ0QmVmb3JlKHdpZGdldC5ub2RlLCByZWYpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItYXR0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyQXR0YWNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSBhIHdpZGdldCBpbiB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUluZGV4IC0gVGhlIHByZXZpb3VzIGluZGV4IG9mIHRoZSB3aWRnZXQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b0luZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gbW92ZSBpbiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBwYW5lbCBsYXlvdXQgYXQgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgdGltZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgdXNlciBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gbW92ZXMgdGhlIHdpZGdldCdzIG5vZGUgdG8gdGhlIHByb3BlclxuICAgICAqIGxvY2F0aW9uIGluIHRoZSBwYXJlbnQncyBub2RlIGFuZCBzZW5kcyB0aGUgYXBwcm9wcmlhdGUgYXR0YWNoIGFuZFxuICAgICAqIGRldGFjaCBtZXNzYWdlcyB0byB0aGUgd2lkZ2V0IGlmIHRoZSBwYXJlbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgbWF5IHJlaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGNvbnRyb2wgaG93IHRoZSB3aWRnZXQnc1xuICAgICAqIG5vZGUgaXMgbW92ZWQgaW4gdGhlIHBhcmVudCdzIG5vZGUuXG4gICAgICovXG4gICAgUGFuZWxMYXlvdXQucHJvdG90eXBlLm1vdmVXaWRnZXQgPSBmdW5jdGlvbiAoZnJvbUluZGV4LCB0b0luZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgYW5kICBtZXNzYWdlIGlmIHRoZSBwYXJlbnQgaXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQWZ0ZXJEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIG5leHQgc2libGluZyByZWZlcmVuY2Ugbm9kZS5cbiAgICAgICAgdmFyIHJlZiA9IHRoaXMucGFyZW50Lm5vZGUuY2hpbGRyZW5bdG9JbmRleF07XG4gICAgICAgIC8vIFNlbmQgYSBgJ2JlZm9yZS1hdHRhY2gnYCBtZXNzYWdlIGlmIHRoZSBwYXJlbnQgaXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQmVmb3JlQXR0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnNlcnQgdGhlIHdpZGdldCdzIG5vZGUgYmVmb3JlIHRoZSBzaWJsaW5nLlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmluc2VydEJlZm9yZSh3aWRnZXQubm9kZSwgcmVmKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckF0dGFjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCBhIHdpZGdldCBmcm9tIHRoZSBwYXJlbnQncyBET00gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBwcmV2aW91cyBpbmRleCBvZiB0aGUgd2lkZ2V0IGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBkZXRhY2ggZnJvbSB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBwYW5lbCBsYXlvdXQgYXQgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgdGltZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgdXNlciBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVtb3ZlcyB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZVxuICAgICAqIHBhcmVudCdzIG5vZGUsIGFuZCBzZW5kcyB0aGUgYXBwcm9wcmlhdGUgZGV0YWNoIG1lc3NhZ2VzIHRvIHRoZVxuICAgICAqIHdpZGdldCBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIG1heSByZWltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBjb250cm9sIGhvdyB0aGUgd2lkZ2V0J3NcbiAgICAgKiBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50J3Mgbm9kZS5cbiAgICAgKi9cbiAgICBQYW5lbExheW91dC5wcm90b3R5cGUuZGV0YWNoV2lkZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyRGV0YWNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhbmVsTGF5b3V0O1xufShMYXlvdXQpKTtcblxudmFyIFV0aWxzO1xuKGZ1bmN0aW9uIChVdGlscykge1xuICAgIC8qKlxuICAgICAqIENsYW1wIGEgZGltZW5zaW9uIHZhbHVlIHRvIGFuIGludGVnZXIgPj0gMC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcERpbWVuc2lvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICAgIH1cbiAgICBVdGlscy5jbGFtcERpbWVuc2lvbiA9IGNsYW1wRGltZW5zaW9uO1xufSkoVXRpbHMgfHwgKFV0aWxzID0ge30pKTtcbnZhciBVdGlscyQxID0gVXRpbHM7XG5cbi8qKlxuICogQSBsYXlvdXQgd2hpY2ggYXJyYW5nZXMgaXRzIHdpZGdldHMgaW50byByZXNpemFibGUgc2VjdGlvbnMuXG4gKi9cbnZhciBTcGxpdExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3BsaXRMYXlvdXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHNwbGl0IGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNwbGl0TGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMud2lkZ2V0T2Zmc2V0ID0gMDtcbiAgICAgICAgX3RoaXMuX2ZpeGVkID0gMDtcbiAgICAgICAgX3RoaXMuX3NwYWNpbmcgPSA0O1xuICAgICAgICBfdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2hhc05vcm1lZFNpemVzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9zaXplcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIF90aGlzLl9oYW5kbGVzID0gW107XG4gICAgICAgIF90aGlzLl9ib3ggPSBudWxsO1xuICAgICAgICBfdGhpcy5fYWxpZ25tZW50ID0gJ3N0YXJ0JztcbiAgICAgICAgX3RoaXMuX29yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICBfdGhpcy5yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXI7XG4gICAgICAgIGlmIChvcHRpb25zLm9yaWVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLl9vcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLl9hbGlnbm1lbnQgPSBvcHRpb25zLmFsaWdubWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zcGFjaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzLl9zcGFjaW5nID0gVXRpbHMuY2xhbXBEaW1lbnNpb24ob3B0aW9ucy5zcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIGxheW91dCBpdGVtcy5cbiAgICAgICAgZWFjaCh0aGlzLl9pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGxheW91dCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fYm94ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2hhbmRsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgcmVzdCBvZiB0aGUgbGF5b3V0LlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGxpdExheW91dC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXlvdXQgb3JpZW50YXRpb24gZm9yIHRoZSBzcGxpdCBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbGF5b3V0IG9yaWVudGF0aW9uIGZvciB0aGUgc3BsaXQgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRhdGFzZXRbJ29yaWVudGF0aW9uJ10gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BsaXRMYXlvdXQucHJvdG90eXBlLCBcImFsaWdubWVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRlbnQgYWxpZ25tZW50IGZvciB0aGUgc3BsaXQgbGF5b3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFsaWdubWVudCBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFsaWdubWVudCBoYXMgbm8gZWZmZWN0IGlmIHRoZSB3aWRnZXRzIGNhbiBleHBhbmQgIHRvIGZpbGwgdGhlXG4gICAgICAgICAqIGVudGlyZSBzcGxpdCBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGlnbm1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbnRlbnQgYWxpZ25tZW50IGZvciB0aGUgc3BsaXQgbGF5b3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFsaWdubWVudCBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFsaWdubWVudCBoYXMgbm8gZWZmZWN0IGlmIHRoZSB3aWRnZXRzIGNhbiBleHBhbmQgIHRvIGZpbGwgdGhlXG4gICAgICAgICAqIGVudGlyZSBzcGxpdCBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsaWdubWVudCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hbGlnbm1lbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5kYXRhc2V0WydhbGlnbm1lbnQnXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGxpdExheW91dC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGludGVyLWVsZW1lbnQgc3BhY2luZyBmb3IgdGhlIHNwbGl0IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NwYWNpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGludGVyLWVsZW1lbnQgc3BhY2luZyBmb3IgdGhlIHNwbGl0IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFV0aWxzLmNsYW1wRGltZW5zaW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGFjaW5nID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NwYWNpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwbGl0TGF5b3V0LnByb3RvdHlwZSwgXCJoYW5kbGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVhZC1vbmx5IGFycmF5IG9mIHRoZSBzcGxpdCBoYW5kbGVzIGluIHRoZSBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlbGF0aXZlIHNpemVzIG9mIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBhcnJheSBvZiB0aGUgcmVsYXRpdmUgc2l6ZXMgb2YgdGhlIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIHJldHVybmVkIHNpemVzIHJlZmxlY3QgdGhlIHNpemVzIG9mIHRoZSB3aWRnZXRzIG5vcm1hbGl6ZWRcbiAgICAgKiByZWxhdGl2ZSB0byB0aGVpciBzaWJsaW5ncy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kICoqZG9lcyBub3QqKiBtZWFzdXJlIHRoZSBET00gbm9kZXMuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLnJlbGF0aXZlU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlJDIubm9ybWFsaXplKHRoaXMuX3NpemVycy5tYXAoZnVuY3Rpb24gKHNpemVyKSB7IHJldHVybiBzaXplci5zaXplOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlbGF0aXZlIHNpemVzIGZvciB0aGUgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpemVzIC0gVGhlIHJlbGF0aXZlIHNpemVzIGZvciB0aGUgd2lkZ2V0cyBpbiB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogRXh0cmEgdmFsdWVzIGFyZSBpZ25vcmVkLCB0b28gZmV3IHdpbGwgeWllbGQgYW4gdW5kZWZpbmVkIGxheW91dC5cbiAgICAgKlxuICAgICAqIFRoZSBhY3R1YWwgZ2VvbWV0cnkgb2YgdGhlIERPTSBub2RlcyBpcyB1cGRhdGVkIGFzeW5jaHJvbm91c2x5LlxuICAgICAqL1xuICAgIFNwbGl0TGF5b3V0LnByb3RvdHlwZS5zZXRSZWxhdGl2ZVNpemVzID0gZnVuY3Rpb24gKHNpemVzKSB7XG4gICAgICAgIC8vIENvcHkgdGhlIHNpemVzIGFuZCBwYWQgd2l0aCB6ZXJvcyBhcyBuZWVkZWQuXG4gICAgICAgIHZhciBuID0gdGhpcy5fc2l6ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRlbXAgPSBzaXplcy5zbGljZSgwLCBuKTtcbiAgICAgICAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbikge1xuICAgICAgICAgICAgdGVtcC5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGFkZGVkIHNpemVzLlxuICAgICAgICB2YXIgbm9ybWVkID0gUHJpdmF0ZSQyLm5vcm1hbGl6ZSh0ZW1wKTtcbiAgICAgICAgLy8gQXBwbHkgdGhlIG5vcm1hbGl6ZWQgc2l6ZXMgdG8gdGhlIHNpemVycy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzaXplciA9IHRoaXMuX3NpemVyc1tpXTtcbiAgICAgICAgICAgIHNpemVyLnNpemVIaW50ID0gbm9ybWVkW2ldO1xuICAgICAgICAgICAgc2l6ZXIuc2l6ZSA9IG5vcm1lZFtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGZsYWcgaW5kaWNhdGluZyB0aGUgc2l6ZXMgYXJlIG5vcm1hbGl6ZWQuXG4gICAgICAgIHRoaXMuX2hhc05vcm1lZFNpemVzID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIHBhcmVudCB3aWRnZXQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIG9mZnNldCBwb3NpdGlvbiBvZiBhIHNwbGl0IGhhbmRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgaGFuZGxlIG9mIHRoZSBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSBkZXNpcmVkIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0IHBhcmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBtb3ZlIHRoZSBoYW5kbGUgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIGRlc2lyZWRcbiAgICAgKiBwb3NpdGlvbi4gVGhlIHNpYmxpbmcgd2lkZ2V0cyB3aWxsIGJlIGFkanVzdGVkIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBTcGxpdExheW91dC5wcm90b3R5cGUubW92ZUhhbmRsZSA9IGZ1bmN0aW9uIChpbmRleCwgcG9zaXRpb24pIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgaW5kZXggaXMgaW52YWxpZCBvciB0aGUgaGFuZGxlIGlzIGhpZGRlbi5cbiAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZXNbaW5kZXhdO1xuICAgICAgICBpZiAoIWhhbmRsZSB8fCBoYW5kbGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdsbS1tb2QtaGlkZGVuJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZXNpcmVkIGRlbHRhIG1vdmVtZW50IGZvciB0aGUgaGFuZGxlLlxuICAgICAgICB2YXIgZGVsdGE7XG4gICAgICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBkZWx0YSA9IHBvc2l0aW9uIC0gaGFuZGxlLm9mZnNldExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHBvc2l0aW9uIC0gaGFuZGxlLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGhhbmRsZSBtb3ZlbWVudC5cbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCB3aWRnZXQgcmVzaXppbmcgdW5sZXNzIG5lZWRlZC5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3NpemVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzaXplciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChzaXplci5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHNpemVyLnNpemVIaW50ID0gc2l6ZXIuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIHNpemVycyB0byByZWZsZWN0IHRoZSBoYW5kbGUgbW92ZW1lbnQuXG4gICAgICAgIEJveEVuZ2luZS5hZGp1c3QodGhpcy5fc2l6ZXJzLCBpbmRleCwgZGVsdGEpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgd2lkZ2V0cy5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBsYXlvdXQgaW5pdGlhbGl6YXRpb24gd2hpY2ggcmVxdWlyZXMgdGhlIHBhcmVudCB3aWRnZXQuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmRhdGFzZXRbJ29yaWVudGF0aW9uJ10gPSB0aGlzLm9yaWVudGF0aW9uO1xuICAgICAgICB0aGlzLnBhcmVudC5kYXRhc2V0WydhbGlnbm1lbnQnXSA9IHRoaXMuYWxpZ25tZW50O1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIHdpZGdldCB0byB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgd2lkZ2V0IGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBhdHRhY2ggdG8gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLmF0dGFjaFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCwgd2lkZ2V0KSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaXRlbSwgaGFuZGxlLCBhbmQgc2l6ZXIgZm9yIHRoZSBuZXcgd2lkZ2V0LlxuICAgICAgICB2YXIgaXRlbSA9IG5ldyBMYXlvdXRJdGVtKHdpZGdldCk7XG4gICAgICAgIHZhciBoYW5kbGUgPSBQcml2YXRlJDIuY3JlYXRlSGFuZGxlKHRoaXMucmVuZGVyZXIpO1xuICAgICAgICB2YXIgYXZlcmFnZSA9IFByaXZhdGUkMi5hdmVyYWdlU2l6ZSh0aGlzLl9zaXplcnMpO1xuICAgICAgICB2YXIgc2l6ZXIgPSBQcml2YXRlJDIuY3JlYXRlU2l6ZXIoYXZlcmFnZSk7XG4gICAgICAgIC8vIEluc2VydCB0aGUgaXRlbSwgaGFuZGxlLCBhbmQgc2l6ZXIgaW50byB0aGUgaW50ZXJuYWwgYXJyYXlzLlxuICAgICAgICBBcnJheUV4dC5pbnNlcnQodGhpcy5faXRlbXMsIGluZGV4LCBpdGVtKTtcbiAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX3NpemVycywgaW5kZXgsIHNpemVyKTtcbiAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX2hhbmRsZXMsIGluZGV4LCBoYW5kbGUpO1xuICAgICAgICAvLyBTZW5kIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkJlZm9yZUF0dGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB3aWRnZXQgYW5kIGhhbmRsZSBub2RlcyB0byB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHdpZGdldC5ub2RlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5hcHBlbmRDaGlsZChoYW5kbGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItYXR0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyQXR0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgYSB3aWRnZXQgaW4gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21JbmRleCAtIFRoZSBwcmV2aW91cyBpbmRleCBvZiB0aGUgd2lkZ2V0IGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9JbmRleCAtIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSB3aWRnZXQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIG1vdmUgaW4gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLm1vdmVXaWRnZXQgPSBmdW5jdGlvbiAoZnJvbUluZGV4LCB0b0luZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgaXRlbSwgc2l6ZXIsIGFuZCBoYW5kbGUgZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIEFycmF5RXh0Lm1vdmUodGhpcy5faXRlbXMsIGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgICAgIEFycmF5RXh0Lm1vdmUodGhpcy5fc2l6ZXJzLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgICBBcnJheUV4dC5tb3ZlKHRoaXMuX2hhbmRsZXMsIGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgICAgIC8vIFBvc3QgYSBmaXQgcmVxdWVzdCB0byB0aGUgcGFyZW50IHRvIHNob3cvaGlkZSBsYXN0IGhhbmRsZS5cbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSB3aWRnZXQgZnJvbSB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gZGV0YWNoIGZyb20gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLmRldGFjaFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCwgd2lkZ2V0KSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbSwgaGFuZGxlLCBhbmQgc2l6ZXIgZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIHZhciBpdGVtID0gQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5faXRlbXMsIGluZGV4KTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IEFycmF5RXh0LnJlbW92ZUF0KHRoaXMuX2hhbmRsZXMsIGluZGV4KTtcbiAgICAgICAgQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5fc2l6ZXJzLCBpbmRleCk7XG4gICAgICAgIC8vIFNlbmQgYSBgJ2JlZm9yZS1kZXRhY2gnYCBtZXNzYWdlIGlmIHRoZSBwYXJlbnQgaXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQmVmb3JlRGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHdpZGdldCBhbmQgaGFuZGxlIG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5yZW1vdmVDaGlsZCh3aWRnZXQubm9kZSk7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQoaGFuZGxlKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgbGF5b3V0IGl0ZW0uXG4gICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1zaG93J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTcGxpdExheW91dC5wcm90b3R5cGUub25CZWZvcmVTaG93ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uQmVmb3JlU2hvdy5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1zaG93bidgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRTaG93biA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1oaWRkZW4nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFNwbGl0TGF5b3V0LnByb3RvdHlwZS5vbkNoaWxkSGlkZGVuID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ3Jlc2l6ZSdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3BsaXRMYXlvdXQucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUobXNnLndpZHRoLCBtc2cuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ3VwZGF0ZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTcGxpdExheW91dC5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoLTEsIC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnZml0LXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFNwbGl0TGF5b3V0LnByb3RvdHlwZS5vbkZpdFJlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBpdGVtIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgSXRlbSBpbmRleFxuICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgV2hldGhlciB0aGUgbGF5b3V0IGlzIGhvcml6b250YWwgb3Igbm90XG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gdG9wIFRvcCBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IEl0ZW0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHdpZHRoIEl0ZW0gd2lkdGhcbiAgICAgKiBAcGFyYW0gc2l6ZSBJdGVtIHNpemVcbiAgICAgKi9cbiAgICBTcGxpdExheW91dC5wcm90b3R5cGUudXBkYXRlSXRlbVBvc2l0aW9uID0gZnVuY3Rpb24gKGksIGlzSG9yaXpvbnRhbCwgbGVmdCwgdG9wLCBoZWlnaHQsIHdpZHRoLCBzaXplKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHN0eWxlIGZvciB0aGUgaGFuZGxlLlxuICAgICAgICB2YXIgaGFuZGxlU3R5bGUgPSB0aGlzLl9oYW5kbGVzW2ldLnN0eWxlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHdpZGdldCBhbmQgaGFuZGxlLCBhbmQgYWR2YW5jZSB0aGUgcmVsZXZhbnQgZWRnZS5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgbGVmdCArPSB0aGlzLndpZGdldE9mZnNldDtcbiAgICAgICAgICAgIGl0ZW0udXBkYXRlKGxlZnQsIHRvcCwgc2l6ZSwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGxlZnQgKz0gc2l6ZTtcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgaGFuZGxlU3R5bGUud2lkdGggPSB0aGlzLl9zcGFjaW5nICsgXCJweFwiO1xuICAgICAgICAgICAgaGFuZGxlU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9wICs9IHRoaXMud2lkZ2V0T2Zmc2V0O1xuICAgICAgICAgICAgaXRlbS51cGRhdGUobGVmdCwgdG9wLCB3aWR0aCwgc2l6ZSk7XG4gICAgICAgICAgICB0b3AgKz0gc2l6ZTtcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgaGFuZGxlU3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgIGhhbmRsZVN0eWxlLmhlaWdodCA9IHRoaXMuX3NwYWNpbmcgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpdCB0aGUgbGF5b3V0IHRvIHRoZSB0b3RhbCBzaXplIHJlcXVpcmVkIGJ5IHRoZSB3aWRnZXRzLlxuICAgICAqL1xuICAgIFNwbGl0TGF5b3V0LnByb3RvdHlwZS5fZml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGhhbmRsZXMgYW5kIHRyYWNrIHRoZSB2aXNpYmxlIHdpZGdldCBjb3VudC5cbiAgICAgICAgdmFyIG5WaXNpYmxlID0gMDtcbiAgICAgICAgdmFyIGxhc3RIYW5kbGVJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zW2ldLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpXS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpXS5jbGFzc0xpc3QuYWRkKCdwLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2xtLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICBsYXN0SGFuZGxlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG5WaXNpYmxlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlkZSB0aGUgaGFuZGxlIGZvciB0aGUgbGFzdCB2aXNpYmxlIHdpZGdldC5cbiAgICAgICAgaWYgKGxhc3RIYW5kbGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbbGFzdEhhbmRsZUluZGV4XS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbbGFzdEhhbmRsZUluZGV4XS5jbGFzc0xpc3QuYWRkKCdwLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGZpeGVkIHNwYWNlIGZvciB0aGUgdmlzaWJsZSBpdGVtcy5cbiAgICAgICAgdGhpcy5fZml4ZWQgPVxuICAgICAgICAgICAgdGhpcy5fc3BhY2luZyAqIE1hdGgubWF4KDAsIG5WaXNpYmxlIC0gMSkgK1xuICAgICAgICAgICAgICAgIHRoaXMud2lkZ2V0T2Zmc2V0ICogdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgICAgICAvLyBTZXR1cCB0aGUgY29tcHV0ZWQgbWluaW11bSBzaXplLlxuICAgICAgICB2YXIgaG9yeiA9IHRoaXMuX29yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgIHZhciBtaW5XID0gaG9yeiA/IHRoaXMuX2ZpeGVkIDogMDtcbiAgICAgICAgdmFyIG1pbkggPSBob3J6ID8gMCA6IHRoaXMuX2ZpeGVkO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNpemVycyBhbmQgY29tcHV0ZWQgc2l6ZSBsaW1pdHMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaXRlbSBhbmQgY29ycmVzcG9uZGluZyBib3ggc2l6ZXIuXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1zW2ldO1xuICAgICAgICAgICAgdmFyIHNpemVyID0gdGhpcy5fc2l6ZXJzW2ldO1xuICAgICAgICAgICAgLy8gUHJldmVudCByZXNpemluZyB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKHNpemVyLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIuc2l6ZUhpbnQgPSBzaXplci5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgaGlkZGVuLCBpdCBzaG91bGQgY29uc3VtZSB6ZXJvIHNpemUuXG4gICAgICAgICAgICBpZiAoaXRlbS5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIHNpemVyLm1pblNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHNpemVyLm1heFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzaXplIGxpbWl0cyBmb3IgdGhlIGl0ZW0uXG4gICAgICAgICAgICBpdGVtLmZpdCgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdHJldGNoIGZhY3Rvci5cbiAgICAgICAgICAgIHNpemVyLnN0cmV0Y2ggPSBTcGxpdExheW91dC5nZXRTdHJldGNoKGl0ZW0ud2lkZ2V0KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2l6ZXIgbGltaXRzIGFuZCBjb21wdXRlZCBtaW4gc2l6ZS5cbiAgICAgICAgICAgIGlmIChob3J6KSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIubWluU2l6ZSA9IGl0ZW0ubWluV2lkdGg7XG4gICAgICAgICAgICAgICAgc2l6ZXIubWF4U2l6ZSA9IGl0ZW0ubWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgbWluVyArPSBpdGVtLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIG1pbkggPSBNYXRoLm1heChtaW5ILCBpdGVtLm1pbkhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaXplci5taW5TaXplID0gaXRlbS5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgc2l6ZXIubWF4U2l6ZSA9IGl0ZW0ubWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIG1pbkggKz0gaXRlbS5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWluVyA9IE1hdGgubWF4KG1pblcsIGl0ZW0ubWluV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYm94IHNpemluZyBhbmQgYWRkIGl0IHRvIHRoZSBjb21wdXRlZCBtaW4gc2l6ZS5cbiAgICAgICAgdmFyIGJveCA9ICh0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKSk7XG4gICAgICAgIG1pblcgKz0gYm94Lmhvcml6b250YWxTdW07XG4gICAgICAgIG1pbkggKz0gYm94LnZlcnRpY2FsU3VtO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHBhcmVudCdzIG1pbiBzaXplIGNvbnN0cmFpbnRzLlxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnBhcmVudC5ub2RlLnN0eWxlO1xuICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pblcgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLm1pbkhlaWdodCA9IG1pbkggKyBcInB4XCI7XG4gICAgICAgIC8vIFNldCB0aGUgZGlydHkgZmxhZyB0byBlbnN1cmUgb25seSBhIHNpbmdsZSB1cGRhdGUgb2NjdXJzLlxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIC8vIE5vdGlmeSB0aGUgYW5jZXN0b3IgdGhhdCBpdCBzaG91bGQgZml0IGltbWVkaWF0ZWx5LiBUaGlzIG1heVxuICAgICAgICAvLyBjYXVzZSBhIHJlc2l6ZSBvZiB0aGUgcGFyZW50LCBmdWxmaWxsaW5nIHRoZSByZXF1aXJlZCB1cGRhdGUuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHRoaXMucGFyZW50LnBhcmVudCwgV2lkZ2V0Lk1zZy5GaXRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZGlydHkgZmxhZyBpcyBzdGlsbCBzZXQsIHRoZSBwYXJlbnQgd2FzIG5vdCByZXNpemVkLlxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSByZXF1aXJlZCB1cGRhdGUgb24gdGhlIHBhcmVudCB3aWRnZXQgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5wYXJlbnQsIFdpZGdldC5Nc2cuVXBkYXRlUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgbGF5b3V0IHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSB3aWRnZXRzLlxuICAgICAqXG4gICAgICogVGhlIHBhcmVudCBvZmZzZXQgZGltZW5zaW9ucyBzaG91bGQgYmUgYC0xYCBpZiB1bmtub3duLlxuICAgICAqL1xuICAgIFNwbGl0TGF5b3V0LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRpcnR5IGZsYWcgdG8gaW5kaWNhdGUgdGhlIHVwZGF0ZSBvY2N1cnJlZC5cbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdmlzaWJsZSBpdGVtIGNvdW50LlxuICAgICAgICB2YXIgblZpc2libGUgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgblZpc2libGUgKz0gKyF0aGlzLl9pdGVtc1tpXS5pc0hpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGFyZSBubyB2aXNpYmxlIGl0ZW1zIHRvIGxheW91dC5cbiAgICAgICAgaWYgKG5WaXNpYmxlID09PSAwICYmIHRoaXMud2lkZ2V0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVhc3VyZSB0aGUgcGFyZW50IGlmIHRoZSBvZmZzZXQgZGltZW5zaW9ucyBhcmUgdW5rbm93bi5cbiAgICAgICAgaWYgKG9mZnNldFdpZHRoIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSB0aGlzLnBhcmVudC5ub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBib3ggc2l6aW5nIGRhdGEgaXMgY29tcHV0ZWQuXG4gICAgICAgIGlmICghdGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhY3R1YWwgbGF5b3V0IGJvdW5kcyBhZGp1c3RlZCBmb3IgYm9yZGVyIGFuZCBwYWRkaW5nLlxuICAgICAgICB2YXIgdG9wID0gdGhpcy5fYm94LnBhZGRpbmdUb3A7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fYm94LnBhZGRpbmdMZWZ0O1xuICAgICAgICB2YXIgd2lkdGggPSBvZmZzZXRXaWR0aCAtIHRoaXMuX2JveC5ob3Jpem9udGFsU3VtO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0IC0gdGhpcy5fYm94LnZlcnRpY2FsU3VtO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIHZhcmlhYmxlcyBmb3IganVzdGlmaWNhdGlvbiBhbmQgYWxpZ25tZW50IG9mZnNldC5cbiAgICAgICAgdmFyIGV4dHJhID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBob3J6ID0gdGhpcy5fb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgaWYgKG5WaXNpYmxlID4gMCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgbGF5b3V0IHNwYWNlLlxuICAgICAgICAgICAgdmFyIHNwYWNlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGhvcnopIHtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0ICs9IHRoaXMud2lkZ2V0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNwYWNlID0gTWF0aC5tYXgoMCwgd2lkdGggLSB0aGlzLl9maXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b3AgKz0gdGhpcy53aWRnZXRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSBNYXRoLm1heCgwLCBoZWlnaHQgLSB0aGlzLl9maXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgc2l6ZSBoaW50cyBpZiB0aGV5IGFyZSBub3JtYWxpemVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc05vcm1lZFNpemVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3NpemVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBzaXplci5zaXplSGludCAqPSBzcGFjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzTm9ybWVkU2l6ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgdGhlIGxheW91dCBzcGFjZSB0byB0aGUgYm94IHNpemVycy5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IEJveEVuZ2luZS5jYWxjKHRoaXMuX3NpemVycywgc3BhY2UpO1xuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgYWxpZ25tZW50IGlmIHRoZXJlIGlzIGV4dHJhIGxheW91dCBzcGFjZS5cbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX2FsaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGRlbHRhIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnanVzdGlmeSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSA9IGRlbHRhIC8gblZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMYXlvdXQgdGhlIGl0ZW1zIHVzaW5nIHRoZSBjb21wdXRlZCBib3ggc2l6ZXMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaXRlbS5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgY29tcHV0ZWQgc2l6ZSBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgICAgIHZhciBzaXplID0gaXRlbS5pc0hpZGRlbiA/IDAgOiB0aGlzLl9zaXplcnNbaV0uc2l6ZSArIGV4dHJhO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJdGVtUG9zaXRpb24oaSwgaG9yeiwgaG9yeiA/IGxlZnQgKyBvZmZzZXQgOiBsZWZ0LCBob3J6ID8gdG9wIDogdG9wICsgb2Zmc2V0LCBoZWlnaHQsIHdpZHRoLCBzaXplKTtcbiAgICAgICAgICAgIHZhciBmdWxsT2Zmc2V0ID0gdGhpcy53aWRnZXRPZmZzZXQgK1xuICAgICAgICAgICAgICAgICh0aGlzLl9oYW5kbGVzW2ldLmNsYXNzTGlzdC5jb250YWlucygnbG0tbW9kLWhpZGRlbicpXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3NwYWNpbmcpO1xuICAgICAgICAgICAgaWYgKGhvcnopIHtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHNpemUgKyBmdWxsT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IHNpemUgKyBmdWxsT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3BsaXRMYXlvdXQ7XG59KFBhbmVsTGF5b3V0KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgU3BsaXRMYXlvdXRgIGNsYXNzIHN0YXRpY3MuXG4gKi9cbihmdW5jdGlvbiAoU3BsaXRMYXlvdXQpIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNwbGl0IGxheW91dCBzdHJldGNoIGZhY3RvciBmb3IgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHNwbGl0IGxheW91dCBzdHJldGNoIGZhY3RvciBmb3IgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdHJldGNoKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZSQyLnN0cmV0Y2hQcm9wZXJ0eS5nZXQod2lkZ2V0KTtcbiAgICB9XG4gICAgU3BsaXRMYXlvdXQuZ2V0U3RyZXRjaCA9IGdldFN0cmV0Y2g7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzcGxpdCBsYXlvdXQgc3RyZXRjaCBmYWN0b3IgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHN0cmV0Y2ggZmFjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFN0cmV0Y2god2lkZ2V0LCB2YWx1ZSkge1xuICAgICAgICBQcml2YXRlJDIuc3RyZXRjaFByb3BlcnR5LnNldCh3aWRnZXQsIHZhbHVlKTtcbiAgICB9XG4gICAgU3BsaXRMYXlvdXQuc2V0U3RyZXRjaCA9IHNldFN0cmV0Y2g7XG59KShTcGxpdExheW91dCB8fCAoU3BsaXRMYXlvdXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJDI7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYSB3aWRnZXQgc3RyZXRjaCBmYWN0b3IuXG4gICAgICovXG4gICAgUHJpdmF0ZS5zdHJldGNoUHJvcGVydHkgPSBuZXcgQXR0YWNoZWRQcm9wZXJ0eSh7XG4gICAgICAgIG5hbWU6ICdzdHJldGNoJyxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICBjb2VyY2U6IGZ1bmN0aW9uIChvd25lciwgdmFsdWUpIHsgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGguZmxvb3IodmFsdWUpKTsgfSxcbiAgICAgICAgY2hhbmdlZDogb25DaGlsZFNpemluZ0NoYW5nZWQsXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGJveCBzaXplciB3aXRoIHRoZSBnaXZlbiBzaXplIGhpbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2l6ZXIoc2l6ZSkge1xuICAgICAgICB2YXIgc2l6ZXIgPSBuZXcgQm94U2l6ZXIoKTtcbiAgICAgICAgc2l6ZXIuc2l6ZUhpbnQgPSBNYXRoLmZsb29yKHNpemUpO1xuICAgICAgICByZXR1cm4gc2l6ZXI7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlU2l6ZXIgPSBjcmVhdGVTaXplcjtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3BsaXQgaGFuZGxlIG5vZGUgdXNpbmcgdGhlIGdpdmVuIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUhhbmRsZShyZW5kZXJlcikge1xuICAgICAgICB2YXIgaGFuZGxlID0gcmVuZGVyZXIuY3JlYXRlSGFuZGxlKCk7XG4gICAgICAgIGhhbmRsZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlSGFuZGxlID0gY3JlYXRlSGFuZGxlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGF2ZXJhZ2Ugc2l6ZSBvZiBhbiBhcnJheSBvZiBib3ggc2l6ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF2ZXJhZ2VTaXplKHNpemVycykge1xuICAgICAgICByZXR1cm4gc2l6ZXJzLnJlZHVjZShmdW5jdGlvbiAodiwgcykgeyByZXR1cm4gdiArIHMuc2l6ZTsgfSwgMCkgLyBzaXplcnMubGVuZ3RoIHx8IDA7XG4gICAgfVxuICAgIFByaXZhdGUuYXZlcmFnZVNpemUgPSBhdmVyYWdlU2l6ZTtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdW0gPSB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgTWF0aC5hYnMoYik7IH0sIDApO1xuICAgICAgICByZXR1cm4gc3VtID09PSAwID8gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gMSAvIG47IH0pIDogdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdiAvIHN1bTsgfSk7XG4gICAgfVxuICAgIFByaXZhdGUubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGFuZ2UgaGFuZGxlciBmb3IgdGhlIGF0dGFjaGVkIHNpemluZyBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQ2hpbGRTaXppbmdDaGFuZ2VkKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgJiYgY2hpbGQucGFyZW50LmxheW91dCBpbnN0YW5jZW9mIFNwbGl0TGF5b3V0KSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQuZml0KCk7XG4gICAgICAgIH1cbiAgICB9XG59KShQcml2YXRlJDIgfHwgKFByaXZhdGUkMiA9IHt9KSk7XG5cbi8qKlxuICogQSBsYXlvdXQgd2hpY2ggYXJyYW5nZXMgaXRzIHdpZGdldHMgaW50byBjb2xsYXBzaWJsZSByZXNpemFibGUgc2VjdGlvbnMuXG4gKi9cbnZhciBBY2NvcmRpb25MYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY29yZGlvbkxheW91dCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYWNjb3JkaW9uIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBkZWZhdWx0IG9yaWVudGF0aW9uIHdpbGwgYmUgdmVydGljYWwuXG4gICAgICpcbiAgICAgKiBUaXRsZXMgbXVzdCBiZSByb3RhdGVkIGZvciBob3Jpem9udGFsIGFjY29yZGlvbiBwYW5lbCB1c2luZyBDU1M6IHNlZSBhY2NvcmRpb25wYW5lbC5jc3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBY2NvcmRpb25MYXlvdXQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgb3JpZW50YXRpb246IG9wdGlvbnMub3JpZW50YXRpb24gfHwgJ3ZlcnRpY2FsJyB9KSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RpdGxlcyA9IFtdO1xuICAgICAgICBfdGhpcy50aXRsZVNwYWNlID0gb3B0aW9ucy50aXRsZVNwYWNlIHx8IDIyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2NvcmRpb25MYXlvdXQucHJvdG90eXBlLCBcInRpdGxlU3BhY2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlY3Rpb24gdGl0bGUgaGVpZ2h0IG9yIHdpZHRoIGRlcGVuZGluZyBvbiB0aGUgb3JpZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZGdldE9mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gVXRpbHMkMS5jbGFtcERpbWVuc2lvbih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy53aWRnZXRPZmZzZXQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53aWRnZXRPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY29yZGlvbkxheW91dC5wcm90b3R5cGUsIFwidGl0bGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVhZC1vbmx5IGFycmF5IG9mIHRoZSBzZWN0aW9uIHRpdGxlcyBpbiB0aGUgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aXRsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgQWNjb3JkaW9uTGF5b3V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGxheW91dCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fdGl0bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIHJlc3Qgb2YgdGhlIGxheW91dC5cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSB3aWRnZXQgdG8gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYXR0YWNoIHRvIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgQWNjb3JkaW9uTGF5b3V0LnByb3RvdHlwZS5hdHRhY2hXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHdpZGdldCkge1xuICAgICAgICB2YXIgdGl0bGUgPSBQcml2YXRlJDMuY3JlYXRlVGl0bGUodGhpcy5yZW5kZXJlciwgd2lkZ2V0LnRpdGxlKTtcbiAgICAgICAgdGl0bGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aXRsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB3aWRnZXQudGl0bGUubGFiZWwgKyBcIiBTZWN0aW9uXCIpO1xuICAgICAgICB0aXRsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgICB0aXRsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCB3aWRnZXQuaWQpO1xuICAgICAgICB0aXRsZS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtZXhwYW5kZWQnKTtcbiAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX3RpdGxlcywgaW5kZXgsIHRpdGxlKTtcbiAgICAgICAgLy8gQWRkIHRoZSB0aXRsZSBub2RlIHRvIHRoZSBwYXJlbnQgYmVmb3JlIHRoZSB3aWRnZXQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgICAgICB3aWRnZXQubm9kZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncmVnaW9uJyk7XG4gICAgICAgIHdpZGdldC5ub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgdGl0bGUuaWQpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmF0dGFjaFdpZGdldC5jYWxsKHRoaXMsIGluZGV4LCB3aWRnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSBhIHdpZGdldCBpbiB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbUluZGV4IC0gVGhlIHByZXZpb3VzIGluZGV4IG9mIHRoZSB3aWRnZXQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b0luZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gbW92ZSBpbiB0aGUgcGFyZW50LlxuICAgICAqL1xuICAgIEFjY29yZGlvbkxheW91dC5wcm90b3R5cGUubW92ZVdpZGdldCA9IGZ1bmN0aW9uIChmcm9tSW5kZXgsIHRvSW5kZXgsIHdpZGdldCkge1xuICAgICAgICBBcnJheUV4dC5tb3ZlKHRoaXMuX3RpdGxlcywgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5tb3ZlV2lkZ2V0LmNhbGwodGhpcywgZnJvbUluZGV4LCB0b0luZGV4LCB3aWRnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoIGEgd2lkZ2V0IGZyb20gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIHByZXZpb3VzIGluZGV4IG9mIHRoZSB3aWRnZXQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGRldGFjaCBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIHJlaW1wbGVtZW50YXRpb24gb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kLlxuICAgICAqL1xuICAgIEFjY29yZGlvbkxheW91dC5wcm90b3R5cGUuZGV0YWNoV2lkZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5fdGl0bGVzLCBpbmRleCk7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQodGl0bGUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaFdpZGdldC5jYWxsKHRoaXMsIGluZGV4LCB3aWRnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBpdGVtIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgSXRlbSBpbmRleFxuICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgV2hldGhlciB0aGUgbGF5b3V0IGlzIGhvcml6b250YWwgb3Igbm90XG4gICAgICogQHBhcmFtIGxlZnQgTGVmdCBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gdG9wIFRvcCBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IEl0ZW0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHdpZHRoIEl0ZW0gd2lkdGhcbiAgICAgKiBAcGFyYW0gc2l6ZSBJdGVtIHNpemVcbiAgICAgKi9cbiAgICBBY2NvcmRpb25MYXlvdXQucHJvdG90eXBlLnVwZGF0ZUl0ZW1Qb3NpdGlvbiA9IGZ1bmN0aW9uIChpLCBpc0hvcml6b250YWwsIGxlZnQsIHRvcCwgaGVpZ2h0LCB3aWR0aCwgc2l6ZSkge1xuICAgICAgICB2YXIgdGl0bGVTdHlsZSA9IHRoaXMuX3RpdGxlc1tpXS5zdHlsZTtcbiAgICAgICAgLy8gVGl0bGVzIG11c3QgYmUgcm90YXRlZCBmb3IgaG9yaXpvbnRhbCBhY2NvcmRpb24gcGFuZWwgdXNpbmcgQ1NTOiBzZWUgYWNjb3JkaW9ucGFuZWwuY3NzXG4gICAgICAgIHRpdGxlU3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICB0aXRsZVN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICB0aXRsZVN0eWxlLmhlaWdodCA9IHRoaXMud2lkZ2V0T2Zmc2V0ICsgXCJweFwiO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aXRsZVN0eWxlLndpZHRoID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGl0bGVTdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlSXRlbVBvc2l0aW9uLmNhbGwodGhpcywgaSwgaXNIb3Jpem9udGFsLCBsZWZ0LCB0b3AsIGhlaWdodCwgd2lkdGgsIHNpemUpO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY29yZGlvbkxheW91dDtcbn0oU3BsaXRMYXlvdXQpKTtcbnZhciBQcml2YXRlJDM7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRpdGxlIEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW5kZXJlciBBY2NvcmRpb24gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gZGF0YSBXaWRnZXQgdGl0bGVcbiAgICAgKiBAcmV0dXJucyBUaXRsZSBIVE1MIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUaXRsZShyZW5kZXJlciwgZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIuY3JlYXRlU2VjdGlvblRpdGxlKGRhdGEpO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZVRpdGxlID0gY3JlYXRlVGl0bGU7XG59KShQcml2YXRlJDMgfHwgKFByaXZhdGUkMyA9IHt9KSk7XG5cbi8qKlxuICogQSBzaW1wbGUgYW5kIGNvbnZlbmllbnQgcGFuZWwgd2lkZ2V0IGNsYXNzLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgaXMgc3VpdGFibGUgYXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgYSB2YXJpZXR5IG9mXG4gKiBjb252ZW5pZW5jZSBwYW5lbCB3aWRnZXRzLCBidXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSB3aXRoIENTUyB0b1xuICogYXJyYW5nZSBhIGNvbGxlY3Rpb24gb2Ygd2lkZ2V0cy5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgY29udmVuaWVuY2Ugd3JhcHBlciBhcm91bmQgYSBbW1BhbmVsTGF5b3V0XV0uXG4gKi9cbnZhciBQYW5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFuZWwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBwYW5lbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYW5lbChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdsbS1QYW5lbCcpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3AtUGFuZWwnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5sYXlvdXQgPSBQcml2YXRlJDQuY3JlYXRlTGF5b3V0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYW5lbC5wcm90b3R5cGUsIFwid2lkZ2V0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlYWQtb25seSBhcnJheSBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC53aWRnZXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB3aWRnZXQgdG8gdGhlIGVuZCBvZiB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBhZGQgdG8gdGhlIHBhbmVsLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSB3aWRnZXQgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIHBhbmVsLCBpdCB3aWxsIGJlIG1vdmVkLlxuICAgICAqL1xuICAgIFBhbmVsLnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmFkZFdpZGdldCh3aWRnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgd2lkZ2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBpbnNlcnQgaW50byB0byB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHdpZGdldCBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgcGFuZWwsIGl0IHdpbGwgYmUgbW92ZWQuXG4gICAgICovXG4gICAgUGFuZWwucHJvdG90eXBlLmluc2VydFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCwgd2lkZ2V0KSB7XG4gICAgICAgIHRoaXMubGF5b3V0Lmluc2VydFdpZGdldChpbmRleCwgd2lkZ2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBQYW5lbDtcbn0oV2lkZ2V0KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkNDtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHBhbmVsIGxheW91dCBmb3IgdGhlIGdpdmVuIHBhbmVsIG9wdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGF5b3V0IHx8IG5ldyBQYW5lbExheW91dCgpO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZUxheW91dCA9IGNyZWF0ZUxheW91dDtcbn0pKFByaXZhdGUkNCB8fCAoUHJpdmF0ZSQ0ID0ge30pKTtcblxuLyoqXG4gKiBBIHBhbmVsIHdoaWNoIGFycmFuZ2VzIGl0cyB3aWRnZXRzIGludG8gcmVzaXphYmxlIHNlY3Rpb25zLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCBhIFtbU3BsaXRMYXlvdXRdXS5cbiAqL1xudmFyIFNwbGl0UGFuZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNwbGl0UGFuZWwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHNwbGl0IHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBzcGxpdCBwYW5lbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTcGxpdFBhbmVsKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeyBsYXlvdXQ6IFByaXZhdGUkNS5jcmVhdGVMYXlvdXQob3B0aW9ucykgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3ByZXNzRGF0YSA9IG51bGw7XG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdsbS1TcGxpdFBhbmVsJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygncC1TcGxpdFBhbmVsJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgcGFuZWwuXG4gICAgICovXG4gICAgU3BsaXRQYW5lbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwbGl0UGFuZWwucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF5b3V0IG9yaWVudGF0aW9uIGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5vcmllbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbGF5b3V0IG9yaWVudGF0aW9uIGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQub3JpZW50YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwbGl0UGFuZWwucHJvdG90eXBlLCBcImFsaWdubWVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRlbnQgYWxpZ25tZW50IGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYWxpZ25tZW50IG9mIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IGhhcyBubyBlZmZlY3QgaWYgdGhlIHdpZGdldHMgY2FuIGV4cGFuZCB0byBmaWxsIHRoZVxuICAgICAgICAgKiBlbnRpcmUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5hbGlnbm1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbnRlbnQgYWxpZ25tZW50IGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYWxpZ25tZW50IG9mIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IGhhcyBubyBlZmZlY3QgaWYgdGhlIHdpZGdldHMgY2FuIGV4cGFuZCB0byBmaWxsIHRoZVxuICAgICAgICAgKiBlbnRpcmUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuYWxpZ25tZW50ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGxpdFBhbmVsLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaW50ZXItZWxlbWVudCBzcGFjaW5nIGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5zcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBpbnRlci1lbGVtZW50IHNwYWNpbmcgZm9yIHRoZSBzcGxpdCBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5zcGFjaW5nID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGxpdFBhbmVsLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVuZGVyZXIgdXNlZCBieSB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5yZW5kZXJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwbGl0UGFuZWwucHJvdG90eXBlLCBcImhhbmRsZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIHNwbGl0IGhhbmRsZXMgaW4gdGhlIHBhbmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuaGFuZGxlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZWxhdGl2ZSBzaXplcyBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBhcnJheSBvZiB0aGUgcmVsYXRpdmUgc2l6ZXMgb2YgdGhlIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIHJldHVybmVkIHNpemVzIHJlZmxlY3QgdGhlIHNpemVzIG9mIHRoZSB3aWRnZXRzIG5vcm1hbGl6ZWRcbiAgICAgKiByZWxhdGl2ZSB0byB0aGVpciBzaWJsaW5ncy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kICoqZG9lcyBub3QqKiBtZWFzdXJlIHRoZSBET00gbm9kZXMuXG4gICAgICovXG4gICAgU3BsaXRQYW5lbC5wcm90b3R5cGUucmVsYXRpdmVTaXplcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnJlbGF0aXZlU2l6ZXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVsYXRpdmUgc2l6ZXMgZm9yIHRoZSB3aWRnZXRzIGluIHRoZSBwYW5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplcyAtIFRoZSByZWxhdGl2ZSBzaXplcyBmb3IgdGhlIHdpZGdldHMgaW4gdGhlIHBhbmVsLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIEV4dHJhIHZhbHVlcyBhcmUgaWdub3JlZCwgdG9vIGZldyB3aWxsIHlpZWxkIGFuIHVuZGVmaW5lZCBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBUaGUgYWN0dWFsIGdlb21ldHJ5IG9mIHRoZSBET00gbm9kZXMgaXMgdXBkYXRlZCBhc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICBTcGxpdFBhbmVsLnByb3RvdHlwZS5zZXRSZWxhdGl2ZVNpemVzID0gZnVuY3Rpb24gKHNpemVzKSB7XG4gICAgICAgIHRoaXMubGF5b3V0LnNldFJlbGF0aXZlU2l6ZXMoc2l6ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IHNlbnQgdG8gdGhlIHBhbmVsLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIERPTSBgRXZlbnRMaXN0ZW5lcmAgaW50ZXJmYWNlIGFuZCBpc1xuICAgICAqIGNhbGxlZCBpbiByZXNwb25zZSB0byBldmVudHMgb24gdGhlIHBhbmVsJ3MgRE9NIG5vZGUuIEl0IHNob3VsZFxuICAgICAqIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgdXNlciBjb2RlLlxuICAgICAqL1xuICAgIFNwbGl0UGFuZWwucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VVcChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRLZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTcGxpdFBhbmVsLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FmdGVyLWRldGFjaCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3BsaXRQYW5lbC5wcm90b3R5cGUub25BZnRlckRldGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2NoaWxkLWFkZGVkJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTcGxpdFBhbmVsLnByb3RvdHlwZS5vbkNoaWxkQWRkZWQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIG1zZy5jaGlsZC5hZGRDbGFzcygnbG0tU3BsaXRQYW5lbC1jaGlsZCcpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgbXNnLmNoaWxkLmFkZENsYXNzKCdwLVNwbGl0UGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2NoaWxkLXJlbW92ZWQnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFNwbGl0UGFuZWwucHJvdG90eXBlLm9uQ2hpbGRSZW1vdmVkID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBtc2cuY2hpbGQucmVtb3ZlQ2xhc3MoJ2xtLVNwbGl0UGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIG1zZy5jaGlsZC5yZW1vdmVDbGFzcygncC1TcGxpdFBhbmVsLWNoaWxkJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAna2V5ZG93bidgIGV2ZW50IGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICovXG4gICAgU3BsaXRQYW5lbC5wcm90b3R5cGUuX2V2dEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcCBpbnB1dCBldmVudHMgZHVyaW5nIGRyYWcuXG4gICAgICAgIGlmICh0aGlzLl9wcmVzc0RhdGEpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWxlYXNlIHRoZSBtb3VzZSBpZiBgRXNjYXBlYCBpcyBwcmVzc2VkLlxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vkb3duJ2AgZXZlbnQgZm9yIHRoZSBzcGxpdCBwYW5lbC5cbiAgICAgKi9cbiAgICBTcGxpdFBhbmVsLnByb3RvdHlwZS5fZXZ0TW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIG5vdCBwcmVzc2VkLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgaGFuZGxlIHdoaWNoIGNvbnRhaW5zIHRoZSBtb3VzZSB0YXJnZXQsIGlmIGFueS5cbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgICB2YXIgaW5kZXggPSBBcnJheUV4dC5maW5kRmlyc3RJbmRleChsYXlvdXQuaGFuZGxlcywgZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgbW91c2UgcHJlc3Mgd2FzIG5vdCBvbiBhIGhhbmRsZS5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHdoZW4gYSBzcGxpdCBoYW5kbGUgaXMgcHJlc3NlZC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEFkZCB0aGUgZXh0cmEgZG9jdW1lbnQgbGlzdGVuZXJzLlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9mZnNldCBkZWx0YSBmb3IgdGhlIGhhbmRsZSBwcmVzcy5cbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICB2YXIgaGFuZGxlID0gbGF5b3V0LmhhbmRsZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcmVjdCA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxheW91dC5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBkZWx0YSA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdmVycmlkZSB0aGUgY3Vyc29yIGFuZCBzdG9yZSB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaGFuZGxlKTtcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gRHJhZy5vdmVycmlkZUN1cnNvcihzdHlsZS5jdXJzb3IpO1xuICAgICAgICB0aGlzLl9wcmVzc0RhdGEgPSB7IGluZGV4OiBpbmRleCwgZGVsdGE6IGRlbHRhLCBvdmVycmlkZTogb3ZlcnJpZGUgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdtb3VzZW1vdmUnYCBldmVudCBmb3IgdGhlIHNwbGl0IHBhbmVsLlxuICAgICAqL1xuICAgIFNwbGl0UGFuZWwucHJvdG90eXBlLl9ldnRNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgd2hlbiBkcmFnZ2luZyBhIHNwbGl0IGhhbmRsZS5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGRlc2lyZWQgb2Zmc2V0IHBvc2l0aW9uIGZvciB0aGUgaGFuZGxlLlxuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobGF5b3V0Lm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHBvcyA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSB0aGlzLl9wcmVzc0RhdGEuZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSB0aGlzLl9wcmVzc0RhdGEuZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW92ZSB0aGUgaGFuZGxlIGFzIGNsb3NlIHRvIHRoZSBkZXNpcmVkIHBvc2l0aW9uIGFzIHBvc3NpYmxlLlxuICAgICAgICBsYXlvdXQubW92ZUhhbmRsZSh0aGlzLl9wcmVzc0RhdGEuaW5kZXgsIHBvcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2V1cCdgIGV2ZW50IGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICovXG4gICAgU3BsaXRQYW5lbC5wcm90b3R5cGUuX2V2dE1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgbm90IHJlbGVhc2VkLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgd2hlbiByZWxlYXNpbmcgYSBoYW5kbGUuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbW91c2UgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBtb3VzZSBncmFiIGZvciB0aGUgc3BsaXQgcGFuZWwuXG4gICAgICovXG4gICAgU3BsaXRQYW5lbC5wcm90b3R5cGUuX3JlbGVhc2VNb3VzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiBubyBkcmFnIGlzIGluIHByb2dyZXNzLlxuICAgICAgICBpZiAoIXRoaXMuX3ByZXNzRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSBvdmVycmlkZSBjdXJzb3IuXG4gICAgICAgIHRoaXMuX3ByZXNzRGF0YS5vdmVycmlkZS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3ByZXNzRGF0YSA9IG51bGw7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZXh0cmEgZG9jdW1lbnQgbGlzdGVuZXJzLlxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcywgdHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3BsaXRQYW5lbDtcbn0oUGFuZWwpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIGBTcGxpdFBhbmVsYCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKFNwbGl0UGFuZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgSVJlbmRlcmVyYC5cbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgaGFuZGxlIGZvciB1c2Ugd2l0aCBhIHNwbGl0IHBhbmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyBoYW5kbGUgZWxlbWVudCBmb3IgYSBzcGxpdCBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVIYW5kbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoYW5kbGUuY2xhc3NOYW1lID0gJ2xtLVNwbGl0UGFuZWwtaGFuZGxlJztcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgaGFuZGxlLmNsYXNzTGlzdC5hZGQoJ3AtU3BsaXRQYW5lbC1oYW5kbGUnKTtcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIFNwbGl0UGFuZWwuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBgUmVuZGVyZXJgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFNwbGl0UGFuZWwuZGVmYXVsdFJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzcGxpdCBwYW5lbCBzdHJldGNoIGZhY3RvciBmb3IgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHNwbGl0IHBhbmVsIHN0cmV0Y2ggZmFjdG9yIGZvciB0aGUgd2lkZ2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0cmV0Y2god2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiBTcGxpdExheW91dC5nZXRTdHJldGNoKHdpZGdldCk7XG4gICAgfVxuICAgIFNwbGl0UGFuZWwuZ2V0U3RyZXRjaCA9IGdldFN0cmV0Y2g7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzcGxpdCBwYW5lbCBzdHJldGNoIGZhY3RvciBmb3IgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGZvciB0aGUgc3RyZXRjaCBmYWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0U3RyZXRjaCh3aWRnZXQsIHZhbHVlKSB7XG4gICAgICAgIFNwbGl0TGF5b3V0LnNldFN0cmV0Y2god2lkZ2V0LCB2YWx1ZSk7XG4gICAgfVxuICAgIFNwbGl0UGFuZWwuc2V0U3RyZXRjaCA9IHNldFN0cmV0Y2g7XG59KShTcGxpdFBhbmVsIHx8IChTcGxpdFBhbmVsID0ge30pKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSQ1O1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3BsaXQgbGF5b3V0IGZvciB0aGUgZ2l2ZW4gcGFuZWwgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVMYXlvdXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMubGF5b3V0IHx8XG4gICAgICAgICAgICBuZXcgU3BsaXRMYXlvdXQoe1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBvcHRpb25zLnJlbmRlcmVyIHx8IFNwbGl0UGFuZWwuZGVmYXVsdFJlbmRlcmVyLFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBvcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogb3B0aW9ucy5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgc3BhY2luZzogb3B0aW9ucy5zcGFjaW5nLFxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZUxheW91dCA9IGNyZWF0ZUxheW91dDtcbn0pKFByaXZhdGUkNSB8fCAoUHJpdmF0ZSQ1ID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEEgcGFuZWwgd2hpY2ggYXJyYW5nZXMgaXRzIHdpZGdldHMgaW50byByZXNpemFibGUgc2VjdGlvbnMgc2VwYXJhdGVkIGJ5IGEgdGl0bGUgd2lkZ2V0LlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCBbW0FjY29yZGlvbkxheW91dF1dLlxuICovXG52YXIgQWNjb3JkaW9uUGFuZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY29yZGlvblBhbmVsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBhY2NvcmRpb24gcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIGFjY29yZGlvbiBwYW5lbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBY2NvcmRpb25QYW5lbChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBsYXlvdXQ6IFByaXZhdGUkNi5jcmVhdGVMYXlvdXQob3B0aW9ucykgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdsbS1BY2NvcmRpb25QYW5lbCcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2NvcmRpb25QYW5lbC5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlbmRlcmVyIHVzZWQgYnkgdGhlIGFjY29yZGlvbiBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWNjb3JkaW9uUGFuZWwucHJvdG90eXBlLCBcInRpdGxlU3BhY2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlY3Rpb24gdGl0bGUgc3BhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGhlaWdodCBpZiB0aGUgcGFuZWwgaXMgdmVydGljYWwgYW5kIHRoZSB3aWR0aCBpZiBpdCBpc1xuICAgICAgICAgKiBob3Jpem9udGFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQudGl0bGVTcGFjZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnRpdGxlU3BhY2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY29yZGlvblBhbmVsLnByb3RvdHlwZSwgXCJ0aXRsZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIHNlY3Rpb24gdGl0bGVzIGluIHRoZSBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnRpdGxlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgYWNjb3JkaW9uIHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIERPTSBldmVudCBzZW50IHRvIHRoZSBwYW5lbC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBET00gYEV2ZW50TGlzdGVuZXJgIGludGVyZmFjZSBhbmQgaXNcbiAgICAgKiBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gZXZlbnRzIG9uIHRoZSBwYW5lbCdzIERPTSBub2RlLiBJdCBzaG91bGRcbiAgICAgKiBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBBY2NvcmRpb25QYW5lbC5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0Q2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRLZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgQWNjb3JkaW9uUGFuZWwucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaC5jYWxsKHRoaXMsIG1zZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBBY2NvcmRpb25QYW5lbC5wcm90b3R5cGUub25BZnRlckRldGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkFmdGVyRGV0YWNoLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnY2xpY2snYCBldmVudCBmb3IgdGhlIGFjY29yZGlvbiBwYW5lbFxuICAgICAqL1xuICAgIEFjY29yZGlvblBhbmVsLnByb3RvdHlwZS5fZXZ0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gQXJyYXlFeHQuZmluZEZpcnN0SW5kZXgodGhpcy50aXRsZXMsIGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aXRsZS5jb250YWlucyh0YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMubGF5b3V0LndpZGdldHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh3aWRnZXQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2xtLW1vZC1leHBhbmRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnNob3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdsbS1tb2QtZXhwYW5kZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ2tleWRvd24nYCBldmVudCBmb3IgdGhlIGFjY29yZGlvbiBwYW5lbC5cbiAgICAgKi9cbiAgICBBY2NvcmRpb25QYW5lbC5wcm90b3R5cGUuX2V2ZW50S2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRoaXMudGl0bGVzLCBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGUuY29udGFpbnModGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBTcGFjZSBvciBFbnRlciBpcyBwcmVzc2VkIG9uIHRpdGxlLCBlbXVsYXRlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleS5tYXRjaCgvU3BhY2V8RW50ZXIvKSB8fCBrZXlDb2RlLm1hdGNoKC8xM3wzMi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnXG4gICAgICAgICAgICAgICAgICAgID8gZXZlbnQua2V5Lm1hdGNoKC9BcnJvd0xlZnR8QXJyb3dSaWdodC8pIHx8IGtleUNvZGUubWF0Y2goLzM3fDM5LylcbiAgICAgICAgICAgICAgICAgICAgOiBldmVudC5rZXkubWF0Y2goL0Fycm93VXB8QXJyb3dEb3duLykgfHwga2V5Q29kZS5tYXRjaCgvMzh8NDAvKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBVcCBvciBEb3duIChmb3IgdmVydGljYWwpIC8gTGVmdCBvciBSaWdodCAoZm9yIGhvcml6b250YWwpIGlzIHByZXNzZWQgb24gdGl0bGUsIGxvb3Agb24gdGl0bGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBldmVudC5rZXkubWF0Y2goL0Fycm93TGVmdHxBcnJvd1VwLykgfHwga2V5Q29kZS5tYXRjaCgvMzd8MzgvKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSB0aGlzLnRpdGxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IChpbmRleCArIGxlbmd0aF8xICsgZGlyZWN0aW9uKSAlIGxlbmd0aF8xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpdGxlc1tuZXdJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcgfHwga2V5Q29kZSA9PT0gJzM1Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBFbmQgaXMgcHJlc3NlZCBvbiB0aXRsZSwgZm9jdXMgb24gdGhlIGxhc3QgdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aXRsZXNbdGhpcy50aXRsZXMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0hvbWUnIHx8IGtleUNvZGUgPT09ICczNicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgSG9tZSBpcyBwcmVzc2VkIG9uIHRpdGxlLCBmb2N1cyBvbiB0aGUgZmlyc3QgdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aXRsZXNbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3JkaW9uUGFuZWw7XG59KFNwbGl0UGFuZWwpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIGBBY2NvcmRpb25QYW5lbGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChBY2NvcmRpb25QYW5lbCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBJUmVuZGVyZXJgLlxuICAgICAqL1xuICAgIHZhciBSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHNlbGVjdG9yIHdoaWNoIG1hdGNoZXMgYW55IHRpdGxlIG5vZGUgaW4gdGhlIGFjY29yZGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMudGl0bGVDbGFzc05hbWUgPSAnbG0tQWNjb3JkaW9uUGFuZWwtdGl0bGUnO1xuICAgICAgICAgICAgX3RoaXMuX3RpdGxlSUQgPSAwO1xuICAgICAgICAgICAgX3RoaXMuX3RpdGxlS2V5cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgY29sbGFwc2UgaW5kaWNhdG9yIGZvciBhIHNlY3Rpb24gdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIHNlY3Rpb24gdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbGxhcHNlIGluZGljYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb2xsYXBzZUljb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgZWxlbWVudCBmb3IgYSBzZWN0aW9uIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBzZWN0aW9uIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBzZWN0aW9uIHRpdGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNlY3Rpb25UaXRsZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgICAgICBoYW5kbGUuaWQgPSB0aGlzLmNyZWF0ZVRpdGxlS2V5KGRhdGEpO1xuICAgICAgICAgICAgaGFuZGxlLmNsYXNzTmFtZSA9IHRoaXMudGl0bGVDbGFzc05hbWU7XG4gICAgICAgICAgICBoYW5kbGUudGl0bGUgPSBkYXRhLmNhcHRpb247XG4gICAgICAgICAgICBmb3IgKHZhciBhRGF0YSBpbiBkYXRhLmRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUuZGF0YXNldFthRGF0YV0gPSBkYXRhLmRhdGFzZXRbYURhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbGxhcHNlciA9IGhhbmRsZS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUNvbGxhcHNlSWNvbihkYXRhKSk7XG4gICAgICAgICAgICBjb2xsYXBzZXIuY2xhc3NOYW1lID0gJ2xtLUFjY29yZGlvblBhbmVsLXRpdGxlQ29sbGFwc2VyJztcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGhhbmRsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuICAgICAgICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ2xtLUFjY29yZGlvblBhbmVsLXRpdGxlTGFiZWwnO1xuICAgICAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBkYXRhLmxhYmVsO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHVuaXF1ZSByZW5kZXIga2V5IGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgdGl0bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSB1bmlxdWUgcmVuZGVyIGtleSBmb3IgdGhlIHRpdGxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGNhY2hlcyB0aGUga2V5IGFnYWluc3QgdGhlIHNlY3Rpb24gdGl0bGUgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICogdGhlIGtleSBpcyBnZW5lcmF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGl0bGVLZXkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX3RpdGxlS2V5cy5nZXQoZGF0YSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcInRpdGxlLWtleS1cIiArIHRoaXMuX3RpdGxlSUQrKztcbiAgICAgICAgICAgICAgICB0aGlzLl90aXRsZUtleXMuc2V0KGRhdGEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVuZGVyZXI7XG4gICAgfShTcGxpdFBhbmVsLlJlbmRlcmVyKSk7XG4gICAgQWNjb3JkaW9uUGFuZWwuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBgUmVuZGVyZXJgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEFjY29yZGlvblBhbmVsLmRlZmF1bHRSZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xufSkoQWNjb3JkaW9uUGFuZWwgfHwgKEFjY29yZGlvblBhbmVsID0ge30pKTtcbnZhciBQcml2YXRlJDY7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYWNjb3JkaW9uIGxheW91dCBmb3IgdGhlIGdpdmVuIHBhbmVsIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBQYW5lbCBvcHRpb25zXG4gICAgICogQHJldHVybnMgUGFuZWwgbGF5b3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmxheW91dCB8fFxuICAgICAgICAgICAgbmV3IEFjY29yZGlvbkxheW91dCh7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IG9wdGlvbnMucmVuZGVyZXIgfHwgQWNjb3JkaW9uUGFuZWwuZGVmYXVsdFJlbmRlcmVyLFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBvcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogb3B0aW9ucy5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgc3BhY2luZzogb3B0aW9ucy5zcGFjaW5nLFxuICAgICAgICAgICAgICAgIHRpdGxlU3BhY2U6IG9wdGlvbnMudGl0bGVTcGFjZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVMYXlvdXQgPSBjcmVhdGVMYXlvdXQ7XG59KShQcml2YXRlJDYgfHwgKFByaXZhdGUkNiA9IHt9KSk7XG5cbi8qKlxuICogQSBsYXlvdXQgd2hpY2ggYXJyYW5nZXMgaXRzIHdpZGdldHMgaW4gYSBzaW5nbGUgcm93IG9yIGNvbHVtbi5cbiAqL1xudmFyIEJveExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm94TGF5b3V0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBib3ggbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm94TGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2ZpeGVkID0gMDtcbiAgICAgICAgX3RoaXMuX3NwYWNpbmcgPSA0O1xuICAgICAgICBfdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3NpemVycyA9IFtdO1xuICAgICAgICBfdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2JveCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9hbGlnbm1lbnQgPSAnc3RhcnQnO1xuICAgICAgICBfdGhpcy5fZGlyZWN0aW9uID0gJ3RvcC10by1ib3R0b20nO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMuX2RpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fYWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnbm1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc3BhY2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fc3BhY2luZyA9IFV0aWxzJDEuY2xhbXBEaW1lbnNpb24ob3B0aW9ucy5zcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgQm94TGF5b3V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSBsYXlvdXQgaXRlbXMuXG4gICAgICAgIGVhY2godGhpcy5faXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGxheW91dCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fYm94ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIHJlc3Qgb2YgdGhlIGxheW91dC5cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94TGF5b3V0LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXlvdXQgZGlyZWN0aW9uIGZvciB0aGUgYm94IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbGF5b3V0IGRpcmVjdGlvbiBmb3IgdGhlIGJveCBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5kYXRhc2V0WydkaXJlY3Rpb24nXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3hMYXlvdXQucHJvdG90eXBlLCBcImFsaWdubWVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRlbnQgYWxpZ25tZW50IGZvciB0aGUgYm94IGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIGlzIHRoZSBhbGlnbm1lbnQgb2YgdGhlIHdpZGdldHMgaW4gdGhlIGxheW91dCBkaXJlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhbGlnbm1lbnQgaGFzIG5vIGVmZmVjdCBpZiB0aGUgd2lkZ2V0cyBjYW4gZXhwYW5kIHRvIGZpbGwgdGhlXG4gICAgICAgICAqIGVudGlyZSBib3ggbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ25tZW50O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjb250ZW50IGFsaWdubWVudCBmb3IgdGhlIGJveCBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYWxpZ25tZW50IG9mIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IGhhcyBubyBlZmZlY3QgaWYgdGhlIHdpZGdldHMgY2FuIGV4cGFuZCB0byBmaWxsIHRoZVxuICAgICAgICAgKiBlbnRpcmUgYm94IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxpZ25tZW50ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FsaWdubWVudCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50LmRhdGFzZXRbJ2FsaWdubWVudCddID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveExheW91dC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGludGVyLWVsZW1lbnQgc3BhY2luZyBmb3IgdGhlIGJveCBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBpbnRlci1lbGVtZW50IHNwYWNpbmcgZm9yIHRoZSBib3ggbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gVXRpbHMkMS5jbGFtcERpbWVuc2lvbih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3BhY2luZyA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zcGFjaW5nID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gbGF5b3V0IGluaXRpYWxpemF0aW9uIHdoaWNoIHJlcXVpcmVzIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAqL1xuICAgIEJveExheW91dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZGF0YXNldFsnZGlyZWN0aW9uJ10gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQuZGF0YXNldFsnYWxpZ25tZW50J10gPSB0aGlzLmFsaWdubWVudDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSB3aWRnZXQgdG8gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYXR0YWNoIHRvIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIHJlaW1wbGVtZW50YXRpb24gb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kLlxuICAgICAqL1xuICAgIEJveExheW91dC5wcm90b3R5cGUuYXR0YWNoV2lkZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgYSBuZXcgbGF5b3V0IGl0ZW0gZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIEFycmF5RXh0Lmluc2VydCh0aGlzLl9pdGVtcywgaW5kZXgsIG5ldyBMYXlvdXRJdGVtKHdpZGdldCkpO1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBhIG5ldyBzaXplciBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX3NpemVycywgaW5kZXgsIG5ldyBCb3hTaXplcigpKTtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVBdHRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgd2lkZ2V0J3Mgbm9kZSB0byB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHdpZGdldC5ub2RlKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckF0dGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9zdCBhIGZpdCByZXF1ZXN0IGZvciB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgd2lkZ2V0IGluIHRoZSBwYXJlbnQncyBET00gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tSW5kZXggLSBUaGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvSW5kZXggLSBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgd2lkZ2V0IGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBtb3ZlIGluIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIHJlaW1wbGVtZW50YXRpb24gb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kLlxuICAgICAqL1xuICAgIEJveExheW91dC5wcm90b3R5cGUubW92ZVdpZGdldCA9IGZ1bmN0aW9uIChmcm9tSW5kZXgsIHRvSW5kZXgsIHdpZGdldCkge1xuICAgICAgICAvLyBNb3ZlIHRoZSBsYXlvdXQgaXRlbSBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgQXJyYXlFeHQubW92ZSh0aGlzLl9pdGVtcywgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgLy8gTW92ZSB0aGUgc2l6ZXIgZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIEFycmF5RXh0Lm1vdmUodGhpcy5fc2l6ZXJzLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgICAvLyBQb3N0IGFuIHVwZGF0ZSByZXF1ZXN0IGZvciB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSB3aWRnZXQgZnJvbSB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgcHJldmlvdXMgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gZGV0YWNoIGZyb20gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAgICovXG4gICAgQm94TGF5b3V0LnByb3RvdHlwZS5kZXRhY2hXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHdpZGdldCkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGxheW91dCBpdGVtIGZvciB0aGUgd2lkZ2V0LlxuICAgICAgICB2YXIgaXRlbSA9IEFycmF5RXh0LnJlbW92ZUF0KHRoaXMuX2l0ZW1zLCBpbmRleCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc2l6ZXIgZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIEFycmF5RXh0LnJlbW92ZUF0KHRoaXMuX3NpemVycywgaW5kZXgpO1xuICAgICAgICAvLyBTZW5kIGEgYCdiZWZvcmUtZGV0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkJlZm9yZURldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB3aWRnZXQncyBub2RlIGZyb20gdGhlIHBhcmVudC5cbiAgICAgICAgdGhpcy5wYXJlbnQubm9kZS5yZW1vdmVDaGlsZCh3aWRnZXQubm9kZSk7XG4gICAgICAgIC8vIFNlbmQgYW4gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlIGlmIHRoZSBwYXJlbnQgaXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQWZ0ZXJEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIGxheW91dCBpdGVtLlxuICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gUG9zdCBhIGZpdCByZXF1ZXN0IGZvciB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtc2hvdydgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgQm94TGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZVNob3cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25CZWZvcmVTaG93LmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBCb3hMYXlvdXQucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1zaG93bidgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgQm94TGF5b3V0LnByb3RvdHlwZS5vbkNoaWxkU2hvd24gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtaGlkZGVuJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBCb3hMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRIaWRkZW4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAncmVzaXplJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBCb3hMYXlvdXQucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUobXNnLndpZHRoLCBtc2cuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ3VwZGF0ZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBCb3hMYXlvdXQucHJvdG90eXBlLm9uVXBkYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKC0xLCAtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2ZpdC1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBCb3hMYXlvdXQucHJvdG90eXBlLm9uRml0UmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXQgdGhlIGxheW91dCB0byB0aGUgdG90YWwgc2l6ZSByZXF1aXJlZCBieSB0aGUgd2lkZ2V0cy5cbiAgICAgKi9cbiAgICBCb3hMYXlvdXQucHJvdG90eXBlLl9maXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHZpc2libGUgaXRlbSBjb3VudC5cbiAgICAgICAgdmFyIG5WaXNpYmxlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIG5WaXNpYmxlICs9ICshdGhpcy5faXRlbXNbaV0uaXNIaWRkZW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBmaXhlZCBzcGFjZSBmb3IgdGhlIHZpc2libGUgaXRlbXMuXG4gICAgICAgIHRoaXMuX2ZpeGVkID0gdGhpcy5fc3BhY2luZyAqIE1hdGgubWF4KDAsIG5WaXNpYmxlIC0gMSk7XG4gICAgICAgIC8vIFNldHVwIHRoZSBjb21wdXRlZCBtaW5pbXVtIHNpemUuXG4gICAgICAgIHZhciBob3J6ID0gUHJpdmF0ZSQ3LmlzSG9yaXpvbnRhbCh0aGlzLl9kaXJlY3Rpb24pO1xuICAgICAgICB2YXIgbWluVyA9IGhvcnogPyB0aGlzLl9maXhlZCA6IDA7XG4gICAgICAgIHZhciBtaW5IID0gaG9yeiA/IDAgOiB0aGlzLl9maXhlZDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzaXplcnMgYW5kIGNvbXB1dGVkIG1pbmltdW0gc2l6ZS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBpdGVtIGFuZCBjb3JyZXNwb25kaW5nIGJveCBzaXplci5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICB2YXIgc2l6ZXIgPSB0aGlzLl9zaXplcnNbaV07XG4gICAgICAgICAgICAvLyBJZiB0aGUgaXRlbSBpcyBoaWRkZW4sIGl0IHNob3VsZCBjb25zdW1lIHplcm8gc2l6ZS5cbiAgICAgICAgICAgIGlmIChpdGVtLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIubWluU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgc2l6ZXIubWF4U2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNpemUgbGltaXRzIGZvciB0aGUgaXRlbS5cbiAgICAgICAgICAgIGl0ZW0uZml0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNpemUgYmFzaXMgYW5kIHN0cmV0Y2ggZmFjdG9yLlxuICAgICAgICAgICAgc2l6ZXIuc2l6ZUhpbnQgPSBCb3hMYXlvdXQuZ2V0U2l6ZUJhc2lzKGl0ZW0ud2lkZ2V0KTtcbiAgICAgICAgICAgIHNpemVyLnN0cmV0Y2ggPSBCb3hMYXlvdXQuZ2V0U3RyZXRjaChpdGVtLndpZGdldCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNpemVyIGxpbWl0cyBhbmQgY29tcHV0ZWQgbWluIHNpemUuXG4gICAgICAgICAgICBpZiAoaG9yeikge1xuICAgICAgICAgICAgICAgIHNpemVyLm1pblNpemUgPSBpdGVtLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIHNpemVyLm1heFNpemUgPSBpdGVtLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIG1pblcgKz0gaXRlbS5taW5XaWR0aDtcbiAgICAgICAgICAgICAgICBtaW5IID0gTWF0aC5tYXgobWluSCwgaXRlbS5taW5IZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZXIubWluU2l6ZSA9IGl0ZW0ubWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNpemVyLm1heFNpemUgPSBpdGVtLm1heEhlaWdodDtcbiAgICAgICAgICAgICAgICBtaW5IICs9IGl0ZW0ubWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgIG1pblcgPSBNYXRoLm1heChtaW5XLCBpdGVtLm1pbldpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGJveCBzaXppbmcgYW5kIGFkZCBpdCB0byB0aGUgY29tcHV0ZWQgbWluIHNpemUuXG4gICAgICAgIHZhciBib3ggPSB0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKTtcbiAgICAgICAgbWluVyArPSBib3guaG9yaXpvbnRhbFN1bTtcbiAgICAgICAgbWluSCArPSBib3gudmVydGljYWxTdW07XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyZW50J3MgbWluIHNpemUgY29uc3RyYWludHMuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMucGFyZW50Lm5vZGUuc3R5bGU7XG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluVyArIFwicHhcIjtcbiAgICAgICAgc3R5bGUubWluSGVpZ2h0ID0gbWluSCArIFwicHhcIjtcbiAgICAgICAgLy8gU2V0IHRoZSBkaXJ0eSBmbGFnIHRvIGVuc3VyZSBvbmx5IGEgc2luZ2xlIHVwZGF0ZSBvY2N1cnMuXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgLy8gTm90aWZ5IHRoZSBhbmNlc3RvciB0aGF0IGl0IHNob3VsZCBmaXQgaW1tZWRpYXRlbHkuIFRoaXMgbWF5XG4gICAgICAgIC8vIGNhdXNlIGEgcmVzaXplIG9mIHRoZSBwYXJlbnQsIGZ1bGZpbGxpbmcgdGhlIHJlcXVpcmVkIHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5wYXJlbnQucGFyZW50LCBXaWRnZXQuTXNnLkZpdFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBkaXJ0eSBmbGFnIGlzIHN0aWxsIHNldCwgdGhlIHBhcmVudCB3YXMgbm90IHJlc2l6ZWQuXG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIHJlcXVpcmVkIHVwZGF0ZSBvbiB0aGUgcGFyZW50IHdpZGdldCBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLnBhcmVudCwgV2lkZ2V0Lk1zZy5VcGRhdGVSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBsYXlvdXQgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiBUaGUgcGFyZW50IG9mZnNldCBkaW1lbnNpb25zIHNob3VsZCBiZSBgLTFgIGlmIHVua25vd24uXG4gICAgICovXG4gICAgQm94TGF5b3V0LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRpcnR5IGZsYWcgdG8gaW5kaWNhdGUgdGhlIHVwZGF0ZSBvY2N1cnJlZC5cbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdmlzaWJsZSBpdGVtIGNvdW50LlxuICAgICAgICB2YXIgblZpc2libGUgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgblZpc2libGUgKz0gKyF0aGlzLl9pdGVtc1tpXS5pc0hpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGFyZSBubyB2aXNpYmxlIGl0ZW1zIHRvIGxheW91dC5cbiAgICAgICAgaWYgKG5WaXNpYmxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVhc3VyZSB0aGUgcGFyZW50IGlmIHRoZSBvZmZzZXQgZGltZW5zaW9ucyBhcmUgdW5rbm93bi5cbiAgICAgICAgaWYgKG9mZnNldFdpZHRoIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSB0aGlzLnBhcmVudC5ub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBib3ggc2l6aW5nIGRhdGEgaXMgY29tcHV0ZWQuXG4gICAgICAgIGlmICghdGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBsYXlvdXQgYXJlYSBhZGp1c3RlZCBmb3IgYm9yZGVyIGFuZCBwYWRkaW5nLlxuICAgICAgICB2YXIgdG9wID0gdGhpcy5fYm94LnBhZGRpbmdUb3A7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fYm94LnBhZGRpbmdMZWZ0O1xuICAgICAgICB2YXIgd2lkdGggPSBvZmZzZXRXaWR0aCAtIHRoaXMuX2JveC5ob3Jpem9udGFsU3VtO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0IC0gdGhpcy5fYm94LnZlcnRpY2FsU3VtO1xuICAgICAgICAvLyBEaXN0cmlidXRlIHRoZSBsYXlvdXQgc3BhY2UgYW5kIGFkanVzdCB0aGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQtdG8tcmlnaHQnOlxuICAgICAgICAgICAgICAgIGRlbHRhID0gQm94RW5naW5lLmNhbGModGhpcy5fc2l6ZXJzLCBNYXRoLm1heCgwLCB3aWR0aCAtIHRoaXMuX2ZpeGVkKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AtdG8tYm90dG9tJzpcbiAgICAgICAgICAgICAgICBkZWx0YSA9IEJveEVuZ2luZS5jYWxjKHRoaXMuX3NpemVycywgTWF0aC5tYXgoMCwgaGVpZ2h0IC0gdGhpcy5fZml4ZWQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0LXRvLWxlZnQnOlxuICAgICAgICAgICAgICAgIGRlbHRhID0gQm94RW5naW5lLmNhbGModGhpcy5fc2l6ZXJzLCBNYXRoLm1heCgwLCB3aWR0aCAtIHRoaXMuX2ZpeGVkKSk7XG4gICAgICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS10by10b3AnOlxuICAgICAgICAgICAgICAgIGRlbHRhID0gQm94RW5naW5lLmNhbGModGhpcy5fc2l6ZXJzLCBNYXRoLm1heCgwLCBoZWlnaHQgLSB0aGlzLl9maXhlZCkpO1xuICAgICAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dXAgdGhlIHZhcmlhYmxlcyBmb3IganVzdGlmaWNhdGlvbiBhbmQgYWxpZ25tZW50IG9mZnNldC5cbiAgICAgICAgdmFyIGV4dHJhID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIGFsaWdubWVudCBpZiB0aGVyZSBpcyBleHRyYSBsYXlvdXQgc3BhY2UuXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fYWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGRlbHRhIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnanVzdGlmeSc6XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhID0gZGVsdGEgLyBuVmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVhY2hhYmxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMYXlvdXQgdGhlIGl0ZW1zIHVzaW5nIHRoZSBjb21wdXRlZCBib3ggc2l6ZXMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaXRlbS5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICAvLyBJZ25vcmUgaGlkZGVuIGl0ZW1zLlxuICAgICAgICAgICAgaWYgKGl0ZW0uaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjb21wdXRlZCBzaXplIGZvciB0aGUgd2lkZ2V0LlxuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplcnNbaV0uc2l6ZTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgd2lkZ2V0IGdlb21ldHJ5IGFuZCBhZHZhbmNlIHRoZSByZWxldmFudCBlZGdlLlxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0LXRvLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgaXRlbS51cGRhdGUobGVmdCArIG9mZnNldCwgdG9wLCBzaXplICsgZXh0cmEsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gc2l6ZSArIGV4dHJhICsgdGhpcy5fc3BhY2luZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wLXRvLWJvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udXBkYXRlKGxlZnQsIHRvcCArIG9mZnNldCwgd2lkdGgsIHNpemUgKyBleHRyYSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCArPSBzaXplICsgZXh0cmEgKyB0aGlzLl9zcGFjaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodC10by1sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgaXRlbS51cGRhdGUobGVmdCAtIG9mZnNldCAtIHNpemUgLSBleHRyYSwgdG9wLCBzaXplICsgZXh0cmEsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gc2l6ZSArIGV4dHJhICsgdGhpcy5fc3BhY2luZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tLXRvLXRvcCc6XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udXBkYXRlKGxlZnQsIHRvcCAtIG9mZnNldCAtIHNpemUgLSBleHRyYSwgd2lkdGgsIHNpemUgKyBleHRyYSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAtPSBzaXplICsgZXh0cmEgKyB0aGlzLl9zcGFjaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQm94TGF5b3V0O1xufShQYW5lbExheW91dCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYEJveExheW91dGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChCb3hMYXlvdXQpIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJveCBsYXlvdXQgc3RyZXRjaCBmYWN0b3IgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBib3ggbGF5b3V0IHN0cmV0Y2ggZmFjdG9yIGZvciB0aGUgd2lkZ2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0cmV0Y2god2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlJDcuc3RyZXRjaFByb3BlcnR5LmdldCh3aWRnZXQpO1xuICAgIH1cbiAgICBCb3hMYXlvdXQuZ2V0U3RyZXRjaCA9IGdldFN0cmV0Y2g7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBib3ggbGF5b3V0IHN0cmV0Y2ggZmFjdG9yIGZvciB0aGUgZ2l2ZW4gd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgZm9yIHRoZSBzdHJldGNoIGZhY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRTdHJldGNoKHdpZGdldCwgdmFsdWUpIHtcbiAgICAgICAgUHJpdmF0ZSQ3LnN0cmV0Y2hQcm9wZXJ0eS5zZXQod2lkZ2V0LCB2YWx1ZSk7XG4gICAgfVxuICAgIEJveExheW91dC5zZXRTdHJldGNoID0gc2V0U3RyZXRjaDtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJveCBsYXlvdXQgc2l6ZSBiYXNpcyBmb3IgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJveCBsYXlvdXQgc2l6ZSBiYXNpcyBmb3IgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaXplQmFzaXMod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlJDcuc2l6ZUJhc2lzUHJvcGVydHkuZ2V0KHdpZGdldCk7XG4gICAgfVxuICAgIEJveExheW91dC5nZXRTaXplQmFzaXMgPSBnZXRTaXplQmFzaXM7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBib3ggbGF5b3V0IHNpemUgYmFzaXMgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHNpemUgYmFzaXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0U2l6ZUJhc2lzKHdpZGdldCwgdmFsdWUpIHtcbiAgICAgICAgUHJpdmF0ZSQ3LnNpemVCYXNpc1Byb3BlcnR5LnNldCh3aWRnZXQsIHZhbHVlKTtcbiAgICB9XG4gICAgQm94TGF5b3V0LnNldFNpemVCYXNpcyA9IHNldFNpemVCYXNpcztcbn0pKEJveExheW91dCB8fCAoQm94TGF5b3V0ID0ge30pKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSQ3O1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGEgd2lkZ2V0IHN0cmV0Y2ggZmFjdG9yLlxuICAgICAqL1xuICAgIFByaXZhdGUuc3RyZXRjaFByb3BlcnR5ID0gbmV3IEF0dGFjaGVkUHJvcGVydHkoe1xuICAgICAgICBuYW1lOiAnc3RyZXRjaCcsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgY29lcmNlOiBmdW5jdGlvbiAob3duZXIsIHZhbHVlKSB7IHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHZhbHVlKSk7IH0sXG4gICAgICAgIGNoYW5nZWQ6IG9uQ2hpbGRTaXppbmdDaGFuZ2VkXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGEgd2lkZ2V0IHNpemUgYmFzaXMuXG4gICAgICovXG4gICAgUHJpdmF0ZS5zaXplQmFzaXNQcm9wZXJ0eSA9IG5ldyBBdHRhY2hlZFByb3BlcnR5KHtcbiAgICAgICAgbmFtZTogJ3NpemVCYXNpcycsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgY29lcmNlOiBmdW5jdGlvbiAob3duZXIsIHZhbHVlKSB7IHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHZhbHVlKSk7IH0sXG4gICAgICAgIGNoYW5nZWQ6IG9uQ2hpbGRTaXppbmdDaGFuZ2VkXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEgZGlyZWN0aW9uIGhhcyBob3Jpem9udGFsIG9yaWVudGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSG9yaXpvbnRhbChkaXIpIHtcbiAgICAgICAgcmV0dXJuIGRpciA9PT0gJ2xlZnQtdG8tcmlnaHQnIHx8IGRpciA9PT0gJ3JpZ2h0LXRvLWxlZnQnO1xuICAgIH1cbiAgICBQcml2YXRlLmlzSG9yaXpvbnRhbCA9IGlzSG9yaXpvbnRhbDtcbiAgICAvKipcbiAgICAgKiBDbGFtcCBhIHNwYWNpbmcgdmFsdWUgdG8gYW4gaW50ZWdlciA+PSAwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wU3BhY2luZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICAgIH1cbiAgICBQcml2YXRlLmNsYW1wU3BhY2luZyA9IGNsYW1wU3BhY2luZztcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbmdlIGhhbmRsZXIgZm9yIHRoZSBhdHRhY2hlZCBzaXppbmcgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkNoaWxkU2l6aW5nQ2hhbmdlZChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50ICYmIGNoaWxkLnBhcmVudC5sYXlvdXQgaW5zdGFuY2VvZiBCb3hMYXlvdXQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5maXQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pKFByaXZhdGUkNyB8fCAoUHJpdmF0ZSQ3ID0ge30pKTtcblxuLyoqXG4gKiBBIHBhbmVsIHdoaWNoIGFycmFuZ2VzIGl0cyB3aWRnZXRzIGluIGEgc2luZ2xlIHJvdyBvciBjb2x1bW4uXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgYXJvdW5kIGEgW1tCb3hMYXlvdXRdXS5cbiAqL1xudmFyIEJveFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCb3hQYW5lbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm94IHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBib3ggcGFuZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm94UGFuZWwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IGxheW91dDogUHJpdmF0ZSQ4LmNyZWF0ZUxheW91dChvcHRpb25zKSB9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygnbG0tQm94UGFuZWwnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdwLUJveFBhbmVsJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm94UGFuZWwucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxheW91dCBkaXJlY3Rpb24gZm9yIHRoZSBib3ggcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kaXJlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGxheW91dCBkaXJlY3Rpb24gZm9yIHRoZSBib3ggcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuZGlyZWN0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3hQYW5lbC5wcm90b3R5cGUsIFwiYWxpZ25tZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY29udGVudCBhbGlnbm1lbnQgZm9yIHRoZSBib3ggcGFuZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYWxpZ25tZW50IG9mIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IGhhcyBubyBlZmZlY3QgaWYgdGhlIHdpZGdldHMgY2FuIGV4cGFuZCB0byBmaWxsIHRoZVxuICAgICAgICAgKiBlbnRpcmUgYm94IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmFsaWdubWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY29udGVudCBhbGlnbm1lbnQgZm9yIHRoZSBib3ggcGFuZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYWxpZ25tZW50IG9mIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IGhhcyBubyBlZmZlY3QgaWYgdGhlIHdpZGdldHMgY2FuIGV4cGFuZCB0byBmaWxsIHRoZVxuICAgICAgICAgKiBlbnRpcmUgYm94IGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5hbGlnbm1lbnQgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveFBhbmVsLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaW50ZXItZWxlbWVudCBzcGFjaW5nIGZvciB0aGUgYm94IHBhbmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuc3BhY2luZztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgaW50ZXItZWxlbWVudCBzcGFjaW5nIGZvciB0aGUgYm94IHBhbmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LnNwYWNpbmcgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtYWRkZWQnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIEJveFBhbmVsLnByb3RvdHlwZS5vbkNoaWxkQWRkZWQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIG1zZy5jaGlsZC5hZGRDbGFzcygnbG0tQm94UGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIG1zZy5jaGlsZC5hZGRDbGFzcygncC1Cb3hQYW5lbC1jaGlsZCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1yZW1vdmVkJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBCb3hQYW5lbC5wcm90b3R5cGUub25DaGlsZFJlbW92ZWQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIG1zZy5jaGlsZC5yZW1vdmVDbGFzcygnbG0tQm94UGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIG1zZy5jaGlsZC5yZW1vdmVDbGFzcygncC1Cb3hQYW5lbC1jaGlsZCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgfTtcbiAgICByZXR1cm4gQm94UGFuZWw7XG59KFBhbmVsKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgQm94UGFuZWxgIGNsYXNzIHN0YXRpY3MuXG4gKi9cbihmdW5jdGlvbiAoQm94UGFuZWwpIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJveCBwYW5lbCBzdHJldGNoIGZhY3RvciBmb3IgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJveCBwYW5lbCBzdHJldGNoIGZhY3RvciBmb3IgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdHJldGNoKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gQm94TGF5b3V0LmdldFN0cmV0Y2god2lkZ2V0KTtcbiAgICB9XG4gICAgQm94UGFuZWwuZ2V0U3RyZXRjaCA9IGdldFN0cmV0Y2g7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBib3ggcGFuZWwgc3RyZXRjaCBmYWN0b3IgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHN0cmV0Y2ggZmFjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFN0cmV0Y2god2lkZ2V0LCB2YWx1ZSkge1xuICAgICAgICBCb3hMYXlvdXQuc2V0U3RyZXRjaCh3aWRnZXQsIHZhbHVlKTtcbiAgICB9XG4gICAgQm94UGFuZWwuc2V0U3RyZXRjaCA9IHNldFN0cmV0Y2g7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBib3ggcGFuZWwgc2l6ZSBiYXNpcyBmb3IgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJveCBwYW5lbCBzaXplIGJhc2lzIGZvciB0aGUgd2lkZ2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNpemVCYXNpcyh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIEJveExheW91dC5nZXRTaXplQmFzaXMod2lkZ2V0KTtcbiAgICB9XG4gICAgQm94UGFuZWwuZ2V0U2l6ZUJhc2lzID0gZ2V0U2l6ZUJhc2lzO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYm94IHBhbmVsIHNpemUgYmFzaXMgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIHNpemUgYmFzaXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0U2l6ZUJhc2lzKHdpZGdldCwgdmFsdWUpIHtcbiAgICAgICAgQm94TGF5b3V0LnNldFNpemVCYXNpcyh3aWRnZXQsIHZhbHVlKTtcbiAgICB9XG4gICAgQm94UGFuZWwuc2V0U2l6ZUJhc2lzID0gc2V0U2l6ZUJhc2lzO1xufSkoQm94UGFuZWwgfHwgKEJveFBhbmVsID0ge30pKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSQ4O1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYm94IGxheW91dCBmb3IgdGhlIGdpdmVuIHBhbmVsIG9wdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGF5b3V0IHx8IG5ldyBCb3hMYXlvdXQob3B0aW9ucyk7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlTGF5b3V0ID0gY3JlYXRlTGF5b3V0O1xufSkoUHJpdmF0ZSQ4IHx8IChQcml2YXRlJDggPSB7fSkpO1xuXG4vKipcbiAqIEEgd2lkZ2V0IHdoaWNoIGRpc3BsYXlzIGNvbW1hbmQgaXRlbXMgYXMgYSBzZWFyY2hhYmxlIHBhbGV0dGUuXG4gKi9cbnZhciBDb21tYW5kUGFsZXR0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWFuZFBhbGV0dGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgcGFsZXR0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21tYW5kUGFsZXR0ZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHsgbm9kZTogUHJpdmF0ZSQ5LmNyZWF0ZU5vZGUoKSB9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fYWN0aXZlSW5kZXggPSAtMTtcbiAgICAgICAgX3RoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIF90aGlzLl9yZXN1bHRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ2xtLUNvbW1hbmRQYWxldHRlJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygncC1Db21tYW5kUGFsZXR0ZScpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLnNldEZsYWcoV2lkZ2V0LkZsYWcuRGlzYWxsb3dMYXlvdXQpO1xuICAgICAgICBfdGhpcy5jb21tYW5kcyA9IG9wdGlvbnMuY29tbWFuZHM7XG4gICAgICAgIF90aGlzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlciB8fCBDb21tYW5kUGFsZXR0ZS5kZWZhdWx0UmVuZGVyZXI7XG4gICAgICAgIF90aGlzLmNvbW1hbmRzLmNvbW1hbmRDaGFuZ2VkLmNvbm5lY3QoX3RoaXMuX29uR2VuZXJpY0NoYW5nZSwgX3RoaXMpO1xuICAgICAgICBfdGhpcy5jb21tYW5kcy5rZXlCaW5kaW5nQ2hhbmdlZC5jb25uZWN0KF90aGlzLl9vbkdlbmVyaWNDaGFuZ2UsIF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgd2lkZ2V0LlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9yZXN1bHRzID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLCBcInNlYXJjaE5vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbW1hbmQgcGFsZXR0ZSBzZWFyY2ggbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIGlzIHRoZSBub2RlIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWFyY2gtcmVsYXRlZCBlbGVtZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsbS1Db21tYW5kUGFsZXR0ZS1zZWFyY2gnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRQYWxldHRlLnByb3RvdHlwZSwgXCJpbnB1dE5vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbW1hbmQgcGFsZXR0ZSBpbnB1dCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFjdHVhbCBpbnB1dCBub2RlIGZvciB0aGUgc2VhcmNoIGFyZWEuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG0tQ29tbWFuZFBhbGV0dGUtaW5wdXQnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRQYWxldHRlLnByb3RvdHlwZSwgXCJjb250ZW50Tm9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tbWFuZCBwYWxldHRlIGNvbnRlbnQgbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIGlzIHRoZSBub2RlIHdoaWNoIGhvbGRzIHRoZSBjb21tYW5kIGl0ZW0gbm9kZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1vZGlmeWluZyB0aGlzIG5vZGUgZGlyZWN0bHkgY2FuIGxlYWQgdG8gdW5kZWZpbmVkIGJlaGF2aW9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xtLUNvbW1hbmRQYWxldHRlLWNvbnRlbnQnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRQYWxldHRlLnByb3RvdHlwZSwgXCJpdGVtc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlYWQtb25seSBhcnJheSBvZiB0aGUgY29tbWFuZCBpdGVtcyBpbiB0aGUgcGFsZXR0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb21tYW5kIGl0ZW0gdG8gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBjb21tYW5kIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tbWFuZCBpdGVtIGFkZGVkIHRvIHRoZSBwYWxldHRlLlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbW1hbmQgaXRlbSBmb3IgdGhlIG9wdGlvbnMuXG4gICAgICAgIHZhciBpdGVtID0gUHJpdmF0ZSQ5LmNyZWF0ZUl0ZW0odGhpcy5jb21tYW5kcywgb3B0aW9ucyk7XG4gICAgICAgIC8vIEFkZCB0aGUgaXRlbSB0byB0aGUgYXJyYXkuXG4gICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIC8vIFJlZnJlc2ggdGhlIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBpdGVtIGFkZGVkIHRvIHRoZSBwYWxldHRlLlxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgY29tbWFuZCBpdGVtcyB0byB0aGUgY29tbWFuZCBwYWxldHRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIC0gQW4gYXJyYXkgb2Ygb3B0aW9ucyBmb3IgY3JlYXRpbmcgZWFjaCBjb21tYW5kIGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tbWFuZCBpdGVtcyBhZGRlZCB0byB0aGUgcGFsZXR0ZS5cbiAgICAgKi9cbiAgICBDb21tYW5kUGFsZXR0ZS5wcm90b3R5cGUuYWRkSXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5ld0l0ZW1zID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBQcml2YXRlJDkuY3JlYXRlSXRlbShfdGhpcy5jb21tYW5kcywgaXRlbSk7IH0pO1xuICAgICAgICBuZXdJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy5faXRlbXMucHVzaChpdGVtKTsgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gbmV3SXRlbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBjb21tYW5kIHBhbGV0dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBwYWxldHRlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgaXRlbSBpcyBub3QgaW4gdGhlIHBhbGV0dGUuXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW1BdCh0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgaXRlbSBhdCBhIGdpdmVuIGluZGV4IGZyb20gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLnJlbW92ZUl0ZW1BdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgYXJyYXkuXG4gICAgICAgIHZhciBpdGVtID0gQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5faXRlbXMsIGluZGV4KTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWZyZXNoIHRoZSBzZWFyY2ggcmVzdWx0cy5cbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKi9cbiAgICBDb21tYW5kUGFsZXR0ZS5wcm90b3R5cGUuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIHJlbW92ZS5cbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSBhcnJheSBvZiBpdGVtcy5cbiAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gUmVmcmVzaCB0aGUgc2VhcmNoIHJlc3VsdHMuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHNlYXJjaCByZXN1bHRzIGFuZCBzY2hlZHVsZSBhbiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzZWFyY2ggcmVzdWx0cyBvZiB0aGUgcGFsZXR0ZVxuICAgICAqIHNob3VsZCBiZSB1cGRhdGVkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHBhbGV0dGUgYXMgbmVlZGVkLFxuICAgICAqIGJ1dCBjYW4gYmUgY2FsbGVkIG1hbnVhbGx5IGlmIHRoZSBpbnB1dCB0ZXh0IGlzIHByb2dyYW1hdGljYWxseVxuICAgICAqIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBUaGUgcmVuZGVyZWQgcmVzdWx0cyBhcmUgdXBkYXRlZCBhc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICBDb21tYW5kUGFsZXR0ZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlucHV0Tm9kZS52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHZhciBjbGVhciA9IHRoaXMubm9kZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsbS1jbG9zZS1pY29uJylbMF07XG4gICAgICAgICAgICBjbGVhci5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNsZWFyID0gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xtLWNsb3NlLWljb24nKVswXTtcbiAgICAgICAgICAgIGNsZWFyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBET00gZXZlbnQgc2VudCB0byB0aGUgY29tbWFuZCBwYWxldHRlLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIERPTSBgRXZlbnRMaXN0ZW5lcmAgaW50ZXJmYWNlIGFuZCBpc1xuICAgICAqIGNhbGxlZCBpbiByZXNwb25zZSB0byBldmVudHMgb24gdGhlIGNvbW1hbmQgcGFsZXR0ZSdzIERPTSBub2RlLlxuICAgICAqIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBDb21tYW5kUGFsZXR0ZS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0Q2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0S2V5RG93bihldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVGb2N1c2VkKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1hdHRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5vbkFmdGVyRGV0YWNoID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMsIHRydWUpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FjdGl2YXRlLXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5vbkFjdGl2YXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dE5vZGU7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCd1cGRhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLm9uVXBkYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGN1cnJlbnQgcXVlcnkgdGV4dCBhbmQgY29udGVudCBub2RlLlxuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLmlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGNvbnRlbnROb2RlID0gdGhpcy5jb250ZW50Tm9kZTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgZ2VuZXJhdGVkLlxuICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX3Jlc3VsdHM7XG4gICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYW5kIHN0b3JlIHRoZSBuZXcgc2VhcmNoIHJlc3VsdHMuXG4gICAgICAgICAgICByZXN1bHRzID0gdGhpcy5fcmVzdWx0cyA9IFByaXZhdGUkOS5zZWFyY2godGhpcy5faXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBhY3RpdmUgaW5kZXguXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVJbmRleCA9IChxdWVyeSA/IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHJlc3VsdHMsIFByaXZhdGUkOS5jYW5BY3RpdmF0ZSkgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcXVlcnkgYW5kIG5vIHJlc3VsdHMsIGNsZWFyIHRoZSBjb250ZW50LlxuICAgICAgICBpZiAoIXF1ZXJ5ICYmIHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBWaXJ0dWFsRE9NLnJlbmRlcihudWxsLCBjb250ZW50Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGlzIGEgcXVlcnkgYnV0IG5vIHJlc3VsdHMsIHJlbmRlciB0aGUgZW1wdHkgbWVzc2FnZS5cbiAgICAgICAgaWYgKHF1ZXJ5ICYmIHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudF8xID0gdGhpcy5yZW5kZXJlci5yZW5kZXJFbXB0eU1lc3NhZ2UoeyBxdWVyeTogcXVlcnkgfSk7XG4gICAgICAgICAgICBWaXJ0dWFsRE9NLnJlbmRlcihjb250ZW50XzEsIGNvbnRlbnROb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHJlbmRlciBjb250ZW50IGZvciB0aGUgc2VhcmNoIHJlc3VsdHMuXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuX2FjdGl2ZUluZGV4O1xuICAgICAgICB2YXIgY29udGVudCA9IG5ldyBBcnJheShyZXN1bHRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnaGVhZGVyJykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gcmVzdWx0LmluZGljZXM7XG4gICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gcmVzdWx0LmNhdGVnb3J5O1xuICAgICAgICAgICAgICAgIGNvbnRlbnRbaV0gPSByZW5kZXJlci5yZW5kZXJIZWFkZXIoeyBjYXRlZ29yeTogY2F0ZWdvcnksIGluZGljZXM6IGluZGljZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHJlc3VsdC5pdGVtO1xuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gcmVzdWx0LmluZGljZXM7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IGkgPT09IGFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnRlbnRbaV0gPSByZW5kZXJlci5yZW5kZXJJdGVtKHsgaXRlbTogaXRlbSwgaW5kaWNlczogaW5kaWNlcywgYWN0aXZlOiBhY3RpdmUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBzZWFyY2ggcmVzdWx0IGNvbnRlbnQuXG4gICAgICAgIFZpcnR1YWxET00ucmVuZGVyKGNvbnRlbnQsIGNvbnRlbnROb2RlKTtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBzY3JvbGwgcG9zaXRpb24gYXMgbmVlZGVkLlxuICAgICAgICBpZiAoYWN0aXZlSW5kZXggPCAwIHx8IGFjdGl2ZUluZGV4ID49IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250ZW50Tm9kZS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjb250ZW50Tm9kZS5jaGlsZHJlblthY3RpdmVJbmRleF07XG4gICAgICAgICAgICBFbGVtZW50RXh0LnNjcm9sbEludG9WaWV3SWZOZWVkZWQoY29udGVudE5vZGUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnY2xpY2snYCBldmVudCBmb3IgdGhlIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKi9cbiAgICBDb21tYW5kUGFsZXR0ZS5wcm90b3R5cGUuX2V2dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGNsaWNrIGlzIG5vdCB0aGUgbGVmdCBidXR0b24uXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBpbnB1dCBpZiB0aGUgdGFyZ2V0IGlzIGNsZWFyIGJ1dHRvblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImxtLWNsb3NlLWljb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXROb2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgaXRlbSB3aGljaCB3YXMgY2xpY2tlZC5cbiAgICAgICAgdmFyIGluZGV4ID0gQXJyYXlFeHQuZmluZEZpcnN0SW5kZXgodGhpcy5jb250ZW50Tm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBjbGljayB3YXMgbm90IG9uIGFuIGl0ZW0uXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBLaWxsIHRoZSBldmVudCB3aGVuIGEgY29udGVudCBpdGVtIGlzIGNsaWNrZWQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBpdGVtIGlmIHBvc3NpYmxlLlxuICAgICAgICB0aGlzLl9leGVjdXRlKGluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdrZXlkb3duJ2AgZXZlbnQgZm9yIHRoZSBjb21tYW5kIHBhbGV0dGUuXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLl9ldnRLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDEzOiAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZSh0aGlzLl9hY3RpdmVJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyBVcCBBcnJvd1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVQcmV2aW91c0l0ZW0oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDA6IC8vIERvd24gQXJyb3dcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlTmV4dEl0ZW0oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgdGhlIG5leHQgZW5hYmxlZCBjb21tYW5kIGl0ZW0uXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLl9hY3RpdmF0ZU5leHRJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGFyZSBubyBzZWFyY2ggcmVzdWx0cy5cbiAgICAgICAgaWYgKCF0aGlzLl9yZXN1bHRzIHx8IHRoaXMuX3Jlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgbmV4dCBlbmFibGVkIGl0ZW0gaW5kZXguXG4gICAgICAgIHZhciBhaSA9IHRoaXMuX2FjdGl2ZUluZGV4O1xuICAgICAgICB2YXIgbiA9IHRoaXMuX3Jlc3VsdHMubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhcnQgPSBhaSA8IG4gLSAxID8gYWkgKyAxIDogMDtcbiAgICAgICAgdmFyIHN0b3AgPSBzdGFydCA9PT0gMCA/IG4gLSAxIDogc3RhcnQgLSAxO1xuICAgICAgICB0aGlzLl9hY3RpdmVJbmRleCA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRoaXMuX3Jlc3VsdHMsIFByaXZhdGUkOS5jYW5BY3RpdmF0ZSwgc3RhcnQsIHN0b3ApO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgdGhlIHByZXZpb3VzIGVuYWJsZWQgY29tbWFuZCBpdGVtLlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5fYWN0aXZhdGVQcmV2aW91c0l0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgYXJlIG5vIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICBpZiAoIXRoaXMuX3Jlc3VsdHMgfHwgdGhpcy5fcmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBwcmV2aW91cyBlbmFibGVkIGl0ZW0gaW5kZXguXG4gICAgICAgIHZhciBhaSA9IHRoaXMuX2FjdGl2ZUluZGV4O1xuICAgICAgICB2YXIgbiA9IHRoaXMuX3Jlc3VsdHMubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhcnQgPSBhaSA8PSAwID8gbiAtIDEgOiBhaSAtIDE7XG4gICAgICAgIHZhciBzdG9wID0gc3RhcnQgPT09IG4gLSAxID8gMCA6IHN0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy5fYWN0aXZlSW5kZXggPSBBcnJheUV4dC5maW5kTGFzdEluZGV4KHRoaXMuX3Jlc3VsdHMsIFByaXZhdGUkOS5jYW5BY3RpdmF0ZSwgc3RhcnQsIHN0b3ApO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY29tbWFuZCBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgcG9zc2libGUuXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgYXJlIG5vIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICBpZiAoIXRoaXMuX3Jlc3VsdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIHZhciBwYXJ0ID0gdGhpcy5fcmVzdWx0c1tpbmRleF07XG4gICAgICAgIGlmICghcGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VhcmNoIHRleHQgaWYgdGhlIGl0ZW0gaXMgYSBoZWFkZXIuXG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0Tm9kZTtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gcGFydC5jYXRlZ29yeS50b0xvd2VyQ2FzZSgpICsgXCIgXCI7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBpZiBpdGVtIGlzIG5vdCBlbmFibGVkLlxuICAgICAgICBpZiAoIXBhcnQuaXRlbS5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBpdGVtLlxuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWN1dGUocGFydC5pdGVtLmNvbW1hbmQsIHBhcnQuaXRlbS5hcmdzKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHF1ZXJ5IHRleHQuXG4gICAgICAgIHRoaXMuaW5wdXROb2RlLnZhbHVlID0gJyc7XG4gICAgICAgIC8vIFJlZnJlc2ggdGhlIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgZm9jdXNlZCBtb2RpZmllciBiYXNlZCBvbiB0aGUgaW5wdXQgbm9kZSBmb2N1cyBzdGF0ZS5cbiAgICAgKi9cbiAgICBDb21tYW5kUGFsZXR0ZS5wcm90b3R5cGUuX3RvZ2dsZUZvY3VzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5pbnB1dE5vZGU7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoJ2xtLW1vZC1mb2N1c2VkJywgZm9jdXNlZCk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKCdwLW1vZC1mb2N1c2VkJywgZm9jdXNlZCk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2lnbmFsIGhhbmRsZXIgZm9yIGdlbmVyaWMgY29tbWFuZCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvbW1hbmRQYWxldHRlLnByb3RvdHlwZS5fb25HZW5lcmljQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tYW5kUGFsZXR0ZTtcbn0oV2lkZ2V0KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBgQ29tbWFuZFBhbGV0dGVgIGNsYXNzIHN0YXRpY3MuXG4gKi9cbihmdW5jdGlvbiAoQ29tbWFuZFBhbGV0dGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgSVJlbmRlcmVyYC5cbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIHZpcnR1YWwgZWxlbWVudCBmb3IgYSBjb21tYW5kIHBhbGV0dGUgaGVhZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBoZWFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaGVhZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckhlYWRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZm9ybWF0SGVhZGVyKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGgubGkoeyBjbGFzc05hbWU6ICdsbS1Db21tYW5kUGFsZXR0ZS1oZWFkZXInXG4gICAgICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgICAgICArICcgcC1Db21tYW5kUGFsZXR0ZS1oZWFkZXInXG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfSwgY29udGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIHZpcnR1YWwgZWxlbWVudCBmb3IgYSBjb21tYW5kIHBhbGV0dGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQSB2aXJ0dWFsIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckl0ZW0gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY3JlYXRlSXRlbUNsYXNzKGRhdGEpO1xuICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmNyZWF0ZUl0ZW1EYXRhc2V0KGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEuaXRlbS5pc1RvZ2dsZWFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGgubGkoe1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtY2hlY2tlZCc6IFwiXCIgKyBkYXRhLml0ZW0uaXNUb2dnbGVkXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5yZW5kZXJJdGVtSWNvbihkYXRhKSwgdGhpcy5yZW5kZXJJdGVtQ29udGVudChkYXRhKSwgdGhpcy5yZW5kZXJJdGVtU2hvcnRjdXQoZGF0YSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoaC5saSh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldFxuICAgICAgICAgICAgfSwgdGhpcy5yZW5kZXJJdGVtSWNvbihkYXRhKSwgdGhpcy5yZW5kZXJJdGVtQ29udGVudChkYXRhKSwgdGhpcy5yZW5kZXJJdGVtU2hvcnRjdXQoZGF0YSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgZW1wdHkgcmVzdWx0cyBtZXNzYWdlIGZvciBhIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWVzc2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQSB2aXJ0dWFsIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckVtcHR5TWVzc2FnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZm9ybWF0RW1wdHlNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGgubGkoe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xtLUNvbW1hbmRQYWxldHRlLWVtcHR5TWVzc2FnZSdcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLUNvbW1hbmRQYWxldHRlLWVtcHR5TWVzc2FnZSdcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9LCBjb250ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgaWNvbiBmb3IgYSBjb21tYW5kIHBhbGV0dGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgaWNvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQSB2aXJ0dWFsIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpY29uLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckl0ZW1JY29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNyZWF0ZUljb25DbGFzcyhkYXRhKTtcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLml0ZW0uaWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaC5kaXYoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCBkYXRhLml0ZW0uaWNvbkxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIGlmIGRhdGEuaXRlbS5pY29uIGlzIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBpZ25vcmVkXG4gICAgICAgICAgICByZXR1cm4gaC5kaXYoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCBkYXRhLml0ZW0uaWNvbiwgZGF0YS5pdGVtLmljb25MYWJlbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGNvbnRlbnQgZm9yIGEgY29tbWFuZCBwYWxldHRlIGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJdGVtQ29udGVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGguZGl2KHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdsbS1Db21tYW5kUGFsZXR0ZS1pdGVtQ29udGVudCdcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLUNvbW1hbmRQYWxldHRlLWl0ZW1Db250ZW50J1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH0sIHRoaXMucmVuZGVySXRlbUxhYmVsKGRhdGEpLCB0aGlzLnJlbmRlckl0ZW1DYXB0aW9uKGRhdGEpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGxhYmVsIGZvciBhIGNvbW1hbmQgcGFsZXR0ZSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBsYWJlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgQSB2aXJ0dWFsIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBsYWJlbC5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJdGVtTGFiZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmZvcm1hdEl0ZW1MYWJlbChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbG0tQ29tbWFuZFBhbGV0dGUtaXRlbUxhYmVsJ1xuICAgICAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICAgICAgKyAnIHAtQ29tbWFuZFBhbGV0dGUtaXRlbUxhYmVsJ1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH0sIGNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBjYXB0aW9uIGZvciBhIGNvbW1hbmQgcGFsZXR0ZSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBjYXB0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIHZpcnR1YWwgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNhcHRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySXRlbUNhcHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmZvcm1hdEl0ZW1DYXB0aW9uKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGguZGl2KHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdsbS1Db21tYW5kUGFsZXR0ZS1pdGVtQ2FwdGlvbidcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLUNvbW1hbmRQYWxldHRlLWl0ZW1DYXB0aW9uJ1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH0sIGNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBzaG9ydGN1dCBmb3IgYSBjb21tYW5kIHBhbGV0dGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgc2hvcnRjdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgc2hvcnRjdXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySXRlbVNob3J0Y3V0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5mb3JtYXRJdGVtU2hvcnRjdXQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gaC5kaXYoe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xtLUNvbW1hbmRQYWxldHRlLWl0ZW1TaG9ydGN1dCdcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLUNvbW1hbmRQYWxldHRlLWl0ZW1TaG9ydGN1dCdcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9LCBjb250ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgY2xhc3MgbmFtZSBmb3IgdGhlIGNvbW1hbmQgcGFsZXR0ZSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGNsYXNzIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBmdWxsIGNsYXNzIG5hbWUgZm9yIHRoZSBjb21tYW5kIHBhbGV0dGUgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJdGVtQ2xhc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBpbml0aWFsIGNsYXNzIG5hbWUuXG4gICAgICAgICAgICB2YXIgbmFtZSA9ICdsbS1Db21tYW5kUGFsZXR0ZS1pdGVtJztcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgbmFtZSArPSAnIHAtQ29tbWFuZFBhbGV0dGUtaXRlbSc7XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGJvb2xlYW4gc3RhdGUgY2xhc3Nlcy5cbiAgICAgICAgICAgIGlmICghZGF0YS5pdGVtLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBsbS1tb2QtZGlzYWJsZWQnO1xuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBwLW1vZC1kaXNhYmxlZCc7XG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuaXRlbS5pc1RvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICcgbG0tbW9kLXRvZ2dsZWQnO1xuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBwLW1vZC10b2dnbGVkJztcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICcgbG0tbW9kLWFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIHAtbW9kLWFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBleHRyYSBjbGFzcy5cbiAgICAgICAgICAgIHZhciBleHRyYSA9IGRhdGEuaXRlbS5jbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiIFwiICsgZXh0cmE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNvbXBsZXRlIGNsYXNzIG5hbWUuXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgZGF0YXNldCBmb3IgdGhlIGNvbW1hbmQgcGFsZXR0ZSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgY3JlYXRpbmcgdGhlIGRhdGFzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBkYXRhc2V0IGZvciB0aGUgY29tbWFuZCBwYWxldHRlIGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSXRlbURhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhLml0ZW0uZGF0YXNldCksIHsgY29tbWFuZDogZGF0YS5pdGVtLmNvbW1hbmQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIGNsYXNzIG5hbWUgZm9yIHRoZSBjb21tYW5kIGl0ZW0gaWNvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSBjbGFzcyBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgZnVsbCBjbGFzcyBuYW1lIGZvciB0aGUgaXRlbSBpY29uLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUljb25DbGFzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICdsbS1Db21tYW5kUGFsZXR0ZS1pdGVtSWNvbic7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIG5hbWUgKz0gJyBwLUNvbW1hbmRQYWxldHRlLWl0ZW1JY29uJztcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHZhciBleHRyYSA9IGRhdGEuaXRlbS5pY29uQ2xhc3M7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmEgPyBuYW1lICsgXCIgXCIgKyBleHRyYSA6IG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIHJlbmRlciBjb250ZW50IGZvciB0aGUgaGVhZGVyIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgaGVhZGVyIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBjb250ZW50IHRvIGFkZCB0byB0aGUgaGVhZGVyIG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuZm9ybWF0SGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YS5pbmRpY2VzIHx8IGRhdGEuaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jYXRlZ29yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFeHQuaGlnaGxpZ2h0KGRhdGEuY2F0ZWdvcnksIGRhdGEuaW5kaWNlcywgaC5tYXJrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgcmVuZGVyIGNvbnRlbnQgZm9yIHRoZSBlbXB0eSBtZXNzYWdlIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgZW1wdHkgbWVzc2FnZSBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgY29udGVudCB0byBhZGQgdG8gdGhlIGVtcHR5IG1lc3NhZ2Ugbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5mb3JtYXRFbXB0eU1lc3NhZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29tbWFuZHMgZm91bmQgdGhhdCBtYXRjaCAnXCIgKyBkYXRhLnF1ZXJ5ICsgXCInXCI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIHJlbmRlciBjb250ZW50IGZvciB0aGUgaXRlbSBzaG9ydGN1dCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIHNob3J0Y3V0IGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBjb250ZW50IHRvIGFkZCB0byB0aGUgc2hvcnRjdXQgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5mb3JtYXRJdGVtU2hvcnRjdXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGtiID0gZGF0YS5pdGVtLmtleUJpbmRpbmc7XG4gICAgICAgICAgICByZXR1cm4ga2IgPyBrYi5rZXlzLm1hcChDb21tYW5kUmVnaXN0cnkuZm9ybWF0S2V5c3Ryb2tlKS5qb2luKCcsICcpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgcmVuZGVyIGNvbnRlbnQgZm9yIHRoZSBpdGVtIGxhYmVsIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgbGFiZWwgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSBsYWJlbCBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmZvcm1hdEl0ZW1MYWJlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaW5kaWNlcyB8fCBkYXRhLmluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaXRlbS5sYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFeHQuaGlnaGxpZ2h0KGRhdGEuaXRlbS5sYWJlbCwgZGF0YS5pbmRpY2VzLCBoLm1hcmspO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSByZW5kZXIgY29udGVudCBmb3IgdGhlIGl0ZW0gY2FwdGlvbiBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGNhcHRpb24gY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSBjYXB0aW9uIG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuZm9ybWF0SXRlbUNhcHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuaXRlbS5jYXB0aW9uO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICBDb21tYW5kUGFsZXR0ZS5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGBSZW5kZXJlcmAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgQ29tbWFuZFBhbGV0dGUuZGVmYXVsdFJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG59KShDb21tYW5kUGFsZXR0ZSB8fCAoQ29tbWFuZFBhbGV0dGUgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJDk7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIERPTSBub2RlIGZvciBhIGNvbW1hbmQgcGFsZXR0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVOb2RlKCkge1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgc2VhcmNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgdmFyIGNsZWFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNlYXJjaC5jbGFzc05hbWUgPSAnbG0tQ29tbWFuZFBhbGV0dGUtc2VhcmNoJztcbiAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSAnbG0tQ29tbWFuZFBhbGV0dGUtd3JhcHBlcic7XG4gICAgICAgIGlucHV0LmNsYXNzTmFtZSA9ICdsbS1Db21tYW5kUGFsZXR0ZS1pbnB1dCc7XG4gICAgICAgIGNsZWFyLmNsYXNzTmFtZSA9ICdsbS1jbG9zZS1pY29uJztcbiAgICAgICAgY29udGVudC5jbGFzc05hbWUgPSAnbG0tQ29tbWFuZFBhbGV0dGUtY29udGVudCc7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBzZWFyY2guY2xhc3NMaXN0LmFkZCgncC1Db21tYW5kUGFsZXR0ZS1zZWFyY2gnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdwLUNvbW1hbmRQYWxldHRlLXdyYXBwZXInKTtcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgncC1Db21tYW5kUGFsZXR0ZS1pbnB1dCcpO1xuICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3AtQ29tbWFuZFBhbGV0dGUtY29udGVudCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIGlucHV0LnNwZWxsY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoY2xlYXIpO1xuICAgICAgICBzZWFyY2guYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc2VhcmNoKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlTm9kZSA9IGNyZWF0ZU5vZGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbW1hbmQgaXRlbSBmcm9tIGEgY29tbWFuZCByZWdpc3RyeSBhbmQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJdGVtKGNvbW1hbmRzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWFuZEl0ZW0oY29tbWFuZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCBhbiBhcnJheSBvZiBjb21tYW5kIGl0ZW1zIGZvciBmdXp6eSBtYXRjaGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlYXJjaChpdGVtcywgcXVlcnkpIHtcbiAgICAgICAgLy8gRnV6enkgbWF0Y2ggdGhlIGl0ZW1zIGZvciB0aGUgcXVlcnkuXG4gICAgICAgIHZhciBzY29yZXMgPSBtYXRjaEl0ZW1zKGl0ZW1zLCBxdWVyeSk7XG4gICAgICAgIC8vIFNvcnQgdGhlIGl0ZW1zIGJhc2VkIG9uIHRoZWlyIHNjb3JlLlxuICAgICAgICBzY29yZXMuc29ydChzY29yZUNtcCk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcmVzdWx0cyBmb3IgdGhlIHNlYXJjaC5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdHMoc2NvcmVzKTtcbiAgICB9XG4gICAgUHJpdmF0ZS5zZWFyY2ggPSBzZWFyY2g7XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEgcmVzdWx0IGl0ZW0gY2FuIGJlIGFjdGl2YXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5BY3RpdmF0ZShyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50eXBlID09PSAnaXRlbScgJiYgcmVzdWx0Lml0ZW0uaXNFbmFibGVkO1xuICAgIH1cbiAgICBQcml2YXRlLmNhbkFjdGl2YXRlID0gY2FuQWN0aXZhdGU7XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgY2F0ZWdvcnkgZm9yIGEgY29tbWFuZCBpdGVtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNhdGVnb3J5KGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiBjYXRlZ29yeS50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIHF1ZXJ5IHRleHQgZm9yIGEgZnV6enkgc2VhcmNoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxzKy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIGZ1enp5IG1hdGNoIG9uIGFuIGFycmF5IG9mIGNvbW1hbmQgaXRlbXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hJdGVtcyhpdGVtcywgcXVlcnkpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBxdWVyeSB0ZXh0IHRvIGxvd2VyIGNhc2Ugd2l0aCBubyB3aGl0ZXNwYWNlLlxuICAgICAgICBxdWVyeSA9IG5vcm1hbGl6ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBhcnJheSB0byBob2xkIHRoZSBzY29yZXMuXG4gICAgICAgIHZhciBzY29yZXMgPSBbXTtcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBhbmQgbWF0Y2ggYWdhaW5zdCB0aGUgcXVlcnkuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaXRlbXMgd2hpY2ggYXJlIG5vdCB2aXNpYmxlLlxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGlmICghaXRlbS5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBxdWVyeSBpcyBlbXB0eSwgYWxsIGl0ZW1zIGFyZSBtYXRjaGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtYXRjaFR5cGU6IDMgLyogRGVmYXVsdCAqLyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRpY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbEluZGljZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiAwLCBpdGVtOiBpdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGZ1enp5IHNlYXJjaCBmb3IgdGhlIGl0ZW0gYW5kIHF1ZXJ5LlxuICAgICAgICAgICAgdmFyIHNjb3JlID0gZnV6enlTZWFyY2goaXRlbSwgcXVlcnkpO1xuICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBpdGVtIGlmIGl0IGlzIG5vdCBhIG1hdGNoLlxuICAgICAgICAgICAgaWYgKCFzY29yZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVuYWxpemUgZGlzYWJsZWQgaXRlbXMuXG4gICAgICAgICAgICAvLyBUT0RPIC0gcHVzaCBkaXNhYmxlZCBpdGVtcyBhbGwgdGhlIHdheSBkb3duIGluIHNvcnQgY21wP1xuICAgICAgICAgICAgaWYgKCFpdGVtLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHNjb3JlLnNjb3JlICs9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIHNjb3JlIHRvIHRoZSByZXN1bHRzLlxuICAgICAgICAgICAgc2NvcmVzLnB1c2goc2NvcmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgZmluYWwgYXJyYXkgb2Ygc2NvcmVzLlxuICAgICAgICByZXR1cm4gc2NvcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZnV6enkgc2VhcmNoIG9uIGEgc2luZ2xlIGNvbW1hbmQgaXRlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdXp6eVNlYXJjaChpdGVtLCBxdWVyeSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHNvdXJjZSB0ZXh0IHRvIGJlIHNlYXJjaGVkLlxuICAgICAgICB2YXIgY2F0ZWdvcnkgPSBpdGVtLmNhdGVnb3J5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBsYWJlbCA9IGl0ZW0ubGFiZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGNhdGVnb3J5ICsgXCIgXCIgKyBsYWJlbDtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBtYXRjaCBzY29yZSBhbmQgaW5kaWNlcyBhcnJheS5cbiAgICAgICAgdmFyIHNjb3JlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBpbmRpY2VzID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIHJlZ2V4IGZvciBzZWFyY2ggd29yZCBib3VuZGFyaWVzXG4gICAgICAgIHZhciByZ3ggPSAvXFxiXFx3L2c7XG4gICAgICAgIC8vIFNlYXJjaCB0aGUgc291cmNlIGJ5IHdvcmQgYm91bmRhcnkuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHdvcmQgYm91bmRhcnkgaW4gdGhlIHNvdXJjZS5cbiAgICAgICAgICAgIHZhciByZ3hNYXRjaCA9IHJneC5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICAvLyBCcmVhayBpZiB0aGVyZSBpcyBubyBtb3JlIHNvdXJjZSBjb250ZXh0LlxuICAgICAgICAgICAgaWYgKCFyZ3hNYXRjaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIHRoZSBzdHJpbmcgbWF0Y2ggb24gdGhlIHJlbGV2YW50IHN1YnN0cmluZy5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IFN0cmluZ0V4dC5tYXRjaFN1bU9mRGVsdGFzKHNvdXJjZSwgcXVlcnksIHJneE1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIC8vIEJyZWFrIGlmIHRoZXJlIGlzIG5vIG1hdGNoLlxuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXRjaCBpZiB0aGUgc2NvcmUgaXMgYmV0dGVyLlxuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLnNjb3JlIDw9IHNjb3JlKSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgPSBtYXRjaC5zY29yZTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzID0gbWF0Y2guaW5kaWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAgICAgICAgaWYgKCFpbmRpY2VzIHx8IHNjb3JlID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGl2b3QgaW5kZXggYmV0d2VlbiBjYXRlZ29yeSBhbmQgbGFiZWwgdGV4dC5cbiAgICAgICAgdmFyIHBpdm90ID0gY2F0ZWdvcnkubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gRmluZCB0aGUgc2xpY2UgaW5kZXggdG8gc2VwYXJhdGUgbWF0Y2hlZCBpbmRpY2VzLlxuICAgICAgICB2YXIgaiA9IEFycmF5RXh0Lmxvd2VyQm91bmQoaW5kaWNlcywgcGl2b3QsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIG1hdGNoZWQgY2F0ZWdvcnkgYW5kIGxhYmVsIGluZGljZXMuXG4gICAgICAgIHZhciBjYXRlZ29yeUluZGljZXMgPSBpbmRpY2VzLnNsaWNlKDAsIGopO1xuICAgICAgICB2YXIgbGFiZWxJbmRpY2VzID0gaW5kaWNlcy5zbGljZShqKTtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBsYWJlbCBpbmRpY2VzIGZvciB0aGUgcGl2b3Qgb2Zmc2V0LlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxhYmVsSW5kaWNlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGxhYmVsSW5kaWNlc1tpXSAtPSBwaXZvdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYSBwdXJlIGxhYmVsIG1hdGNoLlxuICAgICAgICBpZiAoY2F0ZWdvcnlJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXRjaFR5cGU6IDAgLyogTGFiZWwgKi8sXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRpY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgIGxhYmVsSW5kaWNlczogbGFiZWxJbmRpY2VzLFxuICAgICAgICAgICAgICAgIHNjb3JlOiBzY29yZSwgaXRlbTogaXRlbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYSBwdXJlIGNhdGVnb3J5IG1hdGNoLlxuICAgICAgICBpZiAobGFiZWxJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXRjaFR5cGU6IDEgLyogQ2F0ZWdvcnkgKi8sXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRpY2VzOiBjYXRlZ29yeUluZGljZXMsXG4gICAgICAgICAgICAgICAgbGFiZWxJbmRpY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjb3JlOiBzY29yZSwgaXRlbTogaXRlbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYSBzcGxpdCBtYXRjaC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoVHlwZTogMiAvKiBTcGxpdCAqLyxcbiAgICAgICAgICAgIGNhdGVnb3J5SW5kaWNlczogY2F0ZWdvcnlJbmRpY2VzLFxuICAgICAgICAgICAgbGFiZWxJbmRpY2VzOiBsYWJlbEluZGljZXMsXG4gICAgICAgICAgICBzY29yZTogc2NvcmUsIGl0ZW06IGl0ZW1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzb3J0IGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGEgbWF0Y2ggc2NvcmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NvcmVDbXAoYSwgYikge1xuICAgICAgICAvLyBGaXJzdCBjb21wYXJlIGJhc2VkIG9uIHRoZSBtYXRjaCB0eXBlXG4gICAgICAgIHZhciBtMSA9IGEubWF0Y2hUeXBlIC0gYi5tYXRjaFR5cGU7XG4gICAgICAgIGlmIChtMSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgY29tcGFyZSBiYXNlZCBvbiB0aGUgbWF0Y2ggc2NvcmUuXG4gICAgICAgIHZhciBkMSA9IGEuc2NvcmUgLSBiLnNjb3JlO1xuICAgICAgICBpZiAoZDEgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaCBpbmRleCBiYXNlZCBvbiB0aGUgbWF0Y2ggdHlwZS5cbiAgICAgICAgdmFyIGkxID0gMDtcbiAgICAgICAgdmFyIGkyID0gMDtcbiAgICAgICAgc3dpdGNoIChhLm1hdGNoVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIExhYmVsICovOlxuICAgICAgICAgICAgICAgIGkxID0gYS5sYWJlbEluZGljZXNbMF07XG4gICAgICAgICAgICAgICAgaTIgPSBiLmxhYmVsSW5kaWNlc1swXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBDYXRlZ29yeSAqLzpcbiAgICAgICAgICAgIGNhc2UgMiAvKiBTcGxpdCAqLzpcbiAgICAgICAgICAgICAgICBpMSA9IGEuY2F0ZWdvcnlJbmRpY2VzWzBdO1xuICAgICAgICAgICAgICAgIGkyID0gYi5jYXRlZ29yeUluZGljZXNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBiYXNlZCBvbiB0aGUgbWF0Y2ggaW5kZXguXG4gICAgICAgIGlmIChpMSAhPT0gaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMSAtIGkyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgY29tcGFyZSBieSBjYXRlZ29yeS5cbiAgICAgICAgdmFyIGQyID0gYS5pdGVtLmNhdGVnb3J5LmxvY2FsZUNvbXBhcmUoYi5pdGVtLmNhdGVnb3J5KTtcbiAgICAgICAgaWYgKGQyICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjb21wYXJlIGJ5IHJhbmsuXG4gICAgICAgIHZhciByMSA9IGEuaXRlbS5yYW5rO1xuICAgICAgICB2YXIgcjIgPSBiLml0ZW0ucmFuaztcbiAgICAgICAgaWYgKHIxICE9PSByMikge1xuICAgICAgICAgICAgcmV0dXJuIHIxIDwgcjIgPyAtMSA6IDE7IC8vIEluZmluaXR5IHNhZmVcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBjb21wYXJlIGJ5IGxhYmVsLlxuICAgICAgICByZXR1cm4gYS5pdGVtLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5pdGVtLmxhYmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSByZXN1bHRzIGZyb20gYW4gYXJyYXkgb2Ygc29ydGVkIHNjb3Jlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXN1bHRzKHNjb3Jlcykge1xuICAgICAgICAvLyBTZXQgdXAgYW4gYXJyYXkgdG8gdHJhY2sgd2hpY2ggc2NvcmVzIGhhdmUgYmVlbiB2aXNpdGVkLlxuICAgICAgICB2YXIgdmlzaXRlZCA9IG5ldyBBcnJheShzY29yZXMubGVuZ3RoKTtcbiAgICAgICAgQXJyYXlFeHQuZmlsbCh2aXNpdGVkLCBmYWxzZSk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgc2VhcmNoIHJlc3VsdHMgYXJyYXkuXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIHNjb3JlIGluIHRoZSBhcnJheS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzY29yZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgYSBzY29yZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjdXJyZW50IGl0ZW0gYW5kIGluZGljZXMuXG4gICAgICAgICAgICB2YXIgX2EgPSBzY29yZXNbaV0sIGl0ZW0gPSBfYS5pdGVtLCBjYXRlZ29yeUluZGljZXMgPSBfYS5jYXRlZ29yeUluZGljZXM7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjYXRlZ29yeSBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IGl0ZW0uY2F0ZWdvcnk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGhlYWRlciByZXN1bHQgZm9yIHRoZSBjYXRlZ29yeS5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IHR5cGU6ICdoZWFkZXInLCBjYXRlZ29yeTogY2F0ZWdvcnksIGluZGljZXM6IGNhdGVnb3J5SW5kaWNlcyB9KTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJlc3Qgb2YgdGhlIHNjb3JlcyB3aXRoIHRoZSBzYW1lIGNhdGVnb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYSBzY29yZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtqXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgZGF0YSBmb3IgdGhlIGN1cnJlbnQgc2NvcmUuXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gc2NvcmVzW2pdLCBpdGVtXzEgPSBfYi5pdGVtLCBsYWJlbEluZGljZXMgPSBfYi5sYWJlbEluZGljZXM7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFuIGl0ZW0gd2l0aCBhIGRpZmZlcmVudCBjYXRlZ29yeS5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbV8xLmNhdGVnb3J5ICE9PSBjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBpdGVtIHJlc3VsdCBmb3IgdGhlIHNjb3JlLlxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IHR5cGU6ICdpdGVtJywgaXRlbTogaXRlbV8xLCBpbmRpY2VzOiBsYWJlbEluZGljZXMgfSk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgc2NvcmUgYXMgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbal0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgZmluYWwgcmVzdWx0cy5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYENvbW1hbmRQYWxldHRlLklJdGVtYC5cbiAgICAgKi9cbiAgICB2YXIgQ29tbWFuZEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgY29tbWFuZCBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29tbWFuZEl0ZW0oY29tbWFuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbW1hbmRzID0gY29tbWFuZHM7XG4gICAgICAgICAgICB0aGlzLmNhdGVnb3J5ID0gbm9ybWFsaXplQ2F0ZWdvcnkob3B0aW9ucy5jYXRlZ29yeSk7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmQgPSBvcHRpb25zLmNvbW1hbmQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBvcHRpb25zLmFyZ3MgfHwgSlNPTkV4dC5lbXB0eU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IG9wdGlvbnMucmFuayAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yYW5rIDogSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBkaXNwbGF5IGxhYmVsIGZvciB0aGUgY29tbWFuZCBpdGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZHMubGFiZWwodGhpcy5jb21tYW5kLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tYW5kSXRlbS5wcm90b3R5cGUsIFwiaWNvblwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBpY29uIHJlbmRlcmVyIGZvciB0aGUgY29tbWFuZCBpdGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZHMuaWNvbih0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJpY29uQ2xhc3NcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaWNvbiBjbGFzcyBmb3IgdGhlIGNvbW1hbmQgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmljb25DbGFzcyh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJpY29uTGFiZWxcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaWNvbiBsYWJlbCBmb3IgdGhlIGNvbW1hbmQgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmljb25MYWJlbCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJjYXB0aW9uXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGRpc3BsYXkgY2FwdGlvbiBmb3IgdGhlIGNvbW1hbmQgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmNhcHRpb24odGhpcy5jb21tYW5kLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tYW5kSXRlbS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGV4dHJhIGNsYXNzIG5hbWUgZm9yIHRoZSBjb21tYW5kIGl0ZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5jbGFzc05hbWUodGhpcy5jb21tYW5kLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21tYW5kSXRlbS5wcm90b3R5cGUsIFwiZGF0YXNldFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBkYXRhc2V0IGZvciB0aGUgY29tbWFuZCBpdGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZHMuZGF0YXNldCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJpc0VuYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb21tYW5kIGl0ZW0gaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzRW5hYmxlZCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJpc1RvZ2dsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb21tYW5kIGl0ZW0gaXMgdG9nZ2xlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzVG9nZ2xlZCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJpc1RvZ2dsZWFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb21tYW5kIGl0ZW0gaXMgdG9nZ2xlYWJsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzVG9nZ2xlYWJsZSh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJpc1Zpc2libGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb21tYW5kIGl0ZW0gaXMgdmlzaWJsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzVmlzaWJsZSh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbW1hbmRJdGVtLnByb3RvdHlwZSwgXCJrZXlCaW5kaW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGtleSBiaW5kaW5nIGZvciB0aGUgY29tbWFuZCBpdGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb21tYW5kID0gX2EuY29tbWFuZCwgYXJncyA9IF9hLmFyZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5RXh0LmZpbmRMYXN0VmFsdWUodGhpcy5fY29tbWFuZHMua2V5QmluZGluZ3MsIGZ1bmN0aW9uIChrYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2IuY29tbWFuZCA9PT0gY29tbWFuZCAmJiBKU09ORXh0LmRlZXBFcXVhbChrYi5hcmdzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KSB8fCBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDb21tYW5kSXRlbTtcbiAgICB9KCkpO1xufSkoUHJpdmF0ZSQ5IHx8IChQcml2YXRlJDkgPSB7fSkpO1xuXG4vKipcbiAqIEEgd2lkZ2V0IHdoaWNoIGRpc3BsYXlzIGl0ZW1zIGFzIGEgY2Fub25pY2FsIG1lbnUuXG4gKi9cbnZhciBNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW51LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBtZW51LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBtZW51LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lbnUob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IG5vZGU6IFByaXZhdGUkYS5jcmVhdGVOb2RlKCkgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NoaWxkSW5kZXggPSAtMTtcbiAgICAgICAgX3RoaXMuX2FjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgIF90aGlzLl9vcGVuVGltZXJJRCA9IDA7XG4gICAgICAgIF90aGlzLl9jbG9zZVRpbWVySUQgPSAwO1xuICAgICAgICBfdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2NoaWxkTWVudSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9wYXJlbnRNZW51ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2Fib3V0VG9DbG9zZSA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fbWVudVJlcXVlc3RlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygnbG0tTWVudScpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3AtTWVudScpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLnNldEZsYWcoV2lkZ2V0LkZsYWcuRGlzYWxsb3dMYXlvdXQpO1xuICAgICAgICBfdGhpcy5jb21tYW5kcyA9IG9wdGlvbnMuY29tbWFuZHM7XG4gICAgICAgIF90aGlzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlciB8fCBNZW51LmRlZmF1bHRSZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA9IDA7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnUucHJvdG90eXBlLCBcImFib3V0VG9DbG9zZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIGp1c3QgYmVmb3JlIHRoZSBtZW51IGlzIGNsb3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHNpZ25hbCBpcyBlbWl0dGVkIHdoZW4gdGhlIG1lbnUgcmVjZWl2ZXMgYSBgJ2Nsb3NlLXJlcXVlc3QnYFxuICAgICAgICAgKiBtZXNzYWdlLCBqdXN0IGJlZm9yZSBpdCByZW1vdmVzIGl0c2VsZiBmcm9tIHRoZSBET00uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIG5vdCBlbWl0dGVkIGlmIHRoZSBtZW51IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbVxuICAgICAgICAgKiB0aGUgRE9NIHdoZW4gaXQgcmVjZWl2ZXMgdGhlIGAnY2xvc2UtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm91dFRvQ2xvc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51LnByb3RvdHlwZSwgXCJtZW51UmVxdWVzdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiBhIG5ldyBtZW51IGlzIHJlcXVlc3RlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHNpZ25hbCBpcyBlbWl0dGVkIHdoZW5ldmVyIHRoZSB1c2VyIHByZXNzZXMgdGhlIHJpZ2h0IG9yIGxlZnRcbiAgICAgICAgICogYXJyb3cga2V5cywgYW5kIGEgc3VibWVudSBjYW5ub3QgYmUgb3BlbmVkIG9yIGNsb3NlZCBpbiByZXNwb25zZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBzaWduYWwgaXMgdXNlZnVsIHdoZW4gaW1wbGVtZW50aW5nIG1lbnUgYmFycyBpbiBvcmRlciB0byBvcGVuXG4gICAgICAgICAqIHRoZSBuZXh0IG9yIHByZXZpb3VzIG1lbnUgaW4gcmVzcG9uc2UgdG8gYSB1c2VyIGtleSBwcmVzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBzaWduYWwgaXMgb25seSBlbWl0dGVkIGZvciB0aGUgcm9vdCBtZW51IGluIGEgaGllcmFyY2h5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVudVJlcXVlc3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnUucHJvdG90eXBlLCBcInBhcmVudE1lbnVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCBtZW51IG9mIHRoZSBtZW51LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgYG51bGxgIHVubGVzcyB0aGUgbWVudSBpcyBhbiBvcGVuIHN1Ym1lbnUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRNZW51O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudS5wcm90b3R5cGUsIFwiY2hpbGRNZW51XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGlsZCBtZW51IG9mIHRoZSBtZW51LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgYG51bGxgIHVubGVzcyB0aGUgbWVudSBoYXMgYW4gb3BlbiBzdWJtZW51LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRNZW51O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudS5wcm90b3R5cGUsIFwicm9vdE1lbnVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvb3QgbWVudSBvZiB0aGUgbWVudSBoaWVyYXJjaHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZW51ID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChtZW51Ll9wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICAgICAgbWVudSA9IG1lbnUuX3BhcmVudE1lbnU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVudTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnUucHJvdG90eXBlLCBcImxlYWZNZW51XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsZWFmIG1lbnUgb2YgdGhlIG1lbnUgaGllcmFyY2h5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVudSA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAobWVudS5fY2hpbGRNZW51KSB7XG4gICAgICAgICAgICAgICAgbWVudSA9IG1lbnUuX2NoaWxkTWVudTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW51O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudS5wcm90b3R5cGUsIFwiY29udGVudE5vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1lbnUgY29udGVudCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIG5vZGUgd2hpY2ggaG9sZHMgdGhlIG1lbnUgaXRlbSBub2Rlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTW9kaWZ5aW5nIHRoaXMgbm9kZSBkaXJlY3RseSBjYW4gbGVhZCB0byB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG0tTWVudS1jb250ZW50JylbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51LnByb3RvdHlwZSwgXCJhY3RpdmVJdGVtXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBtZW51IGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1t0aGlzLl9hY3RpdmVJbmRleF0gfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBtZW51IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogSWYgdGhlIGl0ZW0gY2Fubm90IGJlIGFjdGl2YXRlZCwgdGhlIGl0ZW0gd2lsbCBiZSBzZXQgdG8gYG51bGxgLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSB2YWx1ZSA/IHRoaXMuX2l0ZW1zLmluZGV4T2YodmFsdWUpIDogLTE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51LnByb3RvdHlwZSwgXCJhY3RpdmVJbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgYC0xYCBpZiBubyBtZW51IGl0ZW0gaXMgYWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBJZiB0aGUgaXRlbSBjYW5ub3QgYmUgYWN0aXZhdGVkLCB0aGUgaW5kZXggd2lsbCBiZSBzZXQgdG8gYC0xYC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHZhbHVlIGZvciBhbiBvdXQgb2YgcmFuZ2UgaW5kZXguXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGl0ZW0gY2FuIGJlIGFjdGl2YXRlZC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gLTEgJiYgIVByaXZhdGUkYS5jYW5BY3RpdmF0ZSh0aGlzLl9pdGVtc1t2YWx1ZV0pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJhaWwgaWYgdGhlIGluZGV4IHdpbGwgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVJbmRleCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGFjdGl2ZSBpbmRleC5cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBNYWtlIGFjdGl2ZSBlbGVtZW50IGluIGZvY3VzXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlSW5kZXggPj0gMCAmJiB0aGlzLmNvbnRlbnROb2RlLmNoaWxkTm9kZXNbdGhpcy5fYWN0aXZlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZS5jaGlsZE5vZGVzW3RoaXMuX2FjdGl2ZUluZGV4XS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBpdGVtcy5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlYWQtb25seSBhcnJheSBvZiB0aGUgbWVudSBpdGVtcyBpbiB0aGUgbWVudS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgbmV4dCBzZWxlY3RhYmxlIGl0ZW0gaW4gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgbm8gaXRlbSBpcyBzZWxlY3RhYmxlLCB0aGUgaW5kZXggd2lsbCBiZSBzZXQgdG8gYC0xYC5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5hY3RpdmF0ZU5leHRJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICAgICAgdmFyIGFpID0gdGhpcy5fYWN0aXZlSW5kZXg7XG4gICAgICAgIHZhciBzdGFydCA9IGFpIDwgbiAtIDEgPyBhaSArIDEgOiAwO1xuICAgICAgICB2YXIgc3RvcCA9IHN0YXJ0ID09PSAwID8gbiAtIDEgOiBzdGFydCAtIDE7XG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBBcnJheUV4dC5maW5kRmlyc3RJbmRleCh0aGlzLl9pdGVtcywgUHJpdmF0ZSRhLmNhbkFjdGl2YXRlLCBzdGFydCwgc3RvcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSB0aGUgcHJldmlvdXMgc2VsZWN0YWJsZSBpdGVtIGluIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIG5vIGl0ZW0gaXMgc2VsZWN0YWJsZSwgdGhlIGluZGV4IHdpbGwgYmUgc2V0IHRvIGAtMWAuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuYWN0aXZhdGVQcmV2aW91c0l0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgYWkgPSB0aGlzLl9hY3RpdmVJbmRleDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gYWkgPD0gMCA/IG4gLSAxIDogYWkgLSAxO1xuICAgICAgICB2YXIgc3RvcCA9IHN0YXJ0ID09PSBuIC0gMSA/IDAgOiBzdGFydCArIDE7XG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBBcnJheUV4dC5maW5kTGFzdEluZGV4KHRoaXMuX2l0ZW1zLCBQcml2YXRlJGEuY2FuQWN0aXZhdGUsIHN0YXJ0LCBzdG9wKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIGFjdGl2ZSBtZW51IGl0ZW0uXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIGFjdGl2ZSBpdGVtIGlzIGEgc3VibWVudSwgaXQgd2lsbCBiZSBvcGVuZWQgYW5kIHRoZSBmaXJzdFxuICAgICAqIGl0ZW0gd2lsbCBiZSBhY3RpdmF0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYWN0aXZlIGl0ZW0gaXMgYSBjb21tYW5kLCB0aGUgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIG1lbnUgaXMgbm90IGF0dGFjaGVkLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBhY3RpdmUgaXRlbSwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLnRyaWdnZXJBY3RpdmVJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBtZW51IGlzIG5vdCBhdHRhY2hlZC5cbiAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGFjdGl2ZSBpdGVtLlxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlSXRlbTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBwZW5kaW5nIHRpbWVycy5cbiAgICAgICAgdGhpcy5fY2FuY2VsT3BlblRpbWVyKCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbENsb3NlVGltZXIoKTtcbiAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgYSBzdWJtZW51LCBvcGVuIGl0LlxuICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnc3VibWVudScpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5DaGlsZE1lbnUodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgdGhlIHJvb3QgbWVudSBiZWZvcmUgZXhlY3V0aW5nIHRoZSBjb21tYW5kLlxuICAgICAgICB0aGlzLnJvb3RNZW51LmNsb3NlKCk7XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvbW1hbmQgZm9yIHRoZSBpdGVtLlxuICAgICAgICB2YXIgY29tbWFuZCA9IGl0ZW0uY29tbWFuZCwgYXJncyA9IGl0ZW0uYXJncztcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZHMuaXNFbmFibGVkKGNvbW1hbmQsIGFyZ3MpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWN1dGUoY29tbWFuZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbW1hbmQgJ1wiICsgY29tbWFuZCArIFwiJyBpcyBkaXNhYmxlZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIG1lbnUgaXRlbSB0byB0aGUgZW5kIG9mIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIG1lbnUgaXRlbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBtZW51IGl0ZW0gYWRkZWQgdG8gdGhlIG1lbnUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydEl0ZW0odGhpcy5faXRlbXMubGVuZ3RoLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG1lbnUgaXRlbSBpbnRvIHRoZSBtZW51IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBpdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIG1lbnUgaXRlbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBtZW51IGl0ZW0gYWRkZWQgdG8gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGluZGV4IHdpbGwgYmUgY2xhbXBlZCB0byB0aGUgYm91bmRzIG9mIHRoZSBpdGVtcy5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5pbnNlcnRJdGVtID0gZnVuY3Rpb24gKGluZGV4LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENsb3NlIHRoZSBtZW51IGlmIGl0J3MgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgYWN0aXZlIGluZGV4LlxuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgIC8vIENsYW1wIHRoZSBpbnNlcnQgaW5kZXggdG8gdGhlIGFycmF5IGJvdW5kcy5cbiAgICAgICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5faXRlbXMubGVuZ3RoKSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaXRlbSBmb3IgdGhlIG9wdGlvbnMuXG4gICAgICAgIHZhciBpdGVtID0gUHJpdmF0ZSRhLmNyZWF0ZUl0ZW0odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluc2VydCB0aGUgaXRlbSBpbnRvIHRoZSBhcnJheS5cbiAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHRoaXMuX2l0ZW1zLCBpLCBpdGVtKTtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBpdGVtcy5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBpdGVtIGFkZGVkIHRvIHRoZSBtZW51LlxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgaXRlbSBpcyBub3QgaW4gdGhlIG1lbnUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbUF0KHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBpdGVtIGF0IGEgZ2l2ZW4gaW5kZXggZnJvbSB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUucmVtb3ZlSXRlbUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIC8vIENsb3NlIHRoZSBtZW51IGlmIGl0J3MgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgYWN0aXZlIGluZGV4LlxuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBhcnJheS5cbiAgICAgICAgdmFyIGl0ZW0gPSBBcnJheUV4dC5yZW1vdmVBdCh0aGlzLl9pdGVtcywgaW5kZXgpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvZiB0aGUgaXRlbXMuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIG1lbnUgaXRlbXMgZnJvbSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5jbGVhckl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDbG9zZSB0aGUgbWVudSBpZiBpdCdzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIGFjdGl2ZSBpbmRleC5cbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IC0xO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gcmVtb3ZlLlxuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGl0ZW1zLlxuICAgICAgICB0aGlzLl9pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgbWVudSBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHggLSBUaGUgY2xpZW50IFggY29vcmRpbmF0ZSBvZiB0aGUgbWVudSBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5IC0gVGhlIGNsaWVudCBZIGNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIG9wZW5pbmcgdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIG1lbnUgd2lsbCBiZSBvcGVuZWQgYXQgdGhlIGdpdmVuIGxvY2F0aW9uIHVubGVzcyBpdCB3aWxsIG5vdFxuICAgICAqIGZ1bGx5IGZpdCBvbiB0aGUgc2NyZWVuLiBJZiBpdCB3aWxsIG5vdCBmaXQsIGl0IHdpbGwgYmUgYWRqdXN0ZWRcbiAgICAgKiB0byBmaXQgbmF0dXJhbGx5IG9uIHRoZSBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIG1lbnUgaXMgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoeCwgeSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBtZW51IGlzIGFscmVhZHkgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBwb3NpdGlvbiBvcHRpb25zLlxuICAgICAgICB2YXIgZm9yY2VYID0gb3B0aW9ucy5mb3JjZVggfHwgZmFsc2U7XG4gICAgICAgIHZhciBmb3JjZVkgPSBvcHRpb25zLmZvcmNlWSB8fCBmYWxzZTtcbiAgICAgICAgLy8gT3BlbiB0aGUgbWVudSBhcyBhIHJvb3QgbWVudS5cbiAgICAgICAgUHJpdmF0ZSRhLm9wZW5Sb290TWVudSh0aGlzLCB4LCB5LCBmb3JjZVgsIGZvcmNlWSk7XG4gICAgICAgIC8vIEFjdGl2YXRlIHRoZSBtZW51IHRvIGFjY2VwdCBrZXlib2FyZCBpbnB1dC5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBET00gZXZlbnQgc2VudCB0byB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBET00gYEV2ZW50TGlzdGVuZXJgIGludGVyZmFjZSBhbmQgaXNcbiAgICAgKiBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gZXZlbnRzIG9uIHRoZSBtZW51J3MgRE9NIG5vZGVzLiBJdCBzaG91bGRcbiAgICAgKiBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dEtleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VVcChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZWVudGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZUVudGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlTGVhdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1hdHRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLm9uQWZ0ZXJEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ2FjdGl2YXRlLXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLm9uQWN0aXZhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ3VwZGF0ZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5vblVwZGF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9hY3RpdmVJbmRleDtcbiAgICAgICAgdmFyIGNvbGxhcHNlZEZsYWdzID0gUHJpdmF0ZSRhLmNvbXB1dGVDb2xsYXBzZWQoaXRlbXMpO1xuICAgICAgICB2YXIgY29udGVudCA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpLCBuKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IGkgPT09IGFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgdmFyIGNvbGxhcHNlZCA9IGNvbGxhcHNlZEZsYWdzW2ldO1xuICAgICAgICAgICAgY29udGVudFtpXSA9IHJlbmRlcmVyLnJlbmRlckl0ZW0oe1xuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgY29sbGFwc2VkOiBjb2xsYXBzZWQsXG4gICAgICAgICAgICAgICAgb25mb2N1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIFZpcnR1YWxET00ucmVuZGVyKGNvbnRlbnQsIHRoaXMuY29udGVudE5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2xvc2UtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUub25DbG9zZVJlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgcGVuZGluZyB0aW1lcnMuXG4gICAgICAgIHRoaXMuX2NhbmNlbE9wZW5UaW1lcigpO1xuICAgICAgICB0aGlzLl9jYW5jZWxDbG9zZVRpbWVyKCk7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhY3RpdmUgaW5kZXguXG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSAtMTtcbiAgICAgICAgLy8gQ2xvc2UgYW55IG9wZW4gY2hpbGQgbWVudS5cbiAgICAgICAgdmFyIGNoaWxkTWVudSA9IHRoaXMuX2NoaWxkTWVudTtcbiAgICAgICAgaWYgKGNoaWxkTWVudSkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRJbmRleCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRNZW51ID0gbnVsbDtcbiAgICAgICAgICAgIGNoaWxkTWVudS5fcGFyZW50TWVudSA9IG51bGw7XG4gICAgICAgICAgICBjaGlsZE1lbnUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBtZW51IGZyb20gaXRzIHBhcmVudCBhbmQgYWN0aXZhdGUgdGhlIHBhcmVudC5cbiAgICAgICAgdmFyIHBhcmVudE1lbnUgPSB0aGlzLl9wYXJlbnRNZW51O1xuICAgICAgICBpZiAocGFyZW50TWVudSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50TWVudSA9IG51bGw7XG4gICAgICAgICAgICBwYXJlbnRNZW51Ll9jaGlsZEluZGV4ID0gLTE7XG4gICAgICAgICAgICBwYXJlbnRNZW51Ll9jaGlsZE1lbnUgPSBudWxsO1xuICAgICAgICAgICAgcGFyZW50TWVudS5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgdGhlIGBhYm91dFRvQ2xvc2VgIHNpZ25hbCBpZiB0aGUgbWVudSBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fYWJvdXRUb0Nsb3NlLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5pc2ggY2xvc2luZyB0aGUgbWVudS5cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkNsb3NlUmVxdWVzdC5jYWxsKHRoaXMsIG1zZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAna2V5ZG93bidgIGV2ZW50IGZvciB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBtZW51IG5vZGUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuX2V2dEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQSBtZW51IGhhbmRsZXMgYWxsIGtleWRvd24gZXZlbnRzLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGtleSBjb2RlIGZvciB0aGUgZXZlbnQuXG4gICAgICAgIHZhciBrYyA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIC8vIEVudGVyXG4gICAgICAgIGlmIChrYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFc2NhcGVcbiAgICAgICAgaWYgKGtjID09PSAyNykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExlZnQgQXJyb3dcbiAgICAgICAgaWYgKGtjID09PSAzNykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudE1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZW51UmVxdWVzdGVkLmVtaXQoJ3ByZXZpb3VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXAgQXJyb3dcbiAgICAgICAgaWYgKGtjID09PSAzOCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVByZXZpb3VzSXRlbSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJpZ2h0IEFycm93XG4gICAgICAgIGlmIChrYyA9PT0gMzkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVJdGVtO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS50eXBlID09PSAnc3VibWVudScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJBY3RpdmVJdGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RNZW51Ll9tZW51UmVxdWVzdGVkLmVtaXQoJ25leHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb3duIEFycm93XG4gICAgICAgIGlmIChrYyA9PT0gNDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVOZXh0SXRlbSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgcHJlc3NlZCBrZXkgY2hhcmFjdGVyLlxuICAgICAgICB2YXIga2V5ID0gZ2V0S2V5Ym9hcmRMYXlvdXQoKS5rZXlGb3JLZXlkb3duRXZlbnQoZXZlbnQpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBrZXkgaXMgbm90IHZhbGlkLlxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5leHQgYmVzdCBtYXRjaGluZyBtbmVtb25pYyBpdGVtLlxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9hY3RpdmVJbmRleCArIDE7XG4gICAgICAgIHZhciByZXN1bHQgPSBQcml2YXRlJGEuZmluZE1uZW1vbmljKHRoaXMuX2l0ZW1zLCBrZXksIHN0YXJ0KTtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSByZXF1ZXN0ZWQgbW5lbW9uaWMgYmFzZWQgb24gdGhlIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICAvLyBJZiBleGFjdGx5IG9uZSBtbmVtb25pYyBpcyBtYXRjaGVkLCB0aGF0IGl0ZW0gaXMgdHJpZ2dlcmVkLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBuZXh0IG1uZW1vbmljIGlzIGFjdGl2YXRlZCBpZiBhdmFpbGFibGUsXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBhdXRvIG1uZW1vbmljIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKHJlc3VsdC5pbmRleCAhPT0gLTEgJiYgIXJlc3VsdC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQuaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gcmVzdWx0LmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5hdXRvICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IHJlc3VsdC5hdXRvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2V1cCdgIGV2ZW50IGZvciB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBtZW51IG5vZGUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuX2V2dE1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnRyaWdnZXJBY3RpdmVJdGVtKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vtb3ZlJ2AgZXZlbnQgZm9yIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gdGhlIG1lbnUgbm9kZS5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5fZXZ0TW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEhpdCB0ZXN0IHRoZSBpdGVtIG5vZGVzIGZvciB0aGUgaXRlbSB1bmRlciB0aGUgbW91c2UuXG4gICAgICAgIHZhciBpbmRleCA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRoaXMuY29udGVudE5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudEV4dC5oaXRUZXN0KG5vZGUsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgbW91c2UgaXMgYWxyZWFkeSBvdmVyIHRoZSBhY3RpdmUgaW5kZXguXG4gICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5fYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgYW5kIGNvZXJjZSB0aGUgYWN0aXZlIGluZGV4LlxuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIGluZGV4ID0gdGhpcy5hY3RpdmVJbmRleDtcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IGlzIHRoZSBjdXJyZW50IGNoaWxkIGluZGV4LCBjYW5jZWwgdGhlIHRpbWVycy5cbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLl9jaGlsZEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxPcGVuVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbENsb3NlVGltZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGNoaWxkIG1lbnUgaXMgY3VycmVudGx5IG9wZW4sIHN0YXJ0IHRoZSBjbG9zZSB0aW1lci5cbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydENsb3NlVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgdGhlIG9wZW4gdGltZXIgdG8gZ2l2ZSBhIGZ1bGwgZGVsYXkgZm9yIG9wZW5pbmcuXG4gICAgICAgIHRoaXMuX2NhbmNlbE9wZW5UaW1lcigpO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBhY3RpdmUgaXRlbSBpcyBub3QgYSB2YWxpZCBzdWJtZW51IGl0ZW0uXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVJdGVtO1xuICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSAnc3VibWVudScgfHwgIWl0ZW0uc3VibWVudSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBvcGVuIHRpbWVyIHRvIG9wZW4gdGhlIGFjdGl2ZSBpdGVtIHN1Ym1lbnUuXG4gICAgICAgIHRoaXMuX3N0YXJ0T3BlblRpbWVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2VlbnRlcidgIGV2ZW50IGZvciB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBtZW51IG5vZGUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuX2V2dE1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gU3luY2hyb25pemUgdGhlIGFjdGl2ZSBhbmNlc3RvciBpdGVtcy5cbiAgICAgICAgZm9yICh2YXIgbWVudSA9IHRoaXMuX3BhcmVudE1lbnU7IG1lbnU7IG1lbnUgPSBtZW51Ll9wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICBtZW51Ll9jYW5jZWxPcGVuVGltZXIoKTtcbiAgICAgICAgICAgIG1lbnUuX2NhbmNlbENsb3NlVGltZXIoKTtcbiAgICAgICAgICAgIG1lbnUuYWN0aXZlSW5kZXggPSBtZW51Ll9jaGlsZEluZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2VsZWF2ZSdgIGV2ZW50IGZvciB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBtZW51IG5vZGUuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuX2V2dE1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHN1Ym1lbnUgb3BlbmluZy5cbiAgICAgICAgdGhpcy5fY2FuY2VsT3BlblRpbWVyKCk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9wZW4gY2hpbGQgbWVudSwganVzdCByZXNldCB0aGUgYWN0aXZlIGluZGV4LlxuICAgICAgICBpZiAoIXRoaXMuX2NoaWxkTWVudSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBtb3VzZSBpcyBvdmVyIHRoZSBjaGlsZCBtZW51LCBjYW5jZWwgdGhlIGNsb3NlIHRpbWVyLlxuICAgICAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFgsIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBpZiAoRWxlbWVudEV4dC5oaXRUZXN0KHRoaXMuX2NoaWxkTWVudS5ub2RlLCBjbGllbnRYLCBjbGllbnRZKSkge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ2xvc2VUaW1lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmVzZXQgdGhlIGFjdGl2ZSBpbmRleCBhbmQgc3RhcnQgdGhlIGNsb3NlIHRpbWVyLlxuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3N0YXJ0Q2xvc2VUaW1lcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNlZG93bidgIGV2ZW50IGZvciB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCBub2RlLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLl9ldnRNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgbWVudSBpcyBub3QgYSByb290IG1lbnUuXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG1vdXNlIGJ1dHRvbiB3aGljaCBpcyBwcmVzc2VkIGlzIGlycmVsZXZhbnQuIElmIHRoZSBwcmVzc1xuICAgICAgICAvLyBpcyBub3Qgb24gYSBtZW51LCB0aGUgZW50aXJlIGhpZXJhcmNoeSBpcyBjbG9zZWQgYW5kIHRoZSBldmVudFxuICAgICAgICAvLyBpcyBhbGxvd2VkIHRvIHByb3BhZ2F0ZS4gVGhpcyBhbGxvd3Mgb3RoZXIgY29kZSB0byBhY3Qgb24gdGhlXG4gICAgICAgIC8vIGV2ZW50LCBzdWNoIGFzIGZvY3VzaW5nIHRoZSBjbGlja2VkIGVsZW1lbnQuXG4gICAgICAgIGlmIChQcml2YXRlJGEuaGl0VGVzdE1lbnVzKHRoaXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGNoaWxkIG1lbnUgYXQgdGhlIGFjdGl2ZSBpbmRleCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIElmIGEgZGlmZmVyZW50IGNoaWxkIG1lbnUgaXMgYWxyZWFkeSBvcGVuLCBpdCB3aWxsIGJlIGNsb3NlZCxcbiAgICAgKiBldmVuIGlmIHRoZSBhY3RpdmUgaXRlbSBpcyBub3QgYSB2YWxpZCBzdWJtZW51LlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLl9vcGVuQ2hpbGRNZW51ID0gZnVuY3Rpb24gKGFjdGl2YXRlRmlyc3QpIHtcbiAgICAgICAgaWYgKGFjdGl2YXRlRmlyc3QgPT09IHZvaWQgMCkgeyBhY3RpdmF0ZUZpcnN0ID0gZmFsc2U7IH1cbiAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgbm90IGEgdmFsaWQgc3VibWVudSwgY2xvc2UgdGhlIGNoaWxkIG1lbnUuXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVJdGVtO1xuICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbS50eXBlICE9PSAnc3VibWVudScgfHwgIWl0ZW0uc3VibWVudSkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VDaGlsZE1lbnUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBjaGlsZCBtZW51IHdpbGwgbm90IGNoYW5nZS5cbiAgICAgICAgdmFyIHN1Ym1lbnUgPSBpdGVtLnN1Ym1lbnU7XG4gICAgICAgIGlmIChzdWJtZW51ID09PSB0aGlzLl9jaGlsZE1lbnUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgY2hpbGQgbWVudSBpcyBjbG9zZWQuXG4gICAgICAgIHRoaXMuX2Nsb3NlQ2hpbGRNZW51KCk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpdmF0ZSBjaGlsZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fY2hpbGRNZW51ID0gc3VibWVudTtcbiAgICAgICAgdGhpcy5fY2hpbGRJbmRleCA9IHRoaXMuX2FjdGl2ZUluZGV4O1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCBtZW51IHJlZmVyZW5jZSBmb3IgdGhlIGNoaWxkLlxuICAgICAgICBzdWJtZW51Ll9wYXJlbnRNZW51ID0gdGhpcztcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBtZW51IGlzIHVwZGF0ZWQgYW5kIGxvb2t1cCB0aGUgaXRlbSBub2RlLlxuICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLCBXaWRnZXQuTXNnLlVwZGF0ZVJlcXVlc3QpO1xuICAgICAgICB2YXIgaXRlbU5vZGUgPSB0aGlzLmNvbnRlbnROb2RlLmNoaWxkcmVuW3RoaXMuX2FjdGl2ZUluZGV4XTtcbiAgICAgICAgLy8gT3BlbiB0aGUgc3VibWVudSBhdCB0aGUgYWN0aXZlIG5vZGUuXG4gICAgICAgIFByaXZhdGUkYS5vcGVuU3VibWVudShzdWJtZW51LCBpdGVtTm9kZSk7XG4gICAgICAgIC8vIEFjdGl2YXRlIHRoZSBmaXJzdCBpdGVtIGlmIGRlc2lyZWQuXG4gICAgICAgIGlmIChhY3RpdmF0ZUZpcnN0KSB7XG4gICAgICAgICAgICBzdWJtZW51LmFjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgICAgICBzdWJtZW51LmFjdGl2YXRlTmV4dEl0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgY2hpbGQgbWVudS5cbiAgICAgICAgc3VibWVudS5hY3RpdmF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNoaWxkIG1lbnUgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgYSBjaGlsZCBtZW51IGlzIG5vdCBvcGVuLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLl9jbG9zZUNoaWxkTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkTWVudSkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRNZW51LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBvcGVuIHRpbWVyLCB1bmxlc3MgaXQgaXMgYWxyZWFkeSBwZW5kaW5nLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLl9zdGFydE9wZW5UaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX29wZW5UaW1lcklEID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuVGltZXJJRCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb3BlblRpbWVySUQgPSAwO1xuICAgICAgICAgICAgICAgIF90aGlzLl9vcGVuQ2hpbGRNZW51KCk7XG4gICAgICAgICAgICB9LCBQcml2YXRlJGEuVElNRVJfREVMQVkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgY2xvc2UgdGltZXIsIHVubGVzcyBpdCBpcyBhbHJlYWR5IHBlbmRpbmcuXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuX3N0YXJ0Q2xvc2VUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlVGltZXJJRCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VUaW1lcklEID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9jbG9zZVRpbWVySUQgPSAwO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jbG9zZUNoaWxkTWVudSgpO1xuICAgICAgICAgICAgfSwgUHJpdmF0ZSRhLlRJTUVSX0RFTEFZKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBvcGVuIHRpbWVyLCBpZiB0aGUgdGltZXIgaXMgcGVuZGluZy5cbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5fY2FuY2VsT3BlblRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3BlblRpbWVySUQgIT09IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuVGltZXJJRCk7XG4gICAgICAgICAgICB0aGlzLl9vcGVuVGltZXJJRCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGUgY2xvc2UgdGltZXIsIGlmIHRoZSB0aW1lciBpcyBwZW5kaW5nLlxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLl9jYW5jZWxDbG9zZVRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VUaW1lcklEICE9PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2xvc2VUaW1lcklEKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlVGltZXJJRCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZW51O1xufShXaWRnZXQpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIGBNZW51YCBjbGFzcyBzdGF0aWNzLlxuICovXG4oZnVuY3Rpb24gKE1lbnUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgSVJlbmRlcmVyYC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBTdWJjbGFzc2VzIGFyZSBmcmVlIHRvIHJlaW1wbGVtZW50IHJlbmRlcmluZyBtZXRob2RzIGFzIG5lZWRlZC5cbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcmVuZGVyZXIuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSB2aXJ0dWFsIGVsZW1lbnQgZm9yIGEgbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIHZpcnR1YWwgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySXRlbSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jcmVhdGVJdGVtQ2xhc3MoZGF0YSk7XG4gICAgICAgICAgICB2YXIgZGF0YXNldCA9IHRoaXMuY3JlYXRlSXRlbURhdGFzZXQoZGF0YSk7XG4gICAgICAgICAgICB2YXIgYXJpYSA9IHRoaXMuY3JlYXRlSXRlbUFSSUEoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gKGgubGkoX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhc2V0OiBkYXRhc2V0LCB0YWJpbmRleDogJzAnLCBvbmZvY3VzOiBkYXRhLm9uZm9jdXMgfSwgYXJpYSksIHRoaXMucmVuZGVySWNvbihkYXRhKSwgdGhpcy5yZW5kZXJMYWJlbChkYXRhKSwgdGhpcy5yZW5kZXJTaG9ydGN1dChkYXRhKSwgdGhpcy5yZW5kZXJTdWJtZW51KGRhdGEpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGljb24gZWxlbWVudCBmb3IgYSBtZW51IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGljb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaXRlbSBpY29uLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckljb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY3JlYXRlSWNvbkNsYXNzKGRhdGEpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuaXRlbS5pY29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoLmRpdih7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGRhdGEuaXRlbS5pY29uTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgLy8gaWYgZGF0YS5pdGVtLmljb24gaXMgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGRhdGEuaXRlbS5pY29uLCBkYXRhLml0ZW0uaWNvbkxhYmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgbGFiZWwgZWxlbWVudCBmb3IgYSBtZW51IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGxhYmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIHZpcnR1YWwgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGl0ZW0gbGFiZWwuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyTGFiZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmZvcm1hdExhYmVsKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGguZGl2KHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdsbS1NZW51LWl0ZW1MYWJlbCdcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLU1lbnUtaXRlbUxhYmVsJ1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH0sIGNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBzaG9ydGN1dCBlbGVtZW50IGZvciBhIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgc2hvcnRjdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaXRlbSBzaG9ydGN1dC5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTaG9ydGN1dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZm9ybWF0U2hvcnRjdXQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gaC5kaXYoe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xtLU1lbnUtaXRlbVNob3J0Y3V0J1xuICAgICAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICAgICAgKyAnIHAtTWVudS1pdGVtU2hvcnRjdXQnXG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfSwgY29udGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIHN1Ym1lbnUgaWNvbiBlbGVtZW50IGZvciBhIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgc3VibWVudSBpY29uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIHZpcnR1YWwgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHN1Ym1lbnUgaWNvbi5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTdWJtZW51ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbG0tTWVudS1pdGVtU3VibWVudUljb24nXG4gICAgICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgICAgICArICcgcC1NZW51LWl0ZW1TdWJtZW51SWNvbidcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgY2xhc3MgbmFtZSBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSBjbGFzcyBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgZnVsbCBjbGFzcyBuYW1lIGZvciB0aGUgbWVudSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW1DbGFzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBTZXR1cCB0aGUgaW5pdGlhbCBjbGFzcyBuYW1lLlxuICAgICAgICAgICAgdmFyIG5hbWUgPSAnbG0tTWVudS1pdGVtJztcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgbmFtZSArPSAnIHAtTWVudS1pdGVtJztcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYm9vbGVhbiBzdGF0ZSBjbGFzc2VzLlxuICAgICAgICAgICAgaWYgKCFkYXRhLml0ZW0uaXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIGxtLW1vZC1kaXNhYmxlZCc7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIHAtbW9kLWRpc2FibGVkJztcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5pdGVtLmlzVG9nZ2xlZCkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBsbS1tb2QtdG9nZ2xlZCc7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIHAtbW9kLXRvZ2dsZWQnO1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YS5pdGVtLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBsbS1tb2QtaGlkZGVuJztcbiAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICBuYW1lICs9ICcgcC1tb2QtaGlkZGVuJztcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9ICcgbG0tbW9kLWFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIHAtbW9kLWFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIGxtLW1vZC1jb2xsYXBzZWQnO1xuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBwLW1vZC1jb2xsYXBzZWQnO1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZXh0cmEgY2xhc3MuXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSBkYXRhLml0ZW0uY2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIiBcIiArIGV4dHJhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb21wbGV0ZSBjbGFzcyBuYW1lLlxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIGRhdGFzZXQgZm9yIHRoZSBtZW51IGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgZGF0YXNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGRhdGFzZXQgZm9yIHRoZSBtZW51IGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSXRlbURhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBfYSA9IGRhdGEuaXRlbSwgdHlwZSA9IF9hLnR5cGUsIGNvbW1hbmQgPSBfYS5jb21tYW5kLCBkYXRhc2V0ID0gX2EuZGF0YXNldDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YXNldCksIHsgdHlwZTogdHlwZSwgY29tbWFuZDogY29tbWFuZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhc2V0KSwgeyB0eXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgY2xhc3MgbmFtZSBmb3IgdGhlIG1lbnUgaXRlbSBpY29uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGNsYXNzIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBmdWxsIGNsYXNzIG5hbWUgZm9yIHRoZSBpdGVtIGljb24uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSWNvbkNsYXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJ2xtLU1lbnUtaXRlbUljb24nO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBuYW1lICs9ICcgcC1NZW51LWl0ZW1JY29uJztcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHZhciBleHRyYSA9IGRhdGEuaXRlbS5pY29uQ2xhc3M7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmEgPyBuYW1lICsgXCIgXCIgKyBleHRyYSA6IG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIGFyaWEgYXR0cmlidXRlcyBmb3IgbWVudSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGFyaWEgYXR0cmlidXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGFyaWEgYXR0cmlidXRlcyBvYmplY3QgZm9yIHRoZSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW1BUklBID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhcmlhID0ge307XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGEuaXRlbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VwYXJhdG9yJzpcbiAgICAgICAgICAgICAgICAgICAgYXJpYS5yb2xlID0gJ3ByZXNlbnRhdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N1Ym1lbnUnOlxuICAgICAgICAgICAgICAgICAgICBhcmlhWydhcmlhLWhhc3BvcHVwJ10gPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5pdGVtLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVsnYXJpYS1kaXNhYmxlZCddID0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5pdGVtLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYVsnYXJpYS1kaXNhYmxlZCddID0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEucm9sZSA9ICdtZW51aXRlbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJpYTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgcmVuZGVyIGNvbnRlbnQgZm9yIHRoZSBsYWJlbCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGxhYmVsIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBjb250ZW50IHRvIGFkZCB0byB0aGUgbGFiZWwgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5mb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgbGFiZWwgdGV4dCBhbmQgbW5lbW9uaWMgaW5kZXguXG4gICAgICAgICAgICB2YXIgX2EgPSBkYXRhLml0ZW0sIGxhYmVsID0gX2EubGFiZWwsIG1uZW1vbmljID0gX2EubW5lbW9uaWM7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLCBkbyBub3QgbW9kaWZ5IHRoZSBsYWJlbC5cbiAgICAgICAgICAgIGlmIChtbmVtb25pYyA8IDAgfHwgbW5lbW9uaWMgPj0gbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGxhYmVsIGludG8gcGFydHMuXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gbGFiZWwuc2xpY2UoMCwgbW5lbW9uaWMpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGxhYmVsLnNsaWNlKG1uZW1vbmljICsgMSk7XG4gICAgICAgICAgICB2YXIgY2hhciA9IGxhYmVsW21uZW1vbmljXTtcbiAgICAgICAgICAgIC8vIFdyYXAgdGhlIG1uZW1vbmljIGNoYXJhY3RlciBpbiBhIHNwYW4uXG4gICAgICAgICAgICB2YXIgc3BhbiA9IGguc3Bhbih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbG0tTWVudS1pdGVtTW5lbW9uaWMnXG4gICAgICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgICAgICArICcgcC1NZW51LWl0ZW1NbmVtb25pYydcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9LCBjaGFyKTtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29udGVudCBwYXJ0cy5cbiAgICAgICAgICAgIHJldHVybiBbcHJlZml4LCBzcGFuLCBzdWZmaXhdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSByZW5kZXIgY29udGVudCBmb3IgdGhlIHNob3J0Y3V0IG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgc2hvcnRjdXQgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSBzaG9ydGN1dCBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmZvcm1hdFNob3J0Y3V0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBrYiA9IGRhdGEuaXRlbS5rZXlCaW5kaW5nO1xuICAgICAgICAgICAgcmV0dXJuIGtiID8ga2Iua2V5cy5tYXAoQ29tbWFuZFJlZ2lzdHJ5LmZvcm1hdEtleXN0cm9rZSkuam9pbignLCAnKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIE1lbnUuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBgUmVuZGVyZXJgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIE1lbnUuZGVmYXVsdFJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG59KShNZW51IHx8IChNZW51ID0ge30pKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSRhO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1zIGRlbGF5IGZvciBvcGVuaW5nIGFuZCBjbG9zaW5nIGEgc3VibWVudS5cbiAgICAgKi9cbiAgICBQcml2YXRlLlRJTUVSX0RFTEFZID0gMzAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBob3Jpem9udGFsIHBpeGVsIG92ZXJsYXAgZm9yIGFuIG9wZW4gc3VibWVudS5cbiAgICAgKi9cbiAgICBQcml2YXRlLlNVQk1FTlVfT1ZFUkxBUCA9IDM7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBET00gbm9kZSBmb3IgYSBtZW51LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgY29udGVudC5jbGFzc05hbWUgPSAnbG0tTWVudS1jb250ZW50JztcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncC1NZW51LWNvbnRlbnQnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XG4gICAgICAgIG5vZGUudGFiSW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVOb2RlID0gY3JlYXRlTm9kZTtcbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgYSBtZW51IGl0ZW0gY2FuIGJlIGFjdGl2YXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5BY3RpdmF0ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgIT09ICdzZXBhcmF0b3InICYmIGl0ZW0uaXNFbmFibGVkICYmIGl0ZW0uaXNWaXNpYmxlO1xuICAgIH1cbiAgICBQcml2YXRlLmNhbkFjdGl2YXRlID0gY2FuQWN0aXZhdGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG1lbnUgaXRlbSBmb3IgYW4gb3duZXIgbWVudS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJdGVtKG93bmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVudUl0ZW0ob3duZXIuY29tbWFuZHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgIC8qKlxuICAgICAqIEhpdCB0ZXN0IGEgbWVudSBoaWVyYXJjaHkgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHJvb3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGl0VGVzdE1lbnVzKG1lbnUsIHgsIHkpIHtcbiAgICAgICAgZm9yICh2YXIgdGVtcCA9IG1lbnU7IHRlbXA7IHRlbXAgPSB0ZW1wLmNoaWxkTWVudSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnRFeHQuaGl0VGVzdCh0ZW1wLm5vZGUsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBQcml2YXRlLmhpdFRlc3RNZW51cyA9IGhpdFRlc3RNZW51cztcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHdoaWNoIGV4dHJhIHNlcGFyYXRvciBpdGVtcyBzaG91bGQgYmUgY29sbGFwc2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVDb2xsYXBzZWQoaXRlbXMpIHtcbiAgICAgICAgLy8gQWxsb2NhdGUgdGhlIHJldHVybiBhcnJheSBhbmQgZmlsbCBpdCB3aXRoIGBmYWxzZWAuXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgQXJyYXlFeHQuZmlsbChyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgLy8gQ29sbGFwc2UgdGhlIGxlYWRpbmcgc2VwYXJhdG9ycy5cbiAgICAgICAgdmFyIGsxID0gMDtcbiAgICAgICAgdmFyIG4gPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBrMSA8IG47ICsrazEpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbazFdO1xuICAgICAgICAgICAgaWYgKCFpdGVtLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gJ3NlcGFyYXRvcicpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrMV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhpZGUgdGhlIHRyYWlsaW5nIHNlcGFyYXRvcnMuXG4gICAgICAgIHZhciBrMiA9IG4gLSAxO1xuICAgICAgICBmb3IgKDsgazIgPj0gMDsgLS1rMikge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1trMl07XG4gICAgICAgICAgICBpZiAoIWl0ZW0uaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlICE9PSAnc2VwYXJhdG9yJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2syXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlkZSB0aGUgcmVtYWluaW5nIGNvbnNlY3V0aXZlIHNlcGFyYXRvcnMuXG4gICAgICAgIHZhciBoaWRlID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgrK2sxIDwgazIpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbazFdO1xuICAgICAgICAgICAgaWYgKCFpdGVtLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gJ3NlcGFyYXRvcicpIHtcbiAgICAgICAgICAgICAgICBoaWRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2sxXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBmbGFncy5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUHJpdmF0ZS5jb21wdXRlQ29sbGFwc2VkID0gY29tcHV0ZUNvbGxhcHNlZDtcbiAgICAvKipcbiAgICAgKiBPcGVuIGEgbWVudSBhcyBhIHJvb3QgbWVudSBhdCB0aGUgdGFyZ2V0IGxvY2F0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9wZW5Sb290TWVudShtZW51LCB4LCB5LCBmb3JjZVgsIGZvcmNlWSkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIG1lbnUgaXMgdXBkYXRlZCBiZWZvcmUgYXR0YWNoaW5nIGFuZCBtZWFzdXJpbmcuXG4gICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKG1lbnUsIFdpZGdldC5Nc2cuVXBkYXRlUmVxdWVzdCk7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgbWFpbiB2aWV3cG9ydC5cbiAgICAgICAgdmFyIHB4ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB2YXIgcHkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHZhciBjdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGNoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW11bSBhbGxvd2VkIGhlaWdodCBmb3IgdGhlIG1lbnUuXG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSBjaCAtIChmb3JjZVkgPyB5IDogMCk7XG4gICAgICAgIC8vIEZldGNoIGNvbW1vbiB2YXJpYWJsZXMuXG4gICAgICAgIHZhciBub2RlID0gbWVudS5ub2RlO1xuICAgICAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgICAgICAvLyBDbGVhciB0aGUgbWVudSBnZW9tZXRyeSBhbmQgcHJlcGFyZSBpdCBmb3IgbWVhc3VyaW5nLlxuICAgICAgICBzdHlsZS50b3AgPSAnJztcbiAgICAgICAgc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICBzdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIC8vIEF0dGFjaCB0aGUgbWVudSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICAgIFdpZGdldC5hdHRhY2gobWVudSwgZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIC8vIE1lYXN1cmUgdGhlIHNpemUgb2YgdGhlIG1lbnUuXG4gICAgICAgIHZhciBfYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBYIHBvc2l0aW9uIG9mIHRoZSBtZW51IHRvIGZpdCBvbi1zY3JlZW4uXG4gICAgICAgIGlmICghZm9yY2VYICYmICh4ICsgd2lkdGggPiBweCArIGN3KSkge1xuICAgICAgICAgICAgeCA9IHB4ICsgY3cgLSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGp1c3QgdGhlIFkgcG9zaXRpb24gb2YgdGhlIG1lbnUgdG8gZml0IG9uLXNjcmVlbi5cbiAgICAgICAgaWYgKCFmb3JjZVkgJiYgKHkgKyBoZWlnaHQgPiBweSArIGNoKSkge1xuICAgICAgICAgICAgaWYgKHkgPiBweSArIGNoKSB7XG4gICAgICAgICAgICAgICAgeSA9IHB5ICsgY2ggLSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0geSAtIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBtZW51IHRvIHRoZSBjb21wdXRlZCBwb3NpdGlvbi5cbiAgICAgICAgc3R5bGUudG9wID0gTWF0aC5tYXgoMCwgeSkgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBNYXRoLm1heCgwLCB4KSArIFwicHhcIjtcbiAgICAgICAgLy8gRmluYWxseSwgbWFrZSB0aGUgbWVudSB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICB9XG4gICAgUHJpdmF0ZS5vcGVuUm9vdE1lbnUgPSBvcGVuUm9vdE1lbnU7XG4gICAgLyoqXG4gICAgICogT3BlbiBhIG1lbnUgYXMgYSBzdWJtZW51IHVzaW5nIGFuIGl0ZW0gbm9kZSBmb3IgcG9zaXRpb25pbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3BlblN1Ym1lbnUoc3VibWVudSwgaXRlbU5vZGUpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBtZW51IGlzIHVwZGF0ZWQgYmVmb3JlIG9wZW5pbmcuXG4gICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHN1Ym1lbnUsIFdpZGdldC5Nc2cuVXBkYXRlUmVxdWVzdCk7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgbWFpbiB2aWV3cG9ydC5cbiAgICAgICAgdmFyIHB4ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB2YXIgcHkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHZhciBjdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGNoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW11bSBhbGxvd2VkIGhlaWdodCBmb3IgdGhlIG1lbnUuXG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSBjaDtcbiAgICAgICAgLy8gRmV0Y2ggY29tbW9uIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIG5vZGUgPSBzdWJtZW51Lm5vZGU7XG4gICAgICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgICAgIC8vIENsZWFyIHRoZSBtZW51IGdlb21ldHJ5IGFuZCBwcmVwYXJlIGl0IGZvciBtZWFzdXJpbmcuXG4gICAgICAgIHN0eWxlLnRvcCA9ICcnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgIHN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgLy8gQXR0YWNoIHRoZSBtZW51IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgICAgV2lkZ2V0LmF0dGFjaChzdWJtZW51LCBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgLy8gTWVhc3VyZSB0aGUgc2l6ZSBvZiB0aGUgbWVudS5cbiAgICAgICAgdmFyIF9hID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBib3ggc2l6aW5nIGZvciB0aGUgbWVudS5cbiAgICAgICAgdmFyIGJveCA9IEVsZW1lbnRFeHQuYm94U2l6aW5nKHN1Ym1lbnUubm9kZSk7XG4gICAgICAgIC8vIEdldCB0aGUgYm91bmRpbmcgcmVjdCBmb3IgdGhlIHRhcmdldCBpdGVtIG5vZGUuXG4gICAgICAgIHZhciBpdGVtUmVjdCA9IGl0ZW1Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSB0YXJnZXQgWCBwb3NpdGlvbi5cbiAgICAgICAgdmFyIHggPSBpdGVtUmVjdC5yaWdodCAtIFByaXZhdGUuU1VCTUVOVV9PVkVSTEFQO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIFggcG9zaXRpb24gdG8gZml0IG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIGlmICh4ICsgd2lkdGggPiBweCArIGN3KSB7XG4gICAgICAgICAgICB4ID0gaXRlbVJlY3QubGVmdCArIFByaXZhdGUuU1VCTUVOVV9PVkVSTEFQIC0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdGFyZ2V0IFkgcG9zaXRpb24uXG4gICAgICAgIHZhciB5ID0gaXRlbVJlY3QudG9wIC0gYm94LmJvcmRlclRvcCAtIGJveC5wYWRkaW5nVG9wO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIFkgcG9zaXRpb24gdG8gZml0IG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIGlmICh5ICsgaGVpZ2h0ID4gcHkgKyBjaCkge1xuICAgICAgICAgICAgeSA9IGl0ZW1SZWN0LmJvdHRvbSArIGJveC5ib3JkZXJCb3R0b20gKyBib3gucGFkZGluZ0JvdHRvbSAtIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBtZW51IHRvIHRoZSBjb21wdXRlZCBwb3NpdGlvbi5cbiAgICAgICAgc3R5bGUudG9wID0gTWF0aC5tYXgoMCwgeSkgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBNYXRoLm1heCgwLCB4KSArIFwicHhcIjtcbiAgICAgICAgLy8gRmluYWxseSwgbWFrZSB0aGUgbWVudSB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICB9XG4gICAgUHJpdmF0ZS5vcGVuU3VibWVudSA9IG9wZW5TdWJtZW51O1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGJlc3QgbWF0Y2hpbmcgbW5lbW9uaWMgaXRlbS5cbiAgICAgKlxuICAgICAqIFRoZSBzZWFyY2ggc3RhcnRzIGF0IHRoZSBnaXZlbiBpbmRleCBhbmQgd3JhcHMgYXJvdW5kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRNbmVtb25pYyhpdGVtcywga2V5LCBzdGFydCkge1xuICAgICAgICAvLyBTZXR1cCB0aGUgcmVzdWx0IHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBhdXRvID0gLTE7XG4gICAgICAgIHZhciBtdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGtleSB0byB1cHBlciBjYXNlLlxuICAgICAgICB2YXIgdXBwZXJLZXkgPSBrZXkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgLy8gU2VhcmNoIHRoZSBpdGVtcyBmcm9tIHRoZSBnaXZlbiBzdGFydCBpbmRleC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHdyYXBwZWQgaW5kZXguXG4gICAgICAgICAgICB2YXIgayA9IChpICsgc3RhcnQpICUgbjtcbiAgICAgICAgICAgIC8vIExvb2t1cCB0aGUgaXRlbVxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1trXTtcbiAgICAgICAgICAgIC8vIElnbm9yZSBpdGVtcyB3aGljaCBjYW5ub3QgYmUgYWN0aXZhdGVkLlxuICAgICAgICAgICAgaWYgKCFjYW5BY3RpdmF0ZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWdub3JlIGl0ZW1zIHdpdGggYW4gZW1wdHkgbGFiZWwuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgaWYgKGxhYmVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSBtbmVtb25pYyBpbmRleCBmb3IgdGhlIGxhYmVsLlxuICAgICAgICAgICAgdmFyIG1uID0gaXRlbS5tbmVtb25pYztcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhIHZhbGlkIG1uZW1vbmljIGluZGV4LlxuICAgICAgICAgICAgaWYgKG1uID49IDAgJiYgbW4gPCBsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxbbW5dLnRvVXBwZXJDYXNlKCkgPT09IHVwcGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGhhbmRsZSB0aGUgYXV0byBpbmRleCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgIGlmIChhdXRvID09PSAtMSAmJiBsYWJlbFswXS50b1VwcGVyQ2FzZSgpID09PSB1cHBlcktleSkge1xuICAgICAgICAgICAgICAgIGF1dG8gPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgc2VhcmNoIHJlc3VsdHMuXG4gICAgICAgIHJldHVybiB7IGluZGV4OiBpbmRleCwgbXVsdGlwbGU6IG11bHRpcGxlLCBhdXRvOiBhdXRvIH07XG4gICAgfVxuICAgIFByaXZhdGUuZmluZE1uZW1vbmljID0gZmluZE1uZW1vbmljO1xuICAgIC8qKlxuICAgICAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYE1lbnUuSUl0ZW1gLlxuICAgICAqL1xuICAgIHZhciBNZW51SXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBtZW51IGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBNZW51SXRlbShjb21tYW5kcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAnY29tbWFuZCc7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmQgPSBvcHRpb25zLmNvbW1hbmQgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBvcHRpb25zLmFyZ3MgfHwgSlNPTkV4dC5lbXB0eU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuc3VibWVudSA9IG9wdGlvbnMuc3VibWVudSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51SXRlbS5wcm90b3R5cGUsIFwibGFiZWxcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGlzcGxheSBsYWJlbCBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5sYWJlbCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdWJtZW51JyAmJiB0aGlzLnN1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VibWVudS50aXRsZS5sYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51SXRlbS5wcm90b3R5cGUsIFwibW5lbW9uaWNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbW5lbW9uaWMgaW5kZXggZm9yIHRoZSBtZW51IGl0ZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdjb21tYW5kJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZHMubW5lbW9uaWModGhpcy5jb21tYW5kLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3VibWVudScgJiYgdGhpcy5zdWJtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Ym1lbnUudGl0bGUubW5lbW9uaWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImljb25cIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaWNvbiByZW5kZXJlciBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5pY29uKHRoaXMuY29tbWFuZCwgdGhpcy5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N1Ym1lbnUnICYmIHRoaXMuc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJtZW51LnRpdGxlLmljb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIC8vIGFsaWFzIHRvIGljb24gY2xhc3MgaWYgbm90IG90aGVyd2lzZSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWNvbkNsYXNzO1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICAvKiA8RlVUVVJFPlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgPC9GVVRVUkU+ICovXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnVJdGVtLnByb3RvdHlwZSwgXCJpY29uQ2xhc3NcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaWNvbiBjbGFzcyBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5pY29uQ2xhc3ModGhpcy5jb21tYW5kLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3VibWVudScgJiYgdGhpcy5zdWJtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Ym1lbnUudGl0bGUuaWNvbkNsYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnVJdGVtLnByb3RvdHlwZSwgXCJpY29uTGFiZWxcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaWNvbiBsYWJlbCBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5pY29uTGFiZWwodGhpcy5jb21tYW5kLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3VibWVudScgJiYgdGhpcy5zdWJtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Ym1lbnUudGl0bGUuaWNvbkxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnVJdGVtLnByb3RvdHlwZSwgXCJjYXB0aW9uXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGRpc3BsYXkgY2FwdGlvbiBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5jYXB0aW9uKHRoaXMuY29tbWFuZCwgdGhpcy5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N1Ym1lbnUnICYmIHRoaXMuc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJtZW51LnRpdGxlLmNhcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImNsYXNzTmFtZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBleHRyYSBjbGFzcyBuYW1lIGZvciB0aGUgbWVudSBpdGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmNsYXNzTmFtZSh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdWJtZW51JyAmJiB0aGlzLnN1Ym1lbnUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VibWVudS50aXRsZS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImRhdGFzZXRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGF0YXNldCBmb3IgdGhlIG1lbnUgaXRlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kcy5kYXRhc2V0KHRoaXMuY29tbWFuZCwgdGhpcy5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N1Ym1lbnUnICYmIHRoaXMuc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJtZW51LnRpdGxlLmRhdGFzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImlzRW5hYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIG1lbnUgaXRlbSBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzRW5hYmxlZCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdWJtZW51Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJtZW51ICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImlzVG9nZ2xlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIG1lbnUgaXRlbSBpcyB0b2dnbGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzVG9nZ2xlZCh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImlzVmlzaWJsZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIG1lbnUgaXRlbSBpcyB2aXNpYmxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzLmlzVmlzaWJsZSh0aGlzLmNvbW1hbmQsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdWJtZW51Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJtZW51ICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUl0ZW0ucHJvdG90eXBlLCBcImtleUJpbmRpbmdcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUga2V5IGJpbmRpbmcgZm9yIHRoZSBtZW51IGl0ZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdjb21tYW5kJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb21tYW5kXzEgPSBfYS5jb21tYW5kLCBhcmdzXzEgPSBfYS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlFeHQuZmluZExhc3RWYWx1ZSh0aGlzLl9jb21tYW5kcy5rZXlCaW5kaW5ncywgZnVuY3Rpb24gKGtiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2IuY29tbWFuZCA9PT0gY29tbWFuZF8xICYmIEpTT05FeHQuZGVlcEVxdWFsKGtiLmFyZ3MsIGFyZ3NfMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBNZW51SXRlbTtcbiAgICB9KCkpO1xufSkoUHJpdmF0ZSRhIHx8IChQcml2YXRlJGEgPSB7fSkpO1xuXG4vKipcbiAqIEFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIGEgdW5pdmVyc2FsIGNvbnRleHQgbWVudS5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGUgaXRlbXMgc2hvd24gaW4gdGhlIGNvbnRleHQgbWVudSBhcmUgZGV0ZXJtaW5lZCBieSBDU1Mgc2VsZWN0b3JcbiAqIG1hdGNoaW5nIGFnYWluc3QgdGhlIERPTSBoaWVyYXJjaHkgYXQgdGhlIHNpdGUgb2YgdGhlIG1vdXNlIGNsaWNrLlxuICogVGhpcyBpcyBzaW1pbGFyIGluIGNvbmNlcHQgdG8gaG93IGtleWJvYXJkIHNob3J0Y3V0cyBhcmUgbWF0Y2hlZFxuICogaW4gdGhlIGNvbW1hbmQgcmVnaXN0cnkuXG4gKi9cbnZhciBDb250ZXh0TWVudSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgY29udGV4dCBtZW51LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBtZW51LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnRleHRNZW51KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBCeVRhcmdldCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lkVGljayA9IDA7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX3NvcnRCeVNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgdmFyIGdyb3VwQnlUYXJnZXQgPSBvcHRpb25zLmdyb3VwQnlUYXJnZXQsIHNvcnRCeVNlbGVjdG9yID0gb3B0aW9ucy5zb3J0QnlTZWxlY3Rvciwgb3RoZXJzID0gX19yZXN0KG9wdGlvbnMsIFtcImdyb3VwQnlUYXJnZXRcIiwgXCJzb3J0QnlTZWxlY3RvclwiXSk7XG4gICAgICAgIHRoaXMubWVudSA9IG5ldyBNZW51KG90aGVycyk7XG4gICAgICAgIHRoaXMuX2dyb3VwQnlUYXJnZXQgPSBncm91cEJ5VGFyZ2V0ICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc29ydEJ5U2VsZWN0b3IgPSBzb3J0QnlTZWxlY3RvciAhPT0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBpdGVtIHRvIHRoZSBjb250ZXh0IG1lbnUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgaXRlbS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZGlzcG9zYWJsZSB3aGljaCB3aWxsIHJlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBtZW51LlxuICAgICAqL1xuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGl0ZW0gZnJvbSB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICAgICAgdmFyIGl0ZW0gPSBQcml2YXRlJGIuY3JlYXRlSXRlbShvcHRpb25zLCB0aGlzLl9pZFRpY2srKyk7XG4gICAgICAgIC8vIEFkZCB0aGUgaXRlbSB0byB0aGUgaW50ZXJuYWwgYXJyYXkuXG4gICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIC8vIFJldHVybiBhIGRpc3Bvc2FibGUgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGl0ZW0uXG4gICAgICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZURlbGVnYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEFycmF5RXh0LnJlbW92ZUZpcnN0T2YoX3RoaXMuX2l0ZW1zLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBjb250ZXh0IG1lbnUgaW4gcmVzcG9uc2UgdG8gYSBgJ2NvbnRleHRtZW51J2AgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgYCdjb250ZXh0bWVudSdgIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZW51IHdhcyBvcGVuZWQsIG9yIGBmYWxzZWAgaWYgbm8gaXRlbXNcbiAgICAgKiAgIG1hdGNoZWQgdGhlIGV2ZW50IGFuZCB0aGUgbWVudSB3YXMgbm90IG9wZW5lZC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHBvcHVsYXRlIHRoZSBjb250ZXh0IG1lbnUgd2l0aCBpdGVtcyB3aGljaCBtYXRjaFxuICAgICAqIHRoZSBwcm9wYWdhdGlvbiBwYXRoIG9mIHRoZSBldmVudCwgdGhlbiBvcGVuIHRoZSBtZW51IGF0IHRoZSBtb3VzZVxuICAgICAqIHBvc2l0aW9uIGluZGljYXRlZCBieSB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGNvbnRleHQgbWVudS5cbiAgICAgICAgdGhpcy5tZW51LmNsZWFySXRlbXMoKTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gaXRlbXMgdG8gbWF0Y2guXG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBtYXRjaGluZyBpdGVtcyBmb3IgdGhlIGV2ZW50LlxuICAgICAgICB2YXIgaXRlbXMgPSBQcml2YXRlJGIubWF0Y2hJdGVtcyh0aGlzLl9pdGVtcywgZXZlbnQsIHRoaXMuX2dyb3VwQnlUYXJnZXQsIHRoaXMuX3NvcnRCeVNlbGVjdG9yKTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBhcmUgbm8gbWF0Y2hpbmcgaXRlbXMuXG4gICAgICAgIGlmICghaXRlbXMgfHwgaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBmaWx0ZXJlZCBpdGVtcyB0byB0aGUgbWVudS5cbiAgICAgICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIF90aGlzLm1lbnUuYWRkSXRlbShpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9wZW4gdGhlIGNvbnRleHQgbWVudSBhdCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5tZW51Lm9wZW4oZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIC8vIEluZGljYXRlIHN1Y2Nlc3MuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHRNZW51O1xufSgpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSRiO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbm9ybWFsaXplZCBjb250ZXh0IG1lbnUgaXRlbSBmcm9tIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZW0ob3B0aW9ucywgaWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdmFsaWRhdGVTZWxlY3RvcihvcHRpb25zLnNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHJhbmsgPSBvcHRpb25zLnJhbmsgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmFuayA6IEluZmluaXR5O1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHNlbGVjdG9yOiBzZWxlY3RvciwgcmFuazogcmFuaywgaWQ6IGlkIH0pO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGl0ZW1zIHdoaWNoIG1hdGNoIGEgY29udGV4dCBtZW51IGV2ZW50LlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdHMgYXJlIHNvcnRlZCBieSBET00gbGV2ZWwsIHNwZWNpZmljaXR5LCBhbmQgcmFuay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaEl0ZW1zKGl0ZW1zLCBldmVudCwgZ3JvdXBCeVRhcmdldCwgc29ydEJ5U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudC5cbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyB0YXJnZXQuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHRoZSBjdXJyZW50IHRhcmdldCBvZiB0aGUgZXZlbnQuXG4gICAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBjdXJyZW50IHRhcmdldC5cbiAgICAgICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBhcmUgc29tZSB0aGlyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBjYXVzZSB0aGUgYHRhcmdldGAgdG9cbiAgICAgICAgLy8gYmUgZGV0YWNoZWQgZnJvbSB0aGUgRE9NIGJlZm9yZSBsdW1pbm8gY2FuIHByb2Nlc3MgdGhlIGV2ZW50LlxuICAgICAgICAvLyBJZiB0aGF0IGhhcHBlbnMsIHNlYXJjaCBmb3IgYSBuZXcgdGFyZ2V0IG5vZGUgYnkgcG9pbnQuIElmIHRoYXRcbiAgICAgICAgLy8gbm9kZSBpcyBzdGlsbCBkYW5nbGluZywgYmFpbC5cbiAgICAgICAgaWYgKCFjdXJyZW50VGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCB8fCAhY3VycmVudFRhcmdldC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHVwIHRoZSByZXN1bHQgYXJyYXkuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgLy8gQ29weSB0aGUgaXRlbXMgYXJyYXkgdG8gYWxsb3cgaW4tcGxhY2UgbW9kaWZpY2F0aW9uLlxuICAgICAgICB2YXIgYXZhaWxhYmxlSXRlbXMgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgICAvLyBXYWxrIHVwIHRoZSBET00gaGllcmFyY2h5IHNlYXJjaGluZyBmb3IgbWF0Y2hlcy5cbiAgICAgICAgd2hpbGUgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBtYXRjaCBhcnJheSBmb3IgdGhpcyBET00gbGV2ZWwuXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSByZW1haW5pbmcgaXRlbXMgZm9yIG1hdGNoZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGF2YWlsYWJsZUl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBpdGVtLlxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gYXZhaWxhYmxlSXRlbXNbaV07XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpdGVtcyB3aGljaCBhcmUgYWxyZWFkeSBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNraXAgaXRlbXMgd2hpY2ggZG8gbm90IG1hdGNoIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGlmICghU2VsZWN0b3IubWF0Y2hlcyh0YXJnZXQsIGl0ZW0uc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG1hdGNoZWQgaXRlbSB0byB0aGUgcmVzdWx0IGZvciB0aGlzIERPTSBsZXZlbC5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgaXRlbSBhcyBjb25zdW1lZC5cbiAgICAgICAgICAgICAgICBhdmFpbGFibGVJdGVtc1tpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb3J0IHRoZSBtYXRjaGVzIGZvciB0aGlzIGxldmVsIGFuZCBhZGQgdGhlbSB0byB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cEJ5VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuc29ydChzb3J0QnlTZWxlY3RvciA/IGl0ZW1DbXAgOiBpdGVtQ21wUmFuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9wIHNlYXJjaGluZyBhdCB0aGUgbGltaXRzIG9mIHRoZSBET00gcmFuZ2UuXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIHRvIHRoZSBwYXJlbnQgRE9NIGxldmVsLlxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFncm91cEJ5VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXN1bHQuc29ydChzb3J0QnlTZWxlY3RvciA/IGl0ZW1DbXAgOiBpdGVtQ21wUmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtYXRjaGVkIGFuZCBzb3J0ZWQgcmVzdWx0cy5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUHJpdmF0ZS5tYXRjaEl0ZW1zID0gbWF0Y2hJdGVtcztcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0b3IgZm9yIGEgbWVudSBpdGVtLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIHRoZSB2YWxpZGF0ZWQgc2VsZWN0b3IsIG9yIHRocm93cyBpZiB0aGUgc2VsZWN0b3IgaXNcbiAgICAgKiBpbnZhbGlkIG9yIGNvbnRhaW5zIGNvbW1hcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvci5pbmRleE9mKCcsJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvciBjYW5ub3QgY29udGFpbiBjb21tYXM6IFwiICsgc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU2VsZWN0b3IuaXNWYWxpZChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3I6IFwiICsgc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzb3J0IGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGEgY29udGV4dCBtZW51IGl0ZW0gYnkgcmFua3MuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlbUNtcFJhbmsoYSwgYikge1xuICAgICAgICAvLyBTb3J0IGJhc2VkIG9uIHJhbmsuXG4gICAgICAgIHZhciByMSA9IGEucmFuaztcbiAgICAgICAgdmFyIHIyID0gYi5yYW5rO1xuICAgICAgICBpZiAocjEgIT09IHIyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjEgPCByMiA/IC0xIDogMTsgLy8gSW5maW5pdHktc2FmZVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gYWxsIGVsc2UgZmFpbHMsIHNvcnQgYnkgaXRlbSBpZC5cbiAgICAgICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNvcnQgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYSBjb250ZXh0IG1lbnUgaXRlbSBieSBzZWxlY3RvcnMgYW5kIHJhbmtzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZW1DbXAoYSwgYikge1xuICAgICAgICAvLyBTb3J0IGZpcnN0IGJhc2VkIG9uIHNlbGVjdG9yIHNwZWNpZmljaXR5LlxuICAgICAgICB2YXIgczEgPSBTZWxlY3Rvci5jYWxjdWxhdGVTcGVjaWZpY2l0eShhLnNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHMyID0gU2VsZWN0b3IuY2FsY3VsYXRlU3BlY2lmaWNpdHkoYi5zZWxlY3Rvcik7XG4gICAgICAgIGlmIChzMSAhPT0gczIpIHtcbiAgICAgICAgICAgIHJldHVybiBzMiAtIHMxO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNwZWNpZmljaXRpZXMgYXJlIGVxdWFsXG4gICAgICAgIHJldHVybiBpdGVtQ21wUmFuayhhLCBiKTtcbiAgICB9XG59KShQcml2YXRlJGIgfHwgKFByaXZhdGUkYiA9IHt9KSk7XG5cbi8qKlxuICogQSB3aWRnZXQgd2hpY2ggZGlzcGxheXMgdGl0bGVzIGFzIGEgc2luZ2xlIHJvdyBvciBjb2x1bW4gb2YgdGFicy5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBJZiBDU1MgdHJhbnNmb3JtcyBhcmUgdXNlZCB0byByb3RhdGUgbm9kZXMgZm9yIHZlcnRpY2FsbHkgb3JpZW50ZWRcbiAqIHRleHQsIHRoZW4gdGFiIGRyYWdnaW5nIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBUaGUgYHRhYnNNb3ZhYmxlYFxuICogcHJvcGVydHkgc2hvdWxkIGJlIHNldCB0byBgZmFsc2VgIHdoZW4gcm90YXRpbmcgbm9kZXMgZnJvbSBDU1MuXG4gKi9cbnZhciBUYWJCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYkJhciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGFiIGJhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgdGFiIGJhci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUYWJCYXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IG5vZGU6IFByaXZhdGUkYy5jcmVhdGVOb2RlKCkgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRJbmRleCA9IC0xO1xuICAgICAgICBfdGhpcy5fdGl0bGVzID0gW107XG4gICAgICAgIF90aGlzLl90aXRsZXNFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fcHJldmlvdXNUaXRsZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9kcmFnRGF0YSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9hZGRCdXR0b25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl90YWJNb3ZlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fY3VycmVudENoYW5nZWQgPSBuZXcgU2lnbmFsKF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2FkZFJlcXVlc3RlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fdGFiQ2xvc2VSZXF1ZXN0ZWQgPSBuZXcgU2lnbmFsKF90aGlzKTtcbiAgICAgICAgX3RoaXMuX3RhYkRldGFjaFJlcXVlc3RlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fdGFiQWN0aXZhdGVSZXF1ZXN0ZWQgPSBuZXcgU2lnbmFsKF90aGlzKTtcbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ2xtLVRhYkJhcicpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3AtVGFiQmFyJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgX3RoaXMuY29udGVudE5vZGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICAgICAgX3RoaXMuc2V0RmxhZyhXaWRnZXQuRmxhZy5EaXNhbGxvd0xheW91dCk7XG4gICAgICAgIF90aGlzLnRhYnNNb3ZhYmxlID0gb3B0aW9ucy50YWJzTW92YWJsZSB8fCBmYWxzZTtcbiAgICAgICAgX3RoaXMudGl0bGVzRWRpdGFibGUgPSBvcHRpb25zLnRpdGxlc0VkaXRhYmxlIHx8IGZhbHNlO1xuICAgICAgICBfdGhpcy5hbGxvd0Rlc2VsZWN0ID0gb3B0aW9ucy5hbGxvd0Rlc2VsZWN0IHx8IGZhbHNlO1xuICAgICAgICBfdGhpcy5hZGRCdXR0b25FbmFibGVkID0gb3B0aW9ucy5hZGRCdXR0b25FbmFibGVkIHx8IGZhbHNlO1xuICAgICAgICBfdGhpcy5pbnNlcnRCZWhhdmlvciA9IG9wdGlvbnMuaW5zZXJ0QmVoYXZpb3IgfHwgJ3NlbGVjdC10YWItaWYtbmVlZGVkJztcbiAgICAgICAgX3RoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnJztcbiAgICAgICAgX3RoaXMub3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uIHx8ICdob3Jpem9udGFsJztcbiAgICAgICAgX3RoaXMucmVtb3ZlQmVoYXZpb3IgPSBvcHRpb25zLnJlbW92ZUJlaGF2aW9yIHx8ICdzZWxlY3QtdGFiLWFmdGVyJztcbiAgICAgICAgX3RoaXMucmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyIHx8IFRhYkJhci5kZWZhdWx0UmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICB0aGlzLl90aXRsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNUaXRsZSA9IG51bGw7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkJhci5wcm90b3R5cGUsIFwiY3VycmVudENoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBjdXJyZW50IHRhYiBpcyBjaGFuZ2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIGVtaXR0ZWQgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYiBpcyBjaGFuZ2VkXG4gICAgICAgICAqIGVpdGhlciB0aHJvdWdoIHVzZXIgb3IgcHJvZ3JhbW1hdGljIGludGVyYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RhYmx5LCB0aGlzIHNpZ25hbCBpcyBub3QgZW1pdHRlZCB3aGVuIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICAgICAgICAgKiB0YWIgY2hhbmdlcyBkdWUgdG8gdGFicyBiZWluZyBpbnNlcnRlZCwgcmVtb3ZlZCwgb3IgbW92ZWQuIEl0IGlzXG4gICAgICAgICAqIG9ubHkgZW1pdHRlZCB3aGVuIHRoZSBhY3R1YWwgY3VycmVudCB0YWIgbm9kZSBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudENoYW5nZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJCYXIucHJvdG90eXBlLCBcInRhYk1vdmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiBhIHRhYiBpcyBtb3ZlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHNpZ25hbCBpcyBlbWl0dGVkIHdoZW4gYSB0YWIgaXMgbW92ZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBzaWduYWwgaXMgbm90IGVtaXR0ZWQgd2hlbiBhIHRhYiBpcyBtb3ZlZCBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFiTW92ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJCYXIucHJvdG90eXBlLCBcInRhYkFjdGl2YXRlUmVxdWVzdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiBhIHRhYiBpcyBjbGlja2VkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIElmIHRoZSBjbGlja2VkIHRhYiBpcyBub3QgdGhlIGN1cnJlbnQgdGFiLCB0aGUgY2xpY2tlZCB0YWIgd2lsbCBiZVxuICAgICAgICAgKiBtYWRlIGN1cnJlbnQgYW5kIHRoZSBgY3VycmVudENoYW5nZWRgIHNpZ25hbCB3aWxsIGJlIGVtaXR0ZWQgZmlyc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIGVtaXR0ZWQgZXZlbiBpZiB0aGUgY2xpY2tlZCB0YWIgaXMgdGhlIGN1cnJlbnQgdGFiLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFiQWN0aXZhdGVSZXF1ZXN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJCYXIucHJvdG90eXBlLCBcImFkZFJlcXVlc3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIHRhYiBiYXIgYWRkIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVxdWVzdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJ0YWJDbG9zZVJlcXVlc3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gYSB0YWIgY2xvc2UgaWNvbiBpcyBjbGlja2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIG5vdCBlbWl0dGVkIHVubGVzcyB0aGUgdGFiIHRpdGxlIGlzIGBjbG9zYWJsZWAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWJDbG9zZVJlcXVlc3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkJhci5wcm90b3R5cGUsIFwidGFiRGV0YWNoUmVxdWVzdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiBhIHRhYiBpcyBkcmFnZ2VkIGJleW9uZCB0aGUgZGV0YWNoIHRocmVzaG9sZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHNpZ25hbCBpcyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYSB0YWIgd2l0aCB0aGUgbW91c2UsXG4gICAgICAgICAqIGFuZCBtb3VzZSBpcyBkcmFnZ2VkIGJleW9uZCB0aGUgZGV0YWNoIHRocmVzaG9sZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNvbnN1bWVyIG9mIHRoZSBzaWduYWwgc2hvdWxkIGNhbGwgYHJlbGVhc2VNb3VzZWAgYW5kIHJlbW92ZVxuICAgICAgICAgKiB0aGUgdGFiIGluIG9yZGVyIHRvIGNvbXBsZXRlIHRoZSBkZXRhY2guXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIG9ubHkgZW1pdHRlZCBvbmNlIHBlciBkcmFnIGN5Y2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFiRGV0YWNoUmVxdWVzdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJ0aXRsZXNFZGl0YWJsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0aXRsZXMgY2FuIGJlIHVzZXItZWRpdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGVzRWRpdGFibGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgd2hldGhlciB0aXRsZXMgY2FuIGJlIHVzZXIgZWRpdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpdGxlc0VkaXRhYmxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJCYXIucHJvdG90eXBlLCBcImN1cnJlbnRUaXRsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgYG51bGxgIGlmIG5vIHRhYiBpcyBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpdGxlc1t0aGlzLl9jdXJyZW50SW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0aXRsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBJZiB0aGUgdGl0bGUgZG9lcyBub3QgZXhpc3QsIHRoZSB0aXRsZSB3aWxsIGJlIHNldCB0byBgbnVsbGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSB2YWx1ZSA/IHRoaXMuX3RpdGxlcy5pbmRleE9mKHZhbHVlKSA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJjdXJyZW50SW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgYC0xYCBpZiBubyB0YWIgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBvdXQgb2YgcmFuZ2UsIHRoZSBpbmRleCB3aWxsIGJlIHNldCB0byBgLTFgLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBmb3IgYW4gb3V0IG9mIHJhbmdlIGluZGV4LlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSB0aGlzLl90aXRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIGluZGV4IHdpbGwgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgcHJldmlvdXMgaW5kZXggYW5kIHRpdGxlLlxuICAgICAgICAgICAgdmFyIHBpID0gdGhpcy5fY3VycmVudEluZGV4O1xuICAgICAgICAgICAgdmFyIHB0ID0gdGhpcy5fdGl0bGVzW3BpXSB8fCBudWxsO1xuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgY3VycmVudCBpbmRleCBhbmQgdGl0bGUuXG4gICAgICAgICAgICB2YXIgY2kgPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBjdCA9IHRoaXMuX3RpdGxlc1tjaV0gfHwgbnVsbDtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBpbmRleCBhbmQgcHJldmlvdXMgdGl0bGUuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSBjaTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVGl0bGUgPSBwdDtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvZiB0aGUgdGFicy5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBjdXJyZW50IGNoYW5nZWQgc2lnbmFsLlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENoYW5nZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNJbmRleDogcGksIHByZXZpb3VzVGl0bGU6IHB0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogY2ksIGN1cnJlbnRUaXRsZTogY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGFiIGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG5hbWUgb2YgdGhlIHRhYiBiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSB0YWIgYmFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgY29udHJvbHMgd2hldGhlciB0aGUgdGFicyBhcmUgYXJyYW5nZWQgaW4gYSByb3cgb3IgY29sdW1uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSB0YWIgYmFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgY29udHJvbHMgd2hldGhlciB0aGUgdGFicyBhcmUgYXJyYW5nZWQgaW4gYSByb3cgb3IgY29sdW1uLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIG9yaWVudGF0aW9uIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWxlYXNlIHRoZSBtb3VzZSBiZWZvcmUgbWFraW5nIGFueSBjaGFuZ2VzLlxuICAgICAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgdGhlIG9yaWVudGF0aW9uIHZhbHVlcy5cbiAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFzZXRbJ29yaWVudGF0aW9uJ10gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLW9yaWVudGF0aW9uJywgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJhZGRCdXR0b25FbmFibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGFkZCBidXR0b24gaXMgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEJ1dHRvbkVuYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgd2hldGhlciB0aGUgYWRkIGJ1dHRvbiBpcyBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hZGRCdXR0b25FbmFibGVkID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZEJ1dHRvbkVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQnV0dG9uTm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJ1dHRvbk5vZGUuY2xhc3NMaXN0LmFkZCgnbG0tbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiQmFyLnByb3RvdHlwZSwgXCJ0aXRsZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIHRpdGxlcyBpbiB0aGUgdGFiIGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpdGxlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkJhci5wcm90b3R5cGUsIFwiY29udGVudE5vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhYiBiYXIgY29udGVudCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIG5vZGUgd2hpY2ggaG9sZHMgdGhlIHRhYiBub2Rlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTW9kaWZ5aW5nIHRoaXMgbm9kZSBkaXJlY3RseSBjYW4gbGVhZCB0byB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG0tVGFiQmFyLWNvbnRlbnQnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkJhci5wcm90b3R5cGUsIFwiYWRkQnV0dG9uTm9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFiIGJhciBhZGQgYnV0dG9uIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyBpcyB0aGUgbm9kZSB3aGljaCBob2xkcyB0aGUgYWRkIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogTW9kaWZ5aW5nIHRoaXMgbm9kZSBkaXJlY3RseSBjYW4gbGVhZCB0byB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG0tVGFiQmFyLWFkZEJ1dHRvbicpWzBdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB0YWIgdG8gdGhlIGVuZCBvZiB0aGUgdGFiIGJhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0aXRsZSB3aGljaCBob2xkcyB0aGUgZGF0YSBmb3IgdGhlIHRhYixcbiAgICAgKiAgIG9yIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYSB0aXRsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0aXRsZSBvYmplY3QgYWRkZWQgdG8gdGhlIHRhYiBiYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHRpdGxlIGlzIGFscmVhZHkgYWRkZWQgdG8gdGhlIHRhYiBiYXIsIGl0IHdpbGwgYmUgbW92ZWQuXG4gICAgICovXG4gICAgVGFiQmFyLnByb3RvdHlwZS5hZGRUYWIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0VGFiKHRoaXMuX3RpdGxlcy5sZW5ndGgsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHRhYiBpbnRvIHRoZSB0YWIgYmFyIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSB0YWIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdGl0bGUgd2hpY2ggaG9sZHMgdGhlIGRhdGEgZm9yIHRoZSB0YWIsXG4gICAgICogICBvciBhbiBvcHRpb25zIG9iamVjdCB0byBjb252ZXJ0IHRvIGEgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdGl0bGUgb2JqZWN0IGFkZGVkIHRvIHRoZSB0YWIgYmFyLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBpbmRleCB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIGJvdW5kcyBvZiB0aGUgdGFicy5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0aXRsZSBpcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSB0YWIgYmFyLCBpdCB3aWxsIGJlIG1vdmVkLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUuaW5zZXJ0VGFiID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBtb3VzZSBiZWZvcmUgbWFraW5nIGFueSBjaGFuZ2VzLlxuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgLy8gQ29lcmNlIHRoZSB2YWx1ZSB0byBhIHRpdGxlLlxuICAgICAgICB2YXIgdGl0bGUgPSBQcml2YXRlJGMuYXNUaXRsZSh2YWx1ZSk7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIGluZGV4IG9mIHRoZSB0aXRsZS5cbiAgICAgICAgdmFyIGkgPSB0aGlzLl90aXRsZXMuaW5kZXhPZih0aXRsZSk7XG4gICAgICAgIC8vIENsYW1wIHRoZSBpbnNlcnQgaW5kZXggdG8gdGhlIGFycmF5IGJvdW5kcy5cbiAgICAgICAgdmFyIGogPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5fdGl0bGVzLmxlbmd0aCkpO1xuICAgICAgICAvLyBJZiB0aGUgdGl0bGUgaXMgbm90IGluIHRoZSBhcnJheSwgaW5zZXJ0IGl0LlxuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgdGl0bGUgaW50byB0aGUgYXJyYXkuXG4gICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQodGhpcy5fdGl0bGVzLCBqLCB0aXRsZSk7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIHRoZSB0aXRsZSBjaGFuZ2VkIHNpZ25hbC5cbiAgICAgICAgICAgIHRpdGxlLmNoYW5nZWQuY29ubmVjdCh0aGlzLl9vblRpdGxlQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIHRhYnMuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBjdXJyZW50IGluZGV4IGZvciB0aGUgaW5zZXJ0LlxuICAgICAgICAgICAgdGhpcy5fYWRqdXN0Q3VycmVudEZvckluc2VydChqLCB0aXRsZSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHRpdGxlIGFkZGVkIHRvIHRoZSB0YWIgYmFyLlxuICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHRpdGxlIGV4aXN0cyBpbiB0aGUgYXJyYXkgYW5kIHNob3VsZCBiZSBtb3ZlZC5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSBpbmRleCBpZiB0aGUgbG9jYXRpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgIGlmIChqID09PSB0aGlzLl90aXRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBlZmZlY3RpdmUgbW92ZS5cbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIHJldHVybiB0aXRsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlIHRoZSB0aXRsZSB0byB0aGUgbmV3IGxvY2F0aW9uLlxuICAgICAgICBBcnJheUV4dC5tb3ZlKHRoaXMuX3RpdGxlcywgaSwgaik7XG4gICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvZiB0aGUgdGFicy5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBjdXJyZW50IGluZGV4IGZvciB0aGUgbW92ZS5cbiAgICAgICAgdGhpcy5fYWRqdXN0Q3VycmVudEZvck1vdmUoaSwgaik7XG4gICAgICAgIC8vIFJldHVybiB0aGUgdGl0bGUgYWRkZWQgdG8gdGhlIHRhYiBiYXIuXG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRhYiBmcm9tIHRoZSB0YWIgYmFyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpdGxlIC0gVGhlIHRpdGxlIGZvciB0aGUgdGFiIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIHRpdGxlIGlzIG5vdCBpbiB0aGUgdGFiIGJhci5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLnJlbW92ZVRhYiA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhYkF0KHRoaXMuX3RpdGxlcy5pbmRleE9mKHRpdGxlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHRhYiBhdCBhIGdpdmVuIGluZGV4IGZyb20gdGhlIHRhYiBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgVGFiQmFyLnByb3RvdHlwZS5yZW1vdmVUYWJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBtb3VzZSBiZWZvcmUgbWFraW5nIGFueSBjaGFuZ2VzLlxuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0aXRsZSBmcm9tIHRoZSBhcnJheS5cbiAgICAgICAgdmFyIHRpdGxlID0gQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5fdGl0bGVzLCBpbmRleCk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgdGl0bGUgY2hhbmdlZCBzaWduYWwuXG4gICAgICAgIHRpdGxlLmNoYW5nZWQuZGlzY29ubmVjdCh0aGlzLl9vblRpdGxlQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBwcmV2aW91cyB0aXRsZSBpZiBpdCdzIGJlaW5nIHJlbW92ZWQuXG4gICAgICAgIGlmICh0aXRsZSA9PT0gdGhpcy5fcHJldmlvdXNUaXRsZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNUaXRsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSB0YWJzLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGN1cnJlbnQgaW5kZXggZm9yIHRoZSByZW1vdmUuXG4gICAgICAgIHRoaXMuX2FkanVzdEN1cnJlbnRGb3JSZW1vdmUoaW5kZXgsIHRpdGxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgdGFicyBmcm9tIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUuY2xlYXJUYWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gcmVtb3ZlLlxuICAgICAgICBpZiAodGhpcy5fdGl0bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlIGJlZm9yZSBtYWtpbmcgYW55IGNoYW5nZXMuXG4gICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICAvLyBEaXNjb25uZWN0IGZyb20gdGhlIHRpdGxlIGNoYW5nZWQgc2lnbmFscy5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3RpdGxlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHRpdGxlLmNoYW5nZWQuZGlzY29ubmVjdCh0aGlzLl9vblRpdGxlQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGluZGV4IGFuZCB0aXRsZS5cbiAgICAgICAgdmFyIHBpID0gdGhpcy5jdXJyZW50SW5kZXg7XG4gICAgICAgIHZhciBwdCA9IHRoaXMuY3VycmVudFRpdGxlO1xuICAgICAgICAvLyBSZXNldCB0aGUgY3VycmVudCBpbmRleCBhbmQgcHJldmlvdXMgdGl0bGUuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1RpdGxlID0gbnVsbDtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHRpdGxlIGFycmF5LlxuICAgICAgICB0aGlzLl90aXRsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSB0YWJzLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAvLyBJZiBubyB0YWIgd2FzIHNlbGVjdGVkLCB0aGVyZSdzIG5vdGhpbmcgZWxzZSB0byBkby5cbiAgICAgICAgaWYgKHBpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgdGhlIGN1cnJlbnQgY2hhbmdlZCBzaWduYWwuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgcHJldmlvdXNJbmRleDogcGksIHByZXZpb3VzVGl0bGU6IHB0LFxuICAgICAgICAgICAgY3VycmVudEluZGV4OiAtMSwgY3VycmVudFRpdGxlOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgbW91c2UgYW5kIHJlc3RvcmUgdGhlIG5vbi1kcmFnZ2VkIHRhYiBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIGNhdXNlIHRoZSB0YWIgYmFyIHRvIHN0b3AgaGFuZGxpbmcgbW91c2UgZXZlbnRzIGFuZCB0b1xuICAgICAqIHJlc3RvcmUgdGhlIHRhYnMgdG8gdGhlaXIgbm9uLWRyYWdnZWQgcG9zaXRpb25zLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUucmVsZWFzZU1vdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIHRhYiBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IHNlbnQgdG8gdGhlIHRhYiBiYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgRE9NIGBFdmVudExpc3RlbmVyYCBpbnRlcmZhY2UgYW5kIGlzXG4gICAgICogY2FsbGVkIGluIHJlc3BvbnNlIHRvIGV2ZW50cyBvbiB0aGUgdGFiIGJhcidzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgVGFiQmFyLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlVXAoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGJsY2xpY2snOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dERibENsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dEtleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1hdHRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUub25CZWZvcmVBdHRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLm9uQWZ0ZXJEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhbiBgJ3VwZGF0ZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLm9uVXBkYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIHRpdGxlcyA9IHRoaXMuX3RpdGxlcztcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGN1cnJlbnRUaXRsZSA9IHRoaXMuY3VycmVudFRpdGxlO1xuICAgICAgICB2YXIgY29udGVudCA9IG5ldyBBcnJheSh0aXRsZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aXRsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSB0aXRsZXNbaV07XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRpdGxlID09PSBjdXJyZW50VGl0bGU7XG4gICAgICAgICAgICB2YXIgekluZGV4ID0gY3VycmVudCA/IG4gOiBuIC0gaSAtIDE7XG4gICAgICAgICAgICBjb250ZW50W2ldID0gcmVuZGVyZXIucmVuZGVyVGFiKHsgdGl0bGU6IHRpdGxlLCBjdXJyZW50OiBjdXJyZW50LCB6SW5kZXg6IHpJbmRleCB9KTtcbiAgICAgICAgfVxuICAgICAgICBWaXJ0dWFsRE9NLnJlbmRlcihjb250ZW50LCB0aGlzLmNvbnRlbnROb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdkYmxjbGljaydgIGV2ZW50IGZvciB0aGUgdGFiIGJhci5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLl9ldnREYmxDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRpdGxlcyBhcmUgbm90IGVkaXRhYmxlXG4gICAgICAgIGlmICghdGhpcy50aXRsZXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWJzID0gdGhpcy5jb250ZW50Tm9kZS5jaGlsZHJlbjtcbiAgICAgICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIHJlbGVhc2VkIHRhYi5cbiAgICAgICAgdmFyIGluZGV4ID0gQXJyYXlFeHQuZmluZEZpcnN0SW5kZXgodGFicywgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRFeHQuaGl0VGVzdCh0YWIsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgcHJlc3MgaXMgbm90IG9uIGEgdGFiLlxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy50aXRsZXNbaW5kZXhdO1xuICAgICAgICB2YXIgbGFiZWwgPSB0YWJzW2luZGV4XS5xdWVyeVNlbGVjdG9yKCcubG0tVGFiQmFyLXRhYkxhYmVsJyk7XG4gICAgICAgIGlmIChsYWJlbCAmJiBsYWJlbC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aXRsZS5sYWJlbCB8fCAnJztcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBsYWJlbCBlbGVtZW50XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWVfMSA9IGxhYmVsLmlubmVySFRNTDtcbiAgICAgICAgICAgIGxhYmVsLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaW5wdXRfMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpbnB1dF8xLmNsYXNzTGlzdC5hZGQoJ2xtLVRhYkJhci10YWJJbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXRfMS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXRfMSk7XG4gICAgICAgICAgICB2YXIgb25ibHVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRfMS5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgb25ibHVyXzEpO1xuICAgICAgICAgICAgICAgIGxhYmVsLmlubmVySFRNTCA9IG9sZFZhbHVlXzE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5wdXRfMS5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IH0pO1xuICAgICAgICAgICAgaW5wdXRfMS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25ibHVyXzEpO1xuICAgICAgICAgICAgaW5wdXRfMS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfMS52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLmxhYmVsID0gdGl0bGUuY2FwdGlvbiA9IGlucHV0XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb25ibHVyXzEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICBvbmJsdXJfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXRfMS5zZWxlY3QoKTtcbiAgICAgICAgICAgIGlucHV0XzEuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChsYWJlbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuY2hpbGRyZW5bMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ2tleWRvd24nYCBldmVudCBmb3IgdGhlIHRhYiBiYXIuXG4gICAgICovXG4gICAgVGFiQmFyLnByb3RvdHlwZS5fZXZ0S2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBTdG9wIGFsbCBpbnB1dCBldmVudHMgZHVyaW5nIGRyYWcuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBSZWxlYXNlIHRoZSBtb3VzZSBpZiBgRXNjYXBlYCBpcyBwcmVzc2VkLlxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vkb3duJ2AgZXZlbnQgZm9yIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUuX2V2dE1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGl0J3Mgbm90IGEgbGVmdCBvciBtaWRkbGUgbW91c2UgcHJlc3MuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgJiYgZXZlbnQuYnV0dG9uICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIGlmICh0aGlzLl9kcmFnRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhZGQgYnV0dG9uIHdhcyBjbGlja2VkLlxuICAgICAgICB2YXIgYWRkQnV0dG9uQ2xpY2tlZCA9IHRoaXMuYWRkQnV0dG9uRW5hYmxlZCAmJlxuICAgICAgICAgICAgdGhpcy5hZGRCdXR0b25Ob2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgdGFiIG5vZGVzLlxuICAgICAgICB2YXIgdGFicyA9IHRoaXMuY29udGVudE5vZGUuY2hpbGRyZW47XG4gICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBwcmVzc2VkIHRhYi5cbiAgICAgICAgdmFyIGluZGV4ID0gQXJyYXlFeHQuZmluZEZpcnN0SW5kZXgodGFicywgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRFeHQuaGl0VGVzdCh0YWIsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgcHJlc3MgaXMgbm90IG9uIGEgdGFiIG9yIHRoZSBhZGQgYnV0dG9uLlxuICAgICAgICBpZiAoaW5kZXggPT09IC0xICYmICFhZGRCdXR0b25DbGlja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlc3Npbmcgb24gYSB0YWIgc3RvcHMgdGhlIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbm9uLW1lYXN1cmVkIHBhcnRzIG9mIHRoZSBkcmFnIGRhdGEuXG4gICAgICAgIHRoaXMuX2RyYWdEYXRhID0ge1xuICAgICAgICAgICAgdGFiOiB0YWJzW2luZGV4XSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHByZXNzWDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIHByZXNzWTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgIHRhYlBvczogLTEsXG4gICAgICAgICAgICB0YWJTaXplOiAtMSxcbiAgICAgICAgICAgIHRhYlByZXNzUG9zOiAtMSxcbiAgICAgICAgICAgIHRhcmdldEluZGV4OiAtMSxcbiAgICAgICAgICAgIHRhYkxheW91dDogbnVsbCxcbiAgICAgICAgICAgIGNvbnRlbnRSZWN0OiBudWxsLFxuICAgICAgICAgICAgb3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICBkcmFnQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdBYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGRldGFjaFJlcXVlc3RlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIHRoZSBkb2N1bWVudCBtb3VzZSB1cCBsaXN0ZW5lci5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMsIHRydWUpO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGVsc2UgaWYgdGhlIG1pZGRsZSBidXR0b24gb3IgYWRkIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAxIHx8IGFkZEJ1dHRvbkNsaWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3RoaW5nIGVsc2UgaWYgdGhlIGNsb3NlIGljb24gaXMgY2xpY2tlZC5cbiAgICAgICAgdmFyIGljb24gPSB0YWJzW2luZGV4XS5xdWVyeVNlbGVjdG9yKHRoaXMucmVuZGVyZXIuY2xvc2VJY29uU2VsZWN0b3IpO1xuICAgICAgICBpZiAoaWNvbiAmJiBpY29uLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGV4dHJhIGxpc3RlbmVycyBpZiB0aGUgdGFicyBhcmUgbW92YWJsZS5cbiAgICAgICAgaWYgKHRoaXMudGFic01vdmFibGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgaW5kZXggYXMgYXBwcm9wcmlhdGUuXG4gICAgICAgIGlmICh0aGlzLmFsbG93RGVzZWxlY3QgJiYgdGhpcy5jdXJyZW50SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3RoaW5nIGVsc2UgaWYgdGhlcmUgaXMgbm8gY3VycmVudCB0YWIuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IHRoZSB0YWIgYWN0aXZhdGUgcmVxdWVzdCBzaWduYWwuXG4gICAgICAgIHRoaXMuX3RhYkFjdGl2YXRlUmVxdWVzdGVkLmVtaXQoe1xuICAgICAgICAgICAgaW5kZXg6IHRoaXMuY3VycmVudEluZGV4LCB0aXRsZTogdGhpcy5jdXJyZW50VGl0bGVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vtb3ZlJ2AgZXZlbnQgZm9yIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUuX2V2dE1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG5vIGRyYWcgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZHJhZ0RhdGE7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1cHByZXNzIHRoZSBldmVudCBkdXJpbmcgYSBkcmFnLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gTG9va3VwIHRoZSB0YWIgbm9kZXMuXG4gICAgICAgIHZhciB0YWJzID0gdGhpcy5jb250ZW50Tm9kZS5jaGlsZHJlbjtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgZHJhZyB0aHJlc2hvbGQgaGFzIG5vdCBiZWVuIG1ldC5cbiAgICAgICAgaWYgKCFkYXRhLmRyYWdBY3RpdmUgJiYgIVByaXZhdGUkYy5kcmFnRXhjZWVkZWQoZGF0YSwgZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGRyYWcgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoIWRhdGEuZHJhZ0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgZHJhZyBkYXRhIG1lYXN1cmVtZW50cy5cbiAgICAgICAgICAgIHZhciB0YWJSZWN0ID0gZGF0YS50YWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIGRhdGEudGFiUG9zID0gZGF0YS50YWIub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICBkYXRhLnRhYlNpemUgPSB0YWJSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGRhdGEudGFiUHJlc3NQb3MgPSBkYXRhLnByZXNzWCAtIHRhYlJlY3QubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEudGFiUG9zID0gZGF0YS50YWIub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGRhdGEudGFiU2l6ZSA9IHRhYlJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGRhdGEudGFiUHJlc3NQb3MgPSBkYXRhLnByZXNzWSAtIHRhYlJlY3QudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS50YWJMYXlvdXQgPSBQcml2YXRlJGMuc25hcFRhYkxheW91dCh0YWJzLCB0aGlzLl9vcmllbnRhdGlvbik7XG4gICAgICAgICAgICBkYXRhLmNvbnRlbnRSZWN0ID0gdGhpcy5jb250ZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGRhdGEub3ZlcnJpZGUgPSBEcmFnLm92ZXJyaWRlQ3Vyc29yKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGRyYWdnaW5nIHN0eWxlIGNsYXNzZXMuXG4gICAgICAgICAgICBkYXRhLnRhYi5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2xtLW1vZC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBkYXRhLnRhYi5jbGFzc0xpc3QuYWRkKCdwLW1vZC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcygncC1tb2QtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIGRyYWcgYXMgYWN0aXZlLlxuICAgICAgICAgICAgZGF0YS5kcmFnQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IHRoZSBkZXRhY2ggcmVxdWVzdGVkIHNpZ25hbCBpZiB0aGUgdGhyZXNob2xkIGlzIGV4Y2VlZGVkLlxuICAgICAgICBpZiAoIWRhdGEuZGV0YWNoUmVxdWVzdGVkICYmIFByaXZhdGUkYy5kZXRhY2hFeGNlZWRlZChkYXRhLCBldmVudCkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZW1pdCB0aGUgc2lnbmFsIG9uY2UgcGVyIGRyYWcgY3ljbGUuXG4gICAgICAgICAgICBkYXRhLmRldGFjaFJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBTZXR1cCB0aGUgYXJndW1lbnRzIGZvciB0aGUgc2lnbmFsLlxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5pbmRleDtcbiAgICAgICAgICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIHZhciBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIHZhciB0YWIgPSB0YWJzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuX3RpdGxlc1tpbmRleF07XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSB0YWIgZGV0YWNoIHJlcXVlc3RlZCBzaWduYWwuXG4gICAgICAgICAgICB0aGlzLl90YWJEZXRhY2hSZXF1ZXN0ZWQuZW1pdCh7IGluZGV4OiBpbmRleCwgdGl0bGU6IHRpdGxlLCB0YWI6IHRhYiwgY2xpZW50WDogY2xpZW50WCwgY2xpZW50WTogY2xpZW50WSB9KTtcbiAgICAgICAgICAgIC8vIEJhaWwgaWYgdGhlIHNpZ25hbCBoYW5kbGVyIGFib3J0ZWQgdGhlIGRyYWcuXG4gICAgICAgICAgICBpZiAoZGF0YS5kcmFnQWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUgdGFicy5cbiAgICAgICAgUHJpdmF0ZSRjLmxheW91dFRhYnModGFicywgZGF0YSwgZXZlbnQsIHRoaXMuX29yaWVudGF0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdtb3VzZXVwJ2AgZXZlbnQgZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLl9ldnRNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgaXQncyBub3QgYSBsZWZ0IG9yIG1pZGRsZSBtb3VzZSByZWxlYXNlLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwICYmIGV2ZW50LmJ1dHRvbiAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgbm8gZHJhZyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kcmFnRGF0YTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGV4dHJhIG1vdXNlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMsIHRydWUpO1xuICAgICAgICAvLyBIYW5kbGUgYSByZWxlYXNlIHdoZW4gdGhlIGRyYWcgaXMgbm90IGFjdGl2ZS5cbiAgICAgICAgaWYgKCFkYXRhLmRyYWdBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBkcmFnIGRhdGEuXG4gICAgICAgICAgICB0aGlzLl9kcmFnRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tpbmcgdGhlIGFkZCBidXR0b24uXG4gICAgICAgICAgICB2YXIgYWRkQnV0dG9uQ2xpY2tlZCA9IHRoaXMuYWRkQnV0dG9uRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQnV0dG9uTm9kZS5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGFkZEJ1dHRvbkNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRSZXF1ZXN0ZWQuZW1pdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2t1cCB0aGUgdGFiIG5vZGVzLlxuICAgICAgICAgICAgdmFyIHRhYnMgPSB0aGlzLmNvbnRlbnROb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIHJlbGVhc2VkIHRhYi5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRhYnMsIGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWxlbWVudEV4dC5oaXRUZXN0KHRhYiwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHJlbGVhc2UgaXMgbm90IG9uIHRoZSBvcmlnaW5hbCBwcmVzc2VkIHRhYi5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZGF0YS5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgcmVsZWFzZSBpZiB0aGUgdGl0bGUgaXMgbm90IGNsb3NhYmxlLlxuICAgICAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5fdGl0bGVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghdGl0bGUuY2xvc2FibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBjbG9zZSByZXF1ZXN0ZWQgc2lnbmFsIGlmIHRoZSBtaWRkbGUgYnV0dG9uIGlzIHJlbGVhc2VkLlxuICAgICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkNsb3NlUmVxdWVzdGVkLmVtaXQoeyBpbmRleDogaW5kZXgsIHRpdGxlOiB0aXRsZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBjbG9zZSByZXF1ZXN0ZWQgc2lnbmFsIGlmIHRoZSBjbG9zZSBpY29uIHdhcyByZWxlYXNlZC5cbiAgICAgICAgICAgIHZhciBpY29uID0gdGFic1tpbmRleF0ucXVlcnlTZWxlY3Rvcih0aGlzLnJlbmRlcmVyLmNsb3NlSWNvblNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChpY29uICYmIGljb24uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkNsb3NlUmVxdWVzdGVkLmVtaXQoeyBpbmRleDogaW5kZXgsIHRpdGxlOiB0aXRsZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZXJlIGlzIG5vdGhpbmcgbGVmdCB0byBkby5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBsZWZ0IGJ1dHRvbiBpcyBub3QgcmVsZWFzZWQuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdGFiIGF0IGl0cyBmaW5hbCByZXN0aW5nIHBvc2l0aW9uLlxuICAgICAgICBQcml2YXRlJGMuZmluYWxpemVUYWJQb3NpdGlvbihkYXRhLCB0aGlzLl9vcmllbnRhdGlvbik7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZHJhZ2dpbmcgY2xhc3MgZnJvbSB0aGUgdGFiIHNvIGl0IGNhbiBiZSB0cmFuc2l0aW9uZWQuXG4gICAgICAgIGRhdGEudGFiLmNsYXNzTGlzdC5yZW1vdmUoJ2xtLW1vZC1kcmFnZ2luZycpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgZGF0YS50YWIuY2xhc3NMaXN0LnJlbW92ZSgncC1tb2QtZHJhZ2dpbmcnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAvLyBQYXJzZSB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBmb3IgcmVsZWFzaW5nIHRoZSB0YWIuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IFByaXZhdGUkYy5wYXJzZVRyYW5zaXRpb25EdXJhdGlvbihkYXRhLnRhYik7XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSByZWxlYXNlIG9uIGEgdGltZXIgdG8gYWxsb3cgdGhlIHRhYiB0byB0cmFuc2l0aW9uLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGRyYWcgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgICAgIGlmIChkYXRhLmRyYWdBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGRyYWcgZGF0YSByZWZlcmVuY2UuXG4gICAgICAgICAgICBfdGhpcy5fZHJhZ0RhdGEgPSBudWxsO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9ucyBvZiB0aGUgdGFicy5cbiAgICAgICAgICAgIFByaXZhdGUkYy5yZXNldFRhYlBvc2l0aW9ucyhfdGhpcy5jb250ZW50Tm9kZS5jaGlsZHJlbiwgX3RoaXMuX29yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjdXJzb3IgZ3JhYi5cbiAgICAgICAgICAgIGRhdGEub3ZlcnJpZGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZW1haW5pbmcgZHJhZ2dpbmcgc3R5bGUuXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVDbGFzcygnbG0tbW9kLWRyYWdnaW5nJyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUNsYXNzKCdwLW1vZC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhYiB3YXMgbm90IG1vdmVkLCB0aGVyZSBpcyBub3RoaW5nIGVsc2UgdG8gZG8uXG4gICAgICAgICAgICB2YXIgaSA9IGRhdGEuaW5kZXg7XG4gICAgICAgICAgICB2YXIgaiA9IGRhdGEudGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBpZiAoaiA9PT0gLTEgfHwgaSA9PT0gaikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIHRpdGxlIHRvIHRoZSBuZXcgbG9jYXRpb25zLlxuICAgICAgICAgICAgQXJyYXlFeHQubW92ZShfdGhpcy5fdGl0bGVzLCBpLCBqKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgY3VycmVudCBpbmRleCBmb3IgdGhlIG1vdmUuXG4gICAgICAgICAgICBfdGhpcy5fYWRqdXN0Q3VycmVudEZvck1vdmUoaSwgaik7XG4gICAgICAgICAgICAvLyBFbWl0IHRoZSB0YWIgbW92ZWQgc2lnbmFsLlxuICAgICAgICAgICAgX3RoaXMuX3RhYk1vdmVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGZyb21JbmRleDogaSwgdG9JbmRleDogaiwgdGl0bGU6IF90aGlzLl90aXRsZXNbal1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YWJzIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgZmxpY2tlci5cbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKF90aGlzLCBXaWRnZXQuTXNnLlVwZGF0ZVJlcXVlc3QpO1xuICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBtb3VzZSBhbmQgcmVzdG9yZSB0aGUgbm9uLWRyYWdnZWQgdGFiIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLl9yZWxlYXNlTW91c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgbm8gZHJhZyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kcmFnRGF0YTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRyYWcgZGF0YSByZWZlcmVuY2UuXG4gICAgICAgIHRoaXMuX2RyYWdEYXRhID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHRyYSBtb3VzZSBsaXN0ZW5lcnMuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgLy8gSW5kaWNhdGUgdGhlIGRyYWcgaGFzIGJlZW4gYWJvcnRlZC4gVGhpcyBhbGxvd3MgdGhlIG1vdXNlXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzIHRvIHJldHVybiBlYXJseSB3aGVuIHRoZSBkcmFnIGlzIGNhbmNlbGVkLlxuICAgICAgICBkYXRhLmRyYWdBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gSWYgdGhlIGRyYWcgaXMgbm90IGFjdGl2ZSwgdGhlcmUncyBub3RoaW5nIG1vcmUgdG8gZG8uXG4gICAgICAgIGlmICghZGF0YS5kcmFnQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIHRhYnMgdG8gdGhlaXIgbm9uLWRyYWdnZWQgcG9zaXRpb25zLlxuICAgICAgICBQcml2YXRlJGMucmVzZXRUYWJQb3NpdGlvbnModGhpcy5jb250ZW50Tm9kZS5jaGlsZHJlbiwgdGhpcy5fb3JpZW50YXRpb24pO1xuICAgICAgICAvLyBDbGVhciB0aGUgY3Vyc29yIG92ZXJyaWRlLlxuICAgICAgICBkYXRhLm92ZXJyaWRlLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRyYWdnaW5nIHN0eWxlIGNsYXNzZXMuXG4gICAgICAgIGRhdGEudGFiLmNsYXNzTGlzdC5yZW1vdmUoJ2xtLW1vZC1kcmFnZ2luZycpO1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCdsbS1tb2QtZHJhZ2dpbmcnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIGRhdGEudGFiLmNsYXNzTGlzdC5yZW1vdmUoJ3AtbW9kLWRyYWdnaW5nJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3AtbW9kLWRyYWdnaW5nJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgY3VycmVudCBpbmRleCBmb3IgYSB0YWIgaW5zZXJ0IG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY291bnRzIGZvciB0aGUgdGFiIGJhcidzIGluc2VydGlvbiBiZWhhdmlvciB3aGVuXG4gICAgICogYWRqdXN0aW5nIHRoZSBjdXJyZW50IGluZGV4IGFuZCBlbWl0dGluZyB0aGUgY2hhbmdlZCBzaWduYWwuXG4gICAgICovXG4gICAgVGFiQmFyLnByb3RvdHlwZS5fYWRqdXN0Q3VycmVudEZvckluc2VydCA9IGZ1bmN0aW9uIChpLCB0aXRsZSkge1xuICAgICAgICAvLyBMb29rdXAgY29tbW9ubHkgdXNlZCB2YXJpYWJsZXMuXG4gICAgICAgIHZhciBjdCA9IHRoaXMuY3VycmVudFRpdGxlO1xuICAgICAgICB2YXIgY2kgPSB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgIHZhciBiaCA9IHRoaXMuaW5zZXJ0QmVoYXZpb3I7XG4gICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gZG8gYW4gdXBkYXRlIHRvIHVwZGF0ZSB0aGUgYXJpYS1zZWxlY3RlZCBhdHRyaWJ1dGU/XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgYmVoYXZpb3Igd2hlcmUgdGhlIG5ldyB0YWIgaXMgYWx3YXlzIHNlbGVjdGVkLFxuICAgICAgICAvLyBvciB0aGUgYmVoYXZpb3Igd2hlcmUgdGhlIG5ldyB0YWIgaXMgc2VsZWN0ZWQgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoYmggPT09ICdzZWxlY3QtdGFiJyB8fCAoYmggPT09ICdzZWxlY3QtdGFiLWlmLW5lZWRlZCcgJiYgY2kgPT09IC0xKSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gaTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVGl0bGUgPSBjdDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IGNpLCBwcmV2aW91c1RpdGxlOiBjdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXg6IGksIGN1cnJlbnRUaXRsZTogdGl0bGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2lsZW50bHkgYWRqdXN0IHRoZSBjdXJyZW50IGluZGV4IGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKGNpID49IGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIGN1cnJlbnQgaW5kZXggZm9yIGEgdGFiIG1vdmUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBub3QgY2F1c2UgdGhlIGFjdHVhbCBjdXJyZW50IHRhYiB0byBjaGFuZ2UuXG4gICAgICogSXQgc2lsZW50bHkgYWRqdXN0cyB0aGUgaW5kZXggdG8gYWNjb3VudCBmb3IgdGhlIGdpdmVuIG1vdmUuXG4gICAgICovXG4gICAgVGFiQmFyLnByb3RvdHlwZS5fYWRqdXN0Q3VycmVudEZvck1vdmUgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSBqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA8IGkgJiYgdGhpcy5fY3VycmVudEluZGV4ID49IGopIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA+IGkgJiYgdGhpcy5fY3VycmVudEluZGV4IDw9IGopIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIGN1cnJlbnQgaW5kZXggZm9yIGEgdGFiIHJlbW92ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NvdW50cyBmb3IgdGhlIHRhYiBiYXIncyByZW1vdmUgYmVoYXZpb3Igd2hlblxuICAgICAqIGFkanVzdGluZyB0aGUgY3VycmVudCBpbmRleCBhbmQgZW1pdHRpbmcgdGhlIGNoYW5nZWQgc2lnbmFsLlxuICAgICAqL1xuICAgIFRhYkJhci5wcm90b3R5cGUuX2FkanVzdEN1cnJlbnRGb3JSZW1vdmUgPSBmdW5jdGlvbiAoaSwgdGl0bGUpIHtcbiAgICAgICAgLy8gTG9va3VwIGNvbW1vbmx5IHVzZWQgdmFyaWFibGVzLlxuICAgICAgICB2YXIgY2kgPSB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgIHZhciBiaCA9IHRoaXMucmVtb3ZlQmVoYXZpb3I7XG4gICAgICAgIC8vIFNpbGVudGx5IGFkanVzdCB0aGUgaW5kZXggaWYgdGhlIGN1cnJlbnQgdGFiIGlzIG5vdCByZW1vdmVkLlxuICAgICAgICBpZiAoY2kgIT09IGkpIHtcbiAgICAgICAgICAgIGlmIChjaSA+IGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIGRvIGFuIHVwZGF0ZSB0byBhZGp1c3QgdGhlIGFyaWEtc2VsZWN0ZWQgdmFsdWU/XG4gICAgICAgIC8vIE5vIHRhYiBnZXRzIHNlbGVjdGVkIGlmIHRoZSB0YWIgYmFyIGlzIGVtcHR5LlxuICAgICAgICBpZiAodGhpcy5fdGl0bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4OiBpLCBwcmV2aW91c1RpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXg6IC0xLCBjdXJyZW50VGl0bGU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBiZWhhdmlvciB3aGVyZSB0aGUgbmV4dCBzaWJsaW5nIHRhYiBpcyBzZWxlY3RlZC5cbiAgICAgICAgaWYgKGJoID09PSAnc2VsZWN0LXRhYi1hZnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IE1hdGgubWluKGksIHRoaXMuX3RpdGxlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IGksIHByZXZpb3VzVGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogdGhpcy5fY3VycmVudEluZGV4LCBjdXJyZW50VGl0bGU6IHRoaXMuY3VycmVudFRpdGxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYmVoYXZpb3Igd2hlcmUgdGhlIHByZXZpb3VzIHNpYmxpbmcgdGFiIGlzIHNlbGVjdGVkLlxuICAgICAgICBpZiAoYmggPT09ICdzZWxlY3QtdGFiLWJlZm9yZScpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IE1hdGgubWF4KDAsIGkgLSAxKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IGksIHByZXZpb3VzVGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogdGhpcy5fY3VycmVudEluZGV4LCBjdXJyZW50VGl0bGU6IHRoaXMuY3VycmVudFRpdGxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYmVoYXZpb3Igd2hlcmUgdGhlIHByZXZpb3VzIGhpc3RvcnkgdGFiIGlzIHNlbGVjdGVkLlxuICAgICAgICBpZiAoYmggPT09ICdzZWxlY3QtcHJldmlvdXMtdGFiJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzVGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSB0aGlzLl90aXRsZXMuaW5kZXhPZih0aGlzLl9wcmV2aW91c1RpdGxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1RpdGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IE1hdGgubWluKGksIHRoaXMuX3RpdGxlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IGksIHByZXZpb3VzVGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogdGhpcy5fY3VycmVudEluZGV4LCBjdXJyZW50VGl0bGU6IHRoaXMuY3VycmVudFRpdGxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIG5vIHRhYiBnZXRzIHNlbGVjdGVkLlxuICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fY3VycmVudENoYW5nZWQuZW1pdCh7XG4gICAgICAgICAgICBwcmV2aW91c0luZGV4OiBpLCBwcmV2aW91c1RpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogLTEsIGN1cnJlbnRUaXRsZTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYGNoYW5nZWRgIHNpZ25hbCBvZiBhIHRpdGxlIG9iamVjdC5cbiAgICAgKi9cbiAgICBUYWJCYXIucHJvdG90eXBlLl9vblRpdGxlQ2hhbmdlZCA9IGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJCYXI7XG59KFdpZGdldCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYFRhYkJhcmAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChUYWJCYXIpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgSVJlbmRlcmVyYC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBTdWJjbGFzc2VzIGFyZSBmcmVlIHRvIHJlaW1wbGVtZW50IHJlbmRlcmluZyBtZXRob2RzIGFzIG5lZWRlZC5cbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgcmVuZGVyZXIuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBzZWxlY3RvciB3aGljaCBtYXRjaGVzIHRoZSBjbG9zZSBpY29uIG5vZGUgaW4gYSB0YWIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2xvc2VJY29uU2VsZWN0b3IgPSAnLmxtLVRhYkJhci10YWJDbG9zZUljb24nO1xuICAgICAgICAgICAgdGhpcy5fdGFiSUQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdGFiS2V5cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgdmlydHVhbCBlbGVtZW50IGZvciBhIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIHZpcnR1YWwgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHRhYi5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUYWIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gZGF0YS50aXRsZS5jYXB0aW9uO1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuY3JlYXRlVGFiS2V5KGRhdGEpO1xuICAgICAgICAgICAgdmFyIGlkID0ga2V5O1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5jcmVhdGVUYWJTdHlsZShkYXRhKTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNyZWF0ZVRhYkNsYXNzKGRhdGEpO1xuICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmNyZWF0ZVRhYkRhdGFzZXQoZGF0YSk7XG4gICAgICAgICAgICB2YXIgYXJpYSA9IHRoaXMuY3JlYXRlVGFiQVJJQShkYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnRpdGxlLmNsb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChoLmxpKF9fYXNzaWduKHsgaWQ6IGlkLCBrZXk6IGtleSwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHRpdGxlOiB0aXRsZSwgc3R5bGU6IHN0eWxlLCBkYXRhc2V0OiBkYXRhc2V0IH0sIGFyaWEpLCB0aGlzLnJlbmRlckljb24oZGF0YSksIHRoaXMucmVuZGVyTGFiZWwoZGF0YSksIHRoaXMucmVuZGVyQ2xvc2VJY29uKGRhdGEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGgubGkoX19hc3NpZ24oeyBpZDogaWQsIGtleToga2V5LCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgdGl0bGU6IHRpdGxlLCBzdHlsZTogc3R5bGUsIGRhdGFzZXQ6IGRhdGFzZXQgfSwgYXJpYSksIHRoaXMucmVuZGVySWNvbihkYXRhKSwgdGhpcy5yZW5kZXJMYWJlbChkYXRhKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBpY29uIGVsZW1lbnQgZm9yIGEgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgdGFiIGljb24uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySWNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY3JlYXRlSWNvbkNsYXNzKGRhdGEpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpdGxlLmljb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGguZGl2KHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgdGl0bGUuaWNvbkxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIGlmIHRpdGxlLmljb24gaXMgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIHRpdGxlLmljb24sIHRpdGxlLmljb25MYWJlbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGxhYmVsIGVsZW1lbnQgZm9yIGEgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgdGFiIGxhYmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckxhYmVsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbG0tVGFiQmFyLXRhYkxhYmVsJ1xuICAgICAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICAgICAgKyAnIHAtVGFiQmFyLXRhYkxhYmVsJ1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH0sIGRhdGEudGl0bGUubGFiZWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBjbG9zZSBpY29uIGVsZW1lbnQgZm9yIGEgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgdGFiIGNsb3NlIGljb24uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ2xvc2VJY29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbG0tVGFiQmFyLXRhYkNsb3NlSWNvbidcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLVRhYkJhci10YWJDbG9zZUljb24nXG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB1bmlxdWUgcmVuZGVyIGtleSBmb3IgdGhlIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSB1bmlxdWUgcmVuZGVyIGtleSBmb3IgdGhlIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIG1ldGhvZCBjYWNoZXMgdGhlIGtleSBhZ2FpbnN0IHRoZSB0YWIgdGl0bGUgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICogdGhlIGtleSBpcyBnZW5lcmF0ZWQuIFRoaXMgZW5hYmxlcyBlZmZpY2llbnQgcmVuZGVyaW5nIG9mIG1vdmVkXG4gICAgICAgICAqIHRhYnMgYW5kIGF2b2lkcyBzdWJ0bGUgaG92ZXIgc3R5bGUgYXJ0aWZhY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRhYktleSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fdGFiS2V5cy5nZXQoZGF0YS50aXRsZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcInRhYi1rZXktXCIgKyB0aGlzLl90YWJJRCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhYktleXMuc2V0KGRhdGEudGl0bGUsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBpbmxpbmUgc3R5bGUgb2JqZWN0IGZvciBhIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBpbmxpbmUgc3R5bGUgZGF0YSBmb3IgdGhlIHRhYi5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUYWJTdHlsZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyB6SW5kZXg6IFwiXCIgKyBkYXRhLnpJbmRleCB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBjbGFzcyBuYW1lIGZvciB0aGUgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGZ1bGwgY2xhc3MgbmFtZSBmb3IgdGhlIHRhYi5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUYWJDbGFzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICdsbS1UYWJCYXItdGFiJztcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgbmFtZSArPSAnIHAtVGFiQmFyLXRhYic7XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAoZGF0YS50aXRsZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiIFwiICsgZGF0YS50aXRsZS5jbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aXRsZS5jbG9zYWJsZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBsbS1tb2QtY2xvc2FibGUnO1xuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBwLW1vZC1jbG9zYWJsZSc7XG4gICAgICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBsbS1tb2QtY3VycmVudCc7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIHAtbW9kLWN1cnJlbnQnO1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBkYXRhc2V0IGZvciBhIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBkYXRhc2V0IGZvciB0aGUgdGFiLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRhYkRhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEudGl0bGUuZGF0YXNldDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSB0aGUgQVJJQSBhdHRyaWJ1dGVzIGZvciBhIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBBUklBIGF0dHJpYnV0ZXMgZm9yIHRoZSB0YWIuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGFiQVJJQSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyByb2xlOiAndGFiJywgJ2FyaWEtc2VsZWN0ZWQnOiBkYXRhLmN1cnJlbnQudG9TdHJpbmcoKSB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBjbGFzcyBuYW1lIGZvciB0aGUgdGFiIGljb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgdGFiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgZnVsbCBjbGFzcyBuYW1lIGZvciB0aGUgdGFiIGljb24uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSWNvbkNsYXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJ2xtLVRhYkJhci10YWJJY29uJztcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgbmFtZSArPSAnIHAtVGFiQmFyLXRhYkljb24nO1xuICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgdmFyIGV4dHJhID0gZGF0YS50aXRsZS5pY29uQ2xhc3M7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmEgPyBuYW1lICsgXCIgXCIgKyBleHRyYSA6IG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIFRhYkJhci5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGBSZW5kZXJlcmAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgVGFiQmFyLmRlZmF1bHRSZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuICAgIC8qKlxuICAgICAqIEEgc2VsZWN0b3Igd2hpY2ggbWF0Y2hlcyB0aGUgYWRkIGJ1dHRvbiBub2RlIGluIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYkJhci5hZGRCdXR0b25TZWxlY3RvciA9ICcubG0tVGFiQmFyLWFkZEJ1dHRvbic7XG59KShUYWJCYXIgfHwgKFRhYkJhciA9IHt9KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkYztcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBkcmFnIGRpc3RhbmNlIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBQcml2YXRlLkRSQUdfVEhSRVNIT0xEID0gNTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGV0YWNoIGRpc3RhbmNlIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBQcml2YXRlLkRFVEFDSF9USFJFU0hPTEQgPSAyMDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIERPTSBub2RlIGZvciBhIHRhYiBiYXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTm9kZSgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWJsaXN0Jyk7XG4gICAgICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gJ2xtLVRhYkJhci1jb250ZW50JztcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncC1UYWJCYXItY29udGVudCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHZhciBhZGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWRkLmNsYXNzTmFtZSA9ICdsbS1UYWJCYXItYWRkQnV0dG9uIGxtLW1vZC1oaWRkZW4nO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGFkZCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuICAgIC8qKlxuICAgICAqIENvZXJjZSBhIHRpdGxlIG9yIG9wdGlvbnMgaW50byBhIHJlYWwgdGl0bGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNUaXRsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUaXRsZSA/IHZhbHVlIDogbmV3IFRpdGxlKHZhbHVlKTtcbiAgICB9XG4gICAgUHJpdmF0ZS5hc1RpdGxlID0gYXNUaXRsZTtcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBmb3IgYSB0YWIgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVRyYW5zaXRpb25EdXJhdGlvbih0YWIpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFiKTtcbiAgICAgICAgcmV0dXJuIDEwMDAgKiAocGFyc2VGbG9hdChzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24pIHx8IDApO1xuICAgIH1cbiAgICBQcml2YXRlLnBhcnNlVHJhbnNpdGlvbkR1cmF0aW9uID0gcGFyc2VUcmFuc2l0aW9uRHVyYXRpb247XG4gICAgLyoqXG4gICAgICogR2V0IGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGFiIGxheW91dCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc25hcFRhYkxheW91dCh0YWJzLCBvcmllbnRhdGlvbikge1xuICAgICAgICB2YXIgbGF5b3V0ID0gbmV3IEFycmF5KHRhYnMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0YWJzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0YWJzW2ldO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIGxheW91dFtpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBub2RlLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5MZWZ0KSB8fCAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheW91dFtpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBub2RlLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogbm9kZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApIHx8IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxuICAgIFByaXZhdGUuc25hcFRhYkxheW91dCA9IHNuYXBUYWJMYXlvdXQ7XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgZXZlbnQgZXhjZWVkcyB0aGUgZHJhZyB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhZ0V4Y2VlZGVkKGRhdGEsIGV2ZW50KSB7XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKGV2ZW50LmNsaWVudFggLSBkYXRhLnByZXNzWCk7XG4gICAgICAgIHZhciBkeSA9IE1hdGguYWJzKGV2ZW50LmNsaWVudFkgLSBkYXRhLnByZXNzWSk7XG4gICAgICAgIHJldHVybiBkeCA+PSBQcml2YXRlLkRSQUdfVEhSRVNIT0xEIHx8IGR5ID49IFByaXZhdGUuRFJBR19USFJFU0hPTEQ7XG4gICAgfVxuICAgIFByaXZhdGUuZHJhZ0V4Y2VlZGVkID0gZHJhZ0V4Y2VlZGVkO1xuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIGV2ZW50IGV4Y2VlZHMgdGhlIGRyYWcgZGV0YWNoIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRhY2hFeGNlZWRlZChkYXRhLCBldmVudCkge1xuICAgICAgICB2YXIgcmVjdCA9IGRhdGEuY29udGVudFJlY3Q7XG4gICAgICAgIHJldHVybiAoKGV2ZW50LmNsaWVudFggPCByZWN0LmxlZnQgLSBQcml2YXRlLkRFVEFDSF9USFJFU0hPTEQpIHx8XG4gICAgICAgICAgICAoZXZlbnQuY2xpZW50WCA+PSByZWN0LnJpZ2h0ICsgUHJpdmF0ZS5ERVRBQ0hfVEhSRVNIT0xEKSB8fFxuICAgICAgICAgICAgKGV2ZW50LmNsaWVudFkgPCByZWN0LnRvcCAtIFByaXZhdGUuREVUQUNIX1RIUkVTSE9MRCkgfHxcbiAgICAgICAgICAgIChldmVudC5jbGllbnRZID49IHJlY3QuYm90dG9tICsgUHJpdmF0ZS5ERVRBQ0hfVEhSRVNIT0xEKSk7XG4gICAgfVxuICAgIFByaXZhdGUuZGV0YWNoRXhjZWVkZWQgPSBkZXRhY2hFeGNlZWRlZDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHJlbGF0aXZlIHRhYiBwb3NpdGlvbnMgYW5kIGNvbXB1dGVkIHRhcmdldCBpbmRleC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXlvdXRUYWJzKHRhYnMsIGRhdGEsIGV2ZW50LCBvcmllbnRhdGlvbikge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBvcmllbnRhdGlvbi1zZW5zaXRpdmUgdmFsdWVzLlxuICAgICAgICB2YXIgcHJlc3NQb3M7XG4gICAgICAgIHZhciBsb2NhbFBvcztcbiAgICAgICAgdmFyIGNsaWVudFBvcztcbiAgICAgICAgdmFyIGNsaWVudFNpemU7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBwcmVzc1BvcyA9IGRhdGEucHJlc3NYO1xuICAgICAgICAgICAgbG9jYWxQb3MgPSBldmVudC5jbGllbnRYIC0gZGF0YS5jb250ZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY2xpZW50UG9zID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIGNsaWVudFNpemUgPSBkYXRhLmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJlc3NQb3MgPSBkYXRhLnByZXNzWTtcbiAgICAgICAgICAgIGxvY2FsUG9zID0gZXZlbnQuY2xpZW50WSAtIGRhdGEuY29udGVudFJlY3QudG9wO1xuICAgICAgICAgICAgY2xpZW50UG9zID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIGNsaWVudFNpemUgPSBkYXRhLmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSB0YXJnZXQgZGF0YS5cbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gZGF0YS5pbmRleDtcbiAgICAgICAgdmFyIHRhcmdldFBvcyA9IGxvY2FsUG9zIC0gZGF0YS50YWJQcmVzc1BvcztcbiAgICAgICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFBvcyArIGRhdGEudGFiU2l6ZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZWxhdGl2ZSB0YWIgcG9zaXRpb25zLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRhYnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHhQb3MgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS50YWJMYXlvdXRbaV07XG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gbGF5b3V0LnBvcyArIChsYXlvdXQuc2l6ZSA+PiAxKTtcbiAgICAgICAgICAgIGlmIChpIDwgZGF0YS5pbmRleCAmJiB0YXJnZXRQb3MgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBweFBvcyA9IGRhdGEudGFiU2l6ZSArIGRhdGEudGFiTGF5b3V0W2kgKyAxXS5tYXJnaW4gKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBNYXRoLm1pbih0YXJnZXRJbmRleCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID4gZGF0YS5pbmRleCAmJiB0YXJnZXRFbmQgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBweFBvcyA9IC1kYXRhLnRhYlNpemUgLSBsYXlvdXQubWFyZ2luICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRhcmdldEluZGV4ID0gTWF0aC5tYXgodGFyZ2V0SW5kZXgsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gZGF0YS5pbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBpZGVhbCA9IGNsaWVudFBvcyAtIHByZXNzUG9zO1xuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IGNsaWVudFNpemUgLSAoZGF0YS50YWJQb3MgKyBkYXRhLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHB4UG9zID0gTWF0aC5tYXgoLWRhdGEudGFiUG9zLCBNYXRoLm1pbihpZGVhbCwgbGltaXQpKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB4UG9zID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHRhYnNbaV0uc3R5bGUubGVmdCA9IHB4UG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFic1tpXS5zdHlsZS50b3AgPSBweFBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbXB1dGVkIHRhcmdldCBpbmRleC5cbiAgICAgICAgZGF0YS50YXJnZXRJbmRleCA9IHRhcmdldEluZGV4O1xuICAgIH1cbiAgICBQcml2YXRlLmxheW91dFRhYnMgPSBsYXlvdXRUYWJzO1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBkcmFnIHRhYiBhdCBpdHMgZmluYWwgcmVzdGluZyByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVRhYlBvc2l0aW9uKGRhdGEsIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG9yaWVudGF0aW9uLXNlbnNpdGl2ZSBjbGllbnQgc2l6ZS5cbiAgICAgICAgdmFyIGNsaWVudFNpemU7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBjbGllbnRTaXplID0gZGF0YS5jb250ZW50UmVjdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudFNpemUgPSBkYXRhLmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBpZGVhbCBmaW5hbCB0YWIgcG9zaXRpb24uXG4gICAgICAgIHZhciBpZGVhbDtcbiAgICAgICAgaWYgKGRhdGEudGFyZ2V0SW5kZXggPT09IGRhdGEuaW5kZXgpIHtcbiAgICAgICAgICAgIGlkZWFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLnRhcmdldEluZGV4ID4gZGF0YS5pbmRleCkge1xuICAgICAgICAgICAgdmFyIHRndCA9IGRhdGEudGFiTGF5b3V0W2RhdGEudGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgaWRlYWwgPSB0Z3QucG9zICsgdGd0LnNpemUgLSBkYXRhLnRhYlNpemUgLSBkYXRhLnRhYlBvcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0Z3QgPSBkYXRhLnRhYkxheW91dFtkYXRhLnRhcmdldEluZGV4XTtcbiAgICAgICAgICAgIGlkZWFsID0gdGd0LnBvcyAtIGRhdGEudGFiUG9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHRhYiBwb3NpdGlvbiBsaW1pdC5cbiAgICAgICAgdmFyIGxpbWl0ID0gY2xpZW50U2l6ZSAtIChkYXRhLnRhYlBvcyArIGRhdGEudGFiU2l6ZSk7XG4gICAgICAgIHZhciBmaW5hbCA9IE1hdGgubWF4KC1kYXRhLnRhYlBvcywgTWF0aC5taW4oaWRlYWwsIGxpbWl0KSk7XG4gICAgICAgIC8vIFNldCB0aGUgZmluYWwgb3JpZW50YXRpb24tc2Vuc2l0aXZlIHBvc2l0aW9uLlxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgZGF0YS50YWIuc3R5bGUubGVmdCA9IGZpbmFsICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YS50YWIuc3R5bGUudG9wID0gZmluYWwgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpdmF0ZS5maW5hbGl6ZVRhYlBvc2l0aW9uID0gZmluYWxpemVUYWJQb3NpdGlvbjtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIHRoZSBnaXZlbiB0YWJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0VGFiUG9zaXRpb25zKHRhYnMsIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIGVhY2godGFicywgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICB0YWIuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgUHJpdmF0ZS5yZXNldFRhYlBvc2l0aW9ucyA9IHJlc2V0VGFiUG9zaXRpb25zO1xufSkoUHJpdmF0ZSRjIHx8IChQcml2YXRlJGMgPSB7fSkpO1xuXG4vKipcbiAqIEEgbGF5b3V0IHdoaWNoIHByb3ZpZGVzIGEgZmxleGlibGUgZG9ja2luZyBhcnJhbmdlbWVudC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGUgY29uc3VtZXIgb2YgdGhpcyBsYXlvdXQgaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIGFsbCBzaWduYWxzXG4gKiBmcm9tIHRoZSBnZW5lcmF0ZWQgdGFiIGJhcnMgYW5kIG1hbmFnaW5nIHRoZSB2aXNpYmlsaXR5IG9mIHdpZGdldHNcbiAqIGFuZCB0YWIgYmFycyBhcyBuZWVkZWQuXG4gKi9cbnZhciBEb2NrTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb2NrTGF5b3V0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBkb2NrIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERvY2tMYXlvdXQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fc3BhY2luZyA9IDQ7XG4gICAgICAgIF90aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9ib3ggPSBudWxsO1xuICAgICAgICBfdGhpcy5faXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3BhY2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fc3BhY2luZyA9IFV0aWxzJDEuY2xhbXBEaW1lbnNpb24ob3B0aW9ucy5zcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyB3aWxsIGNsZWFyIGFuZCBkaXNwb3NlIGFsbCB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHdpZGdldHMgaW4gdGhlIGxheW91dC5cbiAgICAgICAgdmFyIHdpZGdldHMgPSB0aGlzLml0ZXIoKTtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgbGF5b3V0IGl0ZW1zLlxuICAgICAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGxheW91dCBzdGF0ZSBiZWZvcmUgZGlzcG9zaW5nIHRoZSB3aWRnZXRzLlxuICAgICAgICB0aGlzLl9ib3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbXMuY2xlYXIoKTtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgd2lkZ2V0cyBjb250YWluZWQgaW4gdGhlIG9sZCBsYXlvdXQgcm9vdC5cbiAgICAgICAgZWFjaCh3aWRnZXRzLCBmdW5jdGlvbiAod2lkZ2V0KSB7IHdpZGdldC5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSBiYXNlIGNsYXNzLlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2NrTGF5b3V0LnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaW50ZXItZWxlbWVudCBzcGFjaW5nIGZvciB0aGUgZG9jayBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBpbnRlci1lbGVtZW50IHNwYWNpbmcgZm9yIHRoZSBkb2NrIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFV0aWxzJDEuY2xhbXBEaW1lbnNpb24odmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NwYWNpbmcgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3BhY2luZyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9ja0xheW91dC5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBkb2NrIGxheW91dCBpcyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpdGVyYXRvciBvdmVyIGFsbCB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBvdmVyIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpdGVyYXRvciBpbmNsdWRlcyB0aGUgZ2VuZXJhdGVkIHRhYiBiYXJzLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290ID8gdGhpcy5fcm9vdC5pdGVyQWxsV2lkZ2V0cygpIDogZW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpdGVyYXRvciBvdmVyIHRoZSB1c2VyIHdpZGdldHMgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIG92ZXIgdGhlIHVzZXIgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXRlcmF0b3IgZG9lcyBub3QgaW5jbHVkZSB0aGUgZ2VuZXJhdGVkIHRhYiBiYXJzLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLndpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290ID8gdGhpcy5fcm9vdC5pdGVyVXNlcldpZGdldHMoKSA6IGVtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3Igb3ZlciB0aGUgc2VsZWN0ZWQgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igb3ZlciB0aGUgc2VsZWN0ZWQgdXNlciB3aWRnZXRzLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXRlcmF0b3IgeWllbGRzIHRoZSB3aWRnZXRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgdGFiXG4gICAgICogb2YgZWFjaCB0YWIgYmFyIGluIHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuc2VsZWN0ZWRXaWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA/IHRoaXMuX3Jvb3QuaXRlclNlbGVjdGVkV2lkZ2V0cygpIDogZW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpdGVyYXRvciBvdmVyIHRoZSB0YWIgYmFycyBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igb3ZlciB0aGUgdGFiIGJhcnMgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGl0ZXJhdG9yIGRvZXMgbm90IGluY2x1ZGUgdGhlIHVzZXIgd2lkZ2V0cy5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS50YWJCYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA/IHRoaXMuX3Jvb3QuaXRlclRhYkJhcnMoKSA6IGVtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3Igb3ZlciB0aGUgaGFuZGxlcyBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igb3ZlciB0aGUgaGFuZGxlcyBpbiB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLmhhbmRsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290ID8gdGhpcy5fcm9vdC5pdGVySGFuZGxlcygpIDogZW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgYSBoYW5kbGUgdG8gdGhlIGdpdmVuIG9mZnNldCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaGFuZGxlIHRvIG1vdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0WCAtIFRoZSBkZXNpcmVkIG9mZnNldCBYIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0WSAtIFRoZSBkZXNpcmVkIG9mZnNldCBZIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIGdpdmVuIGhhbmRsZSBpcyBub3QgY29udGFpbmVkIGluIHRoZSBsYXlvdXQsIHRoaXMgaXMgbm8tb3AuXG4gICAgICpcbiAgICAgKiBUaGUgaGFuZGxlIHdpbGwgYmUgbW92ZWQgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIGRlc2lyZWRcbiAgICAgKiBwb3NpdGlvbiB3aXRob3V0IHZpb2xhdGluZyBhbnkgb2YgdGhlIGxheW91dCBjb25zdHJhaW50cy5cbiAgICAgKlxuICAgICAqIE9ubHkgb25lIG9mIHRoZSBjb29yZGluYXRlcyBpcyB1c2VkIGRlcGVuZGluZyBvbiB0aGUgb3JpZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaGFuZGxlLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGJvdGggY29vcmRpbmF0ZXMgdG8gbWFrZSBpdFxuICAgICAqIGVhc3kgdG8gaW52b2tlIGZyb20gYSBtb3VzZSBtb3ZlIGV2ZW50IHdpdGhvdXQgbmVlZGluZyB0byBrbm93XG4gICAgICogdGhlIGhhbmRsZSBvcmllbnRhdGlvbi5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5tb3ZlSGFuZGxlID0gZnVuY3Rpb24gKGhhbmRsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIHJvb3Qgb3IgaWYgdGhlIGhhbmRsZSBpcyBoaWRkZW4uXG4gICAgICAgIHZhciBoaWRkZW4gPSBoYW5kbGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBoaWRkZW4gPSBoaWRkZW4gfHwgaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucygncC1tb2QtaGlkZGVuJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgaWYgKCF0aGlzLl9yb290IHx8IGhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2t1cCB0aGUgc3BsaXQgbm9kZSBmb3IgdGhlIGhhbmRsZS5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9yb290LmZpbmRTcGxpdE5vZGUoaGFuZGxlKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGVzaXJlZCBkZWx0YSBtb3ZlbWVudCBmb3IgdGhlIGhhbmRsZS5cbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAoZGF0YS5ub2RlLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGRlbHRhID0gb2Zmc2V0WCAtIGhhbmRsZS5vZmZzZXRMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgPSBvZmZzZXRZIC0gaGFuZGxlLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vIGhhbmRsZSBtb3ZlbWVudC5cbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBzaWJsaW5nIHJlc2l6aW5nIHVubGVzcyBuZWVkZWQuXG4gICAgICAgIGRhdGEubm9kZS5ob2xkU2l6ZXMoKTtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBzaXplcnMgdG8gcmVmbGVjdCB0aGUgaGFuZGxlIG1vdmVtZW50LlxuICAgICAgICBCb3hFbmdpbmUuYWRqdXN0KGRhdGEubm9kZS5zaXplcnMsIGRhdGEuaW5kZXgsIGRlbHRhKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhlIHdpZGdldHMuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvZiB0aGUgZG9jayBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBjb25maWcgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsYXlvdXQgc3RhdGUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGByZXN0b3JlTGF5b3V0YCBtZXRob2RcbiAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZSBsYXlvdXQgdG8gaXRzIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5zYXZlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIHJvb3QuXG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWFpbjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEhvbGQgdGhlIGN1cnJlbnQgc2l6ZXMgaW4gdGhlIGxheW91dCB0cmVlLlxuICAgICAgICB0aGlzLl9yb290LmhvbGRBbGxTaXplcygpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGxheW91dCBjb25maWcuXG4gICAgICAgIHJldHVybiB7IG1haW46IHRoaXMuX3Jvb3QuY3JlYXRlQ29uZmlnKCkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIGxheW91dCB0byBhIHByZXZpb3VzbHkgc2F2ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gdG8gcmVzdG9yZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBXaWRnZXRzIHdoaWNoIGN1cnJlbnRseSBiZWxvbmcgdG8gdGhlIGxheW91dCBidXQgd2hpY2ggYXJlIG5vdFxuICAgICAqIGNvbnRhaW5lZCBpbiB0aGUgY29uZmlnIHdpbGwgYmUgdW5wYXJlbnRlZC5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5yZXN0b3JlTGF5b3V0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHdpZGdldCBzZXQgZm9yIHZhbGlkYXRpbmcgdGhlIGNvbmZpZy5cbiAgICAgICAgdmFyIHdpZGdldFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBtYWluIGFyZWEgY29uZmlnIGFuZCBjb2xsZWN0IHRoZSB3aWRnZXRzLlxuICAgICAgICB2YXIgbWFpbkNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5tYWluKSB7XG4gICAgICAgICAgICBtYWluQ29uZmlnID0gUHJpdmF0ZSRkLm5vcm1hbGl6ZUFyZWFDb25maWcoY29uZmlnLm1haW4sIHdpZGdldFNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYWluQ29uZmlnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgaXRlcmF0b3JzIG92ZXIgdGhlIG9sZCBjb250ZW50LlxuICAgICAgICB2YXIgb2xkV2lkZ2V0cyA9IHRoaXMud2lkZ2V0cygpO1xuICAgICAgICB2YXIgb2xkVGFiQmFycyA9IHRoaXMudGFiQmFycygpO1xuICAgICAgICB2YXIgb2xkSGFuZGxlcyA9IHRoaXMuaGFuZGxlcygpO1xuICAgICAgICAvLyBDbGVhciB0aGUgcm9vdCBiZWZvcmUgcmVtb3ZpbmcgdGhlIG9sZCBjb250ZW50LlxuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLy8gVW5wYXJlbnQgdGhlIG9sZCB3aWRnZXRzIHdoaWNoIGFyZSBub3QgaW4gdGhlIG5ldyBjb25maWcuXG4gICAgICAgIGVhY2gob2xkV2lkZ2V0cywgZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKCF3aWRnZXRTZXQuaGFzKHdpZGdldCkpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIG9sZCB0YWIgYmFycy5cbiAgICAgICAgZWFjaChvbGRUYWJCYXJzLCBmdW5jdGlvbiAodGFiQmFyKSB7XG4gICAgICAgICAgICB0YWJCYXIuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgaGFuZGxlcy5cbiAgICAgICAgZWFjaChvbGRIYW5kbGVzLCBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVwYXJlbnQgdGhlIG5ldyB3aWRnZXRzIHRvIHRoZSBjdXJyZW50IHBhcmVudC5cbiAgICAgICAgd2lkZ2V0U2V0LmZvckVhY2goZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgd2lkZ2V0LnBhcmVudCA9IF90aGlzLnBhcmVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcm9vdCBub2RlIGZvciB0aGUgbmV3IGNvbmZpZy5cbiAgICAgICAgaWYgKG1haW5Db25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBQcml2YXRlJGQucmVhbGl6ZUFyZWFDb25maWcobWFpbkNvbmZpZywge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYkJhcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZVRhYkJhcigpOyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUhhbmRsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZUhhbmRsZSgpOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHBhcmVudCwgdGhlcmUgaXMgbm90aGluZyBtb3JlIHRvIGRvLlxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXR0YWNoIHRoZSBuZXcgd2lkZ2V0cyB0byB0aGUgcGFyZW50LlxuICAgICAgICB3aWRnZXRTZXQuZm9yRWFjaChmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRhY2hXaWRnZXQod2lkZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBvc3QgYSBmaXQgcmVxdWVzdCB0byB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHdpZGdldCB0byB0aGUgZG9jayBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBhZGQgdG8gdGhlIGRvY2sgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgYWRkaXRpb25hbCBvcHRpb25zIGZvciBhZGRpbmcgdGhlIHdpZGdldC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgd2lkZ2V0IHdpbGwgYmUgbW92ZWQgaWYgaXQgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIHRoZSByZWZlcmVuY2Ugd2lkZ2V0IGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBQYXJzZSB0aGUgb3B0aW9ucy5cbiAgICAgICAgdmFyIHJlZiA9IG9wdGlvbnMucmVmIHx8IG51bGw7XG4gICAgICAgIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICd0YWItYWZ0ZXInO1xuICAgICAgICAvLyBGaW5kIHRoZSB0YWIgbm9kZSB3aGljaCBob2xkcyB0aGUgcmVmZXJlbmNlIHdpZGdldC5cbiAgICAgICAgdmFyIHJlZk5vZGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fcm9vdCAmJiByZWYpIHtcbiAgICAgICAgICAgIHJlZk5vZGUgPSB0aGlzLl9yb290LmZpbmRUYWJOb2RlKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlZmVyZW5jZSB3aWRnZXQgaXMgaW52YWxpZC5cbiAgICAgICAgaWYgKHJlZiAmJiAhcmVmTm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2Ugd2lkZ2V0IGlzIG5vdCBpbiB0aGUgbGF5b3V0LicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGFyZW50IHRoZSB3aWRnZXQgdG8gdGhlIGN1cnJlbnQgbGF5b3V0IHBhcmVudC5cbiAgICAgICAgd2lkZ2V0LnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAvLyBJbnNlcnQgdGhlIHdpZGdldCBhY2NvcmRpbmcgdG8gdGhlIGluc2VydCBtb2RlLlxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RhYi1hZnRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0VGFiKHdpZGdldCwgcmVmLCByZWZOb2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhYi1iZWZvcmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydFRhYih3aWRnZXQsIHJlZiwgcmVmTm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BsaXQtdG9wJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTcGxpdCh3aWRnZXQsIHJlZiwgcmVmTm9kZSwgJ3ZlcnRpY2FsJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BsaXQtbGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0U3BsaXQod2lkZ2V0LCByZWYsIHJlZk5vZGUsICdob3Jpem9udGFsJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BsaXQtcmlnaHQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydFNwbGl0KHdpZGdldCwgcmVmLCByZWZOb2RlLCAnaG9yaXpvbnRhbCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BsaXQtYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTcGxpdCh3aWRnZXQsIHJlZiwgcmVmTm9kZSwgJ3ZlcnRpY2FsJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90aGluZyBlbHNlIGlmIHRoZXJlIGlzIG5vIHBhcmVudCB3aWRnZXQuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHdpZGdldCBpcyBhdHRhY2hlZCB0byB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgICAgdGhpcy5hdHRhY2hXaWRnZXQod2lkZ2V0KTtcbiAgICAgICAgLy8gUG9zdCBhIGZpdCByZXF1ZXN0IGZvciB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB3aWRnZXQgZnJvbSB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBBIHdpZGdldCBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgbGF5b3V0IHdoZW4gaXRzIGBwYXJlbnRgXG4gICAgICogaXMgc2V0IHRvIGBudWxsYC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCBkaXJlY3RseSB3aGVuXG4gICAgICogcmVtb3ZpbmcgYSB3aWRnZXQgZnJvbSBhIGxheW91dCB3aGljaCBoYXMgeWV0IHRvIGJlIGluc3RhbGxlZCBvbiBhXG4gICAgICogcGFyZW50IHdpZGdldC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgKm5vdCogbW9kaWZ5IHRoZSB3aWRnZXQncyBgcGFyZW50YC5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5yZW1vdmVXaWRnZXQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gaXRzIGN1cnJlbnQgbGF5b3V0IGxvY2F0aW9uLlxuICAgICAgICB0aGlzLl9yZW1vdmVXaWRnZXQod2lkZ2V0KTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBlbHNlIGlmIHRoZXJlIGlzIG5vIHBhcmVudCB3aWRnZXQuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRhY2ggdGhlIHdpZGdldCBmcm9tIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLmRldGFjaFdpZGdldCh3aWRnZXQpO1xuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHRhYiBhcmVhIHdoaWNoIGNvbnRhaW5zIHRoZSBnaXZlbiBjbGllbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50WCAtIFRoZSBjbGllbnQgWCBwb3NpdGlvbiBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnRZIC0gVGhlIGNsaWVudCBZIHBvc2l0aW9uIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGdlb21ldHJ5IG9mIHRoZSB0YWIgYXJlYSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG9yXG4gICAgICogICBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gdGFiIGFyZWEgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLmhpdFRlc3RUYWJBcmVhcyA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgaGl0IHRlc3RpbmcgY2Fubm90IHByb2R1Y2UgdmFsaWQgcmVzdWx0cy5cbiAgICAgICAgaWYgKCF0aGlzLl9yb290IHx8ICF0aGlzLnBhcmVudCB8fCAhdGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBib3ggc2l6aW5nIGRhdGEgaXMgY29tcHV0ZWQuXG4gICAgICAgIGlmICghdGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGZyb20gY2xpZW50IHRvIGxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucGFyZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB4ID0gY2xpZW50WCAtIHJlY3QubGVmdCAtIHRoaXMuX2JveC5ib3JkZXJMZWZ0O1xuICAgICAgICB2YXIgeSA9IGNsaWVudFkgLSByZWN0LnRvcCAtIHRoaXMuX2JveC5ib3JkZXJUb3A7XG4gICAgICAgIC8vIEZpbmQgdGhlIHRhYiBsYXlvdXQgbm9kZSBhdCB0aGUgbG9jYWwgcG9zaXRpb24uXG4gICAgICAgIHZhciB0YWJOb2RlID0gdGhpcy5fcm9vdC5oaXRUZXN0VGFiTm9kZXMoeCwgeSk7XG4gICAgICAgIC8vIEJhaWwgaWYgYSB0YWIgbGF5b3V0IG5vZGUgd2FzIG5vdCBmb3VuZC5cbiAgICAgICAgaWYgKCF0YWJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBkYXRhIGZyb20gdGhlIHRhYiBub2RlLlxuICAgICAgICB2YXIgdGFiQmFyID0gdGFiTm9kZS50YWJCYXIsIHRvcCA9IHRhYk5vZGUudG9wLCBsZWZ0ID0gdGFiTm9kZS5sZWZ0LCB3aWR0aCA9IHRhYk5vZGUud2lkdGgsIGhlaWdodCA9IHRhYk5vZGUuaGVpZ2h0O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSByaWdodCBhbmQgYm90dG9tIGVkZ2VzIG9mIHRoZSB0YWIgYXJlYS5cbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5fYm94LmJvcmRlckxlZnQgKyB0aGlzLl9ib3guYm9yZGVyUmlnaHQ7XG4gICAgICAgIHZhciBib3JkZXJIZWlnaHQgPSB0aGlzLl9ib3guYm9yZGVyVG9wICsgdGhpcy5fYm94LmJvcmRlckJvdHRvbTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcmVjdC53aWR0aCAtIGJvcmRlcldpZHRoIC0gKGxlZnQgKyB3aWR0aCk7XG4gICAgICAgIHZhciBib3R0b20gPSByZWN0LmhlaWdodCAtIGJvcmRlckhlaWdodCAtICh0b3AgKyBoZWlnaHQpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGhpdCB0ZXN0IHJlc3VsdHMuXG4gICAgICAgIHJldHVybiB7IHRhYkJhcjogdGFiQmFyLCB4OiB4LCB5OiB5LCB0b3A6IHRvcCwgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0LCBib3R0b206IGJvdHRvbSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBsYXlvdXQgaW5pdGlhbGl6YXRpb24gd2hpY2ggcmVxdWlyZXMgdGhlIHBhcmVudCB3aWRnZXQuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gUGVyZm9ybSBzdXBlcmNsYXNzIGluaXRpYWxpemF0aW9uLlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gQXR0YWNoIGVhY2ggd2lkZ2V0IHRvIHRoZSBwYXJlbnQuXG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkgeyBfdGhpcy5hdHRhY2hXaWRnZXQod2lkZ2V0KTsgfSk7XG4gICAgICAgIC8vIEF0dGFjaCBlYWNoIGhhbmRsZSB0byB0aGUgcGFyZW50LlxuICAgICAgICBlYWNoKHRoaXMuaGFuZGxlcygpLCBmdW5jdGlvbiAoaGFuZGxlKSB7IF90aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKGhhbmRsZSk7IH0pO1xuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgd2lkZ2V0IHRvIHRoZSBsYXlvdXQgcGFyZW50IHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGF0dGFjaCB0byB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgYXR0YWNoZWQuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuYXR0YWNoV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB3aWRnZXQgaXMgYWxyZWFkeSBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50Lm5vZGUgPT09IHdpZGdldC5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIGxheW91dCBpdGVtIGZvciB0aGUgd2lkZ2V0LlxuICAgICAgICB0aGlzLl9pdGVtcy5zZXQod2lkZ2V0LCBuZXcgTGF5b3V0SXRlbSh3aWRnZXQpKTtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVBdHRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgd2lkZ2V0J3Mgbm9kZSB0byB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHdpZGdldC5ub2RlKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckF0dGFjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUgd2lkZ2V0IGZyb20gdGhlIGxheW91dCBwYXJlbnQgd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gZGV0YWNoIGZyb20gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIHdpZGdldCBpcyBub3QgYXR0YWNoZWQuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuZGV0YWNoV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB3aWRnZXQgaXMgbm90IGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQubm9kZSAhPT0gd2lkZ2V0Lm5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgYSBgJ2JlZm9yZS1kZXRhY2gnYCBtZXNzYWdlIGlmIHRoZSBwYXJlbnQgaXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh3aWRnZXQsIFdpZGdldC5Nc2cuQmVmb3JlRGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHdpZGdldCdzIG5vZGUgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLnJlbW92ZUNoaWxkKHdpZGdldC5ub2RlKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRlIHRoZSBsYXlvdXQgaXRlbSBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtcy5nZXQod2lkZ2V0KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLmRlbGV0ZSh3aWRnZXQpO1xuICAgICAgICAgICAgaXRlbS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1zaG93J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZVNob3cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25CZWZvcmVTaG93LmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaC5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtc2hvd24nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRTaG93biA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1oaWRkZW4nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRIaWRkZW4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAncmVzaXplJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKG1zZy53aWR0aCwgbXNnLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCd1cGRhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoLTEsIC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnZml0LXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLm9uRml0UmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHNwZWNpZmllZCB3aWRnZXQgZnJvbSB0aGUgbGF5b3V0IHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIHdpZGdldCBpcyBub3QgaW4gdGhlIGxheW91dCB0cmVlLlxuICAgICAqXG4gICAgICogVGhpcyBkb2VzIG5vdCBkZXRhY2ggdGhlIHdpZGdldCBmcm9tIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5fcmVtb3ZlV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIGxheW91dCByb290LlxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSB0YWIgbm9kZSB3aGljaCBjb250YWlucyB0aGUgZ2l2ZW4gd2lkZ2V0LlxuICAgICAgICB2YXIgdGFiTm9kZSA9IHRoaXMuX3Jvb3QuZmluZFRhYk5vZGUod2lkZ2V0KTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgdGFiIG5vZGUgaXMgbm90IGZvdW5kLlxuICAgICAgICBpZiAoIXRhYk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBQcml2YXRlJGQucmVtb3ZlQXJpYSh3aWRnZXQpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdGFicywganVzdCByZW1vdmUgdGhlIHdpZGdldCdzIHRhYi5cbiAgICAgICAgaWYgKHRhYk5vZGUudGFiQmFyLnRpdGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0YWJOb2RlLnRhYkJhci5yZW1vdmVUYWIod2lkZ2V0LnRpdGxlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB0YWIgbm9kZSBuZWVkcyB0byBiZSByZW1vdmVkLi4uXG4gICAgICAgIC8vIERpc3Bvc2UgdGhlIHRhYiBiYXIuXG4gICAgICAgIHRhYk5vZGUudGFiQmFyLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSB0YWIgbm9kZSBpcyB0aGUgcm9vdC5cbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT09IHRhYk5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmVtb3ZlIHRoZSB0YWIgbm9kZSBmcm9tIGl0cyBwYXJlbnQuLi5cbiAgICAgICAgLy8gUHJldmVudCB3aWRnZXQgcmVzaXppbmcgdW5sZXNzIG5lZWRlZC5cbiAgICAgICAgdGhpcy5fcm9vdC5ob2xkQWxsU2l6ZXMoKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHBhcmVudCByZWZlcmVuY2Ugb24gdGhlIHRhYiBub2RlLlxuICAgICAgICB2YXIgc3BsaXROb2RlID0gdGFiTm9kZS5wYXJlbnQ7XG4gICAgICAgIHRhYk5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWIgbm9kZSBmcm9tIGl0cyBwYXJlbnQgc3BsaXQgbm9kZS5cbiAgICAgICAgdmFyIGkgPSBBcnJheUV4dC5yZW1vdmVGaXJzdE9mKHNwbGl0Tm9kZS5jaGlsZHJlbiwgdGFiTm9kZSk7XG4gICAgICAgIHZhciBoYW5kbGUgPSBBcnJheUV4dC5yZW1vdmVBdChzcGxpdE5vZGUuaGFuZGxlcywgaSk7XG4gICAgICAgIEFycmF5RXh0LnJlbW92ZUF0KHNwbGl0Tm9kZS5zaXplcnMsIGkpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGhhbmRsZSBmcm9tIGl0cyBwYXJlbnQgRE9NIG5vZGUuXG4gICAgICAgIGlmIChoYW5kbGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaGFuZGxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2hpbGRyZW4sIGp1c3QgdXBkYXRlIHRoZSBoYW5kbGVzLlxuICAgICAgICBpZiAoc3BsaXROb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNwbGl0Tm9kZS5zeW5jSGFuZGxlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHNwbGl0IG5vZGUgYWxzbyBuZWVkcyB0byBiZSByZW1vdmVkLi4uXG4gICAgICAgIC8vIENsZWFyIHRoZSBwYXJlbnQgcmVmZXJlbmNlIG9uIHRoZSBzcGxpdCBub2RlLlxuICAgICAgICB2YXIgbWF5YmVQYXJlbnQgPSBzcGxpdE5vZGUucGFyZW50O1xuICAgICAgICBzcGxpdE5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgLy8gTG9va3VwIHRoZSByZW1haW5pbmcgY2hpbGQgbm9kZSBhbmQgaGFuZGxlLlxuICAgICAgICB2YXIgY2hpbGROb2RlID0gc3BsaXROb2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB2YXIgY2hpbGRIYW5kbGUgPSBzcGxpdE5vZGUuaGFuZGxlc1swXTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHNwbGl0IG5vZGUgZGF0YS5cbiAgICAgICAgc3BsaXROb2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIHNwbGl0Tm9kZS5oYW5kbGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHNwbGl0Tm9kZS5zaXplcnMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBoYW5kbGUgZnJvbSBpdHMgcGFyZW50IG5vZGUuXG4gICAgICAgIGlmIChjaGlsZEhhbmRsZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjaGlsZEhhbmRsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkSGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHNwbGl0IG5vZGUgaXMgdGhlIHJvb3QuXG4gICAgICAgIGlmICh0aGlzLl9yb290ID09PSBzcGxpdE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdGhlIGNoaWxkIG5vZGUgdG8gdGhlIHBhcmVudCBub2RlLi4uXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gbWF5YmVQYXJlbnQ7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgaW5kZXggb2YgdGhlIHNwbGl0IG5vZGUuXG4gICAgICAgIHZhciBqID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmRleE9mKHNwbGl0Tm9kZSk7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY2hpbGQgbm9kZSBpcyBhIHRhYiBub2RlLlxuICAgICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgUHJpdmF0ZSRkLlRhYkxheW91dE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbltqXSA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHNwbGl0IGRhdGEgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICB2YXIgc3BsaXRIYW5kbGUgPSBBcnJheUV4dC5yZW1vdmVBdChwYXJlbnROb2RlLmhhbmRsZXMsIGopO1xuICAgICAgICBBcnJheUV4dC5yZW1vdmVBdChwYXJlbnROb2RlLmNoaWxkcmVuLCBqKTtcbiAgICAgICAgQXJyYXlFeHQucmVtb3ZlQXQocGFyZW50Tm9kZS5zaXplcnMsIGopO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGhhbmRsZSBmcm9tIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAgICAgaWYgKHNwbGl0SGFuZGxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHNwbGl0SGFuZGxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3BsaXRIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBub2RlIGFuZCB0aGUgc3BsaXQgcGFyZW50IG5vZGUgd2lsbCBoYXZlIHRoZSBzYW1lXG4gICAgICAgIC8vIG9yaWVudGF0aW9uLiBNZXJnZSB0aGUgZ3JhbmQtY2hpbGRyZW4gd2l0aCB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgIGZvciAodmFyIGlfMSA9IDAsIG4gPSBjaGlsZE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpXzEgPCBuOyArK2lfMSkge1xuICAgICAgICAgICAgdmFyIGdDaGlsZCA9IGNoaWxkTm9kZS5jaGlsZHJlbltpXzFdO1xuICAgICAgICAgICAgdmFyIGdIYW5kbGUgPSBjaGlsZE5vZGUuaGFuZGxlc1tpXzFdO1xuICAgICAgICAgICAgdmFyIGdTaXplciA9IGNoaWxkTm9kZS5zaXplcnNbaV8xXTtcbiAgICAgICAgICAgIEFycmF5RXh0Lmluc2VydChwYXJlbnROb2RlLmNoaWxkcmVuLCBqICsgaV8xLCBnQ2hpbGQpO1xuICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHBhcmVudE5vZGUuaGFuZGxlcywgaiArIGlfMSwgZ0hhbmRsZSk7XG4gICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQocGFyZW50Tm9kZS5zaXplcnMsIGogKyBpXzEsIGdTaXplcik7XG4gICAgICAgICAgICBnQ2hpbGQucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0aGUgY2hpbGQgbm9kZS5cbiAgICAgICAgY2hpbGROb2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIGNoaWxkTm9kZS5oYW5kbGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNoaWxkTm9kZS5zaXplcnMubGVuZ3RoID0gMDtcbiAgICAgICAgY2hpbGROb2RlLnBhcmVudCA9IG51bGw7XG4gICAgICAgIC8vIFN5bmMgdGhlIGhhbmRsZXMgb24gdGhlIHBhcmVudCBub2RlLlxuICAgICAgICBwYXJlbnROb2RlLnN5bmNIYW5kbGVzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSB3aWRnZXQgbmV4dCB0byBhbiBleGlzdGluZyB0YWIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBkb2VzIG5vdCBhdHRhY2ggdGhlIHdpZGdldCB0byB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5faW5zZXJ0VGFiID0gZnVuY3Rpb24gKHdpZGdldCwgcmVmLCByZWZOb2RlLCBhZnRlcikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB0YWIgaXMgaW5zZXJ0ZWQgbmV4dCB0byBpdHNlbGYuXG4gICAgICAgIGlmICh3aWRnZXQgPT09IHJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcm9vdCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCF0aGlzLl9yb290KSB7XG4gICAgICAgICAgICB2YXIgdGFiTm9kZSA9IG5ldyBQcml2YXRlJGQuVGFiTGF5b3V0Tm9kZSh0aGlzLl9jcmVhdGVUYWJCYXIoKSk7XG4gICAgICAgICAgICB0YWJOb2RlLnRhYkJhci5hZGRUYWIod2lkZ2V0LnRpdGxlKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSB0YWJOb2RlO1xuICAgICAgICAgICAgUHJpdmF0ZSRkLmFkZEFyaWEod2lkZ2V0LCB0YWJOb2RlLnRhYkJhcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCB0YWIgbm9kZSBhcyB0aGUgcmVmIG5vZGUgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIXJlZk5vZGUpIHtcbiAgICAgICAgICAgIHJlZk5vZGUgPSB0aGlzLl9yb290LmZpbmRGaXJzdFRhYk5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgd2lkZ2V0IGlzIG5vdCBjb250YWluZWQgaW4gdGhlIHJlZiBub2RlLCBlbnN1cmUgaXQgaXNcbiAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHRoZSBsYXlvdXQgYW5kIGhpZGRlbiBiZWZvcmUgYmVpbmcgYWRkZWQgYWdhaW4uXG4gICAgICAgIGlmIChyZWZOb2RlLnRhYkJhci50aXRsZXMuaW5kZXhPZih3aWRnZXQudGl0bGUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlV2lkZ2V0KHdpZGdldCk7XG4gICAgICAgICAgICB3aWRnZXQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2t1cCB0aGUgdGFyZ2V0IGluZGV4IGZvciBpbnNlcnRpbmcgdGhlIHRhYi5cbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICBpbmRleCA9IHJlZk5vZGUudGFiQmFyLnRpdGxlcy5pbmRleE9mKHJlZi50aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHJlZk5vZGUudGFiQmFyLmN1cnJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnNlcnQgdGhlIHdpZGdldCdzIHRhYiByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IGluZGV4LlxuICAgICAgICByZWZOb2RlLnRhYkJhci5pbnNlcnRUYWIoaW5kZXggKyAoYWZ0ZXIgPyAxIDogMCksIHdpZGdldC50aXRsZSk7XG4gICAgICAgIFByaXZhdGUkZC5hZGRBcmlhKHdpZGdldCwgcmVmTm9kZS50YWJCYXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgd2lkZ2V0IGFzIGEgbmV3IHNwbGl0IGFyZWEuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBkb2VzIG5vdCBhdHRhY2ggdGhlIHdpZGdldCB0byB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5faW5zZXJ0U3BsaXQgPSBmdW5jdGlvbiAod2lkZ2V0LCByZWYsIHJlZk5vZGUsIG9yaWVudGF0aW9uLCBhZnRlcikge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vIGVmZmVjdGl2ZSBzcGxpdC5cbiAgICAgICAgaWYgKHdpZGdldCA9PT0gcmVmICYmIHJlZk5vZGUgJiYgcmVmTm9kZS50YWJCYXIudGl0bGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgd2lkZ2V0IGlzIHJlbW92ZWQgZnJvbSB0aGUgY3VycmVudCBsYXlvdXQuXG4gICAgICAgIHRoaXMuX3JlbW92ZVdpZGdldCh3aWRnZXQpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHRhYiBsYXlvdXQgbm9kZSB0byBob2xkIHRoZSB3aWRnZXQuXG4gICAgICAgIHZhciB0YWJOb2RlID0gbmV3IFByaXZhdGUkZC5UYWJMYXlvdXROb2RlKHRoaXMuX2NyZWF0ZVRhYkJhcigpKTtcbiAgICAgICAgdGFiTm9kZS50YWJCYXIuYWRkVGFiKHdpZGdldC50aXRsZSk7XG4gICAgICAgIFByaXZhdGUkZC5hZGRBcmlhKHdpZGdldCwgdGFiTm9kZS50YWJCYXIpO1xuICAgICAgICAvLyBTZXQgdGhlIHJvb3QgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHRhYk5vZGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHJlZiBub2RlIHBhcmVudCBpcyBudWxsLCBzcGxpdCB0aGUgcm9vdC5cbiAgICAgICAgaWYgKCFyZWZOb2RlIHx8ICFyZWZOb2RlLnBhcmVudCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSByb290IGlzIHNwbGl0IHdpdGggdGhlIGNvcnJlY3Qgb3JpZW50YXRpb24uXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3NwbGl0Um9vdChvcmllbnRhdGlvbik7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGluc2VydCBpbmRleCBmb3IgdGhlIG5ldyB0YWIgbm9kZS5cbiAgICAgICAgICAgIHZhciBpXzIgPSBhZnRlciA/IHJvb3QuY2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc3BsaXQgbm9kZS5cbiAgICAgICAgICAgIHJvb3Qubm9ybWFsaXplU2l6ZXMoKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2l6ZXIgZm9yIG5ldyB0YWIgbm9kZS5cbiAgICAgICAgICAgIHZhciBzaXplciA9IFByaXZhdGUkZC5jcmVhdGVTaXplcihyZWZOb2RlID8gMSA6IFByaXZhdGUkZC5HT0xERU5fUkFUSU8pO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSB0YWIgbm9kZSBzaXplZCB0byB0aGUgZ29sZGVuIHJhdGlvLlxuICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHJvb3QuY2hpbGRyZW4sIGlfMiwgdGFiTm9kZSk7XG4gICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQocm9vdC5zaXplcnMsIGlfMiwgc2l6ZXIpO1xuICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHJvb3QuaGFuZGxlcywgaV8yLCB0aGlzLl9jcmVhdGVIYW5kbGUoKSk7XG4gICAgICAgICAgICB0YWJOb2RlLnBhcmVudCA9IHJvb3Q7XG4gICAgICAgICAgICAvLyBSZS1ub3JtYWxpemUgdGhlIHNwbGl0IG5vZGUgdG8gbWFpbnRhaW4gdGhlIHJhdGlvcy5cbiAgICAgICAgICAgIHJvb3Qubm9ybWFsaXplU2l6ZXMoKTtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHN5bmNocm9uaXplIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBoYW5kbGVzLlxuICAgICAgICAgICAgcm9vdC5zeW5jSGFuZGxlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2t1cCB0aGUgc3BsaXQgbm9kZSBmb3IgdGhlIHJlZiB3aWRnZXQuXG4gICAgICAgIHZhciBzcGxpdE5vZGUgPSByZWZOb2RlLnBhcmVudDtcbiAgICAgICAgLy8gSWYgdGhlIHNwbGl0IG5vZGUgYWxyZWFkeSBoYWQgdGhlIGNvcnJlY3Qgb3JpZW50YXRpb24sXG4gICAgICAgIC8vIHRoZSB3aWRnZXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIHNwbGl0IG5vZGUgZGlyZWN0bHkuXG4gICAgICAgIGlmIChzcGxpdE5vZGUub3JpZW50YXRpb24gPT09IG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgcmVmIG5vZGUuXG4gICAgICAgICAgICB2YXIgaV8zID0gc3BsaXROb2RlLmNoaWxkcmVuLmluZGV4T2YocmVmTm9kZSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNwbGl0IG5vZGUuXG4gICAgICAgICAgICBzcGxpdE5vZGUubm9ybWFsaXplU2l6ZXMoKTtcbiAgICAgICAgICAgIC8vIENvbnN1bWUgaGFsZiB0aGUgc3BhY2UgZm9yIHRoZSBpbnNlcnQgbG9jYXRpb24uXG4gICAgICAgICAgICB2YXIgcyA9IHNwbGl0Tm9kZS5zaXplcnNbaV8zXS5zaXplSGludCAvPSAyO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSB0YWIgbm9kZSBzaXplZCB0byB0aGUgb3RoZXIgaGFsZi5cbiAgICAgICAgICAgIHZhciBqXzEgPSBpXzMgKyAoYWZ0ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICBBcnJheUV4dC5pbnNlcnQoc3BsaXROb2RlLmNoaWxkcmVuLCBqXzEsIHRhYk5vZGUpO1xuICAgICAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KHNwbGl0Tm9kZS5zaXplcnMsIGpfMSwgUHJpdmF0ZSRkLmNyZWF0ZVNpemVyKHMpKTtcbiAgICAgICAgICAgIEFycmF5RXh0Lmluc2VydChzcGxpdE5vZGUuaGFuZGxlcywgal8xLCB0aGlzLl9jcmVhdGVIYW5kbGUoKSk7XG4gICAgICAgICAgICB0YWJOb2RlLnBhcmVudCA9IHNwbGl0Tm9kZTtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHN5bmNocm9uaXplIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBoYW5kbGVzLlxuICAgICAgICAgICAgc3BsaXROb2RlLnN5bmNIYW5kbGVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWYgbm9kZSBmcm9tIHRoZSBzcGxpdCBub2RlLlxuICAgICAgICB2YXIgaSA9IEFycmF5RXh0LnJlbW92ZUZpcnN0T2Yoc3BsaXROb2RlLmNoaWxkcmVuLCByZWZOb2RlKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG5vcm1hbGl6ZWQgc3BsaXQgbm9kZSBmb3IgdGhlIGNoaWxkcmVuLlxuICAgICAgICB2YXIgY2hpbGROb2RlID0gbmV3IFByaXZhdGUkZC5TcGxpdExheW91dE5vZGUob3JpZW50YXRpb24pO1xuICAgICAgICBjaGlsZE5vZGUubm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIC8vIEFkZCB0aGUgcmVmIG5vZGUgc2l6ZWQgdG8gaGFsZiB0aGUgc3BhY2UuXG4gICAgICAgIGNoaWxkTm9kZS5jaGlsZHJlbi5wdXNoKHJlZk5vZGUpO1xuICAgICAgICBjaGlsZE5vZGUuc2l6ZXJzLnB1c2goUHJpdmF0ZSRkLmNyZWF0ZVNpemVyKDAuNSkpO1xuICAgICAgICBjaGlsZE5vZGUuaGFuZGxlcy5wdXNoKHRoaXMuX2NyZWF0ZUhhbmRsZSgpKTtcbiAgICAgICAgcmVmTm9kZS5wYXJlbnQgPSBjaGlsZE5vZGU7XG4gICAgICAgIC8vIEFkZCB0aGUgdGFiIG5vZGUgc2l6ZWQgdG8gdGhlIG90aGVyIGhhbGYuXG4gICAgICAgIHZhciBqID0gYWZ0ZXIgPyAxIDogMDtcbiAgICAgICAgQXJyYXlFeHQuaW5zZXJ0KGNoaWxkTm9kZS5jaGlsZHJlbiwgaiwgdGFiTm9kZSk7XG4gICAgICAgIEFycmF5RXh0Lmluc2VydChjaGlsZE5vZGUuc2l6ZXJzLCBqLCBQcml2YXRlJGQuY3JlYXRlU2l6ZXIoMC41KSk7XG4gICAgICAgIEFycmF5RXh0Lmluc2VydChjaGlsZE5vZGUuaGFuZGxlcywgaiwgdGhpcy5fY3JlYXRlSGFuZGxlKCkpO1xuICAgICAgICB0YWJOb2RlLnBhcmVudCA9IGNoaWxkTm9kZTtcbiAgICAgICAgLy8gU3luY2hyb25pemUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGhhbmRsZXMuXG4gICAgICAgIGNoaWxkTm9kZS5zeW5jSGFuZGxlcygpO1xuICAgICAgICAvLyBGaW5hbGx5LCBhZGQgdGhlIG5ldyBjaGlsZCBub2RlIHRvIHRoZSBvcmlnaW5hbCBzcGxpdCBub2RlLlxuICAgICAgICBBcnJheUV4dC5pbnNlcnQoc3BsaXROb2RlLmNoaWxkcmVuLCBpLCBjaGlsZE5vZGUpO1xuICAgICAgICBjaGlsZE5vZGUucGFyZW50ID0gc3BsaXROb2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoZSByb290IGlzIGEgc3BsaXQgbm9kZSB3aXRoIHRoZSBnaXZlbiBvcmllbnRhdGlvbi5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5fc3BsaXRSb290ID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIHJvb3QgYWxyZWFkeSBtZWV0cyB0aGUgcmVxdWlyZW1lbnRzLlxuICAgICAgICB2YXIgb2xkUm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGlmIChvbGRSb290IGluc3RhbmNlb2YgUHJpdmF0ZSRkLlNwbGl0TGF5b3V0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG9sZFJvb3Qub3JpZW50YXRpb24gPT09IG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJvb3Qgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZW50YXRpb24uXG4gICAgICAgIHZhciBuZXdSb290ID0gdGhpcy5fcm9vdCA9IG5ldyBQcml2YXRlJGQuU3BsaXRMYXlvdXROb2RlKG9yaWVudGF0aW9uKTtcbiAgICAgICAgLy8gQWRkIHRoZSBvbGQgcm9vdCB0byB0aGUgbmV3IHJvb3QuXG4gICAgICAgIGlmIChvbGRSb290KSB7XG4gICAgICAgICAgICBuZXdSb290LmNoaWxkcmVuLnB1c2gob2xkUm9vdCk7XG4gICAgICAgICAgICBuZXdSb290LnNpemVycy5wdXNoKFByaXZhdGUkZC5jcmVhdGVTaXplcigwKSk7XG4gICAgICAgICAgICBuZXdSb290LmhhbmRsZXMucHVzaCh0aGlzLl9jcmVhdGVIYW5kbGUoKSk7XG4gICAgICAgICAgICBvbGRSb290LnBhcmVudCA9IG5ld1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgcm9vdCBhcyBhIGNvbnZlbmllbmNlLlxuICAgICAgICByZXR1cm4gbmV3Um9vdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpdCB0aGUgbGF5b3V0IHRvIHRoZSB0b3RhbCBzaXplIHJlcXVpcmVkIGJ5IHRoZSB3aWRnZXRzLlxuICAgICAqL1xuICAgIERvY2tMYXlvdXQucHJvdG90eXBlLl9maXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgY29tcHV0ZWQgbWluaW11bSBzaXplLlxuICAgICAgICB2YXIgbWluVyA9IDA7XG4gICAgICAgIHZhciBtaW5IID0gMDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzaXplIGxpbWl0cyBmb3IgdGhlIGxheW91dCB0cmVlLlxuICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgdmFyIGxpbWl0cyA9IHRoaXMuX3Jvb3QuZml0KHRoaXMuX3NwYWNpbmcsIHRoaXMuX2l0ZW1zKTtcbiAgICAgICAgICAgIG1pblcgPSBsaW1pdHMubWluV2lkdGg7XG4gICAgICAgICAgICBtaW5IID0gbGltaXRzLm1pbkhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGJveCBzaXppbmcgYW5kIGFkZCBpdCB0byB0aGUgY29tcHV0ZWQgbWluIHNpemUuXG4gICAgICAgIHZhciBib3ggPSB0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKTtcbiAgICAgICAgbWluVyArPSBib3guaG9yaXpvbnRhbFN1bTtcbiAgICAgICAgbWluSCArPSBib3gudmVydGljYWxTdW07XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyZW50J3MgbWluIHNpemUgY29uc3RyYWludHMuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMucGFyZW50Lm5vZGUuc3R5bGU7XG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluVyArIFwicHhcIjtcbiAgICAgICAgc3R5bGUubWluSGVpZ2h0ID0gbWluSCArIFwicHhcIjtcbiAgICAgICAgLy8gU2V0IHRoZSBkaXJ0eSBmbGFnIHRvIGVuc3VyZSBvbmx5IGEgc2luZ2xlIHVwZGF0ZSBvY2N1cnMuXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgLy8gTm90aWZ5IHRoZSBhbmNlc3RvciB0aGF0IGl0IHNob3VsZCBmaXQgaW1tZWRpYXRlbHkuIFRoaXMgbWF5XG4gICAgICAgIC8vIGNhdXNlIGEgcmVzaXplIG9mIHRoZSBwYXJlbnQsIGZ1bGZpbGxpbmcgdGhlIHJlcXVpcmVkIHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5wYXJlbnQucGFyZW50LCBXaWRnZXQuTXNnLkZpdFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBkaXJ0eSBmbGFnIGlzIHN0aWxsIHNldCwgdGhlIHBhcmVudCB3YXMgbm90IHJlc2l6ZWQuXG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIHJlcXVpcmVkIHVwZGF0ZSBvbiB0aGUgcGFyZW50IHdpZGdldCBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLnBhcmVudCwgV2lkZ2V0Lk1zZy5VcGRhdGVSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBsYXlvdXQgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHdpZGdldHMuXG4gICAgICpcbiAgICAgKiBUaGUgcGFyZW50IG9mZnNldCBkaW1lbnNpb25zIHNob3VsZCBiZSBgLTFgIGlmIHVua25vd24uXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBkaXJ0eSBmbGFnIHRvIGluZGljYXRlIHRoZSB1cGRhdGUgb2NjdXJyZWQuXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gcm9vdCBsYXlvdXQgbm9kZS5cbiAgICAgICAgaWYgKCF0aGlzLl9yb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVhc3VyZSB0aGUgcGFyZW50IGlmIHRoZSBvZmZzZXQgZGltZW5zaW9ucyBhcmUgdW5rbm93bi5cbiAgICAgICAgaWYgKG9mZnNldFdpZHRoIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSB0aGlzLnBhcmVudC5ub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSB0aGlzLnBhcmVudC5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBib3ggc2l6aW5nIGRhdGEgaXMgY29tcHV0ZWQuXG4gICAgICAgIGlmICghdGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLnBhcmVudC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhY3R1YWwgbGF5b3V0IGJvdW5kcyBhZGp1c3RlZCBmb3IgYm9yZGVyIGFuZCBwYWRkaW5nLlxuICAgICAgICB2YXIgeCA9IHRoaXMuX2JveC5wYWRkaW5nVG9wO1xuICAgICAgICB2YXIgeSA9IHRoaXMuX2JveC5wYWRkaW5nTGVmdDtcbiAgICAgICAgdmFyIHdpZHRoID0gb2Zmc2V0V2lkdGggLSB0aGlzLl9ib3guaG9yaXpvbnRhbFN1bTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG9mZnNldEhlaWdodCAtIHRoaXMuX2JveC52ZXJ0aWNhbFN1bTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBvZiB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgIHRoaXMuX3Jvb3QudXBkYXRlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuX3NwYWNpbmcsIHRoaXMuX2l0ZW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0YWIgYmFyIGZvciB1c2UgYnkgdGhlIGRvY2sgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSB0YWIgYmFyIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHBhcmVudCBpZiBpdCBleGlzdHMuXG4gICAgICovXG4gICAgRG9ja0xheW91dC5wcm90b3R5cGUuX2NyZWF0ZVRhYkJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0YWIgYmFyIHVzaW5nIHRoZSByZW5kZXJlci5cbiAgICAgICAgdmFyIHRhYkJhciA9IHRoaXMucmVuZGVyZXIuY3JlYXRlVGFiQmFyKCk7XG4gICAgICAgIC8vIEVuZm9yY2UgbmVjZXNzYXJ5IHRhYiBiYXIgYmVoYXZpb3IuXG4gICAgICAgIHRhYkJhci5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgLy8gUmVwYXJlbnQgYW5kIGF0dGFjaCB0aGUgdGFiIGJhciB0byB0aGUgcGFyZW50IGlmIHBvc3NpYmxlLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRhYkJhci5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoV2lkZ2V0KHRhYkJhcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBpbml0aWFsaXplZCB0YWIgYmFyLlxuICAgICAgICByZXR1cm4gdGFiQmFyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGhhbmRsZSBmb3IgdGhlIGRvY2sgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBoYW5kbGUgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgcGFyZW50IGlmIGl0IGV4aXN0cy5cbiAgICAgKi9cbiAgICBEb2NrTGF5b3V0LnByb3RvdHlwZS5fY3JlYXRlSGFuZGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGhhbmRsZSB1c2luZyB0aGUgcmVuZGVyZXIuXG4gICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUhhbmRsZSgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBoYW5kbGUgbGF5b3V0IGJlaGF2aW9yLlxuICAgICAgICB2YXIgc3R5bGUgPSBoYW5kbGUuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUudG9wID0gJzAnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICcwJztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgICAvLyBBdHRhY2ggdGhlIGhhbmRsZSB0byB0aGUgcGFyZW50IGlmIGl0IGV4aXN0cy5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBpbml0aWFsaXplZCBoYW5kbGUuXG4gICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfTtcbiAgICByZXR1cm4gRG9ja0xheW91dDtcbn0oTGF5b3V0KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkZDtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIEEgZnJhY3Rpb24gdXNlZCBmb3Igc2l6aW5nIHJvb3QgcGFuZWxzOyB+PSBgMSAvIGdvbGRlbl9yYXRpb2AuXG4gICAgICovXG4gICAgUHJpdmF0ZS5HT0xERU5fUkFUSU8gPSAwLjYxODtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBib3ggc2l6ZXIgd2l0aCBhbiBpbml0aWFsIHNpemUgaGludC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTaXplcihoaW50KSB7XG4gICAgICAgIHZhciBzaXplciA9IG5ldyBCb3hTaXplcigpO1xuICAgICAgICBzaXplci5zaXplSGludCA9IGhpbnQ7XG4gICAgICAgIHNpemVyLnNpemUgPSBoaW50O1xuICAgICAgICByZXR1cm4gc2l6ZXI7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlU2l6ZXIgPSBjcmVhdGVTaXplcjtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYW4gYXJlYSBjb25maWcgb2JqZWN0IGFuZCBjb2xsZWN0IHRoZSB2aXNpdGVkIHdpZGdldHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQXJlYUNvbmZpZyhjb25maWcsIHdpZGdldFNldCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoY29uZmlnLnR5cGUgPT09ICd0YWItYXJlYScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVRhYkFyZWFDb25maWcoY29uZmlnLCB3aWRnZXRTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU3BsaXRBcmVhQ29uZmlnKGNvbmZpZywgd2lkZ2V0U2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBQcml2YXRlLm5vcm1hbGl6ZUFyZWFDb25maWcgPSBub3JtYWxpemVBcmVhQ29uZmlnO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBub3JtYWxpemVkIGFyZWEgY29uZmlnIGludG8gYSBsYXlvdXQgdHJlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFsaXplQXJlYUNvbmZpZyhjb25maWcsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAoY29uZmlnLnR5cGUgPT09ICd0YWItYXJlYScpIHtcbiAgICAgICAgICAgIG5vZGUgPSByZWFsaXplVGFiQXJlYUNvbmZpZyhjb25maWcsIHJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSByZWFsaXplU3BsaXRBcmVhQ29uZmlnKGNvbmZpZywgcmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBQcml2YXRlLnJlYWxpemVBcmVhQ29uZmlnID0gcmVhbGl6ZUFyZWFDb25maWc7XG4gICAgLyoqXG4gICAgICogQSBsYXlvdXQgbm9kZSB3aGljaCBob2xkcyB0aGUgZGF0YSBmb3IgYSB0YWJiZWQgYXJlYS5cbiAgICAgKi9cbiAgICB2YXIgVGFiTGF5b3V0Tm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB0YWIgbGF5b3V0IG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0YWJCYXIgLSBUaGUgdGFiIGJhciB0byB1c2UgZm9yIHRoZSBsYXlvdXQgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRhYkxheW91dE5vZGUodGFiQmFyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBwYXJlbnQgb2YgdGhlIGxheW91dCBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90b3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IDA7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgICAgICAgICAgdmFyIHRhYlNpemVyID0gbmV3IEJveFNpemVyKCk7XG4gICAgICAgICAgICB2YXIgd2lkZ2V0U2l6ZXIgPSBuZXcgQm94U2l6ZXIoKTtcbiAgICAgICAgICAgIHRhYlNpemVyLnN0cmV0Y2ggPSAwO1xuICAgICAgICAgICAgd2lkZ2V0U2l6ZXIuc3RyZXRjaCA9IDE7XG4gICAgICAgICAgICB0aGlzLnRhYkJhciA9IHRhYkJhcjtcbiAgICAgICAgICAgIHRoaXMuc2l6ZXJzID0gW3RhYlNpemVyLCB3aWRnZXRTaXplcl07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkxheW91dE5vZGUucHJvdG90eXBlLCBcInRvcFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmb3IgdGhlIGB0b3BgIGVkZ2Ugb2YgdGhlIGxheW91dCBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkxheW91dE5vZGUucHJvdG90eXBlLCBcImxlZnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbW9zdCByZWNlbnQgdmFsdWUgZm9yIHRoZSBgbGVmdGAgZWRnZSBvZiB0aGUgbGF5b3V0IGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkxheW91dE5vZGUucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IHZhbHVlIGZvciB0aGUgYHdpZHRoYCBvZiB0aGUgbGF5b3V0IGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJMYXlvdXROb2RlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbW9zdCByZWNlbnQgdmFsdWUgZm9yIHRoZSBgaGVpZ2h0YCBvZiB0aGUgbGF5b3V0IGJveC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciBhbGwgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBUYWJMYXlvdXROb2RlLnByb3RvdHlwZS5pdGVyQWxsV2lkZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbihvbmNlKHRoaXMudGFiQmFyKSwgdGhpcy5pdGVyVXNlcldpZGdldHMoKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIHRoZSB1c2VyIHdpZGdldHMgaW4gdGhlIGxheW91dCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVGFiTGF5b3V0Tm9kZS5wcm90b3R5cGUuaXRlclVzZXJXaWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcCh0aGlzLnRhYkJhci50aXRsZXMsIGZ1bmN0aW9uICh0aXRsZSkgeyByZXR1cm4gdGl0bGUub3duZXI7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciB0aGUgc2VsZWN0ZWQgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBUYWJMYXlvdXROb2RlLnByb3RvdHlwZS5pdGVyU2VsZWN0ZWRXaWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gdGhpcy50YWJCYXIuY3VycmVudFRpdGxlO1xuICAgICAgICAgICAgcmV0dXJuIHRpdGxlID8gb25jZSh0aXRsZS5vd25lcikgOiBlbXB0eSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciB0aGUgdGFiIGJhcnMgaW4gdGhlIGxheW91dCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVGFiTGF5b3V0Tm9kZS5wcm90b3R5cGUuaXRlclRhYkJhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb25jZSh0aGlzLnRhYkJhcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIHRoZSBoYW5kbGVzIGluIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFRhYkxheW91dE5vZGUucHJvdG90eXBlLml0ZXJIYW5kbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSB0YWIgbGF5b3V0IG5vZGUgd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgICAgICovXG4gICAgICAgIFRhYkxheW91dE5vZGUucHJvdG90eXBlLmZpbmRUYWJOb2RlID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFiQmFyLnRpdGxlcy5pbmRleE9mKHdpZGdldC50aXRsZSkgIT09IC0xID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBzcGxpdCBsYXlvdXQgbm9kZSB3aGljaCBjb250YWlucyB0aGUgZ2l2ZW4gaGFuZGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgVGFiTGF5b3V0Tm9kZS5wcm90b3R5cGUuZmluZFNwbGl0Tm9kZSA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgZmlyc3QgdGFiIGxheW91dCBub2RlIGluIGEgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBUYWJMYXlvdXROb2RlLnByb3RvdHlwZS5maW5kRmlyc3RUYWJOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSB0YWIgbGF5b3V0IG5vZGUgd2hpY2ggY29udGFpbnMgdGhlIGxvY2FsIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgVGFiTGF5b3V0Tm9kZS5wcm90b3R5cGUuaGl0VGVzdFRhYk5vZGVzID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICh4IDwgdGhpcy5fbGVmdCB8fCB4ID49IHRoaXMuX2xlZnQgKyB0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPCB0aGlzLl90b3AgfHwgeSA+PSB0aGlzLl90b3AgKyB0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFRhYkxheW91dE5vZGUucHJvdG90eXBlLmNyZWF0ZUNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWRnZXRzID0gdGhpcy50YWJCYXIudGl0bGVzLm1hcChmdW5jdGlvbiAodGl0bGUpIHsgcmV0dXJuIHRpdGxlLm93bmVyOyB9KTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnRhYkJhci5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAndGFiLWFyZWEnLCB3aWRnZXRzOiB3aWRnZXRzLCBjdXJyZW50SW5kZXg6IGN1cnJlbnRJbmRleCB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjdXJzaXZlbHkgaG9sZCBhbGwgb2YgdGhlIHNpemVzIGluIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpZ25vcmVzIHRoZSBzaXplcnMgb2YgdGFiIGxheW91dCBub2Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIFRhYkxheW91dE5vZGUucHJvdG90eXBlLmhvbGRBbGxTaXplcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpdCB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBUYWJMYXlvdXROb2RlLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAoc3BhY2luZywgaXRlbXMpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgbGltaXQgdmFyaWFibGVzLlxuICAgICAgICAgICAgdmFyIG1pbldpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBtaW5IZWlnaHQgPSAwO1xuICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAvLyBMb29rdXAgdGhlIHRhYiBiYXIgbGF5b3V0IGl0ZW0uXG4gICAgICAgICAgICB2YXIgdGFiQmFySXRlbSA9IGl0ZW1zLmdldCh0aGlzLnRhYkJhcik7XG4gICAgICAgICAgICAvLyBMb29rdXAgdGhlIHdpZGdldCBsYXlvdXQgaXRlbS5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy50YWJCYXIuY3VycmVudFRpdGxlO1xuICAgICAgICAgICAgdmFyIHdpZGdldEl0ZW0gPSBjdXJyZW50ID8gaXRlbXMuZ2V0KGN1cnJlbnQub3duZXIpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSB0YWIgYmFyIGFuZCB3aWRnZXQgc2l6ZXJzLlxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5zaXplcnMsIHRhYkJhclNpemVyID0gX2FbMF0sIHdpZGdldFNpemVyID0gX2FbMV07XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhYiBiYXIgbGltaXRzLlxuICAgICAgICAgICAgaWYgKHRhYkJhckl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0YWJCYXJJdGVtLmZpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB3aWRnZXQgbGltaXRzLlxuICAgICAgICAgICAgaWYgKHdpZGdldEl0ZW0pIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRJdGVtLmZpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZXN1bHRzIGFuZCBzaXplciBmb3IgdGhlIHRhYiBiYXIuXG4gICAgICAgICAgICBpZiAodGFiQmFySXRlbSAmJiAhdGFiQmFySXRlbS5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gTWF0aC5tYXgobWluV2lkdGgsIHRhYkJhckl0ZW0ubWluV2lkdGgpO1xuICAgICAgICAgICAgICAgIG1pbkhlaWdodCArPSB0YWJCYXJJdGVtLm1pbkhlaWdodDtcbiAgICAgICAgICAgICAgICB0YWJCYXJTaXplci5taW5TaXplID0gdGFiQmFySXRlbS5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGFiQmFyU2l6ZXIubWF4U2l6ZSA9IHRhYkJhckl0ZW0ubWF4SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiQmFyU2l6ZXIubWluU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgdGFiQmFyU2l6ZXIubWF4U2l6ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlc3VsdHMgYW5kIHNpemVyIGZvciB0aGUgY3VycmVudCB3aWRnZXQuXG4gICAgICAgICAgICBpZiAod2lkZ2V0SXRlbSAmJiAhd2lkZ2V0SXRlbS5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gTWF0aC5tYXgobWluV2lkdGgsIHdpZGdldEl0ZW0ubWluV2lkdGgpO1xuICAgICAgICAgICAgICAgIG1pbkhlaWdodCArPSB3aWRnZXRJdGVtLm1pbkhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWRnZXRTaXplci5taW5TaXplID0gd2lkZ2V0SXRlbS5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkZ2V0U2l6ZXIubWF4U2l6ZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0U2l6ZXIubWluU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2lkZ2V0U2l6ZXIubWF4U2l6ZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb21wdXRlZCBzaXplIGxpbWl0cyBmb3IgdGhlIGxheW91dCBub2RlLlxuICAgICAgICAgICAgcmV0dXJuIHsgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFRhYkxheW91dE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHNwYWNpbmcsIGl0ZW1zKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxheW91dCBib3ggdmFsdWVzLlxuICAgICAgICAgICAgdGhpcy5fdG9wID0gdG9wO1xuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSB0YWIgYmFyIGxheW91dCBpdGVtLlxuICAgICAgICAgICAgdmFyIHRhYkJhckl0ZW0gPSBpdGVtcy5nZXQodGhpcy50YWJCYXIpO1xuICAgICAgICAgICAgLy8gTG9va3VwIHRoZSB3aWRnZXQgbGF5b3V0IGl0ZW0uXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMudGFiQmFyLmN1cnJlbnRUaXRsZTtcbiAgICAgICAgICAgIHZhciB3aWRnZXRJdGVtID0gY3VycmVudCA/IGl0ZW1zLmdldChjdXJyZW50Lm93bmVyKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgdGhlIGxheW91dCBzcGFjZSB0byB0aGUgc2l6ZXJzLlxuICAgICAgICAgICAgQm94RW5naW5lLmNhbGModGhpcy5zaXplcnMsIGhlaWdodCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhYiBiYXIgaXRlbSB1c2luZyB0aGUgY29tcHV0ZWQgc2l6ZS5cbiAgICAgICAgICAgIGlmICh0YWJCYXJJdGVtICYmICF0YWJCYXJJdGVtLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemVyc1swXS5zaXplO1xuICAgICAgICAgICAgICAgIHRhYkJhckl0ZW0udXBkYXRlKGxlZnQsIHRvcCwgd2lkdGgsIHNpemUpO1xuICAgICAgICAgICAgICAgIHRvcCArPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGF5b3V0IHRoZSB3aWRnZXQgdXNpbmcgdGhlIGNvbXB1dGVkIHNpemUuXG4gICAgICAgICAgICBpZiAod2lkZ2V0SXRlbSAmJiAhd2lkZ2V0SXRlbS5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplcnNbMV0uc2l6ZTtcbiAgICAgICAgICAgICAgICB3aWRnZXRJdGVtLnVwZGF0ZShsZWZ0LCB0b3AsIHdpZHRoLCBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRhYkxheW91dE5vZGU7XG4gICAgfSgpKTtcbiAgICBQcml2YXRlLlRhYkxheW91dE5vZGUgPSBUYWJMYXlvdXROb2RlO1xuICAgIC8qKlxuICAgICAqIEEgbGF5b3V0IG5vZGUgd2hpY2ggaG9sZHMgdGhlIGRhdGEgZm9yIGEgc3BsaXQgYXJlYS5cbiAgICAgKi9cbiAgICB2YXIgU3BsaXRMYXlvdXROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHNwbGl0IGxheW91dCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3JpZW50YXRpb24gLSBUaGUgb3JpZW50YXRpb24gb2YgdGhlIG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTcGxpdExheW91dE5vZGUob3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHBhcmVudCBvZiB0aGUgbGF5b3V0IG5vZGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgc2l6ZXJzIGhhdmUgYmVlbiBub3JtYWxpemVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGNoaWxkIG5vZGVzIGZvciB0aGUgc3BsaXQgbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgYm94IHNpemVycyBmb3IgdGhlIGxheW91dCBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zaXplcnMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGhhbmRsZXMgZm9yIHRoZSBsYXlvdXQgY2hpbGRyZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIGFsbCB3aWRnZXRzIGluIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUuaXRlckFsbFdpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXAodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pdGVyQWxsV2lkZ2V0cygpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5JdGVyYXRvcihjaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIHRoZSB1c2VyIHdpZGdldHMgaW4gdGhlIGxheW91dCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgU3BsaXRMYXlvdXROb2RlLnByb3RvdHlwZS5pdGVyVXNlcldpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXAodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pdGVyVXNlcldpZGdldHMoKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluSXRlcmF0b3IoY2hpbGRyZW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIGZvciB0aGUgc2VsZWN0ZWQgd2lkZ2V0cyBpbiB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBTcGxpdExheW91dE5vZGUucHJvdG90eXBlLml0ZXJTZWxlY3RlZFdpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXAodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pdGVyU2VsZWN0ZWRXaWRnZXRzKCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbkl0ZXJhdG9yKGNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBpdGVyYXRvciBmb3IgdGhlIHRhYiBiYXJzIGluIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUuaXRlclRhYkJhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXAodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pdGVyVGFiQmFycygpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5JdGVyYXRvcihjaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3IgZm9yIHRoZSBoYW5kbGVzIGluIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUuaXRlckhhbmRsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXAodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pdGVySGFuZGxlcygpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbih0aGlzLmhhbmRsZXMsIG5ldyBDaGFpbkl0ZXJhdG9yKGNoaWxkcmVuKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSB0YWIgbGF5b3V0IG5vZGUgd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIHdpZGdldC5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUuZmluZFRhYk5vZGUgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hpbGRyZW5baV0uZmluZFRhYk5vZGUod2lkZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBzcGxpdCBsYXlvdXQgbm9kZSB3aGljaCBjb250YWlucyB0aGUgZ2l2ZW4gaGFuZGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgU3BsaXRMYXlvdXROb2RlLnByb3RvdHlwZS5maW5kU3BsaXROb2RlID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5oYW5kbGVzLmluZGV4T2YoaGFuZGxlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXgsIG5vZGU6IHRoaXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaGlsZHJlbltpXS5maW5kU3BsaXROb2RlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgZmlyc3QgdGFiIGxheW91dCBub2RlIGluIGEgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBTcGxpdExheW91dE5vZGUucHJvdG90eXBlLmZpbmRGaXJzdFRhYk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdLmZpbmRGaXJzdFRhYk5vZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIHRhYiBsYXlvdXQgbm9kZSB3aGljaCBjb250YWlucyB0aGUgbG9jYWwgcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBTcGxpdExheW91dE5vZGUucHJvdG90eXBlLmhpdFRlc3RUYWJOb2RlcyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hpbGRyZW5baV0uaGl0VGVzdFRhYk5vZGVzKHgsIHkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBTcGxpdExheW91dE5vZGUucHJvdG90eXBlLmNyZWF0ZUNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3JpZW50YXRpb247XG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSB0aGlzLmNyZWF0ZU5vcm1hbGl6ZWRTaXplcygpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5jcmVhdGVDb25maWcoKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnc3BsaXQtYXJlYScsIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiwgY2hpbGRyZW46IGNoaWxkcmVuLCBzaXplczogc2l6ZXMgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN5bmMgdGhlIHZpc2liaWxpdHkgYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBoYW5kbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgU3BsaXRMYXlvdXROb2RlLnByb3RvdHlwZS5zeW5jSGFuZGxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBlYWNoKHRoaXMuaGFuZGxlcywgZnVuY3Rpb24gKGhhbmRsZSwgaSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZW50YXRpb24nLCBfdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IF90aGlzLmhhbmRsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2xhc3NMaXN0LmFkZCgnbG0tbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNsYXNzTGlzdC5hZGQoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2xhc3NMaXN0LnJlbW92ZSgnbG0tbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNsYXNzTGlzdC5yZW1vdmUoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkIHRoZSBjdXJyZW50IHNpemVzIG9mIHRoZSBib3ggc2l6ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHNldHMgdGhlIHNpemUgaGludCBvZiBlYWNoIHNpemVyIHRvIGl0cyBjdXJyZW50IHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICBTcGxpdExheW91dE5vZGUucHJvdG90eXBlLmhvbGRTaXplcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy5zaXplcnMsIGZ1bmN0aW9uIChzaXplcikgeyBzaXplci5zaXplSGludCA9IHNpemVyLnNpemU7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjdXJzaXZlbHkgaG9sZCBhbGwgb2YgdGhlIHNpemVzIGluIHRoZSBsYXlvdXQgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpZ25vcmVzIHRoZSBzaXplcnMgb2YgdGFiIGxheW91dCBub2Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUuaG9sZEFsbFNpemVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWFjaCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmhvbGRBbGxTaXplcygpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuaG9sZFNpemVzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3JtYWxpemUgdGhlIHNpemVzIG9mIHRoZSBzcGxpdCBsYXlvdXQgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUubm9ybWFsaXplU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSBzaXplcnMgYXJlIGVtcHR5LlxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnNpemVycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhvbGQgdGhlIGN1cnJlbnQgc2l6ZXMgb2YgdGhlIHNpemVycy5cbiAgICAgICAgICAgIHRoaXMuaG9sZFNpemVzKCk7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBzdW0gb2YgdGhlIHNpemVzLlxuICAgICAgICAgICAgdmFyIHN1bSA9IHJlZHVjZSh0aGlzLnNpemVycywgZnVuY3Rpb24gKHYsIHNpemVyKSB7IHJldHVybiB2ICsgc2l6ZXIuc2l6ZUhpbnQ7IH0sIDApO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaXplcyBiYXNlZCBvbiB0aGUgc3VtLlxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVhY2godGhpcy5zaXplcnMsIGZ1bmN0aW9uIChzaXplcikge1xuICAgICAgICAgICAgICAgICAgICBzaXplci5zaXplID0gc2l6ZXIuc2l6ZUhpbnQgPSAxIC8gbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVhY2godGhpcy5zaXplcnMsIGZ1bmN0aW9uIChzaXplcikge1xuICAgICAgICAgICAgICAgICAgICBzaXplci5zaXplID0gc2l6ZXIuc2l6ZUhpbnQgLz0gc3VtO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFyayB0aGUgc2l6ZXMgYXMgbm9ybWFsaXplZC5cbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTbmFwIHRoZSBub3JtYWxpemVkIHNpemVzIG9mIHRoZSBzcGxpdCBsYXlvdXQgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIFNwbGl0TGF5b3V0Tm9kZS5wcm90b3R5cGUuY3JlYXRlTm9ybWFsaXplZFNpemVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgc2l6ZXJzIGFyZSBlbXB0eS5cbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5zaXplcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBjdXJyZW50IHNpemVzIG9mIHRoZSBzaXplcnMuXG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSB0aGlzLnNpemVycy5tYXAoZnVuY3Rpb24gKHNpemVyKSB7IHJldHVybiBzaXplci5zaXplOyB9KTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHN1bSBvZiB0aGUgc2l6ZXMuXG4gICAgICAgICAgICB2YXIgc3VtID0gcmVkdWNlKHNpemVzLCBmdW5jdGlvbiAodiwgc2l6ZSkgeyByZXR1cm4gdiArIHNpemU7IH0sIDApO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaXplcyBiYXNlZCBvbiB0aGUgc3VtLlxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVhY2goc2l6ZXMsIGZ1bmN0aW9uIChzaXplLCBpKSB7IHNpemVzW2ldID0gMSAvIG47IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWFjaChzaXplcywgZnVuY3Rpb24gKHNpemUsIGkpIHsgc2l6ZXNbaV0gPSBzaXplIC8gc3VtOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbm9ybWFsaXplZCBzaXplcy5cbiAgICAgICAgICAgIHJldHVybiBzaXplcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpdCB0aGUgbGF5b3V0IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBTcGxpdExheW91dE5vZGUucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIChzcGFjaW5nLCBpdGVtcykge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcmVxdWlyZWQgZml4ZWQgc3BhY2UuXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgICAgIHZhciBmaXhlZCA9IE1hdGgubWF4KDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgKiBzcGFjaW5nO1xuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBsaW1pdCB2YXJpYWJsZXMuXG4gICAgICAgICAgICB2YXIgbWluV2lkdGggPSBob3Jpem9udGFsID8gZml4ZWQgOiAwO1xuICAgICAgICAgICAgdmFyIG1pbkhlaWdodCA9IGhvcml6b250YWwgPyAwIDogZml4ZWQ7XG4gICAgICAgICAgICB2YXIgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBtYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIC8vIEZpdCB0aGUgY2hpbGRyZW4gYW5kIHVwZGF0ZSB0aGUgbGltaXRzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW1pdHMgPSB0aGlzLmNoaWxkcmVuW2ldLmZpdChzcGFjaW5nLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluSGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBsaW1pdHMubWluSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggKz0gbGltaXRzLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemVyc1tpXS5taW5TaXplID0gbGltaXRzLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgbGltaXRzLm1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGxpbWl0cy5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZXJzW2ldLm1pblNpemUgPSBsaW1pdHMubWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29tcHV0ZWQgbGltaXRzIGZvciB0aGUgbGF5b3V0IG5vZGUuXG4gICAgICAgICAgICByZXR1cm4geyBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0IH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGxheW91dCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgU3BsaXRMYXlvdXROb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBzcGFjaW5nLCBpdGVtcykge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYXZhaWxhYmxlIGxheW91dCBzcGFjZS5cbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsID0gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gTWF0aC5tYXgoMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSAqIHNwYWNpbmc7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBNYXRoLm1heCgwLCAoaG9yaXpvbnRhbCA/IHdpZHRoIDogaGVpZ2h0KSAtIGZpeGVkKTtcbiAgICAgICAgICAgIC8vIERlLW5vcm1hbGl6ZSB0aGUgc2l6ZXMgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGVhY2godGhpcy5zaXplcnMsIGZ1bmN0aW9uIChzaXplcikgeyBzaXplci5zaXplSGludCAqPSBzcGFjZTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXN0cmlidXRlIHRoZSBsYXlvdXQgc3BhY2UgdG8gdGhlIHNpemVycy5cbiAgICAgICAgICAgIEJveEVuZ2luZS5jYWxjKHRoaXMuc2l6ZXJzLCBzcGFjZSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGdlb21ldHJ5IG9mIHRoZSBjaGlsZCBub2RlcyBhbmQgaGFuZGxlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplcnNbaV0uc2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlU3R5bGUgPSB0aGlzLmhhbmRsZXNbaV0uc3R5bGU7XG4gICAgICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlKGxlZnQsIHRvcCwgc2l6ZSwgaGVpZ2h0LCBzcGFjaW5nLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGUud2lkdGggPSBzcGFjaW5nICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gc3BhY2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZShsZWZ0LCB0b3AsIHdpZHRoLCBzaXplLCBzcGFjaW5nLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCArPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZS5oZWlnaHQgPSBzcGFjaW5nICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b3AgKz0gc3BhY2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTcGxpdExheW91dE5vZGU7XG4gICAgfSgpKTtcbiAgICBQcml2YXRlLlNwbGl0TGF5b3V0Tm9kZSA9IFNwbGl0TGF5b3V0Tm9kZTtcbiAgICBmdW5jdGlvbiBhZGRBcmlhKHdpZGdldCwgdGFiQmFyKSB7XG4gICAgICAgIHdpZGdldC5ub2RlLnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWJwYW5lbCcpO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0YWJCYXIucmVuZGVyZXI7XG4gICAgICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIFRhYkJhci5SZW5kZXJlcikge1xuICAgICAgICAgICAgdmFyIHRhYklkID0gcmVuZGVyZXIuY3JlYXRlVGFiS2V5KHsgdGl0bGU6IHdpZGdldC50aXRsZSwgY3VycmVudDogZmFsc2UsIHpJbmRleDogMCB9KTtcbiAgICAgICAgICAgIHdpZGdldC5ub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgdGFiSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaXZhdGUuYWRkQXJpYSA9IGFkZEFyaWE7XG4gICAgZnVuY3Rpb24gcmVtb3ZlQXJpYSh3aWRnZXQpIHtcbiAgICAgICAgd2lkZ2V0Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICAgIHdpZGdldC5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gICAgfVxuICAgIFByaXZhdGUucmVtb3ZlQXJpYSA9IHJlbW92ZUFyaWE7XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgdGFiIGFyZWEgY29uZmlnIGFuZCBjb2xsZWN0IHRoZSB2aXNpdGVkIHdpZGdldHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVGFiQXJlYUNvbmZpZyhjb25maWcsIHdpZGdldFNldCkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAgICAgIGlmIChjb25maWcud2lkZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHVwIHRoZSBmaWx0ZXJlZCB3aWRnZXRzIGFycmF5LlxuICAgICAgICB2YXIgd2lkZ2V0cyA9IFtdO1xuICAgICAgICAvLyBGaWx0ZXIgdGhlIGNvbmZpZyBmb3IgdW5pcXVlIHdpZGdldHMuXG4gICAgICAgIGVhY2goY29uZmlnLndpZGdldHMsIGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGlmICghd2lkZ2V0U2V0Lmhhcyh3aWRnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0U2V0LmFkZCh3aWRnZXQpO1xuICAgICAgICAgICAgICAgIHdpZGdldHMucHVzaCh3aWRnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBhcmUgbm8gZWZmZWN0aXZlIHdpZGdldHMuXG4gICAgICAgIGlmICh3aWRnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjdXJyZW50IGluZGV4LlxuICAgICAgICB2YXIgaW5kZXggPSBjb25maWcuY3VycmVudEluZGV4O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gd2lkZ2V0cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgbm9ybWFsaXplZCBjb25maWcgb2JqZWN0LlxuICAgICAgICByZXR1cm4geyB0eXBlOiAndGFiLWFyZWEnLCB3aWRnZXRzOiB3aWRnZXRzLCBjdXJyZW50SW5kZXg6IGluZGV4IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIHNwbGl0IGFyZWEgY29uZmlnIGFuZCBjb2xsZWN0IHRoZSB2aXNpdGVkIHdpZGdldHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplU3BsaXRBcmVhQ29uZmlnKGNvbmZpZywgd2lkZ2V0U2V0KSB7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgcmVzdWx0IHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIHNpemVzID0gW107XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgY29uZmlnIGNoaWxkcmVuLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNvbmZpZy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgY2hpbGQgY29uZmlnLlxuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9ybWFsaXplQXJlYUNvbmZpZyhjb25maWcuY2hpbGRyZW5baV0sIHdpZGdldFNldCk7XG4gICAgICAgICAgICAvLyBJZ25vcmUgYW4gZW1wdHkgY2hpbGQuXG4gICAgICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGNoaWxkIG9yIGhvaXN0IGl0cyBjb250ZW50IGFzIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICd0YWItYXJlYScgfHwgY2hpbGQub3JpZW50YXRpb24gIT09IG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgc2l6ZXMucHVzaChNYXRoLmFicyhjb25maWcuc2l6ZXNbaV0gfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaC5hcHBseShjaGlsZHJlbiwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHNpemVzLnB1c2guYXBwbHkoc2l6ZXMsIGNoaWxkLnNpemVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGFyZSBubyBlZmZlY3RpdmUgY2hpbGRyZW4uXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIGVmZmVjdGl2ZSBjaGlsZCwgcmV0dXJuIHRoYXQgY2hpbGQuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBub3JtYWxpemVkIGNvbmZpZyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdzcGxpdC1hcmVhJywgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLCBjaGlsZHJlbjogY2hpbGRyZW4sIHNpemVzOiBzaXplcyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgbm9ybWFsaXplZCB0YWIgYXJlYSBjb25maWcgaW50byBhIGxheW91dCB0cmVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWxpemVUYWJBcmVhQ29uZmlnKGNvbmZpZywgcmVuZGVyZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0YWIgYmFyIGZvciB0aGUgbGF5b3V0IG5vZGUuXG4gICAgICAgIHZhciB0YWJCYXIgPSByZW5kZXJlci5jcmVhdGVUYWJCYXIoKTtcbiAgICAgICAgLy8gSGlkZSBlYWNoIHdpZGdldCBhbmQgYWRkIGl0IHRvIHRoZSB0YWIgYmFyLlxuICAgICAgICBlYWNoKGNvbmZpZy53aWRnZXRzLCBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgICAgICB3aWRnZXQuaGlkZSgpO1xuICAgICAgICAgICAgdGFiQmFyLmFkZFRhYih3aWRnZXQudGl0bGUpO1xuICAgICAgICAgICAgUHJpdmF0ZS5hZGRBcmlhKHdpZGdldCwgdGFiQmFyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBpbmRleCBvZiB0aGUgdGFiIGJhci5cbiAgICAgICAgdGFiQmFyLmN1cnJlbnRJbmRleCA9IGNvbmZpZy5jdXJyZW50SW5kZXg7XG4gICAgICAgIC8vIFJldHVybiB0aGUgbmV3IHRhYiBsYXlvdXQgbm9kZS5cbiAgICAgICAgcmV0dXJuIG5ldyBUYWJMYXlvdXROb2RlKHRhYkJhcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBub3JtYWxpemVkIHNwbGl0IGFyZWEgY29uZmlnIGludG8gYSBsYXlvdXQgdHJlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFsaXplU3BsaXRBcmVhQ29uZmlnKGNvbmZpZywgcmVuZGVyZXIpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzcGxpdCBsYXlvdXQgbm9kZS5cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgU3BsaXRMYXlvdXROb2RlKGNvbmZpZy5vcmllbnRhdGlvbik7XG4gICAgICAgIC8vIEFkZCBlYWNoIGNoaWxkIHRvIHRoZSBsYXlvdXQgbm9kZS5cbiAgICAgICAgZWFjaChjb25maWcuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBjaGlsZCBkYXRhIGZvciB0aGUgbGF5b3V0IG5vZGUuXG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gcmVhbGl6ZUFyZWFDb25maWcoY2hpbGQsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIHZhciBzaXplciA9IGNyZWF0ZVNpemVyKGNvbmZpZy5zaXplc1tpXSk7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gcmVuZGVyZXIuY3JlYXRlSGFuZGxlKCk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGNoaWxkIGRhdGEgdG8gdGhlIGxheW91dCBub2RlLlxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICBub2RlLmhhbmRsZXMucHVzaChoYW5kbGUpO1xuICAgICAgICAgICAgbm9kZS5zaXplcnMucHVzaChzaXplcik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBhcmVudCBmb3IgdGhlIGNoaWxkIG5vZGUuXG4gICAgICAgICAgICBjaGlsZE5vZGUucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN5bmNocm9uaXplIHRoZSBoYW5kbGUgc3RhdGUgZm9yIHRoZSBsYXlvdXQgbm9kZS5cbiAgICAgICAgbm9kZS5zeW5jSGFuZGxlcygpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpemVzIGZvciB0aGUgbGF5b3V0IG5vZGUuXG4gICAgICAgIG5vZGUubm9ybWFsaXplU2l6ZXMoKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXcgbGF5b3V0IG5vZGUuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn0pKFByaXZhdGUkZCB8fCAoUHJpdmF0ZSRkID0ge30pKTtcblxuLyoqXG4gKiBBIHdpZGdldCB3aGljaCBwcm92aWRlcyBhIGZsZXhpYmxlIGRvY2tpbmcgYXJlYSBmb3Igd2lkZ2V0cy5cbiAqL1xudmFyIERvY2tQYW5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9ja1BhbmVsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBkb2NrIHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBwYW5lbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb2NrUGFuZWwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZHJhZyA9IG51bGw7XG4gICAgICAgIF90aGlzLl90YWJzTW92YWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLl90YWJzQ29uc3RyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2FkZEJ1dHRvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3ByZXNzRGF0YSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9sYXlvdXRNb2RpZmllZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fYWRkUmVxdWVzdGVkID0gbmV3IFNpZ25hbChfdGhpcyk7XG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdsbS1Eb2NrUGFuZWwnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdwLURvY2tQYW5lbCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLl9tb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdtdWx0aXBsZS1kb2N1bWVudCc7XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXIgfHwgRG9ja1BhbmVsLmRlZmF1bHRSZW5kZXJlcjtcbiAgICAgICAgX3RoaXMuX2VkZ2VzID0gb3B0aW9ucy5lZGdlcyB8fCBQcml2YXRlJGUuREVGQVVMVF9FREdFUztcbiAgICAgICAgaWYgKG9wdGlvbnMudGFic01vdmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMuX3RhYnNNb3ZhYmxlID0gb3B0aW9ucy50YWJzTW92YWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50YWJzQ29uc3RyYWluZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMuX3RhYnNDb25zdHJhaW5lZCA9IG9wdGlvbnMudGFic0NvbnN0cmFpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFkZEJ1dHRvbkVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMuX2FkZEJ1dHRvbkVuYWJsZWQgPSBvcHRpb25zLmFkZEJ1dHRvbkVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBDU1MgbW9kZSBhdHRyaWJ1dGUuXG4gICAgICAgIF90aGlzLmRhdGFzZXRbJ21vZGUnXSA9IF90aGlzLl9tb2RlO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGRlbGVnYXRlIHJlbmRlcmVyIGZvciB0aGUgbGF5b3V0LlxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB7XG4gICAgICAgICAgICBjcmVhdGVUYWJCYXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVUYWJCYXIoKTsgfSxcbiAgICAgICAgICAgIGNyZWF0ZUhhbmRsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZUhhbmRsZSgpOyB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNldCB1cCB0aGUgZG9jayBsYXlvdXQgZm9yIHRoZSBwYW5lbC5cbiAgICAgICAgX3RoaXMubGF5b3V0ID0gbmV3IERvY2tMYXlvdXQoeyByZW5kZXJlcjogcmVuZGVyZXIsIHNwYWNpbmc6IG9wdGlvbnMuc3BhY2luZyB9KTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBvdmVybGF5IGRyb3AgaW5kaWNhdG9yLlxuICAgICAgICBfdGhpcy5vdmVybGF5ID0gb3B0aW9ucy5vdmVybGF5IHx8IG5ldyBEb2NrUGFuZWwuT3ZlcmxheSgpO1xuICAgICAgICBfdGhpcy5ub2RlLmFwcGVuZENoaWxkKF90aGlzLm92ZXJsYXkubm9kZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHBhbmVsLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBtb3VzZSBpcyByZWxlYXNlZC5cbiAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgICAgIC8vIEhpZGUgdGhlIG92ZXJsYXkuXG4gICAgICAgIHRoaXMub3ZlcmxheS5oaWRlKDApO1xuICAgICAgICAvLyBDYW5jZWwgYSBkcmFnIGlmIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgaWYgKHRoaXMuX2RyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWcuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIGJhc2UgY2xhc3MuXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY2tQYW5lbC5wcm90b3R5cGUsIFwibGF5b3V0TW9kaWZpZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBpcyBtb2RpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHNpZ25hbCBpcyBlbWl0dGVkIHdoZW5ldmVyIHRoZSBjdXJyZW50IGxheW91dCBjb25maWd1cmF0aW9uXG4gICAgICAgICAqIG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIGVtaXR0ZWQgYXN5bmNocm9ub3VzbHkgaW4gYSBjb2xsYXBzZWQgZmFzaGlvbiwgc29cbiAgICAgICAgICogdGhhdCBtdWx0aXBsZSBzeW5jaHJvbm91cyBtb2RpZmljYXRpb25zIHJlc3VsdHMgaW4gb25seSBhIHNpbmdsZVxuICAgICAgICAgKiBlbWl0IG9mIHRoZSBzaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRNb2RpZmllZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY2tQYW5lbC5wcm90b3R5cGUsIFwiYWRkUmVxdWVzdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgYWRkIGJ1dHRvbiBvbiBhIHRhYiBiYXIgaXMgY2xpY2tlZC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJlcXVlc3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY2tQYW5lbC5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlbmRlcmVyIHVzZWQgYnkgdGhlIGRvY2sgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5yZW5kZXJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY2tQYW5lbC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHNwYWNpbmcgYmV0d2VlbiB0aGUgd2lkZ2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnNwYWNpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHNwYWNpbmcgYmV0d2VlbiB0aGUgd2lkZ2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5zcGFjaW5nID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2NrUGFuZWwucHJvdG90eXBlLCBcIm1vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtb2RlIGZvciB0aGUgZG9jayBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1vZGUgZm9yIHRoZSBkb2NrIHBhbmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIENoYW5naW5nIHRoZSBtb2RlIGlzIGEgZGVzdHJ1Y3RpdmUgb3BlcmF0aW9uIHdpdGggcmVzcGVjdCB0byB0aGVcbiAgICAgICAgICogcGFuZWwncyBsYXlvdXQgY29uZmlndXJhdGlvbi4gSWYgbGF5b3V0IHN0YXRlIG11c3QgYmUgcHJlc2VydmVkLFxuICAgICAgICAgKiBzYXZlIHRoZSBjdXJyZW50IGxheW91dCBjb25maWcgYmVmb3JlIGNoYW5naW5nIHRoZSBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlIG1vZGUgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBtb2RlLlxuICAgICAgICAgICAgdGhpcy5fbW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gVG9nZ2xlIHRoZSBDU1MgbW9kZSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICB0aGlzLmRhdGFzZXRbJ21vZGUnXSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsYXlvdXQgZm9yIHRoZSBwYW5lbC5cbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgbGF5b3V0IGZvciB0aGUgc3BlY2lmaWVkIG1vZGUuXG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXVsdGlwbGUtZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICBlYWNoKGxheW91dC50YWJCYXJzKCksIGZ1bmN0aW9uICh0YWJCYXIpIHsgdGFiQmFyLnNob3coKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1kb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dC5yZXN0b3JlTGF5b3V0KFByaXZhdGUkZS5jcmVhdGVTaW5nbGVEb2N1bWVudENvbmZpZyh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhbiBlbWl0IG9mIHRoZSBsYXlvdXQgbW9kaWZpZWQgc2lnbmFsLlxuICAgICAgICAgICAgTWVzc2FnZUxvb3AucG9zdE1lc3NhZ2UodGhpcywgUHJpdmF0ZSRlLkxheW91dE1vZGlmaWVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY2tQYW5lbC5wcm90b3R5cGUsIFwidGFic01vdmFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdGFicyBjYW4gYmUgZHJhZ2dlZCAvIG1vdmVkIGF0IHJ1bnRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWJzTW92YWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZSAvIERpc2FibGUgZHJhZ2dhYmxlIC8gbW92YWJsZSB0YWJzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYnNNb3ZhYmxlID0gdmFsdWU7XG4gICAgICAgICAgICBlYWNoKHRoaXMudGFiQmFycygpLCBmdW5jdGlvbiAodGFiYmFyKSB7IHRhYmJhci50YWJzTW92YWJsZSA9IHZhbHVlOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY2tQYW5lbC5wcm90b3R5cGUsIFwidGFic0NvbnN0cmFpbmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRhYnMgYXJlIGNvbnN0cmFpbmVkIHRvIHRoZWlyIHNvdXJjZSBkb2NrIHBhbmVsXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWJzQ29uc3RyYWluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJhaW4vQWxsb3cgdGFicyB0byBiZSBkcmFnZ2VkIG91dHNpZGUgb2YgdGhpcyBkb2NrIHBhbmVsXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGFic0NvbnN0cmFpbmVkID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2NrUGFuZWwucHJvdG90eXBlLCBcImFkZEJ1dHRvbkVuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYWRkIGJ1dHRvbnMgZm9yIGVhY2ggdGFiIGJhciBhcmUgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEJ1dHRvbkVuYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgd2hldGhlciB0aGUgYWRkIGJ1dHRvbnMgZm9yIGVhY2ggdGFiIGJhciBhcmUgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRCdXR0b25FbmFibGVkID0gdmFsdWU7XG4gICAgICAgICAgICBlYWNoKHRoaXMudGFiQmFycygpLCBmdW5jdGlvbiAodGFiYmFyKSB7IHRhYmJhci5hZGRCdXR0b25FbmFibGVkID0gdmFsdWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9ja1BhbmVsLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGRvY2sgcGFuZWwgaXMgZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5pc0VtcHR5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdXNlciB3aWRnZXRzIGluIHRoZSBwYW5lbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIG92ZXIgdGhlIHVzZXIgd2lkZ2V0cyBpbiB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpdGVyYXRvciBkb2VzIG5vdCBpbmNsdWRlIHRoZSBnZW5lcmF0ZWQgdGFiIGJhcnMuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS53aWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQud2lkZ2V0cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHNlbGVjdGVkIHdpZGdldHMgaW4gdGhlIHBhbmVsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgaXRlcmF0b3Igb3ZlciB0aGUgc2VsZWN0ZWQgdXNlciB3aWRnZXRzLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXRlcmF0b3IgeWllbGRzIHRoZSB3aWRnZXRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgdGFiXG4gICAgICogb2YgZWFjaCB0YWIgYmFyIGluIHRoZSBwYW5lbC5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLnNlbGVjdGVkV2lkZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnNlbGVjdGVkV2lkZ2V0cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHRhYiBiYXJzIGluIHRoZSBwYW5lbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIG92ZXIgdGhlIHRhYiBiYXJzIGluIHRoZSBwYW5lbC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGl0ZXJhdG9yIGRvZXMgbm90IGluY2x1ZGUgdGhlIHVzZXIgd2lkZ2V0cy5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLnRhYkJhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC50YWJCYXJzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaXRlcmF0b3Igb3ZlciB0aGUgaGFuZGxlcyBpbiB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBvdmVyIHRoZSBoYW5kbGVzIGluIHRoZSBwYW5lbC5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLmhhbmRsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5oYW5kbGVzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzcGVjaWZpYyB3aWRnZXQgaW4gdGhlIGRvY2sgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgd2lkZ2V0IHRoZSBjdXJyZW50IHdpZGdldCBpbiBpdHMgdGFiIGFyZWEuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5zZWxlY3RXaWRnZXQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHRhYiBiYXIgd2hpY2ggY29udGFpbnMgdGhlIHdpZGdldC5cbiAgICAgICAgdmFyIHRhYkJhciA9IGZpbmQodGhpcy50YWJCYXJzKCksIGZ1bmN0aW9uIChiYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXIudGl0bGVzLmluZGV4T2Yod2lkZ2V0LnRpdGxlKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBubyB0YWIgYmFyIGlzIGZvdW5kLlxuICAgICAgICBpZiAoIXRhYkJhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaWRnZXQgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jayBwYW5lbC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHdpZGdldCBpcyB0aGUgY3VycmVudCB3aWRnZXQuXG4gICAgICAgIHRhYkJhci5jdXJyZW50VGl0bGUgPSB3aWRnZXQudGl0bGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZSBhIHNwZWNpZmllZCB3aWRnZXQgaW4gdGhlIGRvY2sgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHdpbGwgc2VsZWN0IGFuZCBhY3RpdmF0ZSB0aGUgZ2l2ZW4gd2lkZ2V0LlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuYWN0aXZhdGVXaWRnZXQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0V2lkZ2V0KHdpZGdldCk7XG4gICAgICAgIHdpZGdldC5hY3RpdmF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY3VycmVudCBsYXlvdXQgY29uZmlndXJhdGlvbiBvZiB0aGUgZG9jayBwYW5lbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvbmZpZyBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxheW91dCBzdGF0ZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHJlc3RvcmVMYXlvdXRgIG1ldGhvZFxuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlIGxheW91dCB0byBpdHMgY3VycmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuc2F2ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnNhdmVMYXlvdXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIGxheW91dCB0byBhIHByZXZpb3VzbHkgc2F2ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gdG8gcmVzdG9yZS5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBXaWRnZXRzIHdoaWNoIGN1cnJlbnRseSBiZWxvbmcgdG8gdGhlIGxheW91dCBidXQgd2hpY2ggYXJlIG5vdFxuICAgICAqIGNvbnRhaW5lZCBpbiB0aGUgY29uZmlnIHdpbGwgYmUgdW5wYXJlbnRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkb2NrIHBhbmVsIGF1dG9tYXRpY2FsbHkgcmV2ZXJ0cyB0byBgJ211bHRpcGxlLWRvY3VtZW50J2BcbiAgICAgKiBtb2RlIHdoZW4gYSBsYXlvdXQgY29uZmlnIGlzIHJlc3RvcmVkLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUucmVzdG9yZUxheW91dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIG1vZGUuXG4gICAgICAgIHRoaXMuX21vZGUgPSAnbXVsdGlwbGUtZG9jdW1lbnQnO1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBsYXlvdXQuXG4gICAgICAgIHRoaXMubGF5b3V0LnJlc3RvcmVMYXlvdXQoY29uZmlnKTtcbiAgICAgICAgLy8gRmx1c2ggdGhlIG1lc3NhZ2UgbG9vcCBvbiBJRSBhbmQgRWRnZSB0byBwcmV2ZW50IGZsaWNrZXIuXG4gICAgICAgIGlmIChQbGF0Zm9ybS5JU19FREdFIHx8IFBsYXRmb3JtLklTX0lFKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjaGVkdWxlIGFuIGVtaXQgb2YgdGhlIGxheW91dCBtb2RpZmllZCBzaWduYWwuXG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMsIFByaXZhdGUkZS5MYXlvdXRNb2RpZmllZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB3aWRnZXQgdG8gdGhlIGRvY2sgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBhZGQgdG8gdGhlIGRvY2sgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGFkZGluZyB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSBwYW5lbCBpcyBpbiBzaW5nbGUgZG9jdW1lbnQgbW9kZSwgdGhlIG9wdGlvbnMgYXJlIGlnbm9yZWRcbiAgICAgKiBhbmQgdGhlIHdpZGdldCBpcyBhbHdheXMgYWRkZWQgYXMgdGFiIGluIHRoZSBoaWRkZW4gdGFiIGJhci5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gQWRkIHRoZSB3aWRnZXQgdG8gdGhlIGxheW91dC5cbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09ICdzaW5nbGUtZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5hZGRXaWRnZXQod2lkZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LmFkZFdpZGdldCh3aWRnZXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjaGVkdWxlIGFuIGVtaXQgb2YgdGhlIGxheW91dCBtb2RpZmllZCBzaWduYWwuXG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMsIFByaXZhdGUkZS5MYXlvdXRNb2RpZmllZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgbWVzc2FnZSBzZW50IHRvIHRoZSB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIC0gVGhlIG1lc3NhZ2Ugc2VudCB0byB0aGUgd2lkZ2V0LlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUucHJvY2Vzc01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ2xheW91dC1tb2RpZmllZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dE1vZGlmaWVkLmVtaXQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucHJvY2Vzc01lc3NhZ2UuY2FsbCh0aGlzLCBtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIERPTSBldmVudHMgZm9yIHRoZSBkb2NrIHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIERPTSBldmVudCBzZW50IHRvIHRoZSBwYW5lbC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBET00gYEV2ZW50TGlzdGVuZXJgIGludGVyZmFjZSBhbmQgaXNcbiAgICAgKiBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gZXZlbnRzIG9uIHRoZSBwYW5lbCdzIERPTSBub2RlLiBJdCBzaG91bGRcbiAgICAgKiBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbG0tZHJhZ2VudGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnREcmFnRW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG0tZHJhZ2xlYXZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnREcmFnTGVhdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG0tZHJhZ292ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dERyYWdPdmVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xtLWRyb3AnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dERyb3AoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VVcChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRLZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLm9uQmVmb3JlQXR0YWNoID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbG0tZHJhZ2VudGVyJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdsbS1kcmFnbGVhdmUnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2xtLWRyYWdvdmVyJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdsbS1kcm9wJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUub25BZnRlckRldGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xtLWRyYWdlbnRlcicsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG0tZHJhZ2xlYXZlJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsbS1kcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG0tZHJvcCcsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtYWRkZWQnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUub25DaGlsZEFkZGVkID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGdlbmVyYXRlZCB0YWIgYmFycy5cbiAgICAgICAgaWYgKFByaXZhdGUkZS5pc0dlbmVyYXRlZFRhYkJhclByb3BlcnR5LmdldChtc2cuY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB3aWRnZXQgY2xhc3MgdG8gdGhlIGNoaWxkLlxuICAgICAgICBtc2cuY2hpbGQuYWRkQ2xhc3MoJ2xtLURvY2tQYW5lbC13aWRnZXQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIG1zZy5jaGlsZC5hZGRDbGFzcygncC1Eb2NrUGFuZWwtd2lkZ2V0Jyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2NoaWxkLXJlbW92ZWQnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUub25DaGlsZFJlbW92ZWQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZ2VuZXJhdGVkIHRhYiBiYXJzLlxuICAgICAgICBpZiAoUHJpdmF0ZSRlLmlzR2VuZXJhdGVkVGFiQmFyUHJvcGVydHkuZ2V0KG1zZy5jaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHdpZGdldCBjbGFzcyBmcm9tIHRoZSBjaGlsZC5cbiAgICAgICAgbXNnLmNoaWxkLnJlbW92ZUNsYXNzKCdsbS1Eb2NrUGFuZWwtd2lkZ2V0Jyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBtc2cuY2hpbGQucmVtb3ZlQ2xhc3MoJ3AtRG9ja1BhbmVsLXdpZGdldCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIC8vIFNjaGVkdWxlIGFuIGVtaXQgb2YgdGhlIGxheW91dCBtb2RpZmllZCBzaWduYWwuXG4gICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMsIFByaXZhdGUkZS5MYXlvdXRNb2RpZmllZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbG0tZHJhZ2VudGVyJ2AgZXZlbnQgZm9yIHRoZSBkb2NrIHBhbmVsLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuX2V2dERyYWdFbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBJZiB0aGUgZmFjdG9yeSBtaW1lIHR5cGUgaXMgcHJlc2VudCwgbWFyayB0aGUgZXZlbnQgYXNcbiAgICAgICAgLy8gaGFuZGxlZCBpbiBvcmRlciB0byBnZXQgdGhlIHJlc3Qgb2YgdGhlIGRyYWcgZXZlbnRzLlxuICAgICAgICBpZiAoZXZlbnQubWltZURhdGEuaGFzRGF0YSgnYXBwbGljYXRpb24vdm5kLmx1bWluby53aWRnZXQtZmFjdG9yeScpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdsbS1kcmFnbGVhdmUnYCBldmVudCBmb3IgdGhlIGRvY2sgcGFuZWwuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fZXZ0RHJhZ0xlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIGV2ZW50IGFzIGhhbmRsZWQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBUaGUgbmV3IHRhcmdldCBtaWdodCBiZSBhIGRlc2NlbmRhbnQsIHNvIHdlIG1pZ2h0IHN0aWxsIGhhbmRsZSB0aGUgZHJvcC5cbiAgICAgICAgLy8gSGlkZSBhc3luY2hyb25vdXNseSBzbyB0aGF0IGlmIGEgbG0tZHJhZ292ZXIgZXZlbnQgYnViYmxlcyB1cCB0byB1cywgdGhlXG4gICAgICAgIC8vIGhpZGUgaXMgY2FuY2VsbGVkIGJ5IHRoZSBsbS1kcmFnb3ZlciBoYW5kbGVyJ3Mgc2hvdyBvdmVybGF5IGxvZ2ljLlxuICAgICAgICB0aGlzLm92ZXJsYXkuaGlkZSgxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdsbS1kcmFnb3ZlcidgIGV2ZW50IGZvciB0aGUgZG9jayBwYW5lbC5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLl9ldnREcmFnT3ZlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBldmVudCBhcyBoYW5kbGVkLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gU2hvdyB0aGUgZHJvcCBpbmRpY2F0b3Igb3ZlcmxheSBhbmQgdXBkYXRlIHRoZSBkcm9wXG4gICAgICAgIC8vIGFjdGlvbiBiYXNlZCBvbiB0aGUgZHJvcCB0YXJnZXQgem9uZSB1bmRlciB0aGUgbW91c2UuXG4gICAgICAgIGlmICgodGhpcy5fdGFic0NvbnN0cmFpbmVkICYmIGV2ZW50LnNvdXJjZSAhPT0gdGhpcykgfHwgdGhpcy5fc2hvd092ZXJsYXkoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgPT09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgZXZlbnQuZHJvcEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LmRyb3BBY3Rpb24gPSBldmVudC5wcm9wb3NlZEFjdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ2xtLWRyb3AnYCBldmVudCBmb3IgdGhlIGRvY2sgcGFuZWwuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fZXZ0RHJvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBldmVudCBhcyBoYW5kbGVkLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gSGlkZSB0aGUgZHJvcCBpbmRpY2F0b3Igb3ZlcmxheS5cbiAgICAgICAgdGhpcy5vdmVybGF5LmhpZGUoMCk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIHByb3Bvc2VkIGFjdGlvbiBpcyB0byBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoZXZlbnQucHJvcG9zZWRBY3Rpb24gPT09ICdub25lJykge1xuICAgICAgICAgICAgZXZlbnQuZHJvcEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBkcm9wIHRhcmdldCB1bmRlciB0aGUgbW91c2UuXG4gICAgICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCwgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIHZhciBfYSA9IFByaXZhdGUkZS5maW5kRHJvcFRhcmdldCh0aGlzLCBjbGllbnRYLCBjbGllbnRZLCB0aGlzLl9lZGdlcyksIHpvbmUgPSBfYS56b25lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGRyb3Agem9uZSBpcyBpbnZhbGlkLlxuICAgICAgICBpZiAoem9uZSA9PT0gJ2ludmFsaWQnKSB7XG4gICAgICAgICAgICBldmVudC5kcm9wQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGZhY3RvcnkgbWltZSB0eXBlIGhhcyBpbnZhbGlkIGRhdGEuXG4gICAgICAgIHZhciBtaW1lRGF0YSA9IGV2ZW50Lm1pbWVEYXRhO1xuICAgICAgICB2YXIgZmFjdG9yeSA9IG1pbWVEYXRhLmdldERhdGEoJ2FwcGxpY2F0aW9uL3ZuZC5sdW1pbm8ud2lkZ2V0LWZhY3RvcnknKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBldmVudC5kcm9wQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGZhY3RvcnkgZG9lcyBub3QgcHJvZHVjZSBhIHdpZGdldC5cbiAgICAgICAgdmFyIHdpZGdldCA9IGZhY3RvcnkoKTtcbiAgICAgICAgaWYgKCEod2lkZ2V0IGluc3RhbmNlb2YgV2lkZ2V0KSkge1xuICAgICAgICAgICAgZXZlbnQuZHJvcEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWlsIGlmIHRoZSB3aWRnZXQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGRvY2sgcGFuZWwuXG4gICAgICAgIGlmICh3aWRnZXQuY29udGFpbnModGhpcykpIHtcbiAgICAgICAgICAgIGV2ZW50LmRyb3BBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgcmVmZXJlbmNlIHdpZGdldCBmb3IgdGhlIGRyb3AgdGFyZ2V0LlxuICAgICAgICB2YXIgcmVmID0gdGFyZ2V0ID8gUHJpdmF0ZSRlLmdldERyb3BSZWYodGFyZ2V0LnRhYkJhcikgOiBudWxsO1xuICAgICAgICAvLyBBZGQgdGhlIHdpZGdldCBhY2NvcmRpbmcgdG8gdGhlIGluZGljYXRlZCBkcm9wIHpvbmUuXG4gICAgICAgIHN3aXRjaCAoem9uZSkge1xuICAgICAgICAgICAgY2FzZSAncm9vdC1hbGwnOlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkV2lkZ2V0KHdpZGdldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb290LXRvcCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaWRnZXQod2lkZ2V0LCB7IG1vZGU6ICdzcGxpdC10b3AnIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm9vdC1sZWZ0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFdpZGdldCh3aWRnZXQsIHsgbW9kZTogJ3NwbGl0LWxlZnQnIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm9vdC1yaWdodCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaWRnZXQod2lkZ2V0LCB7IG1vZGU6ICdzcGxpdC1yaWdodCcgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb290LWJvdHRvbSc6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaWRnZXQod2lkZ2V0LCB7IG1vZGU6ICdzcGxpdC1ib3R0b20nIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2lkZ2V0LWFsbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaWRnZXQod2lkZ2V0LCB7IG1vZGU6ICd0YWItYWZ0ZXInLCByZWY6IHJlZiB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dpZGdldC10b3AnOlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkV2lkZ2V0KHdpZGdldCwgeyBtb2RlOiAnc3BsaXQtdG9wJywgcmVmOiByZWYgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWRnZXQtbGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaWRnZXQod2lkZ2V0LCB7IG1vZGU6ICdzcGxpdC1sZWZ0JywgcmVmOiByZWYgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWRnZXQtcmlnaHQnOlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkV2lkZ2V0KHdpZGdldCwgeyBtb2RlOiAnc3BsaXQtcmlnaHQnLCByZWY6IHJlZiB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dpZGdldC1ib3R0b20nOlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkV2lkZ2V0KHdpZGdldCwgeyBtb2RlOiAnc3BsaXQtYm90dG9tJywgcmVmOiByZWYgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWRnZXQtdGFiJzpcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFdpZGdldCh3aWRnZXQsIHsgbW9kZTogJ3RhYi1hZnRlcicsIHJlZjogcmVmIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFjY2VwdCB0aGUgcHJvcG9zZWQgZHJvcCBhY3Rpb24uXG4gICAgICAgIGV2ZW50LmRyb3BBY3Rpb24gPSBldmVudC5wcm9wb3NlZEFjdGlvbjtcbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGRyb3BwZWQgd2lkZ2V0LlxuICAgICAgICB0aGlzLmFjdGl2YXRlV2lkZ2V0KHdpZGdldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAna2V5ZG93bidgIGV2ZW50IGZvciB0aGUgZG9jayBwYW5lbC5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLl9ldnRLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFN0b3AgaW5wdXQgZXZlbnRzIGR1cmluZyBkcmFnLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gUmVsZWFzZSB0aGUgbW91c2UgaWYgYEVzY2FwZWAgaXMgcHJlc3NlZC5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAvLyBGaW5hbGl6ZSB0aGUgbW91c2UgcmVsZWFzZS5cbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZW1pdCBvZiB0aGUgbGF5b3V0IG1vZGlmaWVkIHNpZ25hbC5cbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnBvc3RNZXNzYWdlKHRoaXMsIFByaXZhdGUkZS5MYXlvdXRNb2RpZmllZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdtb3VzZWRvd24nYCBldmVudCBmb3IgdGhlIGRvY2sgcGFuZWwuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fZXZ0TW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIG5vdCBwcmVzc2VkLlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgaGFuZGxlIHdoaWNoIGNvbnRhaW5zIHRoZSBtb3VzZSB0YXJnZXQsIGlmIGFueS5cbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB2YXIgaGFuZGxlID0gZmluZChsYXlvdXQuaGFuZGxlcygpLCBmdW5jdGlvbiAoaGFuZGxlKSB7IHJldHVybiBoYW5kbGUuY29udGFpbnModGFyZ2V0KTsgfSk7XG4gICAgICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgd2hlbiBhIGhhbmRsZSBpcyBwcmVzc2VkLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQWRkIHRoZSBleHRyYSBkb2N1bWVudCBsaXN0ZW5lcnMuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgb2Zmc2V0IGRlbHRhcyBmb3IgdGhlIGhhbmRsZSBwcmVzcy5cbiAgICAgICAgdmFyIHJlY3QgPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBkZWx0YVggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICB2YXIgZGVsdGFZID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgY3Vyc29yIGFuZCBzdG9yZSB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaGFuZGxlKTtcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gRHJhZy5vdmVycmlkZUN1cnNvcihzdHlsZS5jdXJzb3IpO1xuICAgICAgICB0aGlzLl9wcmVzc0RhdGEgPSB7IGhhbmRsZTogaGFuZGxlLCBkZWx0YVg6IGRlbHRhWCwgZGVsdGFZOiBkZWx0YVksIG92ZXJyaWRlOiBvdmVycmlkZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNlbW92ZSdgIGV2ZW50IGZvciB0aGUgZG9jayBwYW5lbC5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLl9ldnRNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiBubyBkcmFnIGlzIGluIHByb2dyZXNzLlxuICAgICAgICBpZiAoIXRoaXMuX3ByZXNzRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHdoZW4gZHJhZ2dpbmcgYSBoYW5kbGUuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZXNpcmVkIG9mZnNldCBwb3NpdGlvbiBmb3IgdGhlIGhhbmRsZS5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB4UG9zID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIHRoaXMuX3ByZXNzRGF0YS5kZWx0YVg7XG4gICAgICAgIHZhciB5UG9zID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gdGhpcy5fcHJlc3NEYXRhLmRlbHRhWTtcbiAgICAgICAgLy8gU2V0IHRoZSBoYW5kbGUgYXMgY2xvc2UgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gYXMgcG9zc2libGUuXG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgbGF5b3V0Lm1vdmVIYW5kbGUodGhpcy5fcHJlc3NEYXRhLmhhbmRsZSwgeFBvcywgeVBvcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2V1cCdgIGV2ZW50IGZvciB0aGUgZG9jayBwYW5lbC5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLl9ldnRNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIG5vdCByZWxlYXNlZC5cbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3AgdGhlIGV2ZW50IHdoZW4gcmVsZWFzaW5nIGEgaGFuZGxlLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gRmluYWxpemUgdGhlIG1vdXNlIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiBlbWl0IG9mIHRoZSBsYXlvdXQgbW9kaWZpZWQgc2lnbmFsLlxuICAgICAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSh0aGlzLCBQcml2YXRlJGUuTGF5b3V0TW9kaWZpZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgbW91c2UgZ3JhYiBmb3IgdGhlIGRvY2sgcGFuZWwuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fcmVsZWFzZU1vdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIG5vIGRyYWcgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIGlmICghdGhpcy5fcHJlc3NEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIG92ZXJyaWRlIGN1cnNvci5cbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhLm92ZXJyaWRlLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHRyYSBkb2N1bWVudCBsaXN0ZW5lcnMuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG92ZXJsYXkgaW5kaWNhdG9yIGF0IHRoZSBnaXZlbiBjbGllbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBkcm9wIHpvbmUgYXQgdGhlIHNwZWNpZmllZCBjbGllbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHBvc2l0aW9uIGlzIG5vdCBvdmVyIGEgdmFsaWQgem9uZSwgdGhlIG92ZXJsYXkgaXMgaGlkZGVuLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuX3Nob3dPdmVybGF5ID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZG9jayB0YXJnZXQgZm9yIHRoZSBnaXZlbiBjbGllbnQgcG9zaXRpb24uXG4gICAgICAgIHZhciBfYSA9IFByaXZhdGUkZS5maW5kRHJvcFRhcmdldCh0aGlzLCBjbGllbnRYLCBjbGllbnRZLCB0aGlzLl9lZGdlcyksIHpvbmUgPSBfYS56b25lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgIC8vIElmIHRoZSBkcm9wIHpvbmUgaXMgaW52YWxpZCwgaGlkZSB0aGUgb3ZlcmxheSBhbmQgYmFpbC5cbiAgICAgICAgaWYgKHpvbmUgPT09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmhpZGUoMTAwKTtcbiAgICAgICAgICAgIHJldHVybiB6b25lO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHVwIHRoZSB2YXJpYWJsZXMgbmVlZGVkIHRvIGNvbXB1dGUgdGhlIG92ZXJsYXkgZ2VvbWV0cnkuXG4gICAgICAgIHZhciB0b3A7XG4gICAgICAgIHZhciBsZWZ0O1xuICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgIHZhciBib3R0b207XG4gICAgICAgIHZhciBib3ggPSBFbGVtZW50RXh0LmJveFNpemluZyh0aGlzLm5vZGUpOyAvLyBUT0RPIGNhY2hlIHRoaXM/XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBvdmVybGF5IGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBkb2NrIHpvbmUuXG4gICAgICAgIHN3aXRjaCAoem9uZSkge1xuICAgICAgICAgICAgY2FzZSAncm9vdC1hbGwnOlxuICAgICAgICAgICAgICAgIHRvcCA9IGJveC5wYWRkaW5nVG9wO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBib3gucGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBib3gucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IGJveC5wYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm9vdC10b3AnOlxuICAgICAgICAgICAgICAgIHRvcCA9IGJveC5wYWRkaW5nVG9wO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBib3gucGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBib3gucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJlY3QuaGVpZ2h0ICogUHJpdmF0ZSRlLkdPTERFTl9SQVRJTztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jvb3QtbGVmdCc6XG4gICAgICAgICAgICAgICAgdG9wID0gYm94LnBhZGRpbmdUb3A7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGJveC5wYWRkaW5nTGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHJlY3Qud2lkdGggKiBQcml2YXRlJGUuR09MREVOX1JBVElPO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IGJveC5wYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm9vdC1yaWdodCc6XG4gICAgICAgICAgICAgICAgdG9wID0gYm94LnBhZGRpbmdUb3A7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHJlY3Qud2lkdGggKiBQcml2YXRlJGUuR09MREVOX1JBVElPO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gYm94LnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBib3gucGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jvb3QtYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0b3AgPSByZWN0LmhlaWdodCAqIFByaXZhdGUkZS5HT0xERU5fUkFUSU87XG4gICAgICAgICAgICAgICAgbGVmdCA9IGJveC5wYWRkaW5nTGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IGJveC5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gYm94LnBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWRnZXQtYWxsJzpcbiAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXQudG9wO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXQubGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldC5yaWdodDtcbiAgICAgICAgICAgICAgICBib3R0b20gPSB0YXJnZXQuYm90dG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2lkZ2V0LXRvcCc6XG4gICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0LnRvcDtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXQucmlnaHQ7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gdGFyZ2V0LmJvdHRvbSArIHRhcmdldC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2lkZ2V0LWxlZnQnOlxuICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldC50b3A7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldC5sZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0LnJpZ2h0ICsgdGFyZ2V0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBib3R0b20gPSB0YXJnZXQuYm90dG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2lkZ2V0LXJpZ2h0JzpcbiAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXQudG9wO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXQubGVmdCArIHRhcmdldC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXQucmlnaHQ7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gdGFyZ2V0LmJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dpZGdldC1ib3R0b20nOlxuICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldC50b3AgKyB0YXJnZXQuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXQucmlnaHQ7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gdGFyZ2V0LmJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dpZGdldC10YWInOlxuICAgICAgICAgICAgICAgIHZhciB0YWJIZWlnaHQgPSB0YXJnZXQudGFiQmFyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldC50b3A7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldC5sZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0LnJpZ2h0O1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHRhcmdldC5ib3R0b20gKyB0YXJnZXQuaGVpZ2h0IC0gdGFiSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3cgdGhlIG92ZXJsYXkgd2l0aCB0aGUgY29tcHV0ZWQgZ2VvbWV0cnkuXG4gICAgICAgIHRoaXMub3ZlcmxheS5zaG93KHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20gfSk7XG4gICAgICAgIC8vIEZpbmFsbHksIHJldHVybiB0aGUgY29tcHV0ZWQgZHJvcCB6b25lLlxuICAgICAgICByZXR1cm4gem9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0YWIgYmFyIGZvciB1c2UgYnkgdGhlIHBhbmVsLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuX2NyZWF0ZVRhYkJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0YWIgYmFyLlxuICAgICAgICB2YXIgdGFiQmFyID0gdGhpcy5fcmVuZGVyZXIuY3JlYXRlVGFiQmFyKCk7XG4gICAgICAgIC8vIFNldCB0aGUgZ2VuZXJhdGVkIHRhYiBiYXIgcHJvcGVydHkgZm9yIHRoZSB0YWIgYmFyLlxuICAgICAgICBQcml2YXRlJGUuaXNHZW5lcmF0ZWRUYWJCYXJQcm9wZXJ0eS5zZXQodGFiQmFyLCB0cnVlKTtcbiAgICAgICAgLy8gSGlkZSB0aGUgdGFiIGJhciB3aGVuIGluIHNpbmdsZSBkb2N1bWVudCBtb2RlLlxuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gJ3NpbmdsZS1kb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHRhYkJhci5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5mb3JjZSBuZWNlc3NhcnkgdGFiIGJhciBiZWhhdmlvci5cbiAgICAgICAgLy8gVE9ETyBkbyB3ZSByZWFsbHkgd2FudCB0byBlbmZvcmNlICphbGwqIG9mIHRoZXNlP1xuICAgICAgICB0YWJCYXIudGFic01vdmFibGUgPSB0aGlzLl90YWJzTW92YWJsZTtcbiAgICAgICAgdGFiQmFyLmFsbG93RGVzZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgdGFiQmFyLmFkZEJ1dHRvbkVuYWJsZWQgPSB0aGlzLl9hZGRCdXR0b25FbmFibGVkO1xuICAgICAgICB0YWJCYXIucmVtb3ZlQmVoYXZpb3IgPSAnc2VsZWN0LXByZXZpb3VzLXRhYic7XG4gICAgICAgIHRhYkJhci5pbnNlcnRCZWhhdmlvciA9ICdzZWxlY3QtdGFiLWlmLW5lZWRlZCc7XG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHNpZ25hbCBoYW5kbGVycyBmb3IgdGhlIHRhYiBiYXIuXG4gICAgICAgIHRhYkJhci50YWJNb3ZlZC5jb25uZWN0KHRoaXMuX29uVGFiTW92ZWQsIHRoaXMpO1xuICAgICAgICB0YWJCYXIuY3VycmVudENoYW5nZWQuY29ubmVjdCh0aGlzLl9vbkN1cnJlbnRDaGFuZ2VkLCB0aGlzKTtcbiAgICAgICAgdGFiQmFyLnRhYkNsb3NlUmVxdWVzdGVkLmNvbm5lY3QodGhpcy5fb25UYWJDbG9zZVJlcXVlc3RlZCwgdGhpcyk7XG4gICAgICAgIHRhYkJhci50YWJEZXRhY2hSZXF1ZXN0ZWQuY29ubmVjdCh0aGlzLl9vblRhYkRldGFjaFJlcXVlc3RlZCwgdGhpcyk7XG4gICAgICAgIHRhYkJhci50YWJBY3RpdmF0ZVJlcXVlc3RlZC5jb25uZWN0KHRoaXMuX29uVGFiQWN0aXZhdGVSZXF1ZXN0ZWQsIHRoaXMpO1xuICAgICAgICB0YWJCYXIuYWRkUmVxdWVzdGVkLmNvbm5lY3QodGhpcy5fb25UYWJBZGRSZXF1ZXN0ZWQsIHRoaXMpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGluaXRpYWxpemVkIHRhYiBiYXIuXG4gICAgICAgIHJldHVybiB0YWJCYXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaGFuZGxlIGZvciB1c2UgYnkgdGhlIHBhbmVsLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuX2NyZWF0ZUhhbmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUhhbmRsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGFiTW92ZWRgIHNpZ25hbCBmcm9tIGEgdGFiIGJhci5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLl9vblRhYk1vdmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSh0aGlzLCBQcml2YXRlJGUuTGF5b3V0TW9kaWZpZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgY3VycmVudENoYW5nZWRgIHNpZ25hbCBmcm9tIGEgdGFiIGJhci5cbiAgICAgKi9cbiAgICBEb2NrUGFuZWwucHJvdG90eXBlLl9vbkN1cnJlbnRDaGFuZ2VkID0gZnVuY3Rpb24gKHNlbmRlciwgYXJncykge1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCB0aXRsZSBmcm9tIHRoZSBhcmdzLlxuICAgICAgICB2YXIgcHJldmlvdXNUaXRsZSA9IGFyZ3MucHJldmlvdXNUaXRsZSwgY3VycmVudFRpdGxlID0gYXJncy5jdXJyZW50VGl0bGU7XG4gICAgICAgIC8vIEhpZGUgdGhlIHByZXZpb3VzIHdpZGdldC5cbiAgICAgICAgaWYgKHByZXZpb3VzVGl0bGUpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVGl0bGUub3duZXIuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3cgdGhlIGN1cnJlbnQgd2lkZ2V0LlxuICAgICAgICBpZiAoY3VycmVudFRpdGxlKSB7XG4gICAgICAgICAgICBjdXJyZW50VGl0bGUub3duZXIuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsdXNoIHRoZSBtZXNzYWdlIGxvb3Agb24gSUUgYW5kIEVkZ2UgdG8gcHJldmVudCBmbGlja2VyLlxuICAgICAgICBpZiAoUGxhdGZvcm0uSVNfRURHRSB8fCBQbGF0Zm9ybS5JU19JRSkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3AuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTY2hlZHVsZSBhbiBlbWl0IG9mIHRoZSBsYXlvdXQgbW9kaWZpZWQgc2lnbmFsLlxuICAgICAgICBNZXNzYWdlTG9vcC5wb3N0TWVzc2FnZSh0aGlzLCBQcml2YXRlJGUuTGF5b3V0TW9kaWZpZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgYWRkUmVxdWVzdGVkYCBzaWduYWwgZnJvbSBhIHRhYiBiYXIuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fb25UYWJBZGRSZXF1ZXN0ZWQgPSBmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIHRoaXMuX2FkZFJlcXVlc3RlZC5lbWl0KHNlbmRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGB0YWJBY3RpdmF0ZVJlcXVlc3RlZGAgc2lnbmFsIGZyb20gYSB0YWIgYmFyLlxuICAgICAqL1xuICAgIERvY2tQYW5lbC5wcm90b3R5cGUuX29uVGFiQWN0aXZhdGVSZXF1ZXN0ZWQgPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MudGl0bGUub3duZXIuYWN0aXZhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYHRhYkNsb3NlUmVxdWVzdGVkYCBzaWduYWwgZnJvbSBhIHRhYiBiYXIuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fb25UYWJDbG9zZVJlcXVlc3RlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcbiAgICAgICAgYXJncy50aXRsZS5vd25lci5jbG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGFiRGV0YWNoUmVxdWVzdGVkYCBzaWduYWwgZnJvbSBhIHRhYiBiYXIuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLnByb3RvdHlwZS5fb25UYWJEZXRhY2hSZXF1ZXN0ZWQgPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgYSBkcmFnIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIGlmICh0aGlzLl9kcmFnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsZWFzZSB0aGUgdGFiIGJhcidzIGhvbGQgb24gdGhlIG1vdXNlLlxuICAgICAgICBzZW5kZXIucmVsZWFzZU1vdXNlKCk7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIGRhdGEgZnJvbSB0aGUgYXJncy5cbiAgICAgICAgdmFyIHRpdGxlID0gYXJncy50aXRsZSwgdGFiID0gYXJncy50YWIsIGNsaWVudFggPSBhcmdzLmNsaWVudFgsIGNsaWVudFkgPSBhcmdzLmNsaWVudFk7XG4gICAgICAgIC8vIFNldHVwIHRoZSBtaW1lIGRhdGEgZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgICAgdmFyIG1pbWVEYXRhID0gbmV3IE1pbWVEYXRhKCk7XG4gICAgICAgIHZhciBmYWN0b3J5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGl0bGUub3duZXI7IH07XG4gICAgICAgIG1pbWVEYXRhLnNldERhdGEoJ2FwcGxpY2F0aW9uL3ZuZC5sdW1pbm8ud2lkZ2V0LWZhY3RvcnknLCBmYWN0b3J5KTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBkcmFnIGltYWdlIGZvciB0aGUgZHJhZyBvcGVyYXRpb24uXG4gICAgICAgIHZhciBkcmFnSW1hZ2UgPSB0YWIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGRyYWcgb2JqZWN0IHRvIG1hbmFnZSB0aGUgZHJhZy1kcm9wIG9wZXJhdGlvbi5cbiAgICAgICAgdGhpcy5fZHJhZyA9IG5ldyBEcmFnKHtcbiAgICAgICAgICAgIG1pbWVEYXRhOiBtaW1lRGF0YSwgZHJhZ0ltYWdlOiBkcmFnSW1hZ2UsXG4gICAgICAgICAgICBwcm9wb3NlZEFjdGlvbjogJ21vdmUnLFxuICAgICAgICAgICAgc3VwcG9ydGVkQWN0aW9uczogJ21vdmUnLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIaWRlIHRoZSB0YWIgbm9kZSBpbiB0aGUgb3JpZ2luYWwgdGFiLlxuICAgICAgICB0YWIuY2xhc3NMaXN0LmFkZCgnbG0tbW9kLWhpZGRlbicpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgdGFiLmNsYXNzTGlzdC5hZGQoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGNsZWFudXAgY2FsbGJhY2suXG4gICAgICAgIHZhciBjbGVhbnVwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9kcmFnID0gbnVsbDtcbiAgICAgICAgICAgIHRhYi5jbGFzc0xpc3QucmVtb3ZlKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHRhYi5jbGFzc0xpc3QucmVtb3ZlKCdwLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBkcmFnIG9wZXJhdGlvbiBhbmQgY2xlYW51cCB3aGVuIGRvbmUuXG4gICAgICAgIHRoaXMuX2RyYWcuc3RhcnQoY2xpZW50WCwgY2xpZW50WSkudGhlbihjbGVhbnVwKTtcbiAgICB9O1xuICAgIHJldHVybiBEb2NrUGFuZWw7XG59KFdpZGdldCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYERvY2tQYW5lbGAgY2xhc3Mgc3RhdGljcy5cbiAqL1xuKGZ1bmN0aW9uIChEb2NrUGFuZWwpIHtcbiAgICAvKipcbiAgICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGBJT3ZlcmxheWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG92ZXJsYXkgaW1wbGVtZW50YXRpb24gZm9yIGEgZG9jayBwYW5lbC5cbiAgICAgKi9cbiAgICB2YXIgT3ZlcmxheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyBvdmVybGF5LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gT3ZlcmxheSgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnbG0tRG9ja1BhbmVsLW92ZXJsYXknKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdwLURvY2tQYW5lbC1vdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgncC1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBvdmVybGF5IHVzaW5nIHRoZSBnaXZlbiBvdmVybGF5IGdlb21ldHJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZ2VvIC0gVGhlIGRlc2lyZWQgZ2VvbWV0cnkgZm9yIHRoZSBvdmVybGF5LlxuICAgICAgICAgKi9cbiAgICAgICAgT3ZlcmxheS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChnZW8pIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLm5vZGUuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS50b3AgPSBnZW8udG9wICsgXCJweFwiO1xuICAgICAgICAgICAgc3R5bGUubGVmdCA9IGdlby5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgc3R5bGUucmlnaHQgPSBnZW8ucmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICBzdHlsZS5ib3R0b20gPSBnZW8uYm90dG9tICsgXCJweFwiO1xuICAgICAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgaGlkZSB0aW1lci5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IC0xO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG92ZXJsYXkgaXMgYWxyZWFkeSB2aXNpYmxlLCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgaGlkZGVuIGZsYWcuXG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHNob3cgdGhlIG92ZXJsYXkuXG4gICAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnbG0tbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnJlbW92ZSgncC1tb2QtaGlkZGVuJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBvdmVybGF5IG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZWxheSAtIFRoZSBkZWxheSAoaW4gbXMpIGJlZm9yZSBoaWRpbmcgdGhlIG92ZXJsYXkuXG4gICAgICAgICAqICAgQSBkZWxheSB2YWx1ZSA8PSAwIHdpbGwgaGlkZSB0aGUgb3ZlcmxheSBpbW1lZGlhdGVseS5cbiAgICAgICAgICovXG4gICAgICAgIE92ZXJsYXkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBvdmVybGF5IGlzIGFscmVhZHkgaGlkZGVuLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2hpZGRlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhpZGUgaW1tZWRpYXRlbHkgaWYgdGhlIGRlbGF5IGlzIDw9IDAuXG4gICAgICAgICAgICBpZiAoZGVsYXkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgYSBoaWRlIGlzIGFscmVhZHkgcGVuZGluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLl90aW1lciAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2V0dXAgdGhlIGhpZGUgdGltZXIuXG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGltZXIgPSAtMTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2xtLW1vZC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ3AtbW9kLWhpZGRlbicpO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT3ZlcmxheTtcbiAgICB9KCkpO1xuICAgIERvY2tQYW5lbC5PdmVybGF5ID0gT3ZlcmxheTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgSVJlbmRlcmVyYC5cbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdGFiIGJhciBmb3IgdXNlIHdpdGggYSBkb2NrIHBhbmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyB0YWIgYmFyIGZvciBhIGRvY2sgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGFiQmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhciA9IG5ldyBUYWJCYXIoKTtcbiAgICAgICAgICAgIGJhci5hZGRDbGFzcygnbG0tRG9ja1BhbmVsLXRhYkJhcicpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBiYXIuYWRkQ2xhc3MoJ3AtRG9ja1BhbmVsLXRhYkJhcicpO1xuICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGJhcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBoYW5kbGUgbm9kZSBmb3IgdXNlIHdpdGggYSBkb2NrIHBhbmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIG5ldyBoYW5kbGUgbm9kZSBmb3IgYSBkb2NrIHBhbmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUhhbmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGhhbmRsZS5jbGFzc05hbWUgPSAnbG0tRG9ja1BhbmVsLWhhbmRsZSc7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIGhhbmRsZS5jbGFzc0xpc3QuYWRkKCdwLURvY2tQYW5lbC1oYW5kbGUnKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIERvY2tQYW5lbC5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGBSZW5kZXJlcmAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgRG9ja1BhbmVsLmRlZmF1bHRSZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xufSkoRG9ja1BhbmVsIHx8IChEb2NrUGFuZWwgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJGU7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBBIGZyYWN0aW9uIHVzZWQgZm9yIHNpemluZyByb290IHBhbmVsczsgfj0gYDEgLyBnb2xkZW5fcmF0aW9gLlxuICAgICAqL1xuICAgIFByaXZhdGUuR09MREVOX1JBVElPID0gMC42MTg7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2l6ZXMgZm9yIHRoZSBlZGdlIGRyb3Agem9uZXMsIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBQcml2YXRlLkRFRkFVTFRfRURHRVMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgdG9wIGVkZ2UgZG9jayB6b25lIGZvciB0aGUgcm9vdCBwYW5lbCwgaW4gcGl4ZWxzLlxuICAgICAgICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlcnMgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdG9wXG4gICAgICAgICAqIHRhYiBiYXIgYW5kIHRoZSB0b3Agcm9vdCB6b25lLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9wOiAxMixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBlZGdlIGRvY2sgem9uZSBmb3IgdGhlIHJvb3QgcGFuZWwsIGluIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIHJpZ2h0OiA0MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBlZGdlIGRvY2sgem9uZSBmb3IgdGhlIHJvb3QgcGFuZWwsIGluIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIGJvdHRvbTogNDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgZWRnZSBkb2NrIHpvbmUgZm9yIHRoZSByb290IHBhbmVsLCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBsZWZ0OiA0MFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaW5nbGV0b24gYCdsYXlvdXQtbW9kaWZpZWQnYCBjb25mbGF0YWJsZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIFByaXZhdGUuTGF5b3V0TW9kaWZpZWQgPSBuZXcgQ29uZmxhdGFibGVNZXNzYWdlKCdsYXlvdXQtbW9kaWZpZWQnKTtcbiAgICAvKipcbiAgICAgKiBBbiBhdHRhY2hlZCBwcm9wZXJ0eSB1c2VkIHRvIHRyYWNrIGdlbmVyYXRlZCB0YWIgYmFycy5cbiAgICAgKi9cbiAgICBQcml2YXRlLmlzR2VuZXJhdGVkVGFiQmFyUHJvcGVydHkgPSBuZXcgQXR0YWNoZWRQcm9wZXJ0eSh7XG4gICAgICAgIG5hbWU6ICdpc0dlbmVyYXRlZFRhYkJhcicsXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaW5nbGUgZG9jdW1lbnQgY29uZmlnIGZvciB0aGUgd2lkZ2V0cyBpbiBhIGRvY2sgcGFuZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2luZ2xlRG9jdW1lbnRDb25maWcocGFuZWwpIHtcbiAgICAgICAgLy8gUmV0dXJuIGFuIGVtcHR5IGNvbmZpZyBpZiB0aGUgcGFuZWwgaXMgZW1wdHkuXG4gICAgICAgIGlmIChwYW5lbC5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYWluOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGEgZmxhdCBhcnJheSBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgcGFuZWwuXG4gICAgICAgIHZhciB3aWRnZXRzID0gdG9BcnJheShwYW5lbC53aWRnZXRzKCkpO1xuICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IHNlbGVjdGVkIHdpZGdldCBpbiB0aGUgcGFuZWwuXG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHBhbmVsLnNlbGVjdGVkV2lkZ2V0cygpLm5leHQoKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY3VycmVudCBpbmRleCBmb3IgdGhlIG5ldyBjb25maWcuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBzZWxlY3RlZCA/IHdpZGdldHMuaW5kZXhPZihzZWxlY3RlZCkgOiAtMTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBzaW5nbGUgZG9jdW1lbnQgY29uZmlnLlxuICAgICAgICByZXR1cm4geyBtYWluOiB7IHR5cGU6ICd0YWItYXJlYScsIHdpZGdldHM6IHdpZGdldHMsIGN1cnJlbnRJbmRleDogY3VycmVudEluZGV4IH0gfTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVTaW5nbGVEb2N1bWVudENvbmZpZyA9IGNyZWF0ZVNpbmdsZURvY3VtZW50Q29uZmlnO1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGRyb3AgdGFyZ2V0IGF0IHRoZSBnaXZlbiBjbGllbnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZERyb3BUYXJnZXQocGFuZWwsIGNsaWVudFgsIGNsaWVudFksIGVkZ2VzKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIG1vdXNlIGlzIG5vdCBvdmVyIHRoZSBkb2NrIHBhbmVsLlxuICAgICAgICBpZiAoIUVsZW1lbnRFeHQuaGl0VGVzdChwYW5lbC5ub2RlLCBjbGllbnRYLCBjbGllbnRZKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgem9uZTogJ2ludmFsaWQnLCB0YXJnZXQ6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHRoZSBsYXlvdXQgZm9yIHRoZSBwYW5lbC5cbiAgICAgICAgdmFyIGxheW91dCA9IHBhbmVsLmxheW91dDtcbiAgICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBlbXB0eSwgaW5kaWNhdGUgdGhlIGVudGlyZSByb290IGRyb3Agem9uZS5cbiAgICAgICAgaWYgKGxheW91dC5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB6b25lOiAncm9vdC1hbGwnLCB0YXJnZXQ6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IHRoZSBlZGdlIHpvbmVzIHdoZW4gaW4gbXVsdGlwbGUgZG9jdW1lbnQgbW9kZS5cbiAgICAgICAgaWYgKHBhbmVsLm1vZGUgPT09ICdtdWx0aXBsZS1kb2N1bWVudCcpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY2xpZW50IHJlY3QgZm9yIHRoZSBkb2NrIHBhbmVsLlxuICAgICAgICAgICAgdmFyIHBhbmVsUmVjdCA9IHBhbmVsLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBkaXN0YW5jZSB0byBlYWNoIGVkZ2Ugb2YgdGhlIHBhbmVsLlxuICAgICAgICAgICAgdmFyIHBsID0gY2xpZW50WCAtIHBhbmVsUmVjdC5sZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBwdCA9IGNsaWVudFkgLSBwYW5lbFJlY3QudG9wICsgMTtcbiAgICAgICAgICAgIHZhciBwciA9IHBhbmVsUmVjdC5yaWdodCAtIGNsaWVudFg7XG4gICAgICAgICAgICB2YXIgcGIgPSBwYW5lbFJlY3QuYm90dG9tIC0gY2xpZW50WTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1pbmltdW0gZGlzdGFuY2UgdG8gYW4gZWRnZS5cbiAgICAgICAgICAgIHZhciBwZCA9IE1hdGgubWluKHB0LCBwciwgcGIsIHBsKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBhIHJvb3Qgem9uZSBpZiB0aGUgbW91c2UgaXMgd2l0aGluIGFuIGVkZ2UuXG4gICAgICAgICAgICBzd2l0Y2ggKHBkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBwdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB0IDwgZWRnZXMudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB6b25lOiAncm9vdC10b3AnLCB0YXJnZXQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHByOlxuICAgICAgICAgICAgICAgICAgICBpZiAocHIgPCBlZGdlcy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgem9uZTogJ3Jvb3QtcmlnaHQnLCB0YXJnZXQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHBiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGIgPCBlZGdlcy5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHpvbmU6ICdyb290LWJvdHRvbScsIHRhcmdldDogbnVsbCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgcGw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbCA8IGVkZ2VzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHpvbmU6ICdyb290LWxlZnQnLCB0YXJnZXQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhpdCB0ZXN0IHRoZSBkb2NrIGxheW91dCBhdCB0aGUgZ2l2ZW4gY2xpZW50IHBvc2l0aW9uLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gbGF5b3V0LmhpdFRlc3RUYWJBcmVhcyhjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgLy8gQmFpbCBpZiBubyB0YXJnZXQgYXJlYSB3YXMgZm91bmQuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4geyB6b25lOiAnaW52YWxpZCcsIHRhcmdldDogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgd2hvbGUgdGFiIGFyZWEgd2hlbiBpbiBzaW5nbGUgZG9jdW1lbnQgbW9kZS5cbiAgICAgICAgaWYgKHBhbmVsLm1vZGUgPT09ICdzaW5nbGUtZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB6b25lOiAnd2lkZ2V0LWFsbCcsIHRhcmdldDogdGFyZ2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8gZWFjaCBlZGdlIG9mIHRoZSB0YWIgYXJlYS5cbiAgICAgICAgdmFyIGFsID0gdGFyZ2V0LnggLSB0YXJnZXQubGVmdCArIDE7XG4gICAgICAgIHZhciBhdCA9IHRhcmdldC55IC0gdGFyZ2V0LnRvcCArIDE7XG4gICAgICAgIHZhciBhciA9IHRhcmdldC5sZWZ0ICsgdGFyZ2V0LndpZHRoIC0gdGFyZ2V0Lng7XG4gICAgICAgIHZhciBhYiA9IHRhcmdldC50b3AgKyB0YXJnZXQuaGVpZ2h0IC0gdGFyZ2V0Lnk7XG4gICAgICAgIHZhciB0YWJIZWlnaHQgPSB0YXJnZXQudGFiQmFyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICBpZiAoYXQgPCB0YWJIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHpvbmU6ICd3aWRnZXQtdGFiJywgdGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIFggYW5kIFkgZWRnZSBzaXplcyBmb3IgdGhlIGFyZWEuXG4gICAgICAgIHZhciByeCA9IE1hdGgucm91bmQodGFyZ2V0LndpZHRoIC8gMyk7XG4gICAgICAgIHZhciByeSA9IE1hdGgucm91bmQodGFyZ2V0LmhlaWdodCAvIDMpO1xuICAgICAgICAvLyBJZiB0aGUgbW91c2UgaXMgbm90IHdpdGhpbiBhbiBlZGdlLCBpbmRpY2F0ZSB0aGUgZW50aXJlIGFyZWEuXG4gICAgICAgIGlmIChhbCA+IHJ4ICYmIGFyID4gcnggJiYgYXQgPiByeSAmJiBhYiA+IHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB6b25lOiAnd2lkZ2V0LWFsbCcsIHRhcmdldDogdGFyZ2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2NhbGUgdGhlIGRpc3RhbmNlcyBieSB0aGUgc2xlbmRlcm5lc3MgcmF0aW8uXG4gICAgICAgIGFsIC89IHJ4O1xuICAgICAgICBhdCAvPSByeTtcbiAgICAgICAgYXIgLz0gcng7XG4gICAgICAgIGFiIC89IHJ5O1xuICAgICAgICAvLyBGaW5kIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHRvIHRoZSBhcmVhIGVkZ2UuXG4gICAgICAgIHZhciBhZCA9IE1hdGgubWluKGFsLCBhdCwgYXIsIGFiKTtcbiAgICAgICAgLy8gRmluZCB0aGUgd2lkZ2V0IHpvbmUgZm9yIHRoZSBhcmVhIGVkZ2UuXG4gICAgICAgIHZhciB6b25lO1xuICAgICAgICBzd2l0Y2ggKGFkKSB7XG4gICAgICAgICAgICBjYXNlIGFsOlxuICAgICAgICAgICAgICAgIHpvbmUgPSAnd2lkZ2V0LWxlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhdDpcbiAgICAgICAgICAgICAgICB6b25lID0gJ3dpZGdldC10b3AnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhcjpcbiAgICAgICAgICAgICAgICB6b25lID0gJ3dpZGdldC1yaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFiOlxuICAgICAgICAgICAgICAgIHpvbmUgPSAnd2lkZ2V0LWJvdHRvbSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBmaW5hbCBkcm9wIHRhcmdldC5cbiAgICAgICAgcmV0dXJuIHsgem9uZTogem9uZSwgdGFyZ2V0OiB0YXJnZXQgfTtcbiAgICB9XG4gICAgUHJpdmF0ZS5maW5kRHJvcFRhcmdldCA9IGZpbmREcm9wVGFyZ2V0O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZHJvcCByZWZlcmVuY2Ugd2lkZ2V0IGZvciBhIHRhYiBiYXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RHJvcFJlZih0YWJCYXIpIHtcbiAgICAgICAgaWYgKHRhYkJhci50aXRsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFiQmFyLmN1cnJlbnRUaXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhYkJhci5jdXJyZW50VGl0bGUub3duZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYkJhci50aXRsZXNbdGFiQmFyLnRpdGxlcy5sZW5ndGggLSAxXS5vd25lcjtcbiAgICB9XG4gICAgUHJpdmF0ZS5nZXREcm9wUmVmID0gZ2V0RHJvcFJlZjtcbn0pKFByaXZhdGUkZSB8fCAoUHJpdmF0ZSRlID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggdHJhY2tzIGZvY3VzIGFtb25nIGEgc2V0IG9mIHdpZGdldHMuXG4gKlxuICogVGhpcyBjbGFzcyBpcyB1c2VmdWwgd2hlbiBjb2RlIG5lZWRzIHRvIGtlZXAgdHJhY2sgb2YgdGhlIG1vc3RcbiAqIHJlY2VudGx5IGZvY3VzZWQgd2lkZ2V0KHMpIGFtb25nIGEgc2V0IG9mIHJlbGF0ZWQgd2lkZ2V0cy5cbiAqL1xudmFyIEZvY3VzVHJhY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgZm9jdXMgdHJhY2tlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGb2N1c1RyYWNrZXIoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl93aWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuX2FjdGl2ZVdpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRXaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1iZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlQ2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHRyYWNrZXIuXG4gICAgICovXG4gICAgRm9jdXNUcmFja2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB0cmFja2VyIGlzIGFscmVhZHkgZGlzcG9zZWQuXG4gICAgICAgIGlmICh0aGlzLl9jb3VudGVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhlIHRyYWNrZXIgYXMgZGlzcG9zZWQuXG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAtMTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbm5lY3Rpb25zIGZvciB0aGUgdHJhY2tlci5cbiAgICAgICAgU2lnbmFsLmNsZWFyRGF0YSh0aGlzKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgIGVhY2godGhpcy5fd2lkZ2V0cywgZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIF90aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgX3RoaXMsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgICAgdGhpcy5fYWN0aXZlV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFdpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX251bWJlcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fd2lkZ2V0cy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvY3VzVHJhY2tlci5wcm90b3R5cGUsIFwiY3VycmVudENoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBjdXJyZW50IHdpZGdldCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaGFuZ2VkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9jdXNUcmFja2VyLnByb3RvdHlwZSwgXCJhY3RpdmVDaGFuZ2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgYWN0aXZlIHdpZGdldCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNoYW5nZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2N1c1RyYWNrZXIucHJvdG90eXBlLCBcImlzRGlzcG9zZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgdHJhY2tlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50ZXIgPCAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9jdXNUcmFja2VyLnByb3RvdHlwZSwgXCJjdXJyZW50V2lkZ2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHdpZGdldCBpbiB0aGUgdHJhY2tlci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgY3VycmVudCB3aWRnZXQgaXMgdGhlIHdpZGdldCBhbW9uZyB0aGUgdHJhY2tlZCB3aWRnZXRzIHdoaWNoXG4gICAgICAgICAqIGhhcyB0aGUgKmRlc2NlbmRhbnQgbm9kZSogd2hpY2ggaGFzIG1vc3QgcmVjZW50bHkgYmVlbiBmb2N1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY3VycmVudCB3aWRnZXQgd2lsbCBub3QgYmUgdXBkYXRlZCBpZiB0aGUgbm9kZSBsb3NlcyBmb2N1cy4gSXRcbiAgICAgICAgICogd2lsbCBvbmx5IGJlIHVwZGF0ZWQgd2hlbiBhIGRpZmZlcmVudCB0cmFja2VkIHdpZGdldCBnYWlucyBmb2N1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgd2lkZ2V0IGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJhY2tlciwgdGhlIHByZXZpb3VzXG4gICAgICAgICAqIGN1cnJlbnQgd2lkZ2V0IHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgYmVoYXZpb3IgaXMgaW50ZW5kZWQgdG8gZm9sbG93IGEgdXNlcidzIGNvbmNlcHR1YWwgbW9kZWwgb2ZcbiAgICAgICAgICogYSBzZW1hbnRpY2FsbHkgXCJjdXJyZW50XCIgd2lkZ2V0LCB3aGVyZSB0aGUgXCJsYXN0IHRoaW5nIG9mIHR5cGUgWFwiXG4gICAgICAgICAqIHRvIGJlIGludGVyYWN0ZWQgd2l0aCBpcyB0aGUgXCJjdXJyZW50IGluc3RhbmNlIG9mIFhcIiwgcmVnYXJkbGVzc1xuICAgICAgICAgKiBvZiB3aGV0aGVyIHRoYXQgaW5zdGFuY2Ugc3RpbGwgaGFzIGZvY3VzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFdpZGdldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvY3VzVHJhY2tlci5wcm90b3R5cGUsIFwiYWN0aXZlV2lkZ2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3RpdmUgd2lkZ2V0IGluIHRoZSB0cmFja2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBhY3RpdmUgd2lkZ2V0IGlzIHRoZSB3aWRnZXQgYW1vbmcgdGhlIHRyYWNrZWQgd2lkZ2V0cyB3aGljaFxuICAgICAgICAgKiBoYXMgdGhlICpkZXNjZW5kYW50IG5vZGUqIHdoaWNoIGlzIGN1cnJlbnRseSBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlV2lkZ2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9jdXNUcmFja2VyLnByb3RvdHlwZSwgXCJ3aWRnZXRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVhZCBvbmx5IGFycmF5IG9mIHRoZSB3aWRnZXRzIGJlaW5nIHRyYWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWRnZXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZvY3VzIG51bWJlciBmb3IgYSBwYXJ0aWN1bGFyIHdpZGdldCBpbiB0aGUgdHJhY2tlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGZvY3VzIG51bWJlciBmb3IgdGhlIGdpdmVuIHdpZGdldCwgb3IgYC0xYCBpZiB0aGVcbiAgICAgKiAgIHdpZGdldCBoYXMgbm90IGhhZCBmb2N1cyBzaW5jZSBiZWluZyBhZGRlZCB0byB0aGUgdHJhY2tlciwgb3JcbiAgICAgKiAgIGlzIG5vdCBjb250YWluZWQgYnkgdGhlIHRyYWNrZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhlIGZvY3VzIG51bWJlciBpbmRpY2F0ZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGluIHdoaWNoIHRoZSB3aWRnZXRzXG4gICAgICogaGF2ZSBnYWluZWQgZm9jdXMuIEEgd2lkZ2V0IHdpdGggYSBsYXJnZXIgbnVtYmVyIGhhcyBnYWluZWQgZm9jdXNcbiAgICAgKiBtb3JlIHJlY2VudGx5IHRoYW4gYSB3aWRnZXQgd2l0aCBhIHNtYWxsZXIgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhlIGBjdXJyZW50V2lkZ2V0YCB3aWxsIGFsd2F5cyBoYXZlIHRoZSBsYXJnZXN0IGZvY3VzIG51bWJlci5cbiAgICAgKlxuICAgICAqIEFsbCB3aWRnZXRzIHN0YXJ0IHdpdGggYSBmb2N1cyBudW1iZXIgb2YgYC0xYCwgd2hpY2ggaW5kaWNhdGVzIHRoYXRcbiAgICAgKiB0aGUgd2lkZ2V0IGhhcyBub3QgYmVlbiBmb2N1c2VkIHNpbmNlIGJlaW5nIGFkZGVkIHRvIHRoZSB0cmFja2VyLlxuICAgICAqL1xuICAgIEZvY3VzVHJhY2tlci5wcm90b3R5cGUuZm9jdXNOdW1iZXIgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5fbnVtYmVycy5nZXQod2lkZ2V0KTtcbiAgICAgICAgcmV0dXJuIG4gPT09IHVuZGVmaW5lZCA/IC0xIDogbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGUgZm9jdXMgdHJhY2tlciBjb250YWlucyBhIGdpdmVuIHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB3aWRnZXQgaXMgdHJhY2tlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgRm9jdXNUcmFja2VyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJzLmhhcyh3aWRnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgd2lkZ2V0IHRvIHRoZSBmb2N1cyB0cmFja2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogQSB3aWRnZXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgdHJhY2tlciBpZiBpdFxuICAgICAqIGlzIGRpc3Bvc2VkIGFmdGVyIGJlaW5nIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHdpZGdldCBpcyBhbHJlYWR5IHRyYWNrZWQsIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBGb2N1c1RyYWNrZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgdHJhY2tlZC5cbiAgICAgICAgaWYgKHRoaXMuX251bWJlcnMuaGFzKHdpZGdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIHdpZGdldCBoYXMgZm9jdXMuXG4gICAgICAgIHZhciBmb2N1c2VkID0gd2lkZ2V0Lm5vZGUuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgaW5pdGlhbCBmb2N1cyBudW1iZXIuXG4gICAgICAgIHZhciBuID0gZm9jdXNlZCA/IHRoaXMuX2NvdW50ZXIrKyA6IC0xO1xuICAgICAgICAvLyBBZGQgdGhlIHdpZGdldCB0byB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAgICB0aGlzLl93aWRnZXRzLnB1c2god2lkZ2V0KTtcbiAgICAgICAgdGhpcy5fbnVtYmVycy5zZXQod2lkZ2V0LCBuKTtcbiAgICAgICAgdGhpcy5fbm9kZXMuc2V0KHdpZGdldC5ub2RlLCB3aWRnZXQpO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGV2ZW50IGxpc3RlbmVycy4gVGhlIGNhcHR1cmluZyBwaGFzZSBtdXN0IGJlIHVzZWRcbiAgICAgICAgLy8gc2luY2UgdGhlICdmb2N1cycgYW5kICdibHVyJyBldmVudHMgZG9uJ3QgYnViYmxlIGFuZCBGaXJlZm94XG4gICAgICAgIC8vIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgJ2ZvY3VzaW4nIG9yICdmb2N1c291dCcgZXZlbnRzLlxuICAgICAgICB3aWRnZXQubm9kZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMsIHRydWUpO1xuICAgICAgICB3aWRnZXQubm9kZS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIC8vIENvbm5lY3QgdGhlIGRpc3Bvc2VkIHNpZ25hbCBoYW5kbGVyLlxuICAgICAgICB3aWRnZXQuZGlzcG9zZWQuY29ubmVjdCh0aGlzLl9vbldpZGdldERpc3Bvc2VkLCB0aGlzKTtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IGFuZCBhY3RpdmUgd2lkZ2V0cyBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRXaWRnZXRzKHdpZGdldCwgd2lkZ2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgd2lkZ2V0IGZyb20gdGhlIGZvY3VzIHRyYWNrZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHdpZGdldCBpcyB0aGUgYGN1cnJlbnRXaWRnZXRgLCB0aGUgcHJldmlvdXMgY3VycmVudCB3aWRnZXRcbiAgICAgKiB3aWxsIGJlY29tZSB0aGUgbmV3IGBjdXJyZW50V2lkZ2V0YC5cbiAgICAgKlxuICAgICAqIEEgd2lkZ2V0IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHRyYWNrZXIgaWYgaXRcbiAgICAgKiBpcyBkaXNwb3NlZCBhZnRlciBiZWluZyBhZGRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB3aWRnZXQgaXMgbm90IHRyYWNrZWQsIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgKi9cbiAgICBGb2N1c1RyYWNrZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgd2lkZ2V0IGlzIG5vdCB0cmFja2VkLlxuICAgICAgICBpZiAoIXRoaXMuX251bWJlcnMuaGFzKHdpZGdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSBkaXNwb3NlZCBzaWduYWwgaGFuZGxlci5cbiAgICAgICAgd2lkZ2V0LmRpc3Bvc2VkLmRpc2Nvbm5lY3QodGhpcy5fb25XaWRnZXREaXNwb3NlZCwgdGhpcyk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICB3aWRnZXQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMsIHRydWUpO1xuICAgICAgICB3aWRnZXQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgICAgQXJyYXlFeHQucmVtb3ZlRmlyc3RPZih0aGlzLl93aWRnZXRzLCB3aWRnZXQpO1xuICAgICAgICB0aGlzLl9ub2Rlcy5kZWxldGUod2lkZ2V0Lm5vZGUpO1xuICAgICAgICB0aGlzLl9udW1iZXJzLmRlbGV0ZSh3aWRnZXQpO1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB3aWRnZXQgaXMgbm90IHRoZSBjdXJyZW50IHdpZGdldC5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRXaWRnZXQgIT09IHdpZGdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlciB0aGUgd2lkZ2V0cyBmb3IgdGhvc2Ugd2hpY2ggaGF2ZSBoYWQgZm9jdXMuXG4gICAgICAgIHZhciB2YWxpZCA9IGZpbHRlcih0aGlzLl93aWRnZXRzLCBmdW5jdGlvbiAodykgeyByZXR1cm4gX3RoaXMuX251bWJlcnMuZ2V0KHcpICE9PSAtMTsgfSk7XG4gICAgICAgIC8vIEdldCB0aGUgdmFsaWQgd2lkZ2V0IHdpdGggdGhlIG1heCBmb2N1cyBudW1iZXIuXG4gICAgICAgIHZhciBwcmV2aW91cyA9IG1heCh2YWxpZCwgZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBhID0gX3RoaXMuX251bWJlcnMuZ2V0KGZpcnN0KTtcbiAgICAgICAgICAgIHZhciBiID0gX3RoaXMuX251bWJlcnMuZ2V0KHNlY29uZCk7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH0pIHx8IG51bGw7XG4gICAgICAgIC8vIFNldCB0aGUgY3VycmVudCBhbmQgYWN0aXZlIHdpZGdldHMuXG4gICAgICAgIHRoaXMuX3NldFdpZGdldHMocHJldmlvdXMsIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgZm9jdXMgdHJhY2tlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBET00gZXZlbnQgc2VudCB0byB0aGUgcGFuZWwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgRE9NIGBFdmVudExpc3RlbmVyYCBpbnRlcmZhY2UgYW5kIGlzXG4gICAgICogY2FsbGVkIGluIHJlc3BvbnNlIHRvIGV2ZW50cyBvbiB0aGUgdHJhY2tlZCBub2Rlcy4gSXQgc2hvdWxkXG4gICAgICogbm90IGJlIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgRm9jdXNUcmFja2VyLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRGb2N1cyhldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRCbHVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IGFuZCBhY3RpdmUgd2lkZ2V0cyBmb3IgdGhlIHRyYWNrZXIuXG4gICAgICovXG4gICAgRm9jdXNUcmFja2VyLnByb3RvdHlwZS5fc2V0V2lkZ2V0cyA9IGZ1bmN0aW9uIChjdXJyZW50LCBhY3RpdmUpIHtcbiAgICAgICAgLy8gU3dhcCB0aGUgY3VycmVudCB3aWRnZXQuXG4gICAgICAgIHZhciBvbGRDdXJyZW50ID0gdGhpcy5fY3VycmVudFdpZGdldDtcbiAgICAgICAgdGhpcy5fY3VycmVudFdpZGdldCA9IGN1cnJlbnQ7XG4gICAgICAgIC8vIFN3YXAgdGhlIGFjdGl2ZSB3aWRnZXQuXG4gICAgICAgIHZhciBvbGRBY3RpdmUgPSB0aGlzLl9hY3RpdmVXaWRnZXQ7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVdpZGdldCA9IGFjdGl2ZTtcbiAgICAgICAgLy8gRW1pdCB0aGUgYGN1cnJlbnRDaGFuZ2VkYCBzaWduYWwgaWYgbmVlZGVkLlxuICAgICAgICBpZiAob2xkQ3VycmVudCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudENoYW5nZWQuZW1pdCh7IG9sZFZhbHVlOiBvbGRDdXJyZW50LCBuZXdWYWx1ZTogY3VycmVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IHRoZSBgYWN0aXZlQ2hhbmdlZGAgc2lnbmFsIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKG9sZEFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVDaGFuZ2VkLmVtaXQoeyBvbGRWYWx1ZTogb2xkQWN0aXZlLCBuZXdWYWx1ZTogYWN0aXZlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnZm9jdXMnYCBldmVudCBmb3IgYSB0cmFja2VkIHdpZGdldC5cbiAgICAgKi9cbiAgICBGb2N1c1RyYWNrZXIucHJvdG90eXBlLl9ldnRGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBGaW5kIHRoZSB3aWRnZXQgd2hpY2ggZ2FpbmVkIGZvY3VzLCB3aGljaCBpcyBrbm93biB0byBleGlzdC5cbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuX25vZGVzLmdldChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBmb2N1cyBudW1iZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAod2lkZ2V0ICE9PSB0aGlzLl9jdXJyZW50V2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJzLnNldCh3aWRnZXQsIHRoaXMuX2NvdW50ZXIrKyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IGFuZCBhY3RpdmUgd2lkZ2V0cy5cbiAgICAgICAgdGhpcy5fc2V0V2lkZ2V0cyh3aWRnZXQsIHdpZGdldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnYmx1cidgIGV2ZW50IGZvciBhIHRyYWNrZWQgd2lkZ2V0LlxuICAgICAqL1xuICAgIEZvY3VzVHJhY2tlci5wcm90b3R5cGUuX2V2dEJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgd2lkZ2V0IHdoaWNoIGxvc3QgZm9jdXMsIHdoaWNoIGlzIGtub3duIHRvIGV4aXN0LlxuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5fbm9kZXMuZ2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAvLyBHZXQgdGhlIG5vZGUgd2hpY2ggYmVpbmcgZm9jdXNlZCBhZnRlciB0aGlzIGJsdXIuXG4gICAgICAgIHZhciBmb2N1c1RhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIC8vIElmIG5vIG90aGVyIG5vZGUgaXMgYmVpbmcgZm9jdXNlZCwgY2xlYXIgdGhlIGFjdGl2ZSB3aWRnZXQuXG4gICAgICAgIGlmICghZm9jdXNUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFdpZGdldHModGhpcy5fY3VycmVudFdpZGdldCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgZm9jdXMgd2lkZ2V0IGlzIG5vdCBjaGFuZ2luZy5cbiAgICAgICAgaWYgKHdpZGdldC5ub2RlLmNvbnRhaW5zKGZvY3VzVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHRyYWNrZWQgd2lkZ2V0IGlzIGJlaW5nIGZvY3VzZWQsIGNsZWFyIHRoZSBhY3RpdmUgd2lkZ2V0LlxuICAgICAgICBpZiAoIWZpbmQodGhpcy5fd2lkZ2V0cywgZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcubm9kZS5jb250YWlucyhmb2N1c1RhcmdldCk7IH0pKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRXaWRnZXRzKHRoaXMuX2N1cnJlbnRXaWRnZXQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGBkaXNwb3NlZGAgc2lnbmFsIGZvciBhIHRyYWNrZWQgd2lkZ2V0LlxuICAgICAqL1xuICAgIEZvY3VzVHJhY2tlci5wcm90b3R5cGUuX29uV2lkZ2V0RGlzcG9zZWQgPSBmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHNlbmRlcik7XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNUcmFja2VyO1xufSgpKTtcblxuLyoqXG4gKiBBIGxheW91dCB3aGljaCBhcnJhbmdlcyBpdHMgd2lkZ2V0cyBpbiBhIGdyaWQuXG4gKi9cbnZhciBHcmlkTGF5b3V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmlkTGF5b3V0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBncmlkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyaWRMYXlvdXQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3Jvd1NwYWNpbmcgPSA0O1xuICAgICAgICBfdGhpcy5fY29sdW1uU3BhY2luZyA9IDQ7XG4gICAgICAgIF90aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICBfdGhpcy5fcm93U3RhcnRzID0gW107XG4gICAgICAgIF90aGlzLl9jb2x1bW5TdGFydHMgPSBbXTtcbiAgICAgICAgX3RoaXMuX3Jvd1NpemVycyA9IFtuZXcgQm94U2l6ZXIoKV07XG4gICAgICAgIF90aGlzLl9jb2x1bW5TaXplcnMgPSBbbmV3IEJveFNpemVyKCldO1xuICAgICAgICBfdGhpcy5fYm94ID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMucm93Q291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZSRmLnJlYWxsb2NTaXplcnMoX3RoaXMuX3Jvd1NpemVycywgb3B0aW9ucy5yb3dDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1uQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUHJpdmF0ZSRmLnJlYWxsb2NTaXplcnMoX3RoaXMuX2NvbHVtblNpemVycywgb3B0aW9ucy5jb2x1bW5Db3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucm93U3BhY2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fcm93U3BhY2luZyA9IFByaXZhdGUkZi5jbGFtcFZhbHVlKG9wdGlvbnMucm93U3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1uU3BhY2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fY29sdW1uU3BhY2luZyA9IFByaXZhdGUkZi5jbGFtcFZhbHVlKG9wdGlvbnMuY29sdW1uU3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgdGhlIHdpZGdldHMgYW5kIGxheW91dCBpdGVtcy5cbiAgICAgICAgZWFjaCh0aGlzLl9pdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciB3aWRnZXQgPSBpdGVtLndpZGdldDtcbiAgICAgICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgd2lkZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBsYXlvdXQgc3RhdGUuXG4gICAgICAgIHRoaXMuX2JveCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3Jvd1N0YXJ0cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9yb3dTaXplcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fY29sdW1uU3RhcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2NvbHVtblNpemVycy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSByZXN0IG9mIHRoZSBsYXlvdXQuXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyaWRMYXlvdXQucHJvdG90eXBlLCBcInJvd0NvdW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd1NpemVycy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIG1pbmltdW0gcm93IGNvdW50IGlzIGAxYC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSByb3cgY291bnQgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLnJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhbGxvY2F0ZSB0aGUgcm93IHNpemVycy5cbiAgICAgICAgICAgIFByaXZhdGUkZi5yZWFsbG9jU2l6ZXJzKHRoaXMuX3Jvd1NpemVycywgdmFsdWUpO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmaXQgb2YgdGhlIHBhcmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR3JpZExheW91dC5wcm90b3R5cGUsIFwiY29sdW1uQ291bnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uU2l6ZXJzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgbWluaW11bSBjb2x1bW4gY291bnQgaXMgYDFgLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIGNvbHVtbiBjb3VudCBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuY29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFsbG9jYXRlIHRoZSBjb2x1bW4gc2l6ZXJzLlxuICAgICAgICAgICAgUHJpdmF0ZSRmLnJlYWxsb2NTaXplcnModGhpcy5fY29sdW1uU2l6ZXJzLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZpdCBvZiB0aGUgcGFyZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmlkTGF5b3V0LnByb3RvdHlwZSwgXCJyb3dTcGFjaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcm93IHNwYWNpbmcgZm9yIHRoZSBsYXlvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3dTcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSByb3cgc3BhY2luZyBmb3IgdGhlIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBDbGFtcCB0aGUgc3BhY2luZyB0byB0aGUgYWxsb3dlZCByYW5nZS5cbiAgICAgICAgICAgIHZhbHVlID0gUHJpdmF0ZSRmLmNsYW1wVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgLy8gQmFpbCBpZiB0aGUgc3BhY2luZyBkb2VzIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dTcGFjaW5nID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgc3BhY2luZy5cbiAgICAgICAgICAgIHRoaXMuX3Jvd1NwYWNpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZml0IG9mIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyaWRMYXlvdXQucHJvdG90eXBlLCBcImNvbHVtblNwYWNpbmdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb2x1bW4gc3BhY2luZyBmb3IgdGhlIGxheW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtblNwYWNpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNvbCBzcGFjaW5nIGZvciB0aGUgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSBzcGFjaW5nIHRvIHRoZSBhbGxvd2VkIHJhbmdlLlxuICAgICAgICAgICAgdmFsdWUgPSBQcml2YXRlJGYuY2xhbXBWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSBzcGFjaW5nIGRvZXMgbm90IGNoYW5nZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbHVtblNwYWNpbmcgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBzcGFjaW5nLlxuICAgICAgICAgICAgdGhpcy5fY29sdW1uU3BhY2luZyA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmaXQgb2YgdGhlIHBhcmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0cmV0Y2ggZmFjdG9yIGZvciBhIHNwZWNpZmljIHJvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSByb3cgaW5kZXggb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyZXRjaCBmYWN0b3IgZm9yIHRoZSByb3cuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyByZXR1cm5zIGAtMWAgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5yb3dTdHJldGNoID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzaXplciA9IHRoaXMuX3Jvd1NpemVyc1tpbmRleF07XG4gICAgICAgIHJldHVybiBzaXplciA/IHNpemVyLnN0cmV0Y2ggOiAtMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3RyZXRjaCBmYWN0b3IgZm9yIGEgc3BlY2lmaWMgcm93LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIHJvdyBpbmRleCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJldGNoIGZhY3RvciBmb3IgdGhlIHJvdy5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5zZXRSb3dTdHJldGNoID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAvLyBMb29rIHVwIHRoZSByb3cgc2l6ZXIuXG4gICAgICAgIHZhciBzaXplciA9IHRoaXMuX3Jvd1NpemVyc1tpbmRleF07XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKCFzaXplcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsYW1wIHRoZSB2YWx1ZSB0byB0aGUgYWxsb3dlZCByYW5nZS5cbiAgICAgICAgdmFsdWUgPSBQcml2YXRlJGYuY2xhbXBWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIHN0cmV0Y2ggZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICBpZiAoc2l6ZXIuc3RyZXRjaCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNpemVyIHN0cmV0Y2guXG4gICAgICAgIHNpemVyLnN0cmV0Y2ggPSB2YWx1ZTtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBwYXJlbnQuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RyZXRjaCBmYWN0b3IgZm9yIGEgc3BlY2lmaWMgY29sdW1uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJldGNoIGZhY3RvciBmb3IgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIHJldHVybnMgYC0xYCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLmNvbHVtblN0cmV0Y2ggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNpemVyID0gdGhpcy5fY29sdW1uU2l6ZXJzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHNpemVyID8gc2l6ZXIuc3RyZXRjaCA6IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHJldGNoIGZhY3RvciBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmV0Y2ggZmFjdG9yIGZvciB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLnNldENvbHVtblN0cmV0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIGNvbHVtbiBzaXplci5cbiAgICAgICAgdmFyIHNpemVyID0gdGhpcy5fY29sdW1uU2l6ZXJzW2luZGV4XTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICAgICBpZiAoIXNpemVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xhbXAgdGhlIHZhbHVlIHRvIHRoZSBhbGxvd2VkIHJhbmdlLlxuICAgICAgICB2YWx1ZSA9IFByaXZhdGUkZi5jbGFtcFZhbHVlKHZhbHVlKTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgc3RyZXRjaCBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgIGlmIChzaXplci5zdHJldGNoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2l6ZXIgc3RyZXRjaC5cbiAgICAgICAgc2l6ZXIuc3RyZXRjaCA9IHZhbHVlO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIHBhcmVudC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIHdpZGdldHMgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGl0ZXJhdG9yIG92ZXIgdGhlIHdpZGdldHMgaW4gdGhlIGxheW91dC5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWFwKHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS53aWRnZXQ7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgd2lkZ2V0IHRvIHRoZSBncmlkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGFkZCB0byB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSB3aWRnZXQgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIGxheW91dCwgdGhpcyBpcyBuby1vcC5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5hZGRXaWRnZXQgPSBmdW5jdGlvbiAod2lkZ2V0KSB7XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIGluZGV4IGZvciB0aGUgd2lkZ2V0LlxuICAgICAgICB2YXIgaSA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoaXQpIHsgcmV0dXJuIGl0LndpZGdldCA9PT0gd2lkZ2V0OyB9KTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgaW4gdGhlIGxheW91dC5cbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB3aWRnZXQgdG8gdGhlIGxheW91dC5cbiAgICAgICAgdGhpcy5faXRlbXMucHVzaChuZXcgTGF5b3V0SXRlbSh3aWRnZXQpKTtcbiAgICAgICAgLy8gQXR0YWNoIHRoZSB3aWRnZXQgdG8gdGhlIHBhcmVudC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFdpZGdldCh3aWRnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB3aWRnZXQgZnJvbSB0aGUgZ3JpZCBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIEEgd2lkZ2V0IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSBsYXlvdXQgd2hlbiBpdHMgYHBhcmVudGBcbiAgICAgKiBpcyBzZXQgdG8gYG51bGxgLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBpbnZva2VkIGRpcmVjdGx5IHdoZW5cbiAgICAgKiByZW1vdmluZyBhIHdpZGdldCBmcm9tIGEgbGF5b3V0IHdoaWNoIGhhcyB5ZXQgdG8gYmUgaW5zdGFsbGVkIG9uIGFcbiAgICAgKiBwYXJlbnQgd2lkZ2V0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyAqbm90KiBtb2RpZnkgdGhlIHdpZGdldCdzIGBwYXJlbnRgLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLnJlbW92ZVdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgaW5kZXggZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIHZhciBpID0gQXJyYXlFeHQuZmluZEZpcnN0SW5kZXgodGhpcy5faXRlbXMsIGZ1bmN0aW9uIChpdCkgeyByZXR1cm4gaXQud2lkZ2V0ID09PSB3aWRnZXQ7IH0pO1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSB3aWRnZXQgaXMgbm90IGluIHRoZSBsYXlvdXQuXG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gdGhlIGxheW91dC5cbiAgICAgICAgdmFyIGl0ZW0gPSBBcnJheUV4dC5yZW1vdmVBdCh0aGlzLl9pdGVtcywgaSk7XG4gICAgICAgIC8vIERldGFjaCB0aGUgd2lkZ2V0IGZyb20gdGhlIHBhcmVudC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaFdpZGdldCh3aWRnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2UgdGhlIGxheW91dCBpdGVtLlxuICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gbGF5b3V0IGluaXRpYWxpemF0aW9uIHdoaWNoIHJlcXVpcmVzIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uICh3aWRnZXQpIHsgX3RoaXMuYXR0YWNoV2lkZ2V0KHdpZGdldCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgd2lkZ2V0IHRvIHRoZSBwYXJlbnQncyBET00gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGF0dGFjaCB0byB0aGUgcGFyZW50LlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLmF0dGFjaFdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVBdHRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgd2lkZ2V0J3Mgbm9kZSB0byB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHdpZGdldC5ub2RlKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckF0dGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9zdCBhIGZpdCByZXF1ZXN0IGZvciB0aGUgcGFyZW50IHdpZGdldC5cbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYSB3aWRnZXQgZnJvbSB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBkZXRhY2ggZnJvbSB0aGUgcGFyZW50LlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLmRldGFjaFdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyRGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1zaG93J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZVNob3cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25CZWZvcmVTaG93LmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaC5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtc2hvd24nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRTaG93biA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1oaWRkZW4nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRIaWRkZW4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAncmVzaXplJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKG1zZy53aWR0aCwgbXNnLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCd1cGRhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgR3JpZExheW91dC5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoLTEsIC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnZml0LXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLm9uRml0UmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXQgdGhlIGxheW91dCB0byB0aGUgdG90YWwgc2l6ZSByZXF1aXJlZCBieSB0aGUgd2lkZ2V0cy5cbiAgICAgKi9cbiAgICBHcmlkTGF5b3V0LnByb3RvdHlwZS5fZml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgbWluIHNpemVzIG9mIHRoZSBzaXplcnMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5yb3dDb3VudDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fcm93U2l6ZXJzW2ldLm1pblNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5jb2x1bW5Db3VudDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uU2l6ZXJzW2ldLm1pblNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlciBmb3IgdGhlIHZpc2libGUgbGF5b3V0IGl0ZW1zLlxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0KSB7IHJldHVybiAhaXQuaXNIaWRkZW47IH0pO1xuICAgICAgICAvLyBGaXQgdGhlIGxheW91dCBpdGVtcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGl0ZW1zW2ldLmZpdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgbWF4IHJvdyBhbmQgY29sdW1uIGluZGV4LlxuICAgICAgICB2YXIgbWF4Um93ID0gdGhpcy5yb3dDb3VudCAtIDE7XG4gICAgICAgIHZhciBtYXhDb2wgPSB0aGlzLmNvbHVtbkNvdW50IC0gMTtcbiAgICAgICAgLy8gU29ydCB0aGUgaXRlbXMgYnkgcm93IHNwYW4uXG4gICAgICAgIGl0ZW1zLnNvcnQoUHJpdmF0ZSRmLnJvd1NwYW5DbXApO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG1pbiBzaXplcyBvZiB0aGUgcm93IHNpemVycy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBpdGVtLlxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm93IGJvdW5kcyBmb3IgdGhlIGl0ZW0uXG4gICAgICAgICAgICB2YXIgY29uZmlnID0gR3JpZExheW91dC5nZXRDZWxsQ29uZmlnKGl0ZW0ud2lkZ2V0KTtcbiAgICAgICAgICAgIHZhciByMSA9IE1hdGgubWluKGNvbmZpZy5yb3csIG1heFJvdyk7XG4gICAgICAgICAgICB2YXIgcjIgPSBNYXRoLm1pbihjb25maWcucm93ICsgY29uZmlnLnJvd1NwYW4gLSAxLCBtYXhSb3cpO1xuICAgICAgICAgICAgLy8gRGlzdHJpYnV0ZSB0aGUgbWluaW11bSBoZWlnaHQgdG8gdGhlIHNpemVycyBhcyBuZWVkZWQuXG4gICAgICAgICAgICBQcml2YXRlJGYuZGlzdHJpYnV0ZU1pbih0aGlzLl9yb3dTaXplcnMsIHIxLCByMiwgaXRlbS5taW5IZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgdGhlIGl0ZW1zIGJ5IGNvbHVtbiBzcGFuLlxuICAgICAgICBpdGVtcy5zb3J0KFByaXZhdGUkZi5jb2x1bW5TcGFuQ21wKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtaW4gc2l6ZXMgb2YgdGhlIGNvbHVtbiBzaXplcnMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaXRlbS5cbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbHVtbiBib3VuZHMgZm9yIHRoZSBpdGVtLlxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEdyaWRMYXlvdXQuZ2V0Q2VsbENvbmZpZyhpdGVtLndpZGdldCk7XG4gICAgICAgICAgICB2YXIgYzEgPSBNYXRoLm1pbihjb25maWcuY29sdW1uLCBtYXhDb2wpO1xuICAgICAgICAgICAgdmFyIGMyID0gTWF0aC5taW4oY29uZmlnLmNvbHVtbiArIGNvbmZpZy5jb2x1bW5TcGFuIC0gMSwgbWF4Q29sKTtcbiAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgdGhlIG1pbmltdW0gd2lkdGggdG8gdGhlIHNpemVycyBhcyBuZWVkZWQuXG4gICAgICAgICAgICBQcml2YXRlJGYuZGlzdHJpYnV0ZU1pbih0aGlzLl9jb2x1bW5TaXplcnMsIGMxLCBjMiwgaXRlbS5taW5XaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gc2l6ZSBjb25zdHJhaW50IGlzIG5lZWRlZCwganVzdCB1cGRhdGUgdGhlIHBhcmVudC5cbiAgICAgICAgaWYgKHRoaXMuZml0UG9saWN5ID09PSAnc2V0LW5vLWNvbnN0cmFpbnQnKSB7XG4gICAgICAgICAgICBNZXNzYWdlTG9vcC5zZW5kTWVzc2FnZSh0aGlzLnBhcmVudCwgV2lkZ2V0Lk1zZy5VcGRhdGVSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdXAgdGhlIGNvbXB1dGVkIG1pbiBzaXplLlxuICAgICAgICB2YXIgbWluSCA9IG1heFJvdyAqIHRoaXMuX3Jvd1NwYWNpbmc7XG4gICAgICAgIHZhciBtaW5XID0gbWF4Q29sICogdGhpcy5fY29sdW1uU3BhY2luZztcbiAgICAgICAgLy8gQWRkIHRoZSBzaXplciBtaW5pbXVtcyB0byB0aGUgY29tcHV0ZWQgbWluIHNpemUuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5yb3dDb3VudDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgbWluSCArPSB0aGlzLl9yb3dTaXplcnNbaV0ubWluU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuY29sdW1uQ291bnQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIG1pblcgKz0gdGhpcy5fY29sdW1uU2l6ZXJzW2ldLm1pblNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBib3ggc2l6aW5nIGFuZCBhZGQgaXQgdG8gdGhlIGNvbXB1dGVkIG1pbiBzaXplLlxuICAgICAgICB2YXIgYm94ID0gdGhpcy5fYm94ID0gRWxlbWVudEV4dC5ib3hTaXppbmcodGhpcy5wYXJlbnQubm9kZSk7XG4gICAgICAgIG1pblcgKz0gYm94Lmhvcml6b250YWxTdW07XG4gICAgICAgIG1pbkggKz0gYm94LnZlcnRpY2FsU3VtO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHBhcmVudCdzIG1pbiBzaXplIGNvbnN0cmFpbnRzLlxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnBhcmVudC5ub2RlLnN0eWxlO1xuICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pblcgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLm1pbkhlaWdodCA9IG1pbkggKyBcInB4XCI7XG4gICAgICAgIC8vIFNldCB0aGUgZGlydHkgZmxhZyB0byBlbnN1cmUgb25seSBhIHNpbmdsZSB1cGRhdGUgb2NjdXJzLlxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIC8vIE5vdGlmeSB0aGUgYW5jZXN0b3IgdGhhdCBpdCBzaG91bGQgZml0IGltbWVkaWF0ZWx5LiBUaGlzIG1heVxuICAgICAgICAvLyBjYXVzZSBhIHJlc2l6ZSBvZiB0aGUgcGFyZW50LCBmdWxmaWxsaW5nIHRoZSByZXF1aXJlZCB1cGRhdGUuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHRoaXMucGFyZW50LnBhcmVudCwgV2lkZ2V0Lk1zZy5GaXRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZGlydHkgZmxhZyBpcyBzdGlsbCBzZXQsIHRoZSBwYXJlbnQgd2FzIG5vdCByZXNpemVkLlxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSByZXF1aXJlZCB1cGRhdGUgb24gdGhlIHBhcmVudCB3aWRnZXQgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5wYXJlbnQsIFdpZGdldC5Nc2cuVXBkYXRlUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgbGF5b3V0IHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSB3aWRnZXRzLlxuICAgICAqXG4gICAgICogVGhlIHBhcmVudCBvZmZzZXQgZGltZW5zaW9ucyBzaG91bGQgYmUgYC0xYCBpZiB1bmtub3duLlxuICAgICAqL1xuICAgIEdyaWRMYXlvdXQucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAob2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCkge1xuICAgICAgICAvLyBDbGVhciB0aGUgZGlydHkgZmxhZyB0byBpbmRpY2F0ZSB0aGUgdXBkYXRlIG9jY3VycmVkLlxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvLyBNZWFzdXJlIHRoZSBwYXJlbnQgaWYgdGhlIG9mZnNldCBkaW1lbnNpb25zIGFyZSB1bmtub3duLlxuICAgICAgICBpZiAob2Zmc2V0V2lkdGggPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXRXaWR0aCA9IHRoaXMucGFyZW50Lm5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IHRoaXMucGFyZW50Lm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcGFyZW50IGJveCBzaXppbmcgZGF0YSBpcyBjb21wdXRlZC5cbiAgICAgICAgaWYgKCF0aGlzLl9ib3gpIHtcbiAgICAgICAgICAgIHRoaXMuX2JveCA9IEVsZW1lbnRFeHQuYm94U2l6aW5nKHRoaXMucGFyZW50Lm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGxheW91dCBhcmVhIGFkanVzdGVkIGZvciBib3JkZXIgYW5kIHBhZGRpbmcuXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLl9ib3gucGFkZGluZ1RvcDtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLl9ib3gucGFkZGluZ0xlZnQ7XG4gICAgICAgIHZhciB3aWR0aCA9IG9mZnNldFdpZHRoIC0gdGhpcy5fYm94Lmhvcml6b250YWxTdW07XG4gICAgICAgIHZhciBoZWlnaHQgPSBvZmZzZXRIZWlnaHQgLSB0aGlzLl9ib3gudmVydGljYWxTdW07XG4gICAgICAgIC8vIEdldCB0aGUgbWF4IHJvdyBhbmQgY29sdW1uIGluZGV4LlxuICAgICAgICB2YXIgbWF4Um93ID0gdGhpcy5yb3dDb3VudCAtIDE7XG4gICAgICAgIHZhciBtYXhDb2wgPSB0aGlzLmNvbHVtbkNvdW50IC0gMTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdG90YWwgZml4ZWQgcm93IGFuZCBjb2x1bW4gc3BhY2UuXG4gICAgICAgIHZhciBmaXhlZFJvd1NwYWNlID0gbWF4Um93ICogdGhpcy5fcm93U3BhY2luZztcbiAgICAgICAgdmFyIGZpeGVkQ29sU3BhY2UgPSBtYXhDb2wgKiB0aGlzLl9jb2x1bW5TcGFjaW5nO1xuICAgICAgICAvLyBEaXN0cmlidXRlIHRoZSBhdmFpbGFibGUgc3BhY2UgdG8gdGhlIGJveCBzaXplcnMuXG4gICAgICAgIEJveEVuZ2luZS5jYWxjKHRoaXMuX3Jvd1NpemVycywgTWF0aC5tYXgoMCwgaGVpZ2h0IC0gZml4ZWRSb3dTcGFjZSkpO1xuICAgICAgICBCb3hFbmdpbmUuY2FsYyh0aGlzLl9jb2x1bW5TaXplcnMsIE1hdGgubWF4KDAsIHdpZHRoIC0gZml4ZWRDb2xTcGFjZSkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJvdyBzdGFydCBwb3NpdGlvbnMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwb3MgPSB0b3AsIG4gPSB0aGlzLnJvd0NvdW50OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dTdGFydHNbaV0gPSBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gdGhpcy5fcm93U2l6ZXJzW2ldLnNpemUgKyB0aGlzLl9yb3dTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29sdW1uIHN0YXJ0IHBvc2l0aW9ucy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IGxlZnQsIG4gPSB0aGlzLmNvbHVtbkNvdW50OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5TdGFydHNbaV0gPSBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gdGhpcy5fY29sdW1uU2l6ZXJzW2ldLnNpemUgKyB0aGlzLl9jb2x1bW5TcGFjaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgb2YgdGhlIGxheW91dCBpdGVtcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBpdGVtLlxuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtc1tpXTtcbiAgICAgICAgICAgIC8vIElnbm9yZSBoaWRkZW4gaXRlbXMuXG4gICAgICAgICAgICBpZiAoaXRlbS5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGNlbGwgYm91bmRzIGZvciB0aGUgd2lkZ2V0LlxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEdyaWRMYXlvdXQuZ2V0Q2VsbENvbmZpZyhpdGVtLndpZGdldCk7XG4gICAgICAgICAgICB2YXIgcjEgPSBNYXRoLm1pbihjb25maWcucm93LCBtYXhSb3cpO1xuICAgICAgICAgICAgdmFyIGMxID0gTWF0aC5taW4oY29uZmlnLmNvbHVtbiwgbWF4Q29sKTtcbiAgICAgICAgICAgIHZhciByMiA9IE1hdGgubWluKGNvbmZpZy5yb3cgKyBjb25maWcucm93U3BhbiAtIDEsIG1heFJvdyk7XG4gICAgICAgICAgICB2YXIgYzIgPSBNYXRoLm1pbihjb25maWcuY29sdW1uICsgY29uZmlnLmNvbHVtblNwYW4gLSAxLCBtYXhDb2wpO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY2VsbCBnZW9tZXRyeS5cbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fY29sdW1uU3RhcnRzW2MxXTtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5fcm93U3RhcnRzW3IxXTtcbiAgICAgICAgICAgIHZhciB3ID0gdGhpcy5fY29sdW1uU3RhcnRzW2MyXSArIHRoaXMuX2NvbHVtblNpemVyc1tjMl0uc2l6ZSAtIHg7XG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuX3Jvd1N0YXJ0c1tyMl0gKyB0aGlzLl9yb3dTaXplcnNbcjJdLnNpemUgLSB5O1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBvZiB0aGUgbGF5b3V0IGl0ZW0uXG4gICAgICAgICAgICBpdGVtLnVwZGF0ZSh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyaWRMYXlvdXQ7XG59KExheW91dCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYEdyaWRMYXlvdXRgIGNsYXNzIHN0YXRpY3MuXG4gKi9cbihmdW5jdGlvbiAoR3JpZExheW91dCkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2VsbCBjb25maWcgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjZWxsIGNvbmZpZyBmb3IgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDZWxsQ29uZmlnKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZSRmLmNlbGxDb25maWdQcm9wZXJ0eS5nZXQod2lkZ2V0KTtcbiAgICB9XG4gICAgR3JpZExheW91dC5nZXRDZWxsQ29uZmlnID0gZ2V0Q2VsbENvbmZpZztcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNlbGwgY29uZmlnIGZvciB0aGUgZ2l2ZW4gd2lkZ2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgZm9yIHRoZSBjZWxsIGNvbmZpZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDZWxsQ29uZmlnKHdpZGdldCwgdmFsdWUpIHtcbiAgICAgICAgUHJpdmF0ZSRmLmNlbGxDb25maWdQcm9wZXJ0eS5zZXQod2lkZ2V0LCBQcml2YXRlJGYubm9ybWFsaXplQ29uZmlnKHZhbHVlKSk7XG4gICAgfVxuICAgIEdyaWRMYXlvdXQuc2V0Q2VsbENvbmZpZyA9IHNldENlbGxDb25maWc7XG59KShHcmlkTGF5b3V0IHx8IChHcmlkTGF5b3V0ID0ge30pKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSRmO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSB3aWRnZXQgY2VsbCBjb25maWcuXG4gICAgICovXG4gICAgUHJpdmF0ZS5jZWxsQ29uZmlnUHJvcGVydHkgPSBuZXcgQXR0YWNoZWRQcm9wZXJ0eSh7XG4gICAgICAgIG5hbWU6ICdjZWxsQ29uZmlnJyxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoeyByb3c6IDAsIGNvbHVtbjogMCwgcm93U3BhbjogMSwgY29sdW1uU3BhbjogMSB9KTsgfSxcbiAgICAgICAgY2hhbmdlZDogb25DaGlsZENlbGxDb25maWdDaGFuZ2VkXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgcGFydGlhbCBjZWxsIGNvbmZpZyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgcm93ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihjb25maWcucm93IHx8IDApKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoY29uZmlnLmNvbHVtbiB8fCAwKSk7XG4gICAgICAgIHZhciByb3dTcGFuID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihjb25maWcucm93U3BhbiB8fCAwKSk7XG4gICAgICAgIHZhciBjb2x1bW5TcGFuID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihjb25maWcuY29sdW1uU3BhbiB8fCAwKSk7XG4gICAgICAgIHJldHVybiB7IHJvdzogcm93LCBjb2x1bW46IGNvbHVtbiwgcm93U3Bhbjogcm93U3BhbiwgY29sdW1uU3BhbjogY29sdW1uU3BhbiB9O1xuICAgIH1cbiAgICBQcml2YXRlLm5vcm1hbGl6ZUNvbmZpZyA9IG5vcm1hbGl6ZUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBDbGFtcCBhIHZhbHVlIHRvIGFuIGludGVnZXIgPj0gMC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gICAgfVxuICAgIFByaXZhdGUuY2xhbXBWYWx1ZSA9IGNsYW1wVmFsdWU7XG4gICAgLyoqXG4gICAgICogQSBzb3J0IGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIHJvdyBzcGFucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3dTcGFuQ21wKGEsIGIpIHtcbiAgICAgICAgdmFyIGMxID0gUHJpdmF0ZS5jZWxsQ29uZmlnUHJvcGVydHkuZ2V0KGEud2lkZ2V0KTtcbiAgICAgICAgdmFyIGMyID0gUHJpdmF0ZS5jZWxsQ29uZmlnUHJvcGVydHkuZ2V0KGIud2lkZ2V0KTtcbiAgICAgICAgcmV0dXJuIGMxLnJvd1NwYW4gLSBjMi5yb3dTcGFuO1xuICAgIH1cbiAgICBQcml2YXRlLnJvd1NwYW5DbXAgPSByb3dTcGFuQ21wO1xuICAgIC8qKlxuICAgICAqIEEgc29ydCBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBjb2x1bW4gc3BhbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29sdW1uU3BhbkNtcChhLCBiKSB7XG4gICAgICAgIHZhciBjMSA9IFByaXZhdGUuY2VsbENvbmZpZ1Byb3BlcnR5LmdldChhLndpZGdldCk7XG4gICAgICAgIHZhciBjMiA9IFByaXZhdGUuY2VsbENvbmZpZ1Byb3BlcnR5LmdldChiLndpZGdldCk7XG4gICAgICAgIHJldHVybiBjMS5jb2x1bW5TcGFuIC0gYzIuY29sdW1uU3BhbjtcbiAgICB9XG4gICAgUHJpdmF0ZS5jb2x1bW5TcGFuQ21wID0gY29sdW1uU3BhbkNtcDtcbiAgICAvKipcbiAgICAgKiBSZWFsbG9jYXRlIHRoZSBib3ggc2l6ZXJzIGZvciB0aGUgZ2l2ZW4gZ3JpZCBkaW1lbnNpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWxsb2NTaXplcnMoc2l6ZXJzLCBjb3VudCkge1xuICAgICAgICAvLyBDb2VyY2UgdGhlIGNvdW50IHRvIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGNvdW50KSk7XG4gICAgICAgIC8vIEFkZCB0aGUgbWlzc2luZyBzaXplcnMuXG4gICAgICAgIHdoaWxlIChzaXplcnMubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgICAgIHNpemVycy5wdXNoKG5ldyBCb3hTaXplcigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGV4dHJhIHNpemVycy5cbiAgICAgICAgaWYgKHNpemVycy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgICAgICAgc2l6ZXJzLmxlbmd0aCA9IGNvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIFByaXZhdGUucmVhbGxvY1NpemVycyA9IHJlYWxsb2NTaXplcnM7XG4gICAgLyoqXG4gICAgICogRGlzdHJpYnV0ZSBhIG1pbiBzaXplIGNvbnN0cmFpbnQgYWNyb3NzIGEgcmFuZ2Ugb2Ygc2l6ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3RyaWJ1dGVNaW4oc2l6ZXJzLCBpMSwgaTIsIG1pblNpemUpIHtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrIHRoZSBpbmRpY2VzLlxuICAgICAgICBpZiAoaTIgPCBpMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc2ltcGxlIGNhc2Ugb2Ygbm8gY2VsbCBzcGFuLlxuICAgICAgICBpZiAoaTEgPT09IGkyKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZXIgPSBzaXplcnNbaTFdO1xuICAgICAgICAgICAgc2l6ZXIubWluU2l6ZSA9IE1hdGgubWF4KHNpemVyLm1pblNpemUsIG1pblNpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHRvdGFsIGN1cnJlbnQgbWluIHNpemUgb2YgdGhlIHNwYW4uXG4gICAgICAgIHZhciB0b3RhbE1pbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBpMTsgaSA8PSBpMjsgKytpKSB7XG4gICAgICAgICAgICB0b3RhbE1pbiArPSBzaXplcnNbaV0ubWluU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB0b3RhbCBpcyBncmVhdGVyIHRoYW4gdGhlIHJlcXVpcmVkLlxuICAgICAgICBpZiAodG90YWxNaW4gPj0gbWluU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBvcnRpb24gb2YgdGhlIHNwYWNlIHRvIGFsbG9jYXRlIHRvIGVhY2ggc2l6ZXIuXG4gICAgICAgIHZhciBwb3J0aW9uID0gKG1pblNpemUgLSB0b3RhbE1pbikgLyAoaTIgLSBpMSArIDEpO1xuICAgICAgICAvLyBBZGQgdGhlIHBvcnRpb24gdG8gZWFjaCBzaXplci5cbiAgICAgICAgZm9yICh2YXIgaSA9IGkxOyBpIDw9IGkyOyArK2kpIHtcbiAgICAgICAgICAgIHNpemVyc1tpXS5taW5TaXplICs9IHBvcnRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJpdmF0ZS5kaXN0cmlidXRlTWluID0gZGlzdHJpYnV0ZU1pbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbmdlIGhhbmRsZXIgZm9yIHRoZSBjaGlsZCBjZWxsIGNvbmZpZyBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkNoaWxkQ2VsbENvbmZpZ0NoYW5nZWQoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAmJiBjaGlsZC5wYXJlbnQubGF5b3V0IGluc3RhbmNlb2YgR3JpZExheW91dCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LmZpdCgpO1xuICAgICAgICB9XG4gICAgfVxufSkoUHJpdmF0ZSRmIHx8IChQcml2YXRlJGYgPSB7fSkpO1xuXG4vKipcbiAqIEEgd2lkZ2V0IHdoaWNoIGRpc3BsYXlzIG1lbnVzIGFzIGEgY2Fub25pY2FsIG1lbnUgYmFyLlxuICovXG52YXIgTWVudUJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVudUJhciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgbWVudSBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIG1lbnUgYmFyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lbnVCYXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IG5vZGU6IFByaXZhdGUkZy5jcmVhdGVOb2RlKCkgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2FjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgIF90aGlzLl9tZW51cyA9IFtdO1xuICAgICAgICBfdGhpcy5fY2hpbGRNZW51ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuYWRkQ2xhc3MoJ2xtLU1lbnVCYXInKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdwLU1lbnVCYXInKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5zZXRGbGFnKFdpZGdldC5GbGFnLkRpc2FsbG93TGF5b3V0KTtcbiAgICAgICAgX3RoaXMucmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyIHx8IE1lbnVCYXIuZGVmYXVsdFJlbmRlcmVyO1xuICAgICAgICBfdGhpcy5fZm9yY2VJdGVtc1Bvc2l0aW9uID0gb3B0aW9ucy5mb3JjZUl0ZW1zUG9zaXRpb24gfHwgeyBmb3JjZVg6IHRydWUsIGZvcmNlWTogdHJ1ZSB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSB3aWRnZXQuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VDaGlsZE1lbnUoKTtcbiAgICAgICAgdGhpcy5fbWVudXMubGVuZ3RoID0gMDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUJhci5wcm90b3R5cGUsIFwiY2hpbGRNZW51XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGlsZCBtZW51IG9mIHRoZSBtZW51IGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgYG51bGxgIGlmIHRoZSBtZW51IGJhciBkb2VzIG5vdCBoYXZlIGFuIG9wZW4gbWVudS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkTWVudTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lbnVCYXIucHJvdG90eXBlLCBcImNvbnRlbnROb2RlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbWVudSBiYXIgY29udGVudCBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIG5vZGUgd2hpY2ggaG9sZHMgdGhlIG1lbnUgdGl0bGUgbm9kZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1vZGlmeWluZyB0aGlzIG5vZGUgZGlyZWN0bHkgY2FuIGxlYWQgdG8gdW5kZWZpbmVkIGJlaGF2aW9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xtLU1lbnVCYXItY29udGVudCcpWzBdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUJhci5wcm90b3R5cGUsIFwiYWN0aXZlTWVudVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgbWVudS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lbnVzW3RoaXMuX2FjdGl2ZUluZGV4XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogSWYgdGhlIG1lbnUgZG9lcyBub3QgZXhpc3QsIHRoZSBtZW51IHdpbGwgYmUgc2V0IHRvIGBudWxsYC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gdmFsdWUgPyB0aGlzLl9tZW51cy5pbmRleE9mKHZhbHVlKSA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVudUJhci5wcm90b3R5cGUsIFwiYWN0aXZlSW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBtZW51LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBgLTFgIGlmIG5vIG1lbnUgaXMgYWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogSWYgdGhlIG1lbnUgY2Fubm90IGJlIGFjdGl2YXRlZCwgdGhlIGluZGV4IHdpbGwgYmUgc2V0IHRvIGAtMWAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSB2YWx1ZSBmb3IgYW4gb3V0IG9mIHJhbmdlIGluZGV4LlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSB0aGlzLl9tZW51cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgaW5kZXggd2lsbCBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUluZGV4ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGluZGV4LlxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlSW5kZXggPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBmb2N1cyB0byBuZXcgYWN0aXZlIGluZGV4XG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlSW5kZXggPj0gMCAmJiB0aGlzLmNvbnRlbnROb2RlLmNoaWxkTm9kZXNbdGhpcy5fYWN0aXZlSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZS5jaGlsZE5vZGVzW3RoaXMuX2FjdGl2ZUluZGV4XS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBpdGVtcy5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZW51QmFyLnByb3RvdHlwZSwgXCJtZW51c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlYWQtb25seSBhcnJheSBvZiB0aGUgbWVudXMgaW4gdGhlIG1lbnUgYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVudXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGFjdGl2ZSBtZW51IGFuZCBhY3RpdmF0ZSBpdHMgZmlyc3QgbWVudSBpdGVtLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZXJlIGlzIG5vIGFjdGl2ZSBtZW51LCB0aGlzIGlzIGEgbm8tb3AuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUub3BlbkFjdGl2ZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGl0ZW0uXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcGVuIHRoZSBjaGlsZCBtZW51LlxuICAgICAgICB0aGlzLl9vcGVuQ2hpbGRNZW51KCk7XG4gICAgICAgIC8vIEFjdGl2YXRlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBjaGlsZCBtZW51LlxuICAgICAgICBpZiAodGhpcy5fY2hpbGRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZE1lbnUuYWN0aXZlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkTWVudS5hY3RpdmF0ZU5leHRJdGVtKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIG1lbnUgdG8gdGhlIGVuZCBvZiB0aGUgbWVudSBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVudSAtIFRoZSBtZW51IHRvIGFkZCB0byB0aGUgbWVudSBiYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIG1lbnUgaXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgbWVudSBiYXIsIGl0IHdpbGwgYmUgbW92ZWQuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuYWRkTWVudSA9IGZ1bmN0aW9uIChtZW51KSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0TWVudSh0aGlzLl9tZW51cy5sZW5ndGgsIG1lbnUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbWVudSBpbnRvIHRoZSBtZW51IGJhciBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZW51IC0gVGhlIG1lbnUgdG8gaW5zZXJ0IGludG8gdGhlIG1lbnUgYmFyLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoZSBpbmRleCB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIGJvdW5kcyBvZiB0aGUgbWVudXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbWVudSBpcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBtZW51IGJhciwgaXQgd2lsbCBiZSBtb3ZlZC5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5pbnNlcnRNZW51ID0gZnVuY3Rpb24gKGluZGV4LCBtZW51KSB7XG4gICAgICAgIC8vIENsb3NlIHRoZSBjaGlsZCBtZW51IGJlZm9yZSBtYWtpbmcgY2hhbmdlcy5cbiAgICAgICAgdGhpcy5fY2xvc2VDaGlsZE1lbnUoKTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgaW5kZXggb2YgdGhlIG1lbnUuXG4gICAgICAgIHZhciBpID0gdGhpcy5fbWVudXMuaW5kZXhPZihtZW51KTtcbiAgICAgICAgLy8gQ2xhbXAgdGhlIGluc2VydCBpbmRleCB0byB0aGUgYXJyYXkgYm91bmRzLlxuICAgICAgICB2YXIgaiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLl9tZW51cy5sZW5ndGgpKTtcbiAgICAgICAgLy8gSWYgdGhlIG1lbnUgaXMgbm90IGluIHRoZSBhcnJheSwgaW5zZXJ0IGl0LlxuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbWVudSBpbnRvIHRoZSBhcnJheS5cbiAgICAgICAgICAgIEFycmF5RXh0Lmluc2VydCh0aGlzLl9tZW51cywgaiwgbWVudSk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIHN0eWxpbmcgY2xhc3MgdG8gdGhlIG1lbnUuXG4gICAgICAgICAgICBtZW51LmFkZENsYXNzKCdsbS1NZW51QmFyLW1lbnUnKTtcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgbWVudS5hZGRDbGFzcygncC1NZW51QmFyLW1lbnUnKTtcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIG1lbnUgc2lnbmFscy5cbiAgICAgICAgICAgIG1lbnUuYWJvdXRUb0Nsb3NlLmNvbm5lY3QodGhpcy5fb25NZW51QWJvdXRUb0Nsb3NlLCB0aGlzKTtcbiAgICAgICAgICAgIG1lbnUubWVudVJlcXVlc3RlZC5jb25uZWN0KHRoaXMuX29uTWVudU1lbnVSZXF1ZXN0ZWQsIHRoaXMpO1xuICAgICAgICAgICAgbWVudS50aXRsZS5jaGFuZ2VkLmNvbm5lY3QodGhpcy5fb25UaXRsZUNoYW5nZWQsIHRoaXMpO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBpdGVtcy5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBub3RoaW5nIG1vcmUgdG8gZG8uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgbWVudSBleGlzdHMgaW4gdGhlIGFycmF5IGFuZCBzaG91bGQgYmUgbW92ZWQuXG4gICAgICAgIC8vIEFkanVzdCB0aGUgaW5kZXggaWYgdGhlIGxvY2F0aW9uIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICBpZiAoaiA9PT0gdGhpcy5fbWVudXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFpbCBpZiB0aGVyZSBpcyBubyBlZmZlY3RpdmUgbW92ZS5cbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlIHRoZSBtZW51IHRvIHRoZSBuZXcgbG9jYXRpb25zLlxuICAgICAgICBBcnJheUV4dC5tb3ZlKHRoaXMuX21lbnVzLCBpLCBqKTtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBpdGVtcy5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIG1lbnUgZnJvbSB0aGUgbWVudSBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVudSAtIFRoZSBtZW51IHRvIHJlbW92ZSBmcm9tIHRoZSBtZW51IGJhci5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIG1lbnUgaXMgbm90IGluIHRoZSBtZW51IGJhci5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5yZW1vdmVNZW51ID0gZnVuY3Rpb24gKG1lbnUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNZW51QXQodGhpcy5fbWVudXMuaW5kZXhPZihtZW51KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIG1lbnUgYXQgYSBnaXZlbiBpbmRleCBmcm9tIHRoZSBtZW51IGJhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgbWVudSB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUucmVtb3ZlTWVudUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIC8vIENsb3NlIHRoZSBjaGlsZCBtZW51IGJlZm9yZSBtYWtpbmcgY2hhbmdlcy5cbiAgICAgICAgdGhpcy5fY2xvc2VDaGlsZE1lbnUoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtZW51IGZyb20gdGhlIGFycmF5LlxuICAgICAgICB2YXIgbWVudSA9IEFycmF5RXh0LnJlbW92ZUF0KHRoaXMuX21lbnVzLCBpbmRleCk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAgICAgaWYgKCFtZW51KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBtZW51IHNpZ25hbHMuXG4gICAgICAgIG1lbnUuYWJvdXRUb0Nsb3NlLmRpc2Nvbm5lY3QodGhpcy5fb25NZW51QWJvdXRUb0Nsb3NlLCB0aGlzKTtcbiAgICAgICAgbWVudS5tZW51UmVxdWVzdGVkLmRpc2Nvbm5lY3QodGhpcy5fb25NZW51TWVudVJlcXVlc3RlZCwgdGhpcyk7XG4gICAgICAgIG1lbnUudGl0bGUuY2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuX29uVGl0bGVDaGFuZ2VkLCB0aGlzKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdHlsaW5nIGNsYXNzIGZyb20gdGhlIG1lbnUuXG4gICAgICAgIG1lbnUucmVtb3ZlQ2xhc3MoJ2xtLU1lbnVCYXItbWVudScpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgbWVudS5yZW1vdmVDbGFzcygncC1NZW51QmFyLW1lbnUnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBtZW51cyBmcm9tIHRoZSBtZW51IGJhci5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5jbGVhck1lbnVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gcmVtb3ZlLlxuICAgICAgICBpZiAodGhpcy5fbWVudXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgdGhlIGNoaWxkIG1lbnUgYmVmb3JlIG1ha2luZyBjaGFuZ2VzLlxuICAgICAgICB0aGlzLl9jbG9zZUNoaWxkTWVudSgpO1xuICAgICAgICAvLyBEaXNjb25uZWN0IGZyb20gdGhlIG1lbnUgc2lnbmFscyBhbmQgcmVtb3ZlIHRoZSBzdHlsaW5nIGNsYXNzLlxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fbWVudXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVudSA9IF9hW19pXTtcbiAgICAgICAgICAgIG1lbnUuYWJvdXRUb0Nsb3NlLmRpc2Nvbm5lY3QodGhpcy5fb25NZW51QWJvdXRUb0Nsb3NlLCB0aGlzKTtcbiAgICAgICAgICAgIG1lbnUubWVudVJlcXVlc3RlZC5kaXNjb25uZWN0KHRoaXMuX29uTWVudU1lbnVSZXF1ZXN0ZWQsIHRoaXMpO1xuICAgICAgICAgICAgbWVudS50aXRsZS5jaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5fb25UaXRsZUNoYW5nZWQsIHRoaXMpO1xuICAgICAgICAgICAgbWVudS5yZW1vdmVDbGFzcygnbG0tTWVudUJhci1tZW51Jyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIG1lbnUucmVtb3ZlQ2xhc3MoJ3AtTWVudUJhci1tZW51Jyk7XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIG1lbnVzIGFycmF5LlxuICAgICAgICB0aGlzLl9tZW51cy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb2YgdGhlIGl0ZW1zLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBET00gZXZlbnRzIGZvciB0aGUgbWVudSBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IHNlbnQgdG8gdGhlIG1lbnUgYmFyLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIERPTSBgRXZlbnRMaXN0ZW5lcmAgaW50ZXJmYWNlIGFuZCBpc1xuICAgICAqIGNhbGxlZCBpbiByZXNwb25zZSB0byBldmVudHMgb24gdGhlIG1lbnUgYmFyJ3MgRE9NIG5vZGVzLiBJdFxuICAgICAqIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHVzZXIgY29kZS5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dEtleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ldnRNb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VMZWF2ZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUub25CZWZvcmVBdHRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhZnRlci1kZXRhY2gnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lbnVCYXIucHJvdG90eXBlLm9uQWZ0ZXJEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fY2xvc2VDaGlsZE1lbnUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCdhY3RpdmF0ZS1yZXF1ZXN0J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5vbkFjdGl2YXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCd1cGRhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVudXMgPSB0aGlzLl9tZW51cztcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5fYWN0aXZlSW5kZXg7XG4gICAgICAgIHZhciBjb250ZW50ID0gbmV3IEFycmF5KG1lbnVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGksIG4pIHtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IG1lbnVzW2ldLnRpdGxlO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IGkgPT09IGFjdGl2ZUluZGV4O1xuICAgICAgICAgICAgY29udGVudFtpXSA9IHJlbmRlcmVyLnJlbmRlckl0ZW0oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICBvbmZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBtZW51cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgVmlydHVhbERPTS5yZW5kZXIoY29udGVudCwgdGhpcy5jb250ZW50Tm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAna2V5ZG93bidgIGV2ZW50IGZvciB0aGUgbWVudSBiYXIuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuX2V2dEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQSBtZW51IGJhciBoYW5kbGVzIGFsbCBrZXlkb3duIGV2ZW50cy5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBrZXkgY29kZSBmb3IgdGhlIGV2ZW50LlxuICAgICAgICB2YXIga2MgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICAvLyBFbnRlciwgVXAgQXJyb3csIERvd24gQXJyb3dcbiAgICAgICAgaWYgKGtjID09PSAxMyB8fCBrYyA9PT0gMzggfHwga2MgPT09IDQwKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5BY3RpdmVNZW51KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXNjYXBlXG4gICAgICAgIGlmIChrYyA9PT0gMjcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQ2hpbGRNZW51KCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYmx1cigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExlZnQgQXJyb3dcbiAgICAgICAgaWYgKGtjID09PSAzNykge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9hY3RpdmVJbmRleDtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fbWVudXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGkgPT09IDAgPyBuIC0gMSA6IGkgLSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJpZ2h0IEFycm93XG4gICAgICAgIGlmIChrYyA9PT0gMzkpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fYWN0aXZlSW5kZXg7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX21lbnVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBpID09PSBuIC0gMSA/IDAgOiBpICsgMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHByZXNzZWQga2V5IGNoYXJhY3Rlci5cbiAgICAgICAgdmFyIGtleSA9IGdldEtleWJvYXJkTGF5b3V0KCkua2V5Rm9yS2V5ZG93bkV2ZW50KGV2ZW50KTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUga2V5IGlzIG5vdCB2YWxpZC5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZXh0IGJlc3QgbWF0Y2hpbmcgbW5lbW9uaWMgaXRlbS5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fYWN0aXZlSW5kZXggKyAxO1xuICAgICAgICB2YXIgcmVzdWx0ID0gUHJpdmF0ZSRnLmZpbmRNbmVtb25pYyh0aGlzLl9tZW51cywga2V5LCBzdGFydCk7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcmVxdWVzdGVkIG1uZW1vbmljIGJhc2VkIG9uIHRoZSBzZWFyY2ggcmVzdWx0cy5cbiAgICAgICAgLy8gSWYgZXhhY3RseSBvbmUgbW5lbW9uaWMgaXMgbWF0Y2hlZCwgdGhhdCBtZW51IGlzIG9wZW5lZC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgbmV4dCBtbmVtb25pYyBpcyBhY3RpdmF0ZWQgaWYgYXZhaWxhYmxlLFxuICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgYXV0byBtbmVtb25pYyBpZiBhdmFpbGFibGUuXG4gICAgICAgIGlmIChyZXN1bHQuaW5kZXggIT09IC0xICYmICFyZXN1bHQubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSByZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm9wZW5BY3RpdmVNZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0LmluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQuYXV0byAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSByZXN1bHQuYXV0bztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNlZG93bidgIGV2ZW50IGZvciB0aGUgbWVudSBiYXIuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuX2V2dE1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBCYWlsIGlmIHRoZSBtb3VzZSBwcmVzcyB3YXMgbm90IG9uIHRoZSBtZW51IGJhci4gVGhpcyBjYW4gb2NjdXJcbiAgICAgICAgLy8gd2hlbiB0aGUgZG9jdW1lbnQgbGlzdGVuZXIgaXMgaW5zdGFsbGVkIGZvciBhbiBhY3RpdmUgbWVudSBiYXIuXG4gICAgICAgIGlmICghRWxlbWVudEV4dC5oaXRUZXN0KHRoaXMubm9kZSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9wIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuIEltbWVkaWF0ZSBwcm9wYWdhdGlvbiBpc1xuICAgICAgICAvLyBhbHNvIHN0b3BwZWQgc28gdGhhdCBhbiBvcGVuIG1lbnUgZG9lcyBub3QgaGFuZGxlIHRoZSBldmVudC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgb3ZlciBvbmUgb2YgdGhlIG1lbnUgaXRlbXMuXG4gICAgICAgIHZhciBpbmRleCA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRoaXMuY29udGVudE5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudEV4dC5oaXRUZXN0KG5vZGUsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXNzIHdhcyBub3Qgb24gYW4gaXRlbSwgY2xvc2UgdGhlIGNoaWxkIG1lbnUuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQ2hpbGRNZW51KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHByZXNzIHdhcyBub3QgdGhlIGxlZnQgbW91c2UgYnV0dG9uLCBkbyBub3RoaW5nIGZ1cnRoZXIuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRvZ2dsZSB0aGUgb3BlbiBzdGF0ZSBvZiB0aGUgY2hpbGQgbWVudS5cbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkTWVudSkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VDaGlsZE1lbnUoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuX29wZW5DaGlsZE1lbnUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNlbW92ZSdgIGV2ZW50IGZvciB0aGUgbWVudSBiYXIuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuX2V2dE1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgb3ZlciBvbmUgb2YgdGhlIG1lbnUgaXRlbXMuXG4gICAgICAgIHZhciBpbmRleCA9IEFycmF5RXh0LmZpbmRGaXJzdEluZGV4KHRoaXMuY29udGVudE5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudEV4dC5oaXRUZXN0KG5vZGUsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQmFpbCBlYXJseSBpZiB0aGUgYWN0aXZlIGluZGV4IHdpbGwgbm90IGNoYW5nZS5cbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLl9hY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgYSBjaGlsZCBtZW51IGlzIG9wZW4gYW5kIHRoZSBtb3VzZSBpcyBub3Qgb3ZlclxuICAgICAgICAvLyBhbiBpdGVtLiBUaGlzIGFsbG93cyB0aGUgY2hpbGQgbWVudSB0byBiZSBrZXB0IG9wZW4gd2hlbiB0aGVcbiAgICAgICAgLy8gbW91c2UgaXMgb3ZlciB0aGUgZW1wdHkgcGFydCBvZiB0aGUgbWVudSBiYXIuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEgJiYgdGhpcy5fY2hpbGRNZW51KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhY3RpdmUgaW5kZXggdG8gdGhlIGhvdmVyZWQgaXRlbS5cbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBPcGVuIHRoZSBuZXcgbWVudSBpZiBhIG1lbnUgaXMgYWxyZWFkeSBvcGVuLlxuICAgICAgICBpZiAodGhpcy5fY2hpbGRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuQ2hpbGRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYCdtb3VzZWxlYXZlJ2AgZXZlbnQgZm9yIHRoZSBtZW51IGJhci5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5fZXZ0TW91c2VMZWF2ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgYWN0aXZlIGluZGV4IGlmIHRoZXJlIGlzIG5vIG9wZW4gbWVudS5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGlsZE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgY2hpbGQgbWVudSBhdCB0aGUgYWN0aXZlIGluZGV4IGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogSWYgYSBkaWZmZXJlbnQgY2hpbGQgbWVudSBpcyBhbHJlYWR5IG9wZW4sIGl0IHdpbGwgYmUgY2xvc2VkLFxuICAgICAqIGV2ZW4gaWYgdGhlcmUgaXMgbm8gYWN0aXZlIG1lbnUuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuX29wZW5DaGlsZE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGFjdGl2ZSBtZW51LCBjbG9zZSB0aGUgY3VycmVudCBtZW51LlxuICAgICAgICB2YXIgbmV3TWVudSA9IHRoaXMuYWN0aXZlTWVudTtcbiAgICAgICAgaWYgKCFuZXdNZW51KSB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUNoaWxkTWVudSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gZWZmZWN0aXZlIG1lbnUgY2hhbmdlLlxuICAgICAgICB2YXIgb2xkTWVudSA9IHRoaXMuX2NoaWxkTWVudTtcbiAgICAgICAgaWYgKG9sZE1lbnUgPT09IG5ld01lbnUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FwIHRoZSBpbnRlcm5hbCBtZW51IHJlZmVyZW5jZS5cbiAgICAgICAgdGhpcy5fY2hpbGRNZW51ID0gbmV3TWVudTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGN1cnJlbnQgbWVudSwgb3Igc2V0dXAgZm9yIHRoZSBuZXcgbWVudS5cbiAgICAgICAgaWYgKG9sZE1lbnUpIHtcbiAgICAgICAgICAgIG9sZE1lbnUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2xtLW1vZC1hY3RpdmUnKTtcbiAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcygncC1tb2QtYWN0aXZlJyk7XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIG1lbnUgYmFyIGlzIHVwZGF0ZWQgYW5kIGxvb2sgdXAgdGhlIGl0ZW0gbm9kZS5cbiAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcywgV2lkZ2V0Lk1zZy5VcGRhdGVSZXF1ZXN0KTtcbiAgICAgICAgdmFyIGl0ZW1Ob2RlID0gdGhpcy5jb250ZW50Tm9kZS5jaGlsZHJlblt0aGlzLl9hY3RpdmVJbmRleF07XG4gICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb25pbmcgZGF0YSBmb3IgdGhlIG5ldyBtZW51LlxuICAgICAgICB2YXIgX2EgPSBpdGVtTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGVmdCA9IF9hLmxlZnQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcbiAgICAgICAgLy8gT3BlbiB0aGUgbmV3IG1lbnUgYXQgdGhlIGNvbXB1dGVkIGxvY2F0aW9uLlxuICAgICAgICBuZXdNZW51Lm9wZW4obGVmdCwgYm90dG9tLCB0aGlzLl9mb3JjZUl0ZW1zUG9zaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNoaWxkIG1lbnUgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbm8tb3AgaWYgYSBjaGlsZCBtZW51IGlzIG5vdCBvcGVuLlxuICAgICAqL1xuICAgIE1lbnVCYXIucHJvdG90eXBlLl9jbG9zZUNoaWxkTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmFpbCBpZiBubyBjaGlsZCBtZW51IGlzIG9wZW4uXG4gICAgICAgIGlmICghdGhpcy5fY2hpbGRNZW51KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbSB0aGUgbWVudSBiYXIuXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ2xtLW1vZC1hY3RpdmUnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3AtbW9kLWFjdGl2ZScpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZG9jdW1lbnQgbGlzdGVuZXJzLlxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGludGVybmFsIG1lbnUgcmVmZXJlbmNlLlxuICAgICAgICB2YXIgbWVudSA9IHRoaXMuX2NoaWxkTWVudTtcbiAgICAgICAgdGhpcy5fY2hpbGRNZW51ID0gbnVsbDtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIG1lbnUuXG4gICAgICAgIG1lbnUuY2xvc2UoKTtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFjdGl2ZSBpbmRleC5cbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgYWJvdXRUb0Nsb3NlYCBzaWduYWwgb2YgYSBtZW51LlxuICAgICAqL1xuICAgIE1lbnVCYXIucHJvdG90eXBlLl9vbk1lbnVBYm91dFRvQ2xvc2UgPSBmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIHNlbmRlciBpcyBub3QgdGhlIGNoaWxkIG1lbnUuXG4gICAgICAgIGlmIChzZW5kZXIgIT09IHRoaXMuX2NoaWxkTWVudSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYWN0aXZlIGNsYXNzIGZyb20gdGhlIG1lbnUgYmFyLlxuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCdsbS1tb2QtYWN0aXZlJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCdwLW1vZC1hY3RpdmUnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGRvY3VtZW50IGxpc3RlbmVycy5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBpbnRlcm5hbCBtZW51IHJlZmVyZW5jZS5cbiAgICAgICAgdGhpcy5fY2hpbGRNZW51ID0gbnVsbDtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFjdGl2ZSBpbmRleC5cbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgbWVudVJlcXVlc3RlZGAgc2lnbmFsIG9mIGEgY2hpbGQgbWVudS5cbiAgICAgKi9cbiAgICBNZW51QmFyLnByb3RvdHlwZS5fb25NZW51TWVudVJlcXVlc3RlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgc2VuZGVyIGlzIG5vdCB0aGUgY2hpbGQgbWVudS5cbiAgICAgICAgaWYgKHNlbmRlciAhPT0gdGhpcy5fY2hpbGRNZW51KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayB1cCB0aGUgYWN0aXZlIGluZGV4IGFuZCBtZW51IGNvdW50LlxuICAgICAgICB2YXIgaSA9IHRoaXMuX2FjdGl2ZUluZGV4O1xuICAgICAgICB2YXIgbiA9IHRoaXMuX21lbnVzLmxlbmd0aDtcbiAgICAgICAgLy8gQWN0aXZlIHRoZSBuZXh0IHJlcXVlc3RlZCBpbmRleC5cbiAgICAgICAgc3dpdGNoIChhcmdzKSB7XG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gaSA9PT0gbiAtIDEgPyAwIDogaSArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGkgPT09IDAgPyBuIC0gMSA6IGkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9wZW4gdGhlIGFjdGl2ZSBtZW51LlxuICAgICAgICB0aGlzLm9wZW5BY3RpdmVNZW51KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGBjaGFuZ2VkYCBzaWduYWwgb2YgYSB0aXRsZSBvYmplY3QuXG4gICAgICovXG4gICAgTWVudUJhci5wcm90b3R5cGUuX29uVGl0bGVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbnVCYXI7XG59KFdpZGdldCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgYE1lbnVCYXJgIGNsYXNzIHN0YXRpY3MuXG4gKi9cbihmdW5jdGlvbiAoTWVudUJhcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBJUmVuZGVyZXJgLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIFN1YmNsYXNzZXMgYXJlIGZyZWUgdG8gcmVpbXBsZW1lbnQgcmVuZGVyaW5nIG1ldGhvZHMgYXMgbmVlZGVkLlxuICAgICAqL1xuICAgIHZhciBSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyByZW5kZXJlci5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIHZpcnR1YWwgZWxlbWVudCBmb3IgYSBtZW51IGJhciBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBIHZpcnR1YWwgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySXRlbSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jcmVhdGVJdGVtQ2xhc3MoZGF0YSk7XG4gICAgICAgICAgICB2YXIgZGF0YXNldCA9IHRoaXMuY3JlYXRlSXRlbURhdGFzZXQoZGF0YSk7XG4gICAgICAgICAgICB2YXIgYXJpYSA9IHRoaXMuY3JlYXRlSXRlbUFSSUEoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gKGgubGkoX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgZGF0YXNldDogZGF0YXNldCwgdGFiaW5kZXg6ICcwJywgb25mb2N1czogZGF0YS5vbmZvY3VzIH0sIGFyaWEpLCB0aGlzLnJlbmRlckljb24oZGF0YSksIHRoaXMucmVuZGVyTGFiZWwoZGF0YSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgaWNvbiBlbGVtZW50IGZvciBhIG1lbnUgYmFyIGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGljb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaXRlbSBpY29uLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckljb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY3JlYXRlSWNvbkNsYXNzKGRhdGEpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudGl0bGUuaWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaC5kaXYoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCBkYXRhLnRpdGxlLmljb25MYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAvLyBpZiBkYXRhLnRpdGxlLmljb24gaXMgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAgICAgIHJldHVybiBoLmRpdih7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGRhdGEudGl0bGUuaWNvbiwgZGF0YS50aXRsZS5pY29uTGFiZWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBsYWJlbCBlbGVtZW50IGZvciBhIG1lbnUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbGFiZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdmlydHVhbCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaXRlbSBsYWJlbC5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZm9ybWF0TGFiZWwoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gaC5kaXYoeyBjbGFzc05hbWU6ICdsbS1NZW51QmFyLWl0ZW1MYWJlbCdcbiAgICAgICAgICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAgICAgICAgICsgJyBwLU1lbnVCYXItaXRlbUxhYmVsJ1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH0sIGNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBjbGFzcyBuYW1lIGZvciB0aGUgbWVudSBiYXIgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSBjbGFzcyBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgZnVsbCBjbGFzcyBuYW1lIGZvciB0aGUgbWVudSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW1DbGFzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICdsbS1NZW51QmFyLWl0ZW0nO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBuYW1lICs9ICcgcC1NZW51QmFyLWl0ZW0nO1xuICAgICAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgaWYgKGRhdGEudGl0bGUuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIiBcIiArIGRhdGEudGl0bGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgbmFtZSArPSAnIGxtLW1vZC1hY3RpdmUnO1xuICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJyBwLW1vZC1hY3RpdmUnO1xuICAgICAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBkYXRhc2V0IGZvciBhIG1lbnUgYmFyIGl0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGRhdGFzZXQgZm9yIHRoZSBtZW51IGJhciBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW1EYXRhc2V0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnRpdGxlLmRhdGFzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIGFyaWEgYXR0cmlidXRlcyBmb3IgbWVudSBiYXIgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1c2UgZm9yIHRoZSBhcmlhIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBhcmlhIGF0dHJpYnV0ZXMgb2JqZWN0IGZvciB0aGUgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJdGVtQVJJQSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyByb2xlOiAnbWVudWl0ZW0nLCAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBjbGFzcyBuYW1lIGZvciB0aGUgbWVudSBiYXIgaXRlbSBpY29uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGNsYXNzIG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBmdWxsIGNsYXNzIG5hbWUgZm9yIHRoZSBpdGVtIGljb24uXG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSWNvbkNsYXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJ2xtLU1lbnVCYXItaXRlbUljb24nO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICBuYW1lICs9ICcgcC1NZW51QmFyLWl0ZW1JY29uJztcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHZhciBleHRyYSA9IGRhdGEudGl0bGUuaWNvbkNsYXNzO1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhID8gbmFtZSArIFwiIFwiICsgZXh0cmEgOiBuYW1lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSByZW5kZXIgY29udGVudCBmb3IgdGhlIGxhYmVsIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gdXNlIGZvciB0aGUgbGFiZWwgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgVGhlIGNvbnRlbnQgdG8gYWRkIHRvIHRoZSBsYWJlbCBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmZvcm1hdExhYmVsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBsYWJlbCB0ZXh0IGFuZCBtbmVtb25pYyBpbmRleC5cbiAgICAgICAgICAgIHZhciBfYSA9IGRhdGEudGl0bGUsIGxhYmVsID0gX2EubGFiZWwsIG1uZW1vbmljID0gX2EubW5lbW9uaWM7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLCBkbyBub3QgbW9kaWZ5IHRoZSBsYWJlbC5cbiAgICAgICAgICAgIGlmIChtbmVtb25pYyA8IDAgfHwgbW5lbW9uaWMgPj0gbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGxhYmVsIGludG8gcGFydHMuXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gbGFiZWwuc2xpY2UoMCwgbW5lbW9uaWMpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGxhYmVsLnNsaWNlKG1uZW1vbmljICsgMSk7XG4gICAgICAgICAgICB2YXIgY2hhciA9IGxhYmVsW21uZW1vbmljXTtcbiAgICAgICAgICAgIC8vIFdyYXAgdGhlIG1uZW1vbmljIGNoYXJhY3RlciBpbiBhIHNwYW4uXG4gICAgICAgICAgICB2YXIgc3BhbiA9IGguc3Bhbih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbG0tTWVudUJhci1pdGVtTW5lbW9uaWMnXG4gICAgICAgICAgICAgICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICAgICAgICAgICAgICArICcgcC1NZW51QmFyLWl0ZW1NbmVtb25pYydcbiAgICAgICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB9LCBjaGFyKTtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29udGVudCBwYXJ0cy5cbiAgICAgICAgICAgIHJldHVybiBbcHJlZml4LCBzcGFuLCBzdWZmaXhdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICBNZW51QmFyLlJlbmRlcmVyID0gUmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgYFJlbmRlcmVyYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBNZW51QmFyLmRlZmF1bHRSZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xufSkoTWVudUJhciB8fCAoTWVudUJhciA9IHt9KSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkZztcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgRE9NIG5vZGUgZm9yIGEgbWVudSBiYXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTm9kZSgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdsbS1NZW51QmFyLWNvbnRlbnQnO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdwLU1lbnVCYXItY29udGVudCcpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnViYXInKTtcbiAgICAgICAgbm9kZS50YWJJbmRleCA9IDA7XG4gICAgICAgIGNvbnRlbnQudGFiSW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVOb2RlID0gY3JlYXRlTm9kZTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBiZXN0IG1hdGNoaW5nIG1uZW1vbmljIGl0ZW0uXG4gICAgICpcbiAgICAgKiBUaGUgc2VhcmNoIHN0YXJ0cyBhdCB0aGUgZ2l2ZW4gaW5kZXggYW5kIHdyYXBzIGFyb3VuZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTW5lbW9uaWMobWVudXMsIGtleSwgc3RhcnQpIHtcbiAgICAgICAgLy8gU2V0dXAgdGhlIHJlc3VsdCB2YXJpYWJsZXMuXG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgYXV0byA9IC0xO1xuICAgICAgICB2YXIgbXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBrZXkgdG8gdXBwZXIgY2FzZS5cbiAgICAgICAgdmFyIHVwcGVyS2V5ID0ga2V5LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIC8vIFNlYXJjaCB0aGUgaXRlbXMgZnJvbSB0aGUgZ2l2ZW4gc3RhcnQgaW5kZXguXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbWVudXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSB3cmFwcGVkIGluZGV4LlxuICAgICAgICAgICAgdmFyIGsgPSAoaSArIHN0YXJ0KSAlIG47XG4gICAgICAgICAgICAvLyBMb29rIHVwIHRoZSBtZW51IHRpdGxlLlxuICAgICAgICAgICAgdmFyIHRpdGxlID0gbWVudXNba10udGl0bGU7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGl0bGVzIHdpdGggYW4gZW1wdHkgbGFiZWwuXG4gICAgICAgICAgICBpZiAodGl0bGUubGFiZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb29rIHVwIHRoZSBtbmVtb25pYyBpbmRleCBmb3IgdGhlIGxhYmVsLlxuICAgICAgICAgICAgdmFyIG1uID0gdGl0bGUubW5lbW9uaWM7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYSB2YWxpZCBtbmVtb25pYyBpbmRleC5cbiAgICAgICAgICAgIGlmIChtbiA+PSAwICYmIG1uIDwgdGl0bGUubGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlLmxhYmVsW21uXS50b1VwcGVyQ2FzZSgpID09PSB1cHBlcktleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCBoYW5kbGUgdGhlIGF1dG8gaW5kZXggaWYgcG9zc2libGUuXG4gICAgICAgICAgICBpZiAoYXV0byA9PT0gLTEgJiYgdGl0bGUubGFiZWxbMF0udG9VcHBlckNhc2UoKSA9PT0gdXBwZXJLZXkpIHtcbiAgICAgICAgICAgICAgICBhdXRvID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXgsIG11bHRpcGxlOiBtdWx0aXBsZSwgYXV0bzogYXV0byB9O1xuICAgIH1cbiAgICBQcml2YXRlLmZpbmRNbmVtb25pYyA9IGZpbmRNbmVtb25pYztcbn0pKFByaXZhdGUkZyB8fCAoUHJpdmF0ZSRnID0ge30pKTtcblxuLyoqXG4gKiBBIHdpZGdldCB3aGljaCBpbXBsZW1lbnRzIGEgY2Fub25pY2FsIHNjcm9sbCBiYXIuXG4gKi9cbnZhciBTY3JvbGxCYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjcm9sbEJhciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgc2Nyb2xsIGJhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgc2Nyb2xsIGJhci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTY3JvbGxCYXIob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7IG5vZGU6IFByaXZhdGUkaC5jcmVhdGVOb2RlKCkgfSkgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZW91dCBjYWxsYmFjayBmb3IgcmVwZWF0aW5nIHRoZSBtb3VzZSBwcmVzcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vblJlcGVhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSByZXBlYXQgdGltZXIgaWQuXG4gICAgICAgICAgICBfdGhpcy5fcmVwZWF0VGltZXIgPSAtMTtcbiAgICAgICAgICAgIC8vIEJhaWwgaWYgdGhlIG1vdXNlIGhhcyBiZWVuIHJlbGVhc2VkLlxuICAgICAgICAgICAgaWYgKCFfdGhpcy5fcHJlc3NEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgcGFydCB0aGF0IHdhcyBwcmVzc2VkLlxuICAgICAgICAgICAgdmFyIHBhcnQgPSBfdGhpcy5fcHJlc3NEYXRhLnBhcnQ7XG4gICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSB0aHVtYiB3YXMgcHJlc3NlZC5cbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAndGh1bWInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIHRpbWVyIGZvciBhbm90aGVyIHJlcGVhdC5cbiAgICAgICAgICAgIF90aGlzLl9yZXBlYXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KF90aGlzLl9vblJlcGVhdCwgMjApO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICAgICAgdmFyIG1vdXNlWCA9IF90aGlzLl9wcmVzc0RhdGEubW91c2VYO1xuICAgICAgICAgICAgdmFyIG1vdXNlWSA9IF90aGlzLl9wcmVzc0RhdGEubW91c2VZO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGEgZGVjcmVtZW50IGJ1dHRvbiByZXBlYXQuXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJ2RlY3JlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSBtb3VzZSBpcyBub3Qgb3ZlciB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgIGlmICghRWxlbWVudEV4dC5oaXRUZXN0KF90aGlzLmRlY3JlbWVudE5vZGUsIG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIHN0ZXAgcmVxdWVzdGVkIHNpZ25hbC5cbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RlcFJlcXVlc3RlZC5lbWl0KCdkZWNyZW1lbnQnKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgYW4gaW5jcmVtZW50IGJ1dHRvbiByZXBlYXQuXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJ2luY3JlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYWlsIGlmIHRoZSBtb3VzZSBpcyBub3Qgb3ZlciB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgIGlmICghRWxlbWVudEV4dC5oaXRUZXN0KF90aGlzLmluY3JlbWVudE5vZGUsIG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIHN0ZXAgcmVxdWVzdGVkIHNpZ25hbC5cbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RlcFJlcXVlc3RlZC5lbWl0KCdpbmNyZW1lbnQnKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgYSB0cmFjayByZXBlYXQuXG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgICAgICAgIC8vIEJhaWwgaWYgdGhlIG1vdXNlIGlzIG5vdCBvdmVyIHRoZSB0cmFjay5cbiAgICAgICAgICAgICAgICBpZiAoIUVsZW1lbnRFeHQuaGl0VGVzdChfdGhpcy50cmFja05vZGUsIG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSB0aHVtYiBub2RlLlxuICAgICAgICAgICAgICAgIHZhciB0aHVtYk5vZGUgPSBfdGhpcy50aHVtYk5vZGU7XG4gICAgICAgICAgICAgICAgLy8gQmFpbCBpZiB0aGUgbW91c2UgaXMgb3ZlciB0aGUgdGh1bWIuXG4gICAgICAgICAgICAgICAgaWYgKEVsZW1lbnRFeHQuaGl0VGVzdCh0aHVtYk5vZGUsIG1vdXNlWCwgbW91c2VZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjbGllbnQgcmVjdCBmb3IgdGhlIHRodW1iLlxuICAgICAgICAgICAgICAgIHZhciB0aHVtYlJlY3QgPSB0aHVtYk5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gZm9yIHRoZSBwYWdlIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyID0gbW91c2VYIDwgdGh1bWJSZWN0LmxlZnQgPyAnZGVjcmVtZW50JyA6ICdpbmNyZW1lbnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyID0gbW91c2VZIDwgdGh1bWJSZWN0LnRvcCA/ICdkZWNyZW1lbnQnIDogJ2luY3JlbWVudCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIHBhZ2UgcmVxdWVzdGVkIHNpZ25hbC5cbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFnZVJlcXVlc3RlZC5lbWl0KGRpcik7XG4gICAgICAgICAgICAgICAgLy8gRmluaXNoZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fdmFsdWUgPSAwO1xuICAgICAgICBfdGhpcy5fcGFnZSA9IDEwO1xuICAgICAgICBfdGhpcy5fbWF4aW11bSA9IDEwMDtcbiAgICAgICAgX3RoaXMuX3JlcGVhdFRpbWVyID0gLTE7XG4gICAgICAgIF90aGlzLl9wcmVzc0RhdGEgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdGh1bWJNb3ZlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fc3RlcFJlcXVlc3RlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fcGFnZVJlcXVlc3RlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygnbG0tU2Nyb2xsQmFyJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygncC1TY3JvbGxCYXInKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy5zZXRGbGFnKFdpZGdldC5GbGFnLkRpc2FsbG93TGF5b3V0KTtcbiAgICAgICAgLy8gU2V0IHRoZSBvcmllbnRhdGlvbi5cbiAgICAgICAgX3RoaXMuX29yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbiB8fCAndmVydGljYWwnO1xuICAgICAgICBfdGhpcy5kYXRhc2V0WydvcmllbnRhdGlvbiddID0gX3RoaXMuX29yaWVudGF0aW9uO1xuICAgICAgICAvLyBQYXJzZSB0aGUgcmVzdCBvZiB0aGUgb3B0aW9ucy5cbiAgICAgICAgaWYgKG9wdGlvbnMubWF4aW11bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWF4aW11bSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWF4aW11bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fcGFnZSA9IE1hdGgubWF4KDAsIG9wdGlvbnMucGFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMuX3ZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ob3B0aW9ucy52YWx1ZSwgX3RoaXMuX21heGltdW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxCYXIucHJvdG90eXBlLCBcInRodW1iTW92ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBzY3JvbGwgdGh1bWIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIHBheWxvYWQgaXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNjcm9sbCBiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHVtYk1vdmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsQmFyLnByb3RvdHlwZSwgXCJzdGVwUmVxdWVzdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBzdGVwIGJ1dHRvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgcGF5bG9hZCBpcyB3aGV0aGVyIGEgZGVjcmVhc2Ugb3IgaW5jcmVhc2UgaXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RlcFJlcXVlc3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbEJhci5wcm90b3R5cGUsIFwicGFnZVJlcXVlc3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBzY3JvbGwgdHJhY2suXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhlIHBheWxvYWQgaXMgd2hldGhlciBhIGRlY3JlYXNlIG9yIGluY3JlYXNlIGlzIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VSZXF1ZXN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxCYXIucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHNjcm9sbCBiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHNjcm9sbCBiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgb3JpZW50YXRpb24gZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlIGJlZm9yZSBtYWtpbmcgY2hhbmdlcy5cbiAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VNb3VzZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBvcmllbnRhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFzZXRbJ29yaWVudGF0aW9uJ10gPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxCYXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzY3JvbGwgYmFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSB2YWx1ZSB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIHJhbmdlIGBbMCwgbWF4aW11bV1gLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSB2YWx1ZSB0byB0aGUgYWxsb3dhYmxlIHJhbmdlLlxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWx1ZSwgdGhpcy5fbWF4aW11bSkpO1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIHRoZSBzY3JvbGwgYmFyLlxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbEJhci5wcm90b3R5cGUsIFwicGFnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBhZ2Ugc2l6ZSBvZiB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgcGFnZSBzaXplIGlzIHRoZSBhbW91bnQgb2YgdmlzaWJsZSBjb250ZW50IGluIHRoZSBzY3JvbGxlZFxuICAgICAgICAgKiByZWdpb24sIGV4cHJlc3NlZCBpbiBkYXRhIHVuaXRzLiBJdCBkZXRlcm1pbmVzIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICAgKiBzY3JvbGwgYmFyIHRodW1iLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcGFnZSBzaXplIG9mIHRoZSBzY3JvbGwgYmFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoZSBwYWdlIHNpemUgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSByYW5nZSBgWzAsIEluZmluaXR5XWAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIHBhZ2Ugc2l6ZSB0byB0aGUgYWxsb3dhYmxlIHJhbmdlLlxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heCgwLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGFnZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIHBhZ2Ugc2l6ZS5cbiAgICAgICAgICAgIHRoaXMuX3BhZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxCYXIucHJvdG90eXBlLCBcIm1heGltdW1cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBzY3JvbGwgYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4aW11bTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBUaGUgbWF4IHNpemUgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSByYW5nZSBgWzAsIEluZmluaXR5XWAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIHZhbHVlIHRvIHRoZSBhbGxvd2FibGUgcmFuZ2UuXG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KDAsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXhpbXVtID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgdmFsdWVzLlxuICAgICAgICAgICAgdGhpcy5fbWF4aW11bSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIGN1cnJlbnQgdmFsdWUgdG8gdGhlIG5ldyByYW5nZS5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5taW4odGhpcy5fdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxCYXIucHJvdG90eXBlLCBcImRlY3JlbWVudE5vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjcm9sbCBiYXIgZGVjcmVtZW50IGJ1dHRvbiBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIE1vZGlmeWluZyB0aGlzIG5vZGUgZGlyZWN0bHkgY2FuIGxlYWQgdG8gdW5kZWZpbmVkIGJlaGF2aW9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xtLVNjcm9sbEJhci1idXR0b24nKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbEJhci5wcm90b3R5cGUsIFwiaW5jcmVtZW50Tm9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Nyb2xsIGJhciBpbmNyZW1lbnQgYnV0dG9uIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogTW9kaWZ5aW5nIHRoaXMgbm9kZSBkaXJlY3RseSBjYW4gbGVhZCB0byB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG0tU2Nyb2xsQmFyLWJ1dHRvbicpWzFdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsQmFyLnByb3RvdHlwZSwgXCJ0cmFja05vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjcm9sbCBiYXIgdHJhY2sgbm9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBNb2RpZnlpbmcgdGhpcyBub2RlIGRpcmVjdGx5IGNhbiBsZWFkIHRvIHVuZGVmaW5lZCBiZWhhdmlvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsbS1TY3JvbGxCYXItdHJhY2snKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbEJhci5wcm90b3R5cGUsIFwidGh1bWJOb2RlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY3JvbGwgYmFyIHRodW1iIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogTW9kaWZ5aW5nIHRoaXMgbm9kZSBkaXJlY3RseSBjYW4gbGVhZCB0byB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG0tU2Nyb2xsQmFyLXRodW1iJylbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIHNjcm9sbCBiYXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgRE9NIGV2ZW50IHNlbnQgdG8gdGhlIHNjcm9sbCBiYXIuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgRE9NIGBFdmVudExpc3RlbmVyYCBpbnRlcmZhY2UgYW5kIGlzXG4gICAgICogY2FsbGVkIGluIHJlc3BvbnNlIHRvIGV2ZW50cyBvbiB0aGUgc2Nyb2xsIGJhcidzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSBieSB1c2VyIGNvZGUuXG4gICAgICovXG4gICAgU2Nyb2xsQmFyLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0TW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V2dE1vdXNlVXAoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZ0S2V5RG93bihldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgaW52b2tlZCBvbiBhICdiZWZvcmUtYXR0YWNoJyBtZXNzYWdlLlxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUub25CZWZvcmVBdHRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIGludm9rZWQgb24gYW4gJ2FmdGVyLWRldGFjaCcgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLm9uQWZ0ZXJEZXRhY2ggPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVsZWFzZU1vdXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCBpbnZva2VkIG9uIGFuICd1cGRhdGUtcmVxdWVzdCcgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLm9uVXBkYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgYW5kIHBhZ2UgaW50byBwZXJjZW50YWdlcy5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWUgKiAxMDAgLyB0aGlzLl9tYXhpbXVtO1xuICAgICAgICB2YXIgcGFnZSA9IHRoaXMuX3BhZ2UgKiAxMDAgLyAodGhpcy5fcGFnZSArIHRoaXMuX21heGltdW0pO1xuICAgICAgICAvLyBDbGFtcCB0aGUgdmFsdWUgYW5kIHBhZ2UgdG8gdGhlIHJlbGV2YW50IHJhbmdlLlxuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZhbHVlLCAxMDApKTtcbiAgICAgICAgcGFnZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2UsIDEwMCkpO1xuICAgICAgICAvLyBGZXRjaCB0aGUgdGh1bWIgc3R5bGUuXG4gICAgICAgIHZhciB0aHVtYlN0eWxlID0gdGhpcy50aHVtYk5vZGUuc3R5bGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGh1bWIgc3R5bGUgZm9yIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uLlxuICAgICAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGh1bWJTdHlsZS50b3AgPSAnJztcbiAgICAgICAgICAgIHRodW1iU3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICB0aHVtYlN0eWxlLmxlZnQgPSB2YWx1ZSArIFwiJVwiO1xuICAgICAgICAgICAgdGh1bWJTdHlsZS53aWR0aCA9IHBhZ2UgKyBcIiVcIjtcbiAgICAgICAgICAgIHRodW1iU3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyAtdmFsdWUgKyBcIiUsIDAlKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGh1bWJTdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgICAgICB0aHVtYlN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgICAgICB0aHVtYlN0eWxlLnRvcCA9IHZhbHVlICsgXCIlXCI7XG4gICAgICAgICAgICB0aHVtYlN0eWxlLmhlaWdodCA9IHBhZ2UgKyBcIiVcIjtcbiAgICAgICAgICAgIHRodW1iU3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoMCUsIFwiICsgLXZhbHVlICsgXCIlKVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAna2V5ZG93bidgIGV2ZW50IGZvciB0aGUgc2Nyb2xsIGJhci5cbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLl9ldnRLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGlucHV0IGV2ZW50cyBkdXJpbmcgZHJhZy5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIElnbm9yZSBhbnl0aGluZyBleGNlcHQgdGhlIGBFc2NhcGVgIGtleS5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IDI3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHByZXZpb3VzIHNjcm9sbCB2YWx1ZS5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcHJlc3NEYXRhID8gdGhpcy5fcHJlc3NEYXRhLnZhbHVlIDogLTE7XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlLlxuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgb2xkIHNjcm9sbCB2YWx1ZSBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbW92ZVRodW1iKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgJ21vdXNlZG93bidgIGV2ZW50IGZvciB0aGUgc2Nyb2xsIGJhci5cbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLl9ldnRNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBpdCdzIG5vdCBhIGxlZnQgbW91c2UgcHJlc3MuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZW5kIGFuIGFjdGl2YXRlIHJlcXVlc3QgdG8gdGhlIHNjcm9sbCBiYXIuIFRoaXMgY2FuIGJlXG4gICAgICAgIC8vIHVzZWQgYnkgbWVzc2FnZSBob29rcyB0byBhY3RpdmF0ZSBzb21ldGhpbmcgcmVsZXZhbnQuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbW91c2UgaXMgYWxyZWFkeSBjYXB0dXJlZC5cbiAgICAgICAgaWYgKHRoaXMuX3ByZXNzRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIHByZXNzZWQgc2Nyb2xsIGJhciBwYXJ0LlxuICAgICAgICB2YXIgcGFydCA9IFByaXZhdGUkaC5maW5kUGFydCh0aGlzLCBldmVudC50YXJnZXQpO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBwYXJ0IGlzIG5vdCBvZiBpbnRlcmVzdC5cbiAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgbW91c2UgY3Vyc29yLlxuICAgICAgICB2YXIgb3ZlcnJpZGUgPSBEcmFnLm92ZXJyaWRlQ3Vyc29yKCdkZWZhdWx0Jyk7XG4gICAgICAgIC8vIFNldCB1cCB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhID0ge1xuICAgICAgICAgICAgcGFydDogcGFydCwgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuICAgICAgICAgICAgZGVsdGE6IC0xLCB2YWx1ZTogLTEsXG4gICAgICAgICAgICBtb3VzZVg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBtb3VzZVk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIHRoZSBleHRyYSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgLy8gSGFuZGxlIGEgdGh1bWIgcHJlc3MuXG4gICAgICAgIGlmIChwYXJ0ID09PSAndGh1bWInKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgdGh1bWIgbm9kZS5cbiAgICAgICAgICAgIHZhciB0aHVtYk5vZGUgPSB0aGlzLnRodW1iTm9kZTtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjbGllbnQgcmVjdCBmb3IgdGhlIHRodW1iLlxuICAgICAgICAgICAgdmFyIHRodW1iUmVjdCA9IHRodW1iTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJlc3MgZGF0YSBkZWx0YSBmb3IgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNzRGF0YS5kZWx0YSA9IGV2ZW50LmNsaWVudFggLSB0aHVtYlJlY3QubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNzRGF0YS5kZWx0YSA9IGV2ZW50LmNsaWVudFkgLSB0aHVtYlJlY3QudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBhY3RpdmUgY2xhc3MgdG8gdGhlIHRodW1iIG5vZGUuXG4gICAgICAgICAgICB0aHVtYk5vZGUuY2xhc3NMaXN0LmFkZCgnbG0tbW9kLWFjdGl2ZScpO1xuICAgICAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICB0aHVtYk5vZGUuY2xhc3NMaXN0LmFkZCgncC1tb2QtYWN0aXZlJyk7XG4gICAgICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCB2YWx1ZSBpbiB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgICAgIHRoaXMuX3ByZXNzRGF0YS52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgLy8gRmluaXNoZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGEgdHJhY2sgcHJlc3MuXG4gICAgICAgIGlmIChwYXJ0ID09PSAndHJhY2snKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgY2xpZW50IHJlY3QgZm9yIHRoZSB0aHVtYi5cbiAgICAgICAgICAgIHZhciB0aHVtYlJlY3QgPSB0aGlzLnRodW1iTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgZGlyZWN0aW9uIGZvciB0aGUgcGFnZSByZXF1ZXN0LlxuICAgICAgICAgICAgdmFyIGRpciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgZGlyID0gZXZlbnQuY2xpZW50WCA8IHRodW1iUmVjdC5sZWZ0ID8gJ2RlY3JlbWVudCcgOiAnaW5jcmVtZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpciA9IGV2ZW50LmNsaWVudFkgPCB0aHVtYlJlY3QudG9wID8gJ2RlY3JlbWVudCcgOiAnaW5jcmVtZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXBlYXQgdGltZXIuXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX29uUmVwZWF0LCAzNTApO1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgcGFnZSByZXF1ZXN0ZWQgc2lnbmFsLlxuICAgICAgICAgICAgdGhpcy5fcGFnZVJlcXVlc3RlZC5lbWl0KGRpcik7XG4gICAgICAgICAgICAvLyBGaW5pc2hlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYSBkZWNyZW1lbnQgYnV0dG9uIHByZXNzLlxuICAgICAgICBpZiAocGFydCA9PT0gJ2RlY3JlbWVudCcpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYWN0aXZlIGNsYXNzIHRvIHRoZSBkZWNyZW1lbnQgbm9kZS5cbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtYWN0aXZlJyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdwLW1vZC1hY3RpdmUnKTtcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXBlYXQgdGltZXIuXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX29uUmVwZWF0LCAzNTApO1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgc3RlcCByZXF1ZXN0ZWQgc2lnbmFsLlxuICAgICAgICAgICAgdGhpcy5fc3RlcFJlcXVlc3RlZC5lbWl0KCdkZWNyZW1lbnQnKTtcbiAgICAgICAgICAgIC8vIEZpbmlzaGVkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbiBpbmNyZW1lbnQgYnV0dG9uIHByZXNzLlxuICAgICAgICBpZiAocGFydCA9PT0gJ2luY3JlbWVudCcpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYWN0aXZlIGNsYXNzIHRvIHRoZSBpbmNyZW1lbnQgbm9kZS5cbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdsbS1tb2QtYWN0aXZlJyk7XG4gICAgICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdwLW1vZC1hY3RpdmUnKTtcbiAgICAgICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXBlYXQgdGltZXIuXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX29uUmVwZWF0LCAzNTApO1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgc3RlcCByZXF1ZXN0ZWQgc2lnbmFsLlxuICAgICAgICAgICAgdGhpcy5fc3RlcFJlcXVlc3RlZC5lbWl0KCdpbmNyZW1lbnQnKTtcbiAgICAgICAgICAgIC8vIEZpbmlzaGVkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2Vtb3ZlJ2AgZXZlbnQgZm9yIHRoZSBzY3JvbGwgYmFyLlxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuX2V2dE1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG5vIGRyYWcgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIGlmICghdGhpcy5fcHJlc3NEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLl9wcmVzc0RhdGEubW91c2VYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhLm1vdXNlWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlIHRodW1iIGlzIG5vdCBiZWluZyBkcmFnZ2VkLlxuICAgICAgICBpZiAodGhpcy5fcHJlc3NEYXRhLnBhcnQgIT09ICd0aHVtYicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGNsaWVudCByZWN0IGZvciB0aGUgdGh1bWIgYW5kIHRyYWNrLlxuICAgICAgICB2YXIgdGh1bWJSZWN0ID0gdGhpcy50aHVtYk5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB0cmFja1JlY3QgPSB0aGlzLnRyYWNrTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHNjcm9sbCBnZW9tZXRyeSBiYXNlZCBvbiB0aGUgb3JpZW50YXRpb24uXG4gICAgICAgIHZhciB0cmFja1BvcztcbiAgICAgICAgdmFyIHRyYWNrU3BhbjtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRyYWNrUG9zID0gZXZlbnQuY2xpZW50WCAtIHRyYWNrUmVjdC5sZWZ0IC0gdGhpcy5fcHJlc3NEYXRhLmRlbHRhO1xuICAgICAgICAgICAgdHJhY2tTcGFuID0gdHJhY2tSZWN0LndpZHRoIC0gdGh1bWJSZWN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tQb3MgPSBldmVudC5jbGllbnRZIC0gdHJhY2tSZWN0LnRvcCAtIHRoaXMuX3ByZXNzRGF0YS5kZWx0YTtcbiAgICAgICAgICAgIHRyYWNrU3BhbiA9IHRyYWNrUmVjdC5oZWlnaHQgLSB0aHVtYlJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGRlc2lyZWQgdmFsdWUgZnJvbSB0aGUgc2Nyb2xsIGdlb21ldHJ5LlxuICAgICAgICB2YXIgdmFsdWUgPSB0cmFja1NwYW4gPT09IDAgPyAwIDogdHJhY2tQb3MgKiB0aGlzLl9tYXhpbXVtIC8gdHJhY2tTcGFuO1xuICAgICAgICAvLyBNb3ZlIHRoZSB0aHVtYiB0byB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAgICAgIHRoaXMuX21vdmVUaHVtYih2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGAnbW91c2V1cCdgIGV2ZW50IGZvciB0aGUgc2Nyb2xsIGJhci5cbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLl9ldnRNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgaXQncyBub3QgYSBsZWZ0IG1vdXNlIHJlbGVhc2UuXG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIFJlbGVhc2UgdGhlIG1vdXNlLlxuICAgICAgICB0aGlzLl9yZWxlYXNlTW91c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIG1vdXNlIGFuZCByZXN0b3JlIHRoZSBub2RlIHN0YXRlcy5cbiAgICAgKi9cbiAgICBTY3JvbGxCYXIucHJvdG90eXBlLl9yZWxlYXNlTW91c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhaWwgaWYgdGhlcmUgaXMgbm8gcHJlc3MgZGF0YS5cbiAgICAgICAgaWYgKCF0aGlzLl9wcmVzc0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0aGUgcmVwZWF0IHRpbWVyLlxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVwZWF0VGltZXIpO1xuICAgICAgICB0aGlzLl9yZXBlYXRUaW1lciA9IC0xO1xuICAgICAgICAvLyBDbGVhciB0aGUgcHJlc3MgZGF0YS5cbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhLm92ZXJyaWRlLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcHJlc3NEYXRhID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHRyYSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3NlcyBmcm9tIHRoZSBub2Rlcy5cbiAgICAgICAgdGhpcy50aHVtYk5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnbG0tbW9kLWFjdGl2ZScpO1xuICAgICAgICB0aGlzLmRlY3JlbWVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnbG0tbW9kLWFjdGl2ZScpO1xuICAgICAgICB0aGlzLmluY3JlbWVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnbG0tbW9kLWFjdGl2ZScpO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgdGhpcy50aHVtYk5vZGUuY2xhc3NMaXN0LnJlbW92ZSgncC1tb2QtYWN0aXZlJyk7XG4gICAgICAgIHRoaXMuZGVjcmVtZW50Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdwLW1vZC1hY3RpdmUnKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnROb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ3AtbW9kLWFjdGl2ZScpO1xuICAgICAgICAvKiA8L0RFUFJFQ0FURUQ+ICovXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSB0aHVtYiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFNjcm9sbEJhci5wcm90b3R5cGUuX21vdmVUaHVtYiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBDbGFtcCB0aGUgdmFsdWUgdG8gdGhlIGFsbG93ZWQgcmFuZ2UuXG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmFsdWUsIHRoaXMuX21heGltdW0pKTtcbiAgICAgICAgLy8gQmFpbCBpZiB0aGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCB2YWx1ZS5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9mIHRoZSBzY3JvbGwgYmFyLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAvLyBFbWl0IHRoZSB0aHVtYiBtb3ZlZCBzaWduYWwuXG4gICAgICAgIHRoaXMuX3RodW1iTW92ZWQuZW1pdCh2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsQmFyO1xufShXaWRnZXQpKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSBmb3IgdGhlIG1vZHVsZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG52YXIgUHJpdmF0ZSRoO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBET00gbm9kZSBmb3IgYSBzY3JvbGwgYmFyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBkZWNyZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGluY3JlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIHRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlY3JlbWVudC5jbGFzc05hbWUgPSAnbG0tU2Nyb2xsQmFyLWJ1dHRvbic7XG4gICAgICAgIGluY3JlbWVudC5jbGFzc05hbWUgPSAnbG0tU2Nyb2xsQmFyLWJ1dHRvbic7XG4gICAgICAgIGRlY3JlbWVudC5kYXRhc2V0WydhY3Rpb24nXSA9ICdkZWNyZW1lbnQnO1xuICAgICAgICBpbmNyZW1lbnQuZGF0YXNldFsnYWN0aW9uJ10gPSAnaW5jcmVtZW50JztcbiAgICAgICAgdHJhY2suY2xhc3NOYW1lID0gJ2xtLVNjcm9sbEJhci10cmFjayc7XG4gICAgICAgIHRodW1iLmNsYXNzTmFtZSA9ICdsbS1TY3JvbGxCYXItdGh1bWInO1xuICAgICAgICAvKiA8REVQUkVDQVRFRD4gKi9cbiAgICAgICAgZGVjcmVtZW50LmNsYXNzTGlzdC5hZGQoJ3AtU2Nyb2xsQmFyLWJ1dHRvbicpO1xuICAgICAgICBpbmNyZW1lbnQuY2xhc3NMaXN0LmFkZCgncC1TY3JvbGxCYXItYnV0dG9uJyk7XG4gICAgICAgIHRyYWNrLmNsYXNzTGlzdC5hZGQoJ3AtU2Nyb2xsQmFyLXRyYWNrJyk7XG4gICAgICAgIHRodW1iLmNsYXNzTGlzdC5hZGQoJ3AtU2Nyb2xsQmFyLXRodW1iJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgdHJhY2suYXBwZW5kQ2hpbGQodGh1bWIpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRlY3JlbWVudCk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHJhY2spO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBQcml2YXRlLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHNjcm9sbCBiYXIgcGFydCB3aGljaCBjb250YWlucyB0aGUgZ2l2ZW4gdGFyZ2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRQYXJ0KHNjcm9sbEJhciwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIFRlc3QgdGhlIHRodW1iLlxuICAgICAgICBpZiAoc2Nyb2xsQmFyLnRodW1iTm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RodW1iJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IHRoZSB0cmFjay5cbiAgICAgICAgaWYgKHNjcm9sbEJhci50cmFja05vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICd0cmFjayc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCB0aGUgZGVjcmVtZW50IGJ1dHRvbi5cbiAgICAgICAgaWYgKHNjcm9sbEJhci5kZWNyZW1lbnROb2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVjcmVtZW50JztcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IHRoZSBpbmNyZW1lbnQgYnV0dG9uLlxuICAgICAgICBpZiAoc2Nyb2xsQmFyLmluY3JlbWVudE5vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpbmNyZW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluZGljYXRlIG5vIG1hdGNoLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgUHJpdmF0ZS5maW5kUGFydCA9IGZpbmRQYXJ0O1xufSkoUHJpdmF0ZSRoIHx8IChQcml2YXRlJGggPSB7fSkpO1xuXG4vKipcbiAqIEEgY29uY3JldGUgbGF5b3V0IGltcGxlbWVudGF0aW9uIHdoaWNoIGhvbGRzIGEgc2luZ2xlIHdpZGdldC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgc2ltcGxlIGNvbnRhaW5lciB3aWRnZXRzIHdoaWNoXG4gKiBob2xkIGEgc2luZ2xlIGNoaWxkLiBUaGUgY2hpbGQgc2hvdWxkIGJlIHBvc2l0aW9uZWQgd2l0aCBDU1MuXG4gKi9cbnZhciBTaW5nbGV0b25MYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpbmdsZXRvbkxheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaW5nbGV0b25MYXlvdXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fd2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgbGF5b3V0LlxuICAgICAqL1xuICAgIFNpbmdsZXRvbkxheW91dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dpZGdldCkge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuX3dpZGdldDtcbiAgICAgICAgICAgIHRoaXMuX3dpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB3aWRnZXQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbmdsZXRvbkxheW91dC5wcm90b3R5cGUsIFwid2lkZ2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2hpbGQgd2lkZ2V0IGZvciB0aGUgbGF5b3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkZ2V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjaGlsZCB3aWRnZXQgZm9yIHRoZSBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogU2V0dGluZyB0aGUgY2hpbGQgd2lkZ2V0IHdpbGwgY2F1c2UgdGhlIG9sZCBjaGlsZCB3aWRnZXQgdG8gYmVcbiAgICAgICAgICogYXV0b21hdGljYWxseSBkaXNwb3NlZC4gSWYgdGhhdCBpcyBub3QgZGVzaXJlZCwgc2V0IHRoZSBwYXJlbnRcbiAgICAgICAgICogb2YgdGhlIG9sZCBjaGlsZCB0byBgbnVsbGAgYmVmb3JlIGFzc2lnbmluZyBhIG5ldyBjaGlsZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB3aWRnZXQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnQuIFRoaXMgaXMgYSBuby1vcFxuICAgICAgICAgICAgLy8gaWYgdGhlIHdpZGdldCdzIHBhcmVudCBpcyBhbHJlYWR5IHRoZSBsYXlvdXQgcGFyZW50IHdpZGdldC5cbiAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB3aWRnZXQgZG9lcyBub3QgY2hhbmdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZGdldCA9PT0gd2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgb2xkIGNoaWxkIHdpZGdldC5cbiAgICAgICAgICAgIGlmICh0aGlzLl93aWRnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWRnZXQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCB3aWRnZXQuXG4gICAgICAgICAgICB0aGlzLl93aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIG5ldyBjaGlsZCB3aWRnZXQgaWYgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHdpZGdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoV2lkZ2V0KHdpZGdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpdGVyYXRvciBvdmVyIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpdGVyYXRvciBvdmVyIHRoZSB3aWRnZXRzIGluIHRoZSBsYXlvdXQuXG4gICAgICovXG4gICAgU2luZ2xldG9uTGF5b3V0LnByb3RvdHlwZS5pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkZ2V0ID8gb25jZSh0aGlzLl93aWRnZXQpIDogZW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHdpZGdldCBmcm9tIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIEEgd2lkZ2V0IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSBsYXlvdXQgd2hlbiBpdHMgYHBhcmVudGBcbiAgICAgKiBpcyBzZXQgdG8gYG51bGxgLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBpbnZva2VkIGRpcmVjdGx5IHdoZW5cbiAgICAgKiByZW1vdmluZyBhIHdpZGdldCBmcm9tIGEgbGF5b3V0IHdoaWNoIGhhcyB5ZXQgdG8gYmUgaW5zdGFsbGVkIG9uIGFcbiAgICAgKiBwYXJlbnQgd2lkZ2V0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyAqbm90KiBtb2RpZnkgdGhlIHdpZGdldCdzIGBwYXJlbnRgLlxuICAgICAqL1xuICAgIFNpbmdsZXRvbkxheW91dC5wcm90b3R5cGUucmVtb3ZlV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICAvLyBCYWlsIGVhcmx5IGlmIHRoZSB3aWRnZXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxheW91dC5cbiAgICAgICAgaWYgKHRoaXMuX3dpZGdldCAhPT0gd2lkZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGludGVybmFsIHdpZGdldC5cbiAgICAgICAgdGhpcy5fd2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBwYXJlbnRlZCwgZGV0YWNoIHRoZSB3aWRnZXQgZnJvbSB0aGUgRE9NLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoV2lkZ2V0KHdpZGdldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gbGF5b3V0IGluaXRpYWxpemF0aW9uIHdoaWNoIHJlcXVpcmVzIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAqL1xuICAgIFNpbmdsZXRvbkxheW91dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG4gICAgICAgIGVhY2godGhpcywgZnVuY3Rpb24gKHdpZGdldCkgeyBfdGhpcy5hdHRhY2hXaWRnZXQod2lkZ2V0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSB3aWRnZXQgdG8gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHdpZGdldCBpbiB0aGUgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYXR0YWNoIHRvIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHNpbmdsZSBsYXlvdXQgYXQgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgdGltZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgdXNlciBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYWRkcyB0aGUgd2lkZ2V0cydzIG5vZGUgdG8gdGhlIHBhcmVudCdzXG4gICAgICogbm9kZSBhdCB0aGUgcHJvcGVyIGxvY2F0aW9uLCBhbmQgc2VuZHMgdGhlIGFwcHJvcHJpYXRlIGF0dGFjaFxuICAgICAqIG1lc3NhZ2VzIHRvIHRoZSB3aWRnZXQgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyBtYXkgcmVpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gY29udHJvbCBob3cgdGhlIHdpZGdldCdzXG4gICAgICogbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFyZW50J3Mgbm9kZS5cbiAgICAgKi9cbiAgICBTaW5nbGV0b25MYXlvdXQucHJvdG90eXBlLmF0dGFjaFdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVBdHRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgd2lkZ2V0J3Mgbm9kZSB0byB0aGUgcGFyZW50LlxuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHdpZGdldC5ub2RlKTtcbiAgICAgICAgLy8gU2VuZCBhbiBgJ2FmdGVyLWF0dGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5BZnRlckF0dGFjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCBhIHdpZGdldCBmcm9tIHRoZSBwYXJlbnQncyBET00gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGRldGFjaCBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHNpbmdsZSBsYXlvdXQgYXQgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgdGltZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgYnkgdXNlciBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVtb3ZlcyB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZVxuICAgICAqIHBhcmVudCdzIG5vZGUsIGFuZCBzZW5kcyB0aGUgYXBwcm9wcmlhdGUgZGV0YWNoIG1lc3NhZ2VzIHRvIHRoZVxuICAgICAqIHdpZGdldCBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIG1heSByZWltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBjb250cm9sIGhvdyB0aGUgd2lkZ2V0J3NcbiAgICAgKiBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50J3Mgbm9kZS5cbiAgICAgKi9cbiAgICBTaW5nbGV0b25MYXlvdXQucHJvdG90eXBlLmRldGFjaFdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyRGV0YWNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZXRvbkxheW91dDtcbn0oTGF5b3V0KSk7XG5cbi8qKlxuICogQSBsYXlvdXQgd2hlcmUgdmlzaWJsZSB3aWRnZXRzIGFyZSBzdGFja2VkIGF0b3Agb25lIGFub3RoZXIuXG4gKlxuICogIyMjIyBOb3Rlc1xuICogVGhlIFotb3JkZXIgb2YgdGhlIHZpc2libGUgd2lkZ2V0cyBmb2xsb3dzIHRoZWlyIGxheW91dCBvcmRlci5cbiAqL1xudmFyIFN0YWNrZWRMYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YWNrZWRMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2tlZExheW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2JveCA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIGxheW91dC5cbiAgICAgKi9cbiAgICBTdGFja2VkTGF5b3V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSBsYXlvdXQgaXRlbXMuXG4gICAgICAgIGVhY2godGhpcy5faXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7IGl0ZW0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGxheW91dCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fYm94ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgcmVzdCBvZiB0aGUgbGF5b3V0LlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIHdpZGdldCB0byB0aGUgcGFyZW50J3MgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgd2lkZ2V0IGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBhdHRhY2ggdG8gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAgICovXG4gICAgU3RhY2tlZExheW91dC5wcm90b3R5cGUuYXR0YWNoV2lkZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgYSBuZXcgbGF5b3V0IGl0ZW0gZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIEFycmF5RXh0Lmluc2VydCh0aGlzLl9pdGVtcywgaW5kZXgsIG5ldyBMYXlvdXRJdGVtKHdpZGdldCkpO1xuICAgICAgICAvLyBTZW5kIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkJlZm9yZUF0dGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB3aWRnZXQncyBub2RlIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUuYXBwZW5kQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItYXR0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyQXR0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgYSB3aWRnZXQgaW4gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21JbmRleCAtIFRoZSBwcmV2aW91cyBpbmRleCBvZiB0aGUgd2lkZ2V0IGluIHRoZSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9JbmRleCAtIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSB3aWRnZXQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIG1vdmUgaW4gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGlzIGlzIGEgcmVpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAgICovXG4gICAgU3RhY2tlZExheW91dC5wcm90b3R5cGUubW92ZVdpZGdldCA9IGZ1bmN0aW9uIChmcm9tSW5kZXgsIHRvSW5kZXgsIHdpZGdldCkge1xuICAgICAgICAvLyBNb3ZlIHRoZSBsYXlvdXQgaXRlbSBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgQXJyYXlFeHQubW92ZSh0aGlzLl9pdGVtcywgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgLy8gUG9zdCBhbiB1cGRhdGUgcmVxdWVzdCBmb3IgdGhlIHBhcmVudCB3aWRnZXQuXG4gICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoIGEgd2lkZ2V0IGZyb20gdGhlIHBhcmVudCdzIERPTSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIHByZXZpb3VzIGluZGV4IG9mIHRoZSB3aWRnZXQgaW4gdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgLSBUaGUgd2lkZ2V0IHRvIGRldGFjaCBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogVGhpcyBpcyBhIHJlaW1wbGVtZW50YXRpb24gb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kLlxuICAgICAqL1xuICAgIFN0YWNrZWRMYXlvdXQucHJvdG90eXBlLmRldGFjaFdpZGdldCA9IGZ1bmN0aW9uIChpbmRleCwgd2lkZ2V0KSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGF5b3V0IGl0ZW0gZm9yIHRoZSB3aWRnZXQuXG4gICAgICAgIHZhciBpdGVtID0gQXJyYXlFeHQucmVtb3ZlQXQodGhpcy5faXRlbXMsIGluZGV4KTtcbiAgICAgICAgLy8gU2VuZCBhIGAnYmVmb3JlLWRldGFjaCdgIG1lc3NhZ2UgaWYgdGhlIHBhcmVudCBpcyBhdHRhY2hlZC5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHdpZGdldCwgV2lkZ2V0Lk1zZy5CZWZvcmVEZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2lkZ2V0J3Mgbm9kZSBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgIHRoaXMucGFyZW50Lm5vZGUucmVtb3ZlQ2hpbGQod2lkZ2V0Lm5vZGUpO1xuICAgICAgICAvLyBTZW5kIGFuIGAnYWZ0ZXItZGV0YWNoJ2AgbWVzc2FnZSBpZiB0aGUgcGFyZW50IGlzIGF0dGFjaGVkLlxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2Uod2lkZ2V0LCBXaWRnZXQuTXNnLkFmdGVyRGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgei1pbmRleCBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgaXRlbS53aWRnZXQubm9kZS5zdHlsZS56SW5kZXggPSAnJztcbiAgICAgICAgLy8gRGlzcG9zZSBvZiB0aGUgbGF5b3V0IGl0ZW0uXG4gICAgICAgIGl0ZW0uZGlzcG9zZSgpO1xuICAgICAgICAvLyBQb3N0IGEgZml0IHJlcXVlc3QgZm9yIHRoZSBwYXJlbnQgd2lkZ2V0LlxuICAgICAgICB0aGlzLnBhcmVudC5maXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2JlZm9yZS1zaG93J2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdGFja2VkTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZVNob3cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25CZWZvcmVTaG93LmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdiZWZvcmUtYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdGFja2VkTGF5b3V0LnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkJlZm9yZUF0dGFjaC5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtc2hvd24nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFN0YWNrZWRMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRTaG93biA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdjaGlsZC1oaWRkZW4nYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFN0YWNrZWRMYXlvdXQucHJvdG90eXBlLm9uQ2hpbGRIaWRkZW4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmZpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAncmVzaXplJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdGFja2VkTGF5b3V0LnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKG1zZy53aWR0aCwgbXNnLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYW4gYCd1cGRhdGUtcmVxdWVzdCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3RhY2tlZExheW91dC5wcm90b3R5cGUub25VcGRhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoLTEsIC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnZml0LXJlcXVlc3QnYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFN0YWNrZWRMYXlvdXQucHJvdG90eXBlLm9uRml0UmVxdWVzdCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXQgdGhlIGxheW91dCB0byB0aGUgdG90YWwgc2l6ZSByZXF1aXJlZCBieSB0aGUgd2lkZ2V0cy5cbiAgICAgKi9cbiAgICBTdGFja2VkTGF5b3V0LnByb3RvdHlwZS5fZml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGNvbXB1dGVkIG1pbmltdW0gc2l6ZS5cbiAgICAgICAgdmFyIG1pblcgPSAwO1xuICAgICAgICB2YXIgbWluSCA9IDA7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tcHV0ZWQgbWluaW11bSBzaXplLlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGl0ZW0uXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1zW2ldO1xuICAgICAgICAgICAgLy8gSWdub3JlIGhpZGRlbiBpdGVtcy5cbiAgICAgICAgICAgIGlmIChpdGVtLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNpemUgbGltaXRzIGZvciB0aGUgaXRlbS5cbiAgICAgICAgICAgIGl0ZW0uZml0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbXB1dGVkIG1pbmltdW0gc2l6ZS5cbiAgICAgICAgICAgIG1pblcgPSBNYXRoLm1heChtaW5XLCBpdGVtLm1pbldpZHRoKTtcbiAgICAgICAgICAgIG1pbkggPSBNYXRoLm1heChtaW5ILCBpdGVtLm1pbkhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBib3ggc2l6aW5nIGFuZCBhZGQgaXQgdG8gdGhlIGNvbXB1dGVkIG1pbiBzaXplLlxuICAgICAgICB2YXIgYm94ID0gdGhpcy5fYm94ID0gRWxlbWVudEV4dC5ib3hTaXppbmcodGhpcy5wYXJlbnQubm9kZSk7XG4gICAgICAgIG1pblcgKz0gYm94Lmhvcml6b250YWxTdW07XG4gICAgICAgIG1pbkggKz0gYm94LnZlcnRpY2FsU3VtO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHBhcmVudCdzIG1pbiBzaXplIGNvbnN0cmFpbnRzLlxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnBhcmVudC5ub2RlLnN0eWxlO1xuICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pblcgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLm1pbkhlaWdodCA9IG1pbkggKyBcInB4XCI7XG4gICAgICAgIC8vIFNldCB0aGUgZGlydHkgZmxhZyB0byBlbnN1cmUgb25seSBhIHNpbmdsZSB1cGRhdGUgb2NjdXJzLlxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIC8vIE5vdGlmeSB0aGUgYW5jZXN0b3IgdGhhdCBpdCBzaG91bGQgZml0IGltbWVkaWF0ZWx5LiBUaGlzIG1heVxuICAgICAgICAvLyBjYXVzZSBhIHJlc2l6ZSBvZiB0aGUgcGFyZW50LCBmdWxmaWxsaW5nIHRoZSByZXF1aXJlZCB1cGRhdGUuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIE1lc3NhZ2VMb29wLnNlbmRNZXNzYWdlKHRoaXMucGFyZW50LnBhcmVudCwgV2lkZ2V0Lk1zZy5GaXRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZGlydHkgZmxhZyBpcyBzdGlsbCBzZXQsIHRoZSBwYXJlbnQgd2FzIG5vdCByZXNpemVkLlxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSByZXF1aXJlZCB1cGRhdGUgb24gdGhlIHBhcmVudCB3aWRnZXQgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3Auc2VuZE1lc3NhZ2UodGhpcy5wYXJlbnQsIFdpZGdldC5Nc2cuVXBkYXRlUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgbGF5b3V0IHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSB3aWRnZXRzLlxuICAgICAqXG4gICAgICogVGhlIHBhcmVudCBvZmZzZXQgZGltZW5zaW9ucyBzaG91bGQgYmUgYC0xYCBpZiB1bmtub3duLlxuICAgICAqL1xuICAgIFN0YWNrZWRMYXlvdXQucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAob2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCkge1xuICAgICAgICAvLyBDbGVhciB0aGUgZGlydHkgZmxhZyB0byBpbmRpY2F0ZSB0aGUgdXBkYXRlIG9jY3VycmVkLlxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSB2aXNpYmxlIGl0ZW0gY291bnQuXG4gICAgICAgIHZhciBuVmlzaWJsZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBuVmlzaWJsZSArPSArIXRoaXMuX2l0ZW1zW2ldLmlzSGlkZGVuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhaWwgZWFybHkgaWYgdGhlcmUgYXJlIG5vIHZpc2libGUgaXRlbXMgdG8gbGF5b3V0LlxuICAgICAgICBpZiAoblZpc2libGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZWFzdXJlIHRoZSBwYXJlbnQgaWYgdGhlIG9mZnNldCBkaW1lbnNpb25zIGFyZSB1bmtub3duLlxuICAgICAgICBpZiAob2Zmc2V0V2lkdGggPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXRXaWR0aCA9IHRoaXMucGFyZW50Lm5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IHRoaXMucGFyZW50Lm5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcGFyZW50IGJveCBzaXppbmcgZGF0YSBpcyBjb21wdXRlZC5cbiAgICAgICAgaWYgKCF0aGlzLl9ib3gpIHtcbiAgICAgICAgICAgIHRoaXMuX2JveCA9IEVsZW1lbnRFeHQuYm94U2l6aW5nKHRoaXMucGFyZW50Lm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFjdHVhbCBsYXlvdXQgYm91bmRzIGFkanVzdGVkIGZvciBib3JkZXIgYW5kIHBhZGRpbmcuXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLl9ib3gucGFkZGluZ1RvcDtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLl9ib3gucGFkZGluZ0xlZnQ7XG4gICAgICAgIHZhciB3aWR0aCA9IG9mZnNldFdpZHRoIC0gdGhpcy5fYm94Lmhvcml6b250YWxTdW07XG4gICAgICAgIHZhciBoZWlnaHQgPSBvZmZzZXRIZWlnaHQgLSB0aGlzLl9ib3gudmVydGljYWxTdW07XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgd2lkZ2V0IHN0YWNraW5nIG9yZGVyIGFuZCBsYXlvdXQgZ2VvbWV0cnkuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaXRlbS5cbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICAvLyBJZ25vcmUgaGlkZGVuIGl0ZW1zLlxuICAgICAgICAgICAgaWYgKGl0ZW0uaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgei1pbmRleCBmb3IgdGhlIHdpZGdldC5cbiAgICAgICAgICAgIGl0ZW0ud2lkZ2V0Lm5vZGUuc3R5bGUuekluZGV4ID0gXCJcIiArIGk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGl0ZW0gZ2VvbWV0cnkuXG4gICAgICAgICAgICBpdGVtLnVwZGF0ZShsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2tlZExheW91dDtcbn0oUGFuZWxMYXlvdXQpKTtcblxuLyoqXG4gKiBBIHBhbmVsIHdoZXJlIHZpc2libGUgd2lkZ2V0cyBhcmUgc3RhY2tlZCBhdG9wIG9uZSBhbm90aGVyLlxuICpcbiAqICMjIyMgTm90ZXNcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCBhIFtbU3RhY2tlZExheW91dF1dLlxuICovXG52YXIgU3RhY2tlZFBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFja2VkUGFuZWwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IHN0YWNrZWQgcGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIHBhbmVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrZWRQYW5lbChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHsgbGF5b3V0OiBQcml2YXRlJGkuY3JlYXRlTGF5b3V0KG9wdGlvbnMpIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl93aWRnZXRSZW1vdmVkID0gbmV3IFNpZ25hbChfdGhpcyk7XG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdsbS1TdGFja2VkUGFuZWwnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdwLVN0YWNrZWRQYW5lbCcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrZWRQYW5lbC5wcm90b3R5cGUsIFwid2lkZ2V0UmVtb3ZlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gYSB3aWRnZXQgaXMgcmVtb3ZlZCBmcm9tIGEgc3RhY2tlZCBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZGdldFJlbW92ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYW5kbGVyIGludm9rZWQgb24gYSBgJ2NoaWxkLWFkZGVkJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBTdGFja2VkUGFuZWwucHJvdG90eXBlLm9uQ2hpbGRBZGRlZCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgbXNnLmNoaWxkLmFkZENsYXNzKCdsbS1TdGFja2VkUGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIG1zZy5jaGlsZC5hZGRDbGFzcygncC1TdGFja2VkUGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXNzYWdlIGhhbmRsZXIgaW52b2tlZCBvbiBhIGAnY2hpbGQtcmVtb3ZlZCdgIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3RhY2tlZFBhbmVsLnByb3RvdHlwZS5vbkNoaWxkUmVtb3ZlZCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgbXNnLmNoaWxkLnJlbW92ZUNsYXNzKCdsbS1TdGFja2VkUGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIG1zZy5jaGlsZC5yZW1vdmVDbGFzcygncC1TdGFja2VkUGFuZWwtY2hpbGQnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICB0aGlzLl93aWRnZXRSZW1vdmVkLmVtaXQobXNnLmNoaWxkKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGFja2VkUGFuZWw7XG59KFBhbmVsKSk7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgZm9yIHRoZSBtb2R1bGUgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqL1xudmFyIFByaXZhdGUkaTtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHN0YWNrZWQgbGF5b3V0IGZvciB0aGUgZ2l2ZW4gcGFuZWwgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVMYXlvdXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sYXlvdXQgfHwgbmV3IFN0YWNrZWRMYXlvdXQoKTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jcmVhdGVMYXlvdXQgPSBjcmVhdGVMYXlvdXQ7XG59KShQcml2YXRlJGkgfHwgKFByaXZhdGUkaSA9IHt9KSk7XG5cbi8qKlxuICogQSB3aWRnZXQgd2hpY2ggY29tYmluZXMgYSBgVGFiQmFyYCBhbmQgYSBgU3RhY2tlZFBhbmVsYC5cbiAqXG4gKiAjIyMjIE5vdGVzXG4gKiBUaGlzIGlzIGEgc2ltcGxlIHBhbmVsIHdoaWNoIGhhbmRsZXMgdGhlIGNvbW1vbiBjYXNlIG9mIGEgdGFiIGJhclxuICogcGxhY2VkIG5leHQgdG8gYSBjb250ZW50IGFyZWEuIFRoZSBzZWxlY3RlZCB0YWIgY29udHJvbHMgdGhlIHdpZGdldFxuICogd2hpY2ggaXMgc2hvd24gaW4gdGhlIGNvbnRlbnQgYXJlYS5cbiAqXG4gKiBGb3IgdXNlIGNhc2VzIHdoaWNoIHJlcXVpcmUgbW9yZSBjb250cm9sIHRoYW4gaXMgcHJvdmlkZWQgYnkgdGhpc1xuICogcGFuZWwsIHRoZSBgVGFiQmFyYCB3aWRnZXQgbWF5IGJlIHVzZWQgaW5kZXBlbmRlbnRseS5cbiAqL1xudmFyIFRhYlBhbmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJQYW5lbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGFiIHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSB0YWIgcGFuZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFiUGFuZWwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY3VycmVudENoYW5nZWQgPSBuZXcgU2lnbmFsKF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2FkZFJlcXVlc3RlZCA9IG5ldyBTaWduYWwoX3RoaXMpO1xuICAgICAgICBfdGhpcy5hZGRDbGFzcygnbG0tVGFiUGFuZWwnKTtcbiAgICAgICAgLyogPERFUFJFQ0FURUQ+ICovXG4gICAgICAgIF90aGlzLmFkZENsYXNzKCdwLVRhYlBhbmVsJyk7XG4gICAgICAgIC8qIDwvREVQUkVDQVRFRD4gKi9cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0YWIgYmFyIGFuZCBzdGFja2VkIHBhbmVsLlxuICAgICAgICBfdGhpcy50YWJCYXIgPSBuZXcgVGFiQmFyKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy50YWJCYXIuYWRkQ2xhc3MoJ2xtLVRhYlBhbmVsLXRhYkJhcicpO1xuICAgICAgICBfdGhpcy5zdGFja2VkUGFuZWwgPSBuZXcgU3RhY2tlZFBhbmVsKCk7XG4gICAgICAgIF90aGlzLnN0YWNrZWRQYW5lbC5hZGRDbGFzcygnbG0tVGFiUGFuZWwtc3RhY2tlZFBhbmVsJyk7XG4gICAgICAgIC8qIDxERVBSRUNBVEVEPiAqL1xuICAgICAgICBfdGhpcy50YWJCYXIuYWRkQ2xhc3MoJ3AtVGFiUGFuZWwtdGFiQmFyJyk7XG4gICAgICAgIF90aGlzLnN0YWNrZWRQYW5lbC5hZGRDbGFzcygncC1UYWJQYW5lbC1zdGFja2VkUGFuZWwnKTtcbiAgICAgICAgLyogPC9ERVBSRUNBVEVEPiAqL1xuICAgICAgICAvLyBDb25uZWN0IHRoZSB0YWIgYmFyIHNpZ25hbCBoYW5kbGVycy5cbiAgICAgICAgX3RoaXMudGFiQmFyLnRhYk1vdmVkLmNvbm5lY3QoX3RoaXMuX29uVGFiTW92ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMudGFiQmFyLmN1cnJlbnRDaGFuZ2VkLmNvbm5lY3QoX3RoaXMuX29uQ3VycmVudENoYW5nZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMudGFiQmFyLnRhYkNsb3NlUmVxdWVzdGVkLmNvbm5lY3QoX3RoaXMuX29uVGFiQ2xvc2VSZXF1ZXN0ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMudGFiQmFyLnRhYkFjdGl2YXRlUmVxdWVzdGVkLmNvbm5lY3QoX3RoaXMuX29uVGFiQWN0aXZhdGVSZXF1ZXN0ZWQsIF90aGlzKTtcbiAgICAgICAgX3RoaXMudGFiQmFyLmFkZFJlcXVlc3RlZC5jb25uZWN0KF90aGlzLl9vblRhYkFkZFJlcXVlc3RlZCwgX3RoaXMpO1xuICAgICAgICAvLyBDb25uZWN0IHRoZSBzdGFja2VkIHBhbmVsIHNpZ25hbCBoYW5kbGVycy5cbiAgICAgICAgX3RoaXMuc3RhY2tlZFBhbmVsLndpZGdldFJlbW92ZWQuY29ubmVjdChfdGhpcy5fb25XaWRnZXRSZW1vdmVkLCBfdGhpcyk7XG4gICAgICAgIC8vIEdldCB0aGUgZGF0YSByZWxhdGVkIHRvIHRoZSBwbGFjZW1lbnQuXG4gICAgICAgIF90aGlzLl90YWJQbGFjZW1lbnQgPSBvcHRpb25zLnRhYlBsYWNlbWVudCB8fCAndG9wJztcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IFByaXZhdGUkai5kaXJlY3Rpb25Gcm9tUGxhY2VtZW50KF90aGlzLl90YWJQbGFjZW1lbnQpO1xuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBQcml2YXRlJGoub3JpZW50YXRpb25Gcm9tUGxhY2VtZW50KF90aGlzLl90YWJQbGFjZW1lbnQpO1xuICAgICAgICAvLyBDb25maWd1cmUgdGhlIHRhYiBiYXIgZm9yIHRoZSBwbGFjZW1lbnQuXG4gICAgICAgIF90aGlzLnRhYkJhci5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgICBfdGhpcy50YWJCYXIuZGF0YXNldFsncGxhY2VtZW50J10gPSBfdGhpcy5fdGFiUGxhY2VtZW50O1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGJveCBsYXlvdXQuXG4gICAgICAgIHZhciBsYXlvdXQgPSBuZXcgQm94TGF5b3V0KHsgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIHNwYWNpbmc6IDAgfSk7XG4gICAgICAgIC8vIFNldCB0aGUgc3RyZXRjaCBmYWN0b3JzIGZvciB0aGUgY2hpbGQgd2lkZ2V0cy5cbiAgICAgICAgQm94TGF5b3V0LnNldFN0cmV0Y2goX3RoaXMudGFiQmFyLCAwKTtcbiAgICAgICAgQm94TGF5b3V0LnNldFN0cmV0Y2goX3RoaXMuc3RhY2tlZFBhbmVsLCAxKTtcbiAgICAgICAgLy8gQWRkIHRoZSBjaGlsZCB3aWRnZXRzIHRvIHRoZSBsYXlvdXQuXG4gICAgICAgIGxheW91dC5hZGRXaWRnZXQoX3RoaXMudGFiQmFyKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChfdGhpcy5zdGFja2VkUGFuZWwpO1xuICAgICAgICAvLyBJbnN0YWxsIHRoZSBsYXlvdXQgb24gdGhlIHRhYiBwYW5lbC5cbiAgICAgICAgX3RoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJQYW5lbC5wcm90b3R5cGUsIFwiY3VycmVudENoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBjdXJyZW50IHRhYiBpcyBjaGFuZ2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgc2lnbmFsIGlzIGVtaXR0ZWQgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYiBpcyBjaGFuZ2VkXG4gICAgICAgICAqIGVpdGhlciB0aHJvdWdoIHVzZXIgb3IgcHJvZ3JhbW1hdGljIGludGVyYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RhYmx5LCB0aGlzIHNpZ25hbCBpcyBub3QgZW1pdHRlZCB3aGVuIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICAgICAgICAgKiB0YWIgY2hhbmdlcyBkdWUgdG8gdGFicyBiZWluZyBpbnNlcnRlZCwgcmVtb3ZlZCwgb3IgbW92ZWQuIEl0IGlzXG4gICAgICAgICAqIG9ubHkgZW1pdHRlZCB3aGVuIHRoZSBhY3R1YWwgY3VycmVudCB0YWIgbm9kZSBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudENoYW5nZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJQYW5lbC5wcm90b3R5cGUsIFwiY3VycmVudEluZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YWIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGhpcyB3aWxsIGJlIGAtMWAgaWYgbm8gdGFiIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJCYXIuY3VycmVudEluZGV4O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIyBOb3Rlc1xuICAgICAgICAgKiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLCBpdCB3aWxsIGJlIHNldCB0byBgLTFgLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudGFiQmFyLmN1cnJlbnRJbmRleCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiUGFuZWwucHJvdG90eXBlLCBcImN1cnJlbnRXaWRnZXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgd2lkZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gc2VsZWN0ZWQgdGFiLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLnRhYkJhci5jdXJyZW50VGl0bGU7XG4gICAgICAgICAgICByZXR1cm4gdGl0bGUgPyB0aXRsZS5vd25lciA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB3aWRnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogSWYgdGhlIHdpZGdldCBpcyBub3QgaW4gdGhlIHBhbmVsLCBpdCB3aWxsIGJlIHNldCB0byBgbnVsbGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50YWJCYXIuY3VycmVudFRpdGxlID0gdmFsdWUgPyB2YWx1ZS50aXRsZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJQYW5lbC5wcm90b3R5cGUsIFwidGFic01vdmFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3aGV0aGVyIHRoZSB0YWJzIGFyZSBtb3ZhYmxlIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRhYnMgY2FuIGFsd2F5cyBiZSBtb3ZlZCBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJCYXIudGFic01vdmFibGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHdoZXRoZXIgdGhlIHRhYnMgYXJlIG1vdmFibGUgYnkgdGhlIHVzZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyMgTm90ZXNcbiAgICAgICAgICogVGFicyBjYW4gYWx3YXlzIGJlIG1vdmVkIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy50YWJCYXIudGFic01vdmFibGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYlBhbmVsLnByb3RvdHlwZSwgXCJhZGRCdXR0b25FbmFibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgd2hldGhlciB0aGUgYWRkIGJ1dHRvbiBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJCYXIuYWRkQnV0dG9uRW5hYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgd2hldGhlciB0aGUgYWRkIGJ1dHRvbiBpcyBlbmFibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudGFiQmFyLmFkZEJ1dHRvbkVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYlBhbmVsLnByb3RvdHlwZSwgXCJ0YWJQbGFjZW1lbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB0YWIgcGxhY2VtZW50IGZvciB0aGUgdGFiIHBhbmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgY29udHJvbHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgYmFyIHJlbGF0aXZlIHRvIHRoZSBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFiUGxhY2VtZW50O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0YWIgcGxhY2VtZW50IGZvciB0aGUgdGFiIHBhbmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIFRoaXMgY29udHJvbHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgYmFyIHJlbGF0aXZlIHRvIHRoZSBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJhaWwgaWYgdGhlIHBsYWNlbWVudCBkb2VzIG5vdCBjaGFuZ2UuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGFiUGxhY2VtZW50ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLl90YWJQbGFjZW1lbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWVzIHJlbGF0ZWQgdG8gdGhlIHBsYWNlbWVudC5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBQcml2YXRlJGouZGlyZWN0aW9uRnJvbVBsYWNlbWVudCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBQcml2YXRlJGoub3JpZW50YXRpb25Gcm9tUGxhY2VtZW50KHZhbHVlKTtcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgdGFiIGJhciBmb3IgdGhlIHBsYWNlbWVudC5cbiAgICAgICAgICAgIHRoaXMudGFiQmFyLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgICAgICAgICB0aGlzLnRhYkJhci5kYXRhc2V0WydwbGFjZW1lbnQnXSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgdGhpcy5sYXlvdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiUGFuZWwucHJvdG90eXBlLCBcImFkZFJlcXVlc3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGFkZCBidXR0b24gb24gYSB0YWIgYmFyIGlzIGNsaWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRSZXF1ZXN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJQYW5lbC5wcm90b3R5cGUsIFwid2lkZ2V0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlYWQtb25seSBhcnJheSBvZiB0aGUgd2lkZ2V0cyBpbiB0aGUgcGFuZWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrZWRQYW5lbC53aWRnZXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSB3aWRnZXQgdG8gdGhlIGVuZCBvZiB0aGUgdGFiIHBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYWRkIHRvIHRoZSB0YWIgcGFuZWwuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogSWYgdGhlIHdpZGdldCBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGUgcGFuZWwsIGl0IHdpbGwgYmUgbW92ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgd2lkZ2V0J3MgYHRpdGxlYCBpcyB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0YWIuXG4gICAgICovXG4gICAgVGFiUGFuZWwucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uICh3aWRnZXQpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRXaWRnZXQodGhpcy53aWRnZXRzLmxlbmd0aCwgd2lkZ2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHdpZGdldCBpbnRvIHRoZSB0YWIgcGFuZWwgYXQgYSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBpbnNlcnQgaW50byB0byB0aGUgdGFiIHBhbmVsLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSB3aWRnZXQgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIHBhbmVsLCBpdCB3aWxsIGJlIG1vdmVkLlxuICAgICAqXG4gICAgICogVGhlIHdpZGdldCdzIGB0aXRsZWAgaXMgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGFiLlxuICAgICAqL1xuICAgIFRhYlBhbmVsLnByb3RvdHlwZS5pbnNlcnRXaWRnZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHdpZGdldCkge1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSB0aGlzLmN1cnJlbnRXaWRnZXQpIHtcbiAgICAgICAgICAgIHdpZGdldC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja2VkUGFuZWwuaW5zZXJ0V2lkZ2V0KGluZGV4LCB3aWRnZXQpO1xuICAgICAgICB0aGlzLnRhYkJhci5pbnNlcnRUYWIoaW5kZXgsIHdpZGdldC50aXRsZSk7XG4gICAgICAgIHdpZGdldC5ub2RlLnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWJwYW5lbCcpO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnRhYkJhci5yZW5kZXJlcjtcbiAgICAgICAgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2YgVGFiQmFyLlJlbmRlcmVyKSB7XG4gICAgICAgICAgICB2YXIgdGFiSWQgPSByZW5kZXJlci5jcmVhdGVUYWJLZXkoeyB0aXRsZTogd2lkZ2V0LnRpdGxlLCBjdXJyZW50OiBmYWxzZSwgekluZGV4OiAwIH0pO1xuICAgICAgICAgICAgd2lkZ2V0Lm5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCB0YWJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgYGN1cnJlbnRDaGFuZ2VkYCBzaWduYWwgZnJvbSB0aGUgdGFiIGJhci5cbiAgICAgKi9cbiAgICBUYWJQYW5lbC5wcm90b3R5cGUuX29uQ3VycmVudENoYW5nZWQgPSBmdW5jdGlvbiAoc2VuZGVyLCBhcmdzKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IHRpdGxlIGZyb20gdGhlIGFyZ3MuXG4gICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gYXJncy5wcmV2aW91c0luZGV4LCBwcmV2aW91c1RpdGxlID0gYXJncy5wcmV2aW91c1RpdGxlLCBjdXJyZW50SW5kZXggPSBhcmdzLmN1cnJlbnRJbmRleCwgY3VycmVudFRpdGxlID0gYXJncy5jdXJyZW50VGl0bGU7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHdpZGdldHMgZnJvbSB0aGUgdGl0bGVzLlxuICAgICAgICB2YXIgcHJldmlvdXNXaWRnZXQgPSBwcmV2aW91c1RpdGxlID8gcHJldmlvdXNUaXRsZS5vd25lciA6IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50V2lkZ2V0ID0gY3VycmVudFRpdGxlID8gY3VycmVudFRpdGxlLm93bmVyIDogbnVsbDtcbiAgICAgICAgLy8gSGlkZSB0aGUgcHJldmlvdXMgd2lkZ2V0LlxuICAgICAgICBpZiAocHJldmlvdXNXaWRnZXQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzV2lkZ2V0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG93IHRoZSBjdXJyZW50IHdpZGdldC5cbiAgICAgICAgaWYgKGN1cnJlbnRXaWRnZXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRXaWRnZXQuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgdGhlIGBjdXJyZW50Q2hhbmdlZGAgc2lnbmFsIGZvciB0aGUgdGFiIHBhbmVsLlxuICAgICAgICB0aGlzLl9jdXJyZW50Q2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IHByZXZpb3VzSW5kZXgsIHByZXZpb3VzV2lkZ2V0OiBwcmV2aW91c1dpZGdldCwgY3VycmVudEluZGV4OiBjdXJyZW50SW5kZXgsIGN1cnJlbnRXaWRnZXQ6IGN1cnJlbnRXaWRnZXRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBtZXNzYWdlIGxvb3Agb24gSUUgYW5kIEVkZ2UgdG8gcHJldmVudCBmbGlja2VyLlxuICAgICAgICBpZiAoUGxhdGZvcm0uSVNfRURHRSB8fCBQbGF0Zm9ybS5JU19JRSkge1xuICAgICAgICAgICAgTWVzc2FnZUxvb3AuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGFiQWRkUmVxdWVzdGVkYCBzaWduYWwgZnJvbSB0aGUgdGFiIGJhci5cbiAgICAgKi9cbiAgICBUYWJQYW5lbC5wcm90b3R5cGUuX29uVGFiQWRkUmVxdWVzdGVkID0gZnVuY3Rpb24gKHNlbmRlciwgYXJncykge1xuICAgICAgICB0aGlzLl9hZGRSZXF1ZXN0ZWQuZW1pdChzZW5kZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGFiQWN0aXZhdGVSZXF1ZXN0ZWRgIHNpZ25hbCBmcm9tIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYlBhbmVsLnByb3RvdHlwZS5fb25UYWJBY3RpdmF0ZVJlcXVlc3RlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcbiAgICAgICAgYXJncy50aXRsZS5vd25lci5hY3RpdmF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGFiQ2xvc2VSZXF1ZXN0ZWRgIHNpZ25hbCBmcm9tIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYlBhbmVsLnByb3RvdHlwZS5fb25UYWJDbG9zZVJlcXVlc3RlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcbiAgICAgICAgYXJncy50aXRsZS5vd25lci5jbG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBgdGFiTW92ZWRgIHNpZ25hbCBmcm9tIHRoZSB0YWIgYmFyLlxuICAgICAqL1xuICAgIFRhYlBhbmVsLnByb3RvdHlwZS5fb25UYWJNb3ZlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5zdGFja2VkUGFuZWwuaW5zZXJ0V2lkZ2V0KGFyZ3MudG9JbmRleCwgYXJncy50aXRsZS5vd25lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGB3aWRnZXRSZW1vdmVkYCBzaWduYWwgZnJvbSB0aGUgc3RhY2tlZCBwYW5lbC5cbiAgICAgKi9cbiAgICBUYWJQYW5lbC5wcm90b3R5cGUuX29uV2lkZ2V0UmVtb3ZlZCA9IGZ1bmN0aW9uIChzZW5kZXIsIHdpZGdldCkge1xuICAgICAgICB3aWRnZXQubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgd2lkZ2V0Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknKTtcbiAgICAgICAgdGhpcy50YWJCYXIucmVtb3ZlVGFiKHdpZGdldC50aXRsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFiUGFuZWw7XG59KFdpZGdldCkpO1xuLyoqXG4gKiBUaGUgbmFtZXNwYWNlIGZvciB0aGUgbW9kdWxlIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKi9cbnZhciBQcml2YXRlJGo7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdGFiIHBsYWNlbWVudCB0byB0YWIgYmFyIG9yaWVudGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yaWVudGF0aW9uRnJvbVBsYWNlbWVudChwbGMpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlbWVudFRvT3JpZW50YXRpb25NYXBbcGxjXTtcbiAgICB9XG4gICAgUHJpdmF0ZS5vcmllbnRhdGlvbkZyb21QbGFjZW1lbnQgPSBvcmllbnRhdGlvbkZyb21QbGFjZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHRhYiBwbGFjZW1lbnQgdG8gYSBib3ggbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXJlY3Rpb25Gcm9tUGxhY2VtZW50KHBsYykge1xuICAgICAgICByZXR1cm4gcGxhY2VtZW50VG9EaXJlY3Rpb25NYXBbcGxjXTtcbiAgICB9XG4gICAgUHJpdmF0ZS5kaXJlY3Rpb25Gcm9tUGxhY2VtZW50ID0gZGlyZWN0aW9uRnJvbVBsYWNlbWVudDtcbiAgICAvKipcbiAgICAgKiBBIG1hcHBpbmcgb2YgdGFiIHBsYWNlbWVudCB0byB0YWIgYmFyIG9yaWVudGF0aW9uLlxuICAgICAqL1xuICAgIHZhciBwbGFjZW1lbnRUb09yaWVudGF0aW9uTWFwID0ge1xuICAgICAgICAndG9wJzogJ2hvcml6b250YWwnLFxuICAgICAgICAnbGVmdCc6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICdyaWdodCc6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICdib3R0b20nOiAnaG9yaXpvbnRhbCdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWFwcGluZyBvZiB0YWIgcGxhY2VtZW50IHRvIGJveCBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHZhciBwbGFjZW1lbnRUb0RpcmVjdGlvbk1hcCA9IHtcbiAgICAgICAgJ3RvcCc6ICd0b3AtdG8tYm90dG9tJyxcbiAgICAgICAgJ2xlZnQnOiAnbGVmdC10by1yaWdodCcsXG4gICAgICAgICdyaWdodCc6ICdyaWdodC10by1sZWZ0JyxcbiAgICAgICAgJ2JvdHRvbSc6ICdib3R0b20tdG8tdG9wJ1xuICAgIH07XG59KShQcml2YXRlJGogfHwgKFByaXZhdGUkaiA9IHt9KSk7XG5cbmV4cG9ydCB7IEFjY29yZGlvbkxheW91dCwgQWNjb3JkaW9uUGFuZWwsIEJveEVuZ2luZSwgQm94TGF5b3V0LCBCb3hQYW5lbCwgQm94U2l6ZXIsIENvbW1hbmRQYWxldHRlLCBDb250ZXh0TWVudSwgRG9ja0xheW91dCwgRG9ja1BhbmVsLCBGb2N1c1RyYWNrZXIsIEdyaWRMYXlvdXQsIExheW91dCwgTGF5b3V0SXRlbSwgTWVudSwgTWVudUJhciwgUGFuZWwsIFBhbmVsTGF5b3V0LCBTY3JvbGxCYXIsIFNpbmdsZXRvbkxheW91dCwgU3BsaXRMYXlvdXQsIFNwbGl0UGFuZWwsIFN0YWNrZWRMYXlvdXQsIFN0YWNrZWRQYW5lbCwgVGFiQmFyLCBUYWJQYW5lbCwgVGl0bGUsIFdpZGdldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXM2LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lumino/widgets/dist/index.es6.js\n")},"./src/example.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nvar _1 = __webpack_require__("./src/index.ts");\nvar widgets_1 = __webpack_require__("./node_modules/@lumino/widgets/dist/index.es6.js");\nwindow.addEventListener(\'load\', function () {\n    var main = document.querySelector(\'main\');\n    var model = window.model = new _1.Life.Model({\n        initial: _1.Life.Model.random(70, 125),\n        interval: 100\n    });\n    widgets_1.Widget.attach(_1.Life.create(model, { size: 8 }), main);\n    model.start();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXhhbXBsZS50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxTQUFTLG1CQUFPLENBQUMsZ0JBQUc7QUFDcEIsZ0JBQWdCLG1CQUFPLENBQUMsa0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vc3JjL2V4YW1wbGUudHM/OTUwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuXCIpO1xudmFyIHdpZGdldHNfMSA9IHJlcXVpcmUoXCJAbHVtaW5vL3dpZGdldHNcIik7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4nKTtcbiAgICB2YXIgbW9kZWwgPSB3aW5kb3cubW9kZWwgPSBuZXcgXzEuTGlmZS5Nb2RlbCh7XG4gICAgICAgIGluaXRpYWw6IF8xLkxpZmUuTW9kZWwucmFuZG9tKDcwLCAxMjUpLFxuICAgICAgICBpbnRlcnZhbDogMTAwXG4gICAgfSk7XG4gICAgd2lkZ2V0c18xLldpZGdldC5hdHRhY2goXzEuTGlmZS5jcmVhdGUobW9kZWwsIHsgc2l6ZTogOCB9KSwgbWFpbik7XG4gICAgbW9kZWwuc3RhcnQoKTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/example.ts\n')},"./src/index.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Life = void 0;\nvar datagrid_1 = __webpack_require__("./node_modules/@lumino/datagrid/dist/index.es6.js");\nvar polling_1 = __webpack_require__("./node_modules/@lumino/polling/dist/index.es6.js");\n/**\n * The default likelihood that a random cell is alive.\n */\nvar LIKELIHOOD = 0.25;\n/**\n * The default number of rows in a randomly generated world.\n */\nvar ROWS = 40;\n/**\n * The default number of columns in a randomly generated world.\n */\nvar COLUMNS = 40;\n/**\n * The default time (in ms) between generations and rendering.\n */\nvar INTERVAL = 250;\n/**\n * A namespace for `Life`.\n */\nvar Life;\n(function (Life) {\n    /**\n     * The minimum size of a cell in a `Life` grid.\n     */\n    Life.MINIMUM_SIZE = 4;\n    /**\n     * A Lumino `DataGrid` data model for Conway\'s Game of Life.\n     */\n    var Model = /** @class */ (function (_super) {\n        __extends(Model, _super);\n        /**\n         * Instantiate a new life model.\n         */\n        function Model(options) {\n            if (options === void 0) { options = {}; }\n            var _this = _super.call(this) || this;\n            _this._tick = Model.tick;\n            _this._ticker = new polling_1.Poll({\n                auto: false,\n                factory: function () { return __awaiter(_this, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        this.state = this.tick(this.state);\n                        this.emitChanged({\n                            type: \'cells-changed\',\n                            rowSpan: this._rowCount,\n                            columnSpan: this._columnCount,\n                            region: \'body\',\n                            row: 0,\n                            column: 0\n                        });\n                        return [2 /*return*/];\n                    });\n                }); },\n            });\n            _this.interval = options.interval || INTERVAL;\n            _this.state = options.initial || Model.random();\n            _this.tick = options.tick || Model.tick;\n            return _this;\n        }\n        Object.defineProperty(Model.prototype, "interval", {\n            /**\n             * The model\'s refresh interval.\n             */\n            get: function () {\n                return this._ticker.frequency.interval;\n            },\n            set: function (interval) {\n                if (this.interval !== interval) {\n                    this._ticker.frequency = __assign(__assign({}, this._ticker.frequency), { interval: interval });\n                }\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Model.prototype, "isDisposed", {\n            /**\n             * Whether the model has been disposed.\n             */\n            get: function () {\n                return this._ticker.isDisposed;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Model.prototype, "state", {\n            /**\n             * The current state of the universe.\n             */\n            get: function () {\n                return this._state;\n            },\n            set: function (state) {\n                if (this.state !== state) {\n                    this._columnCount = state[0].length;\n                    this._rowCount = state.length;\n                    this._state = state;\n                }\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Model.prototype, "tick", {\n            /**\n             * The model\'s tick function.\n             */\n            get: function () {\n                return this._tick;\n            },\n            set: function (tick) {\n                if (this.tick !== tick) {\n                    this._tick = tick;\n                }\n            },\n            enumerable: false,\n            configurable: true\n        });\n        /**\n         * Get the row count for a region in the life data model.\n         */\n        Model.prototype.rowCount = function (region) {\n            return this._rowCount;\n        };\n        /**\n         * Get the column count for a region in the life data model.\n         */\n        Model.prototype.columnCount = function (region) {\n            return this._columnCount;\n        };\n        /**\n         * Get the data for a cell in the life data model.\n         */\n        Model.prototype.data = function (region, row, column) {\n            return this.state[row][column];\n        };\n        /**\n         * Dispose the model.\n         */\n        Model.prototype.dispose = function () {\n            this._ticker.dispose();\n        };\n        /**\n         * Start ticking the life widget, rendering each generation.\n         */\n        Model.prototype.start = function () {\n            void this._ticker.start();\n        };\n        /**\n         * Stop ticking the life widget.\n         */\n        Model.prototype.stop = function () {\n            void this._ticker.stop();\n        };\n        return Model;\n    }(datagrid_1.DataModel));\n    Life.Model = Model;\n    /**\n     * A namespace for `Model` statics.\n     */\n    (function (Model) {\n        /**\n         * Generates a random data set to initialize the state of the world.\n         *\n         * @param rows - The number of rows in the data, defaults to `40`.\n         *\n         * @param columns - The number of columns in the data, defaults to `40`.\n         *\n         * @param likelihood - The likelihood of a live cell, defaults to `0.25`.\n         *\n         * @returns A two-dimensional array representing the state of the world.\n         */\n        function random(rows, columns, likelihood) {\n            if (rows === void 0) { rows = ROWS; }\n            if (columns === void 0) { columns = COLUMNS; }\n            if (likelihood === void 0) { likelihood = LIKELIHOOD; }\n            var data = [];\n            for (var i = 0; i < rows; i += 1) {\n                var row = [];\n                for (var j = 0; j < columns; j += 1) {\n                    row[j] = Math.random() < likelihood ? 1 : 0;\n                }\n                data.push(row);\n            }\n            return data;\n        }\n        Model.random = random;\n        /**\n         * Process a generation of life following Conway\'s original rules.\n         *\n         * @param current - The current state of the world.\n         *\n         * @param fluctuation - An optional value between 0 and 1 that indicates the\n         * likelihood that a bit will flip, contravening the rules.\n         *\n         * #### Notes\n         * Instead of accepting a single state array, this function takes an `input`\n         * and an `output` array to facilitate swapping back and forth between\n         * generation arrays without needing to reallocate memory. The `input` and\n         * `output` arrays must have the same dimensions.\n         */\n        function tick(input, fluctuation) {\n            if (fluctuation === void 0) { fluctuation = 0; }\n            var rows = input.length;\n            var columns = input[0].length;\n            var lastCol = columns - 1;\n            var lastRow = rows - 1;\n            var output = new Array(rows);\n            for (var i = 0; i < rows; i += 1) {\n                output[i] = new Array(columns);\n                for (var j = 0; j < columns; j += 1) {\n                    var alive = input[i][j];\n                    var cell = 0;\n                    var decX = i >= 1 ? i - 1 : lastRow; // decrement x\n                    var decY = j >= 1 ? j - 1 : lastCol; // decrement y\n                    var incX = i + 1 <= lastRow ? i + 1 : 0; // increment x\n                    var incY = j + 1 <= lastCol ? j + 1 : 0; // increment y\n                    var neighbors = input[decX][decY] +\n                        input[i][decY] +\n                        input[incX][decY] +\n                        input[decX][j] +\n                        input[incX][j] +\n                        input[decX][incY] +\n                        input[i][incY] +\n                        input[incX][incY];\n                    // Any live cell with fewer than two live neighbors dies.\n                    // Any live cell with two or three live neighbors lives.\n                    // Any live cell with more than three live neighbors dies.\n                    // Any dead cell with exactly three live neighbors comes to life.\n                    if (alive && neighbors < 2) {\n                        cell = 0;\n                    }\n                    else if (alive && neighbors === 2 || neighbors === 3) {\n                        cell = 1;\n                    }\n                    else if (alive && neighbors > 3) {\n                        cell = 0;\n                    }\n                    else if (!alive && neighbors === 3) {\n                        cell = 1;\n                    }\n                    // If there is a fluctuation, flip the cell value.\n                    if (fluctuation && Math.random() < fluctuation) {\n                        cell = 1 - cell;\n                    }\n                    output[i][j] = cell;\n                }\n            }\n            return output;\n        }\n        Model.tick = tick;\n    })(Model = Life.Model || (Life.Model = {}));\n    /**\n     * Create a `DataGrid` to render a `Life.Model`.\n     *\n     * @param model - The `Life` model.\n     *\n     * @param style - The `Life` style.\n     *\n     * @returns A `DataGrid` that renders the `Life` model.\n     */\n    function create(model, style) {\n        if (style === void 0) { style = {}; }\n        var size = Math.max(Life.MINIMUM_SIZE, style.size || 20);\n        var alive = style.alive || "rgb(0, 0, 0)";\n        var empty = style.empty || "rgb(50, 185, 25)";\n        var grid = new datagrid_1.DataGrid({\n            defaultSizes: {\n                rowHeaderWidth: size,\n                rowHeight: size,\n                columnHeaderHeight: size,\n                columnWidth: size\n            },\n            headerVisibility: \'none\',\n            minimumSizes: {\n                rowHeight: Life.MINIMUM_SIZE,\n                columnWidth: Life.MINIMUM_SIZE,\n                rowHeaderWidth: Life.MINIMUM_SIZE,\n                columnHeaderHeight: Life.MINIMUM_SIZE\n            },\n            style: __assign(__assign({}, datagrid_1.DataGrid.defaultStyle), { gridLineColor: "rgba(255, 255, 255, 0.5)", voidColor: \'transparent\' })\n        });\n        grid.dataModel = model;\n        grid.addClass(\'atd-Life\');\n        grid.disposed.connect(function () { model.dispose(); });\n        var Renderer = /** @class */ (function (_super) {\n            __extends(Renderer, _super);\n            function Renderer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            Renderer.prototype.paint = function (gc, config) {\n                _super.prototype.drawBackground.call(this, gc, __assign(__assign({}, config), { height: size, width: size }));\n            };\n            return Renderer;\n        }(datagrid_1.TextRenderer));\n        grid.cellRenderers.update({\n            \'body\': new Renderer({\n                backgroundColor: function (_a) {\n                    var value = _a.value;\n                    return value === 1 ? alive : empty;\n                }\n            })\n        });\n        return grid;\n    }\n    Life.create = create;\n})(Life = exports.Life || (exports.Life = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsbURBQWtCO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCLElBQUk7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlFQUFpRSw2QkFBNkIsb0JBQW9CO0FBQ2xIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsc0NBQXNDO0FBQ3RDLHlDQUF5QztBQUN6QztBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQsNkRBQTZEO0FBQzdELDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0NBQXdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDLHVDQUF1QyxxRUFBcUU7QUFDbkosU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixhQUFhLDJCQUEyQjtBQUMzSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsWUFBWSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGFmc2hpbi9saWZlLy4vc3JjL2luZGV4LnRzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZmUgPSB2b2lkIDA7XG52YXIgZGF0YWdyaWRfMSA9IHJlcXVpcmUoXCJAbHVtaW5vL2RhdGFncmlkXCIpO1xudmFyIHBvbGxpbmdfMSA9IHJlcXVpcmUoXCJAbHVtaW5vL3BvbGxpbmdcIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGxpa2VsaWhvb2QgdGhhdCBhIHJhbmRvbSBjZWxsIGlzIGFsaXZlLlxuICovXG52YXIgTElLRUxJSE9PRCA9IDAuMjU7XG4vKipcbiAqIFRoZSBkZWZhdWx0IG51bWJlciBvZiByb3dzIGluIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIHdvcmxkLlxuICovXG52YXIgUk9XUyA9IDQwO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBudW1iZXIgb2YgY29sdW1ucyBpbiBhIHJhbmRvbWx5IGdlbmVyYXRlZCB3b3JsZC5cbiAqL1xudmFyIENPTFVNTlMgPSA0MDtcbi8qKlxuICogVGhlIGRlZmF1bHQgdGltZSAoaW4gbXMpIGJldHdlZW4gZ2VuZXJhdGlvbnMgYW5kIHJlbmRlcmluZy5cbiAqL1xudmFyIElOVEVSVkFMID0gMjUwO1xuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgYExpZmVgLlxuICovXG52YXIgTGlmZTtcbihmdW5jdGlvbiAoTGlmZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHNpemUgb2YgYSBjZWxsIGluIGEgYExpZmVgIGdyaWQuXG4gICAgICovXG4gICAgTGlmZS5NSU5JTVVNX1NJWkUgPSA0O1xuICAgIC8qKlxuICAgICAqIEEgTHVtaW5vIGBEYXRhR3JpZGAgZGF0YSBtb2RlbCBmb3IgQ29ud2F5J3MgR2FtZSBvZiBMaWZlLlxuICAgICAqL1xuICAgIHZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE1vZGVsLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGUgYSBuZXcgbGlmZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuX3RpY2sgPSBNb2RlbC50aWNrO1xuICAgICAgICAgICAgX3RoaXMuX3RpY2tlciA9IG5ldyBwb2xsaW5nXzEuUG9sbCh7XG4gICAgICAgICAgICAgICAgYXV0bzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy50aWNrKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NlbGxzLWNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd1NwYW46IHRoaXMuX3Jvd0NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNwYW46IHRoaXMuX2NvbHVtbkNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsIHx8IElOVEVSVkFMO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBvcHRpb25zLmluaXRpYWwgfHwgTW9kZWwucmFuZG9tKCk7XG4gICAgICAgICAgICBfdGhpcy50aWNrID0gb3B0aW9ucy50aWNrIHx8IE1vZGVsLnRpY2s7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBtb2RlbCdzIHJlZnJlc2ggaW50ZXJ2YWwuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZXIuZnJlcXVlbmN5LmludGVydmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgIT09IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tlci5mcmVxdWVuY3kgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5fdGlja2VyLmZyZXF1ZW5jeSksIHsgaW50ZXJ2YWw6IGludGVydmFsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsLnByb3RvdHlwZSwgXCJpc0Rpc3Bvc2VkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgbW9kZWwgaGFzIGJlZW4gZGlzcG9zZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZXIuaXNEaXNwb3NlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB1bml2ZXJzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbkNvdW50ID0gc3RhdGVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb3dDb3VudCA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbC5wcm90b3R5cGUsIFwidGlja1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBtb2RlbCdzIHRpY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aWNrICE9PSB0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2sgPSB0aWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcm93IGNvdW50IGZvciBhIHJlZ2lvbiBpbiB0aGUgbGlmZSBkYXRhIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWwucHJvdG90eXBlLnJvd0NvdW50ID0gZnVuY3Rpb24gKHJlZ2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0NvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjb2x1bW4gY291bnQgZm9yIGEgcmVnaW9uIGluIHRoZSBsaWZlIGRhdGEgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbC5wcm90b3R5cGUuY29sdW1uQ291bnQgPSBmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uQ291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgbGlmZSBkYXRhIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWwucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAocmVnaW9uLCByb3csIGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbcm93XVtjb2x1bW5dO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZSB0aGUgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tlci5kaXNwb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCB0aWNraW5nIHRoZSBsaWZlIHdpZGdldCwgcmVuZGVyaW5nIGVhY2ggZ2VuZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fdGlja2VyLnN0YXJ0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHRpY2tpbmcgdGhlIGxpZmUgd2lkZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWwucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuX3RpY2tlci5zdG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNb2RlbDtcbiAgICB9KGRhdGFncmlkXzEuRGF0YU1vZGVsKSk7XG4gICAgTGlmZS5Nb2RlbCA9IE1vZGVsO1xuICAgIC8qKlxuICAgICAqIEEgbmFtZXNwYWNlIGZvciBgTW9kZWxgIHN0YXRpY3MuXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChNb2RlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIGRhdGEgc2V0IHRvIGluaXRpYWxpemUgdGhlIHN0YXRlIG9mIHRoZSB3b3JsZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvd3MgLSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEsIGRlZmF1bHRzIHRvIGA0MGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBkYXRhLCBkZWZhdWx0cyB0byBgNDBgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGlrZWxpaG9vZCAtIFRoZSBsaWtlbGlob29kIG9mIGEgbGl2ZSBjZWxsLCBkZWZhdWx0cyB0byBgMC4yNWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIHdvcmxkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tKHJvd3MsIGNvbHVtbnMsIGxpa2VsaWhvb2QpIHtcbiAgICAgICAgICAgIGlmIChyb3dzID09PSB2b2lkIDApIHsgcm93cyA9IFJPV1M7IH1cbiAgICAgICAgICAgIGlmIChjb2x1bW5zID09PSB2b2lkIDApIHsgY29sdW1ucyA9IENPTFVNTlM7IH1cbiAgICAgICAgICAgIGlmIChsaWtlbGlob29kID09PSB2b2lkIDApIHsgbGlrZWxpaG9vZCA9IExJS0VMSUhPT0Q7IH1cbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb3dbal0gPSBNYXRoLnJhbmRvbSgpIDwgbGlrZWxpaG9vZCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIE1vZGVsLnJhbmRvbSA9IHJhbmRvbTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2Nlc3MgYSBnZW5lcmF0aW9uIG9mIGxpZmUgZm9sbG93aW5nIENvbndheSdzIG9yaWdpbmFsIHJ1bGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY3VycmVudCAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB3b3JsZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGZsdWN0dWF0aW9uIC0gQW4gb3B0aW9uYWwgdmFsdWUgYmV0d2VlbiAwIGFuZCAxIHRoYXQgaW5kaWNhdGVzIHRoZVxuICAgICAgICAgKiBsaWtlbGlob29kIHRoYXQgYSBiaXQgd2lsbCBmbGlwLCBjb250cmF2ZW5pbmcgdGhlIHJ1bGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMjIE5vdGVzXG4gICAgICAgICAqIEluc3RlYWQgb2YgYWNjZXB0aW5nIGEgc2luZ2xlIHN0YXRlIGFycmF5LCB0aGlzIGZ1bmN0aW9uIHRha2VzIGFuIGBpbnB1dGBcbiAgICAgICAgICogYW5kIGFuIGBvdXRwdXRgIGFycmF5IHRvIGZhY2lsaXRhdGUgc3dhcHBpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlblxuICAgICAgICAgKiBnZW5lcmF0aW9uIGFycmF5cyB3aXRob3V0IG5lZWRpbmcgdG8gcmVhbGxvY2F0ZSBtZW1vcnkuIFRoZSBgaW5wdXRgIGFuZFxuICAgICAgICAgKiBgb3V0cHV0YCBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0aWNrKGlucHV0LCBmbHVjdHVhdGlvbikge1xuICAgICAgICAgICAgaWYgKGZsdWN0dWF0aW9uID09PSB2b2lkIDApIHsgZmx1Y3R1YXRpb24gPSAwOyB9XG4gICAgICAgICAgICB2YXIgcm93cyA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gaW5wdXRbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxhc3RDb2wgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgICAgIHZhciBsYXN0Um93ID0gcm93cyAtIDE7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gbmV3IEFycmF5KHJvd3MpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBuZXcgQXJyYXkoY29sdW1ucyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaXZlID0gaW5wdXRbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY1ggPSBpID49IDEgPyBpIC0gMSA6IGxhc3RSb3c7IC8vIGRlY3JlbWVudCB4XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNZID0gaiA+PSAxID8gaiAtIDEgOiBsYXN0Q29sOyAvLyBkZWNyZW1lbnQgeVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5jWCA9IGkgKyAxIDw9IGxhc3RSb3cgPyBpICsgMSA6IDA7IC8vIGluY3JlbWVudCB4XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmNZID0gaiArIDEgPD0gbGFzdENvbCA/IGogKyAxIDogMDsgLy8gaW5jcmVtZW50IHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IGlucHV0W2RlY1hdW2RlY1ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2ldW2RlY1ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2luY1hdW2RlY1ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2RlY1hdW2pdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2luY1hdW2pdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2RlY1hdW2luY1ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2ldW2luY1ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0W2luY1hdW2luY1ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbnkgbGl2ZSBjZWxsIHdpdGggZmV3ZXIgdGhhbiB0d28gbGl2ZSBuZWlnaGJvcnMgZGllcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW55IGxpdmUgY2VsbCB3aXRoIHR3byBvciB0aHJlZSBsaXZlIG5laWdoYm9ycyBsaXZlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW55IGxpdmUgY2VsbCB3aXRoIG1vcmUgdGhhbiB0aHJlZSBsaXZlIG5laWdoYm9ycyBkaWVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBBbnkgZGVhZCBjZWxsIHdpdGggZXhhY3RseSB0aHJlZSBsaXZlIG5laWdoYm9ycyBjb21lcyB0byBsaWZlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpdmUgJiYgbmVpZ2hib3JzIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpdmUgJiYgbmVpZ2hib3JzID09PSAyIHx8IG5laWdoYm9ycyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpdmUgJiYgbmVpZ2hib3JzID4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsaXZlICYmIG5laWdoYm9ycyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBmbHVjdHVhdGlvbiwgZmxpcCB0aGUgY2VsbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdWN0dWF0aW9uICYmIE1hdGgucmFuZG9tKCkgPCBmbHVjdHVhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9IDEgLSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtpXVtqXSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBNb2RlbC50aWNrID0gdGljaztcbiAgICB9KShNb2RlbCA9IExpZmUuTW9kZWwgfHwgKExpZmUuTW9kZWwgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGBEYXRhR3JpZGAgdG8gcmVuZGVyIGEgYExpZmUuTW9kZWxgLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIGBMaWZlYCBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBgTGlmZWAgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGBEYXRhR3JpZGAgdGhhdCByZW5kZXJzIHRoZSBgTGlmZWAgbW9kZWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG1vZGVsLCBzdHlsZSkge1xuICAgICAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkgeyBzdHlsZSA9IHt9OyB9XG4gICAgICAgIHZhciBzaXplID0gTWF0aC5tYXgoTGlmZS5NSU5JTVVNX1NJWkUsIHN0eWxlLnNpemUgfHwgMjApO1xuICAgICAgICB2YXIgYWxpdmUgPSBzdHlsZS5hbGl2ZSB8fCBcInJnYigwLCAwLCAwKVwiO1xuICAgICAgICB2YXIgZW1wdHkgPSBzdHlsZS5lbXB0eSB8fCBcInJnYig1MCwgMTg1LCAyNSlcIjtcbiAgICAgICAgdmFyIGdyaWQgPSBuZXcgZGF0YWdyaWRfMS5EYXRhR3JpZCh7XG4gICAgICAgICAgICBkZWZhdWx0U2l6ZXM6IHtcbiAgICAgICAgICAgICAgICByb3dIZWFkZXJXaWR0aDogc2l6ZSxcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IHNpemUsXG4gICAgICAgICAgICAgICAgY29sdW1uSGVhZGVySGVpZ2h0OiBzaXplLFxuICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoOiBzaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZGVyVmlzaWJpbGl0eTogJ25vbmUnLFxuICAgICAgICAgICAgbWluaW11bVNpemVzOiB7XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0OiBMaWZlLk1JTklNVU1fU0laRSxcbiAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aDogTGlmZS5NSU5JTVVNX1NJWkUsXG4gICAgICAgICAgICAgICAgcm93SGVhZGVyV2lkdGg6IExpZmUuTUlOSU1VTV9TSVpFLFxuICAgICAgICAgICAgICAgIGNvbHVtbkhlYWRlckhlaWdodDogTGlmZS5NSU5JTVVNX1NJWkVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGFncmlkXzEuRGF0YUdyaWQuZGVmYXVsdFN0eWxlKSwgeyBncmlkTGluZUNvbG9yOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KVwiLCB2b2lkQ29sb3I6ICd0cmFuc3BhcmVudCcgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGdyaWQuZGF0YU1vZGVsID0gbW9kZWw7XG4gICAgICAgIGdyaWQuYWRkQ2xhc3MoJ2F0ZC1MaWZlJyk7XG4gICAgICAgIGdyaWQuZGlzcG9zZWQuY29ubmVjdChmdW5jdGlvbiAoKSB7IG1vZGVsLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIHZhciBSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5wYWludCA9IGZ1bmN0aW9uIChnYywgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kcmF3QmFja2dyb3VuZC5jYWxsKHRoaXMsIGdjLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29uZmlnKSwgeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVuZGVyZXI7XG4gICAgICAgIH0oZGF0YWdyaWRfMS5UZXh0UmVuZGVyZXIpKTtcbiAgICAgICAgZ3JpZC5jZWxsUmVuZGVyZXJzLnVwZGF0ZSh7XG4gICAgICAgICAgICAnYm9keSc6IG5ldyBSZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSA/IGFsaXZlIDogZW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncmlkO1xuICAgIH1cbiAgICBMaWZlLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKExpZmUgPSBleHBvcnRzLkxpZmUgfHwgKGV4cG9ydHMuTGlmZSA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n')},"?b7e7":()=>{}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(C.exports,C,C.exports,__webpack_require__),C.exports}__webpack_require__.d=(g,I)=>{for(var C in I)__webpack_require__.o(I,C)&&!__webpack_require__.o(g,C)&&Object.defineProperty(g,C,{enumerable:!0,get:I[C]})},__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/example.ts")})();